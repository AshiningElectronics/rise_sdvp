
build/rfmote_pa.elf:     file format elf32-littlearm


Disassembly of section .text:

0800c000 <Reset_Handler>:
 800c000:	b672      	cpsid	i
 800c002:	4833      	ldr	r0, [pc, #204]	; (800c0d0 <endfiniloop+0x6>)
 800c004:	f380 8809 	msr	PSP, r0
 800c008:	f240 0000 	movw	r0, #0
 800c00c:	f2cc 0000 	movt	r0, #49152	; 0xc000
 800c010:	f64e 7134 	movw	r1, #61236	; 0xef34
 800c014:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c018:	6008      	str	r0, [r1, #0]
 800c01a:	f3bf 8f4f 	dsb	sy
 800c01e:	f3bf 8f6f 	isb	sy
 800c022:	f240 0000 	movw	r0, #0
 800c026:	f2c0 00f0 	movt	r0, #240	; 0xf0
 800c02a:	f64e 5188 	movw	r1, #60808	; 0xed88
 800c02e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c032:	6008      	str	r0, [r1, #0]
 800c034:	f3bf 8f4f 	dsb	sy
 800c038:	f3bf 8f6f 	isb	sy
 800c03c:	f04f 0000 	mov.w	r0, #0
 800c040:	eee1 0a10 	vmsr	fpscr, r0
 800c044:	f64e 713c 	movw	r1, #61244	; 0xef3c
 800c048:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c04c:	6008      	str	r0, [r1, #0]
 800c04e:	2006      	movs	r0, #6
 800c050:	f380 8814 	msr	CONTROL, r0
 800c054:	f3bf 8f6f 	isb	sy
 800c058:	f000 f91a 	bl	800c290 <__core_init>
 800c05c:	f003 fbd0 	bl	800f800 <__early_init>
 800c060:	481c      	ldr	r0, [pc, #112]	; (800c0d4 <endfiniloop+0xa>)
 800c062:	491d      	ldr	r1, [pc, #116]	; (800c0d8 <endfiniloop+0xe>)
 800c064:	4a1d      	ldr	r2, [pc, #116]	; (800c0dc <endfiniloop+0x12>)

0800c066 <msloop>:
 800c066:	4291      	cmp	r1, r2
 800c068:	bf3c      	itt	cc
 800c06a:	f841 0b04 	strcc.w	r0, [r1], #4
 800c06e:	e7fa      	bcc.n	800c066 <msloop>
 800c070:	491b      	ldr	r1, [pc, #108]	; (800c0e0 <endfiniloop+0x16>)
 800c072:	4a17      	ldr	r2, [pc, #92]	; (800c0d0 <endfiniloop+0x6>)

0800c074 <psloop>:
 800c074:	4291      	cmp	r1, r2
 800c076:	bf3c      	itt	cc
 800c078:	f841 0b04 	strcc.w	r0, [r1], #4
 800c07c:	e7fa      	bcc.n	800c074 <psloop>
 800c07e:	4919      	ldr	r1, [pc, #100]	; (800c0e4 <endfiniloop+0x1a>)
 800c080:	4a19      	ldr	r2, [pc, #100]	; (800c0e8 <endfiniloop+0x1e>)
 800c082:	4b1a      	ldr	r3, [pc, #104]	; (800c0ec <endfiniloop+0x22>)

0800c084 <dloop>:
 800c084:	429a      	cmp	r2, r3
 800c086:	bf3e      	ittt	cc
 800c088:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800c08c:	f842 0b04 	strcc.w	r0, [r2], #4
 800c090:	e7f8      	bcc.n	800c084 <dloop>
 800c092:	2000      	movs	r0, #0
 800c094:	4916      	ldr	r1, [pc, #88]	; (800c0f0 <endfiniloop+0x26>)
 800c096:	4a17      	ldr	r2, [pc, #92]	; (800c0f4 <endfiniloop+0x2a>)

0800c098 <bloop>:
 800c098:	4291      	cmp	r1, r2
 800c09a:	bf3c      	itt	cc
 800c09c:	f841 0b04 	strcc.w	r0, [r1], #4
 800c0a0:	e7fa      	bcc.n	800c098 <bloop>
 800c0a2:	f000 f8fd 	bl	800c2a0 <__late_init>
 800c0a6:	4c14      	ldr	r4, [pc, #80]	; (800c0f8 <endfiniloop+0x2e>)
 800c0a8:	4d14      	ldr	r5, [pc, #80]	; (800c0fc <endfiniloop+0x32>)

0800c0aa <initloop>:
 800c0aa:	42ac      	cmp	r4, r5
 800c0ac:	da03      	bge.n	800c0b6 <endinitloop>
 800c0ae:	f854 1b04 	ldr.w	r1, [r4], #4
 800c0b2:	4788      	blx	r1
 800c0b4:	e7f9      	b.n	800c0aa <initloop>

0800c0b6 <endinitloop>:
 800c0b6:	f004 f873 	bl	80101a0 <main>
 800c0ba:	4c11      	ldr	r4, [pc, #68]	; (800c100 <endfiniloop+0x36>)
 800c0bc:	4d11      	ldr	r5, [pc, #68]	; (800c104 <endfiniloop+0x3a>)

0800c0be <finiloop>:
 800c0be:	42ac      	cmp	r4, r5
 800c0c0:	da03      	bge.n	800c0ca <endfiniloop>
 800c0c2:	f854 1b04 	ldr.w	r1, [r4], #4
 800c0c6:	4788      	blx	r1
 800c0c8:	e7f9      	b.n	800c0be <finiloop>

0800c0ca <endfiniloop>:
 800c0ca:	f000 b8f1 	b.w	800c2b0 <__default_exit>
 800c0ce:	0000      	.short	0x0000
 800c0d0:	20000800 	.word	0x20000800
 800c0d4:	55555555 	.word	0x55555555
 800c0d8:	20000000 	.word	0x20000000
 800c0dc:	20000400 	.word	0x20000400
 800c0e0:	20000400 	.word	0x20000400
 800c0e4:	080112b8 	.word	0x080112b8
 800c0e8:	20000800 	.word	0x20000800
 800c0ec:	20000838 	.word	0x20000838
 800c0f0:	20000838 	.word	0x20000838
 800c0f4:	20005778 	.word	0x20005778
 800c0f8:	0800c000 	.word	0x0800c000
 800c0fc:	0800c000 	.word	0x0800c000
 800c100:	0800c000 	.word	0x0800c000
 800c104:	0800c000 	.word	0x0800c000
	...

0800c110 <_port_switch>:
 800c110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c114:	ed2d 8a10 	vpush	{s16-s31}
 800c118:	f8c1 d00c 	str.w	sp, [r1, #12]
 800c11c:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800c120:	ecbd 8a10 	vpop	{s16-s31}
 800c124:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c128 <_port_thread_start>:
 800c128:	b662      	cpsie	i
 800c12a:	4628      	mov	r0, r5
 800c12c:	47a0      	blx	r4
 800c12e:	2000      	movs	r0, #0
 800c130:	f000 fbae 	bl	800c890 <chThdExit>

0800c134 <_port_switch_from_isr>:
 800c134:	f000 fad4 	bl	800c6e0 <chSchDoReschedule>

0800c138 <_port_exit_from_isr>:
 800c138:	f64e 5304 	movw	r3, #60676	; 0xed04
 800c13c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800c140:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c144:	601a      	str	r2, [r3, #0]
 800c146:	b662      	cpsie	i
 800c148:	e7fe      	b.n	800c148 <_port_exit_from_isr+0x10>
 800c14a:	0000      	movs	r0, r0
 800c14c:	0000      	movs	r0, r0
	...

0800c150 <memcpy>:
 800c150:	4684      	mov	ip, r0
 800c152:	ea41 0300 	orr.w	r3, r1, r0
 800c156:	f013 0303 	ands.w	r3, r3, #3
 800c15a:	d16d      	bne.n	800c238 <memcpy+0xe8>
 800c15c:	3a40      	subs	r2, #64	; 0x40
 800c15e:	d341      	bcc.n	800c1e4 <memcpy+0x94>
 800c160:	f851 3b04 	ldr.w	r3, [r1], #4
 800c164:	f840 3b04 	str.w	r3, [r0], #4
 800c168:	f851 3b04 	ldr.w	r3, [r1], #4
 800c16c:	f840 3b04 	str.w	r3, [r0], #4
 800c170:	f851 3b04 	ldr.w	r3, [r1], #4
 800c174:	f840 3b04 	str.w	r3, [r0], #4
 800c178:	f851 3b04 	ldr.w	r3, [r1], #4
 800c17c:	f840 3b04 	str.w	r3, [r0], #4
 800c180:	f851 3b04 	ldr.w	r3, [r1], #4
 800c184:	f840 3b04 	str.w	r3, [r0], #4
 800c188:	f851 3b04 	ldr.w	r3, [r1], #4
 800c18c:	f840 3b04 	str.w	r3, [r0], #4
 800c190:	f851 3b04 	ldr.w	r3, [r1], #4
 800c194:	f840 3b04 	str.w	r3, [r0], #4
 800c198:	f851 3b04 	ldr.w	r3, [r1], #4
 800c19c:	f840 3b04 	str.w	r3, [r0], #4
 800c1a0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1a4:	f840 3b04 	str.w	r3, [r0], #4
 800c1a8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1ac:	f840 3b04 	str.w	r3, [r0], #4
 800c1b0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1b4:	f840 3b04 	str.w	r3, [r0], #4
 800c1b8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1bc:	f840 3b04 	str.w	r3, [r0], #4
 800c1c0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1c4:	f840 3b04 	str.w	r3, [r0], #4
 800c1c8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1cc:	f840 3b04 	str.w	r3, [r0], #4
 800c1d0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1d4:	f840 3b04 	str.w	r3, [r0], #4
 800c1d8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1dc:	f840 3b04 	str.w	r3, [r0], #4
 800c1e0:	3a40      	subs	r2, #64	; 0x40
 800c1e2:	d2bd      	bcs.n	800c160 <memcpy+0x10>
 800c1e4:	3230      	adds	r2, #48	; 0x30
 800c1e6:	d311      	bcc.n	800c20c <memcpy+0xbc>
 800c1e8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1ec:	f840 3b04 	str.w	r3, [r0], #4
 800c1f0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1f4:	f840 3b04 	str.w	r3, [r0], #4
 800c1f8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c1fc:	f840 3b04 	str.w	r3, [r0], #4
 800c200:	f851 3b04 	ldr.w	r3, [r1], #4
 800c204:	f840 3b04 	str.w	r3, [r0], #4
 800c208:	3a10      	subs	r2, #16
 800c20a:	d2ed      	bcs.n	800c1e8 <memcpy+0x98>
 800c20c:	320c      	adds	r2, #12
 800c20e:	d305      	bcc.n	800c21c <memcpy+0xcc>
 800c210:	f851 3b04 	ldr.w	r3, [r1], #4
 800c214:	f840 3b04 	str.w	r3, [r0], #4
 800c218:	3a04      	subs	r2, #4
 800c21a:	d2f9      	bcs.n	800c210 <memcpy+0xc0>
 800c21c:	3204      	adds	r2, #4
 800c21e:	d008      	beq.n	800c232 <memcpy+0xe2>
 800c220:	07d2      	lsls	r2, r2, #31
 800c222:	bf1c      	itt	ne
 800c224:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800c228:	f800 3b01 	strbne.w	r3, [r0], #1
 800c22c:	d301      	bcc.n	800c232 <memcpy+0xe2>
 800c22e:	880b      	ldrh	r3, [r1, #0]
 800c230:	8003      	strh	r3, [r0, #0]
 800c232:	4660      	mov	r0, ip
 800c234:	4770      	bx	lr
 800c236:	bf00      	nop
 800c238:	2a08      	cmp	r2, #8
 800c23a:	d313      	bcc.n	800c264 <memcpy+0x114>
 800c23c:	078b      	lsls	r3, r1, #30
 800c23e:	d08d      	beq.n	800c15c <memcpy+0xc>
 800c240:	f010 0303 	ands.w	r3, r0, #3
 800c244:	d08a      	beq.n	800c15c <memcpy+0xc>
 800c246:	f1c3 0304 	rsb	r3, r3, #4
 800c24a:	1ad2      	subs	r2, r2, r3
 800c24c:	07db      	lsls	r3, r3, #31
 800c24e:	bf1c      	itt	ne
 800c250:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800c254:	f800 3b01 	strbne.w	r3, [r0], #1
 800c258:	d380      	bcc.n	800c15c <memcpy+0xc>
 800c25a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800c25e:	f820 3b02 	strh.w	r3, [r0], #2
 800c262:	e77b      	b.n	800c15c <memcpy+0xc>
 800c264:	3a04      	subs	r2, #4
 800c266:	d3d9      	bcc.n	800c21c <memcpy+0xcc>
 800c268:	3a01      	subs	r2, #1
 800c26a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800c26e:	f800 3b01 	strb.w	r3, [r0], #1
 800c272:	d2f9      	bcs.n	800c268 <memcpy+0x118>
 800c274:	780b      	ldrb	r3, [r1, #0]
 800c276:	7003      	strb	r3, [r0, #0]
 800c278:	784b      	ldrb	r3, [r1, #1]
 800c27a:	7043      	strb	r3, [r0, #1]
 800c27c:	788b      	ldrb	r3, [r1, #2]
 800c27e:	7083      	strb	r3, [r0, #2]
 800c280:	4660      	mov	r0, ip
 800c282:	4770      	bx	lr
	...

0800c290 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 800c290:	4770      	bx	lr
 800c292:	bf00      	nop
	...

0800c2a0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 800c2a0:	4770      	bx	lr
 800c2a2:	bf00      	nop
	...

0800c2b0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 800c2b0:	e7fe      	b.n	800c2b0 <__default_exit>
 800c2b2:	bf00      	nop
	...

0800c2c0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 800c2c0:	e7fe      	b.n	800c2c0 <_unhandled_exception>
 800c2c2:	bf00      	nop
	...

0800c2d0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 800c2d0:	e7fe      	b.n	800c2d0 <_idle_thread>
 800c2d2:	bf00      	nop
	...

0800c2e0 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 800c2e0:	4b1d      	ldr	r3, [pc, #116]	; (800c358 <chSysInit+0x78>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 800c2e2:	4a1e      	ldr	r2, [pc, #120]	; (800c35c <chSysInit+0x7c>)
  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800c2e4:	481e      	ldr	r0, [pc, #120]	; (800c360 <chSysInit+0x80>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 800c2e6:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 800c2e8:	2400      	movs	r4, #0
 800c2ea:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800c2ec:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800c2ee:	4e1d      	ldr	r6, [pc, #116]	; (800c364 <chSysInit+0x84>)
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800c2f0:	4d1d      	ldr	r5, [pc, #116]	; (800c368 <chSysInit+0x88>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 800c2f2:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 800c2f6:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                 |
 800c2f8:	430a      	orrs	r2, r1
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800c2fa:	60da      	str	r2, [r3, #12]
 800c2fc:	68f2      	ldr	r2, [r6, #12]
 800c2fe:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800c302:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800c304:	6802      	ldr	r2, [r0, #0]
 800c306:	f042 0201 	orr.w	r2, r2, #1
 800c30a:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 800c30c:	b083      	sub	sp, #12
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800c30e:	f883 4022 	strb.w	r4, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 800c312:	f000 f8e5 	bl	800c4e0 <_scheduler_init>
  _vt_init();
 800c316:	f000 f86b 	bl	800c3f0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 800c31a:	f000 fb41 	bl	800c9a0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 800c31e:	f000 fd47 	bl	800cdb0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 800c322:	f000 fd75 	bl	800ce10 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800c326:	4628      	mov	r0, r5
 800c328:	2140      	movs	r1, #64	; 0x40
 800c32a:	f000 f9e9 	bl	800c700 <_thread_init>
 800c32e:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800c332:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800c334:	6198      	str	r0, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800c336:	7702      	strb	r2, [r0, #28]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800c338:	b662      	cpsie	i
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 800c33a:	699b      	ldr	r3, [r3, #24]
 800c33c:	490b      	ldr	r1, [pc, #44]	; (800c36c <chSysInit+0x8c>)
 800c33e:	6199      	str	r1, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 800c340:	f105 0050 	add.w	r0, r5, #80	; 0x50
 800c344:	9400      	str	r4, [sp, #0]
 800c346:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
 800c34a:	4b09      	ldr	r3, [pc, #36]	; (800c370 <chSysInit+0x90>)
 800c34c:	f000 fa38 	bl	800c7c0 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 800c350:	4b08      	ldr	r3, [pc, #32]	; (800c374 <chSysInit+0x94>)
 800c352:	6183      	str	r3, [r0, #24]
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
  }
#endif
}
 800c354:	b003      	add	sp, #12
 800c356:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c358:	e000ed00 	.word	0xe000ed00
 800c35c:	05fa0300 	.word	0x05fa0300
 800c360:	e0001000 	.word	0xe0001000
 800c364:	e000edf0 	.word	0xe000edf0
 800c368:	20000868 	.word	0x20000868
 800c36c:	08010b20 	.word	0x08010b20
 800c370:	0800c2d1 	.word	0x0800c2d1
 800c374:	08010b10 	.word	0x08010b10
	...

0800c380 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 800c380:	b570      	push	{r4, r5, r6, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
 800c382:	4c11      	ldr	r4, [pc, #68]	; (800c3c8 <chSysTimerHandlerI+0x48>)
 800c384:	69a2      	ldr	r2, [r4, #24]
 800c386:	7fd3      	ldrb	r3, [r2, #31]
 800c388:	b10b      	cbz	r3, 800c38e <chSysTimerHandlerI+0xe>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800c38a:	3b01      	subs	r3, #1
 800c38c:	77d3      	strb	r3, [r2, #31]
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
 800c38e:	6a11      	ldr	r1, [r2, #32]

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800c390:	69e3      	ldr	r3, [r4, #28]
 800c392:	4e0e      	ldr	r6, [pc, #56]	; (800c3cc <chSysTimerHandlerI+0x4c>)
 800c394:	3101      	adds	r1, #1
 800c396:	6211      	str	r1, [r2, #32]
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 800c398:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800c39a:	42b3      	cmp	r3, r6
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 800c39c:	f102 0201 	add.w	r2, r2, #1
 800c3a0:	62a2      	str	r2, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800c3a2:	d010      	beq.n	800c3c6 <chSysTimerHandlerI+0x46>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 800c3a4:	689d      	ldr	r5, [r3, #8]
 800c3a6:	3d01      	subs	r5, #1
 800c3a8:	609d      	str	r5, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 800c3aa:	b965      	cbnz	r5, 800c3c6 <chSysTimerHandlerI+0x46>
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
      vtp->vt_func = NULL;
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800c3ac:	681a      	ldr	r2, [r3, #0]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
 800c3ae:	68d9      	ldr	r1, [r3, #12]
      vtp->vt_func = NULL;
 800c3b0:	60dd      	str	r5, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800c3b2:	6056      	str	r6, [r2, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800c3b4:	61e2      	str	r2, [r4, #28]
 800c3b6:	b662      	cpsie	i
      chSysUnlockFromISR();
      fn(vtp->vt_par);
 800c3b8:	6918      	ldr	r0, [r3, #16]
 800c3ba:	4788      	blx	r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800c3bc:	b672      	cpsid	i
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 800c3be:	69e3      	ldr	r3, [r4, #28]
 800c3c0:	689a      	ldr	r2, [r3, #8]
 800c3c2:	2a00      	cmp	r2, #0
 800c3c4:	d0f2      	beq.n	800c3ac <chSysTimerHandlerI+0x2c>
 800c3c6:	bd70      	pop	{r4, r5, r6, pc}
 800c3c8:	20000838 	.word	0x20000838
 800c3cc:	20000854 	.word	0x20000854

0800c3d0 <chSysPolledDelayX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800c3d0:	4a03      	ldr	r2, [pc, #12]	; (800c3e0 <chSysPolledDelayX+0x10>)
 800c3d2:	6851      	ldr	r1, [r2, #4]
 800c3d4:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 800c3d6:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 800c3d8:	4298      	cmp	r0, r3
 800c3da:	d8fb      	bhi.n	800c3d4 <chSysPolledDelayX+0x4>
  }
}
 800c3dc:	4770      	bx	lr
 800c3de:	bf00      	nop
 800c3e0:	e0001000 	.word	0xe0001000
	...

0800c3f0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800c3f0:	4b05      	ldr	r3, [pc, #20]	; (800c408 <_vt_init+0x18>)
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800c3f2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800c3f6:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 800c3fa:	2100      	movs	r1, #0
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800c3fc:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 800c3fe:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800c400:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 800c402:	621a      	str	r2, [r3, #32]
 800c404:	4770      	bx	lr
 800c406:	bf00      	nop
 800c408:	20000838 	.word	0x20000838
 800c40c:	00000000 	.word	0x00000000

0800c410 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800c410:	b470      	push	{r4, r5, r6}
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 800c412:	4e0d      	ldr	r6, [pc, #52]	; (800c448 <chVTDoSetI+0x38>)
 800c414:	69f4      	ldr	r4, [r6, #28]
  while (p->vt_delta < delta) {
 800c416:	68a5      	ldr	r5, [r4, #8]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800c418:	6103      	str	r3, [r0, #16]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800c41a:	42a9      	cmp	r1, r5

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800c41c:	60c2      	str	r2, [r0, #12]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800c41e:	d904      	bls.n	800c42a <chVTDoSetI+0x1a>
    delta -= p->vt_delta;
    p = p->vt_next;
 800c420:	6824      	ldr	r4, [r4, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800c422:	1b49      	subs	r1, r1, r5
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800c424:	68a5      	ldr	r5, [r4, #8]
 800c426:	428d      	cmp	r5, r1
 800c428:	d3fa      	bcc.n	800c420 <chVTDoSetI+0x10>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800c42a:	6863      	ldr	r3, [r4, #4]
 800c42c:	6043      	str	r3, [r0, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 800c42e:	6004      	str	r4, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 800c430:	6018      	str	r0, [r3, #0]
  p->vt_prev = vtp;
 800c432:	6060      	str	r0, [r4, #4]
  vtp->vt_delta = delta
 800c434:	6081      	str	r1, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800c436:	68a3      	ldr	r3, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800c438:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800c43c:	1a59      	subs	r1, r3, r1
 800c43e:	60a1      	str	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800c440:	6272      	str	r2, [r6, #36]	; 0x24
}
 800c442:	bc70      	pop	{r4, r5, r6}
 800c444:	4770      	bx	lr
 800c446:	bf00      	nop
 800c448:	20000838 	.word	0x20000838
 800c44c:	00000000 	.word	0x00000000

0800c450 <chVTDoResetI>:
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 800c450:	6803      	ldr	r3, [r0, #0]
 800c452:	6882      	ldr	r2, [r0, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 800c454:	6841      	ldr	r1, [r0, #4]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800c456:	b430      	push	{r4, r5}
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 800c458:	689d      	ldr	r5, [r3, #8]
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 800c45a:	4c06      	ldr	r4, [pc, #24]	; (800c474 <chVTDoResetI+0x24>)
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 800c45c:	442a      	add	r2, r5
 800c45e:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 800c460:	600b      	str	r3, [r1, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800c462:	6805      	ldr	r5, [r0, #0]
  vtp->vt_func = NULL;
 800c464:	2200      	movs	r2, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 800c466:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800c46a:	6069      	str	r1, [r5, #4]
  vtp->vt_func = NULL;
 800c46c:	60c2      	str	r2, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 800c46e:	6263      	str	r3, [r4, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c470:	bc30      	pop	{r4, r5}
 800c472:	4770      	bx	lr
 800c474:	20000838 	.word	0x20000838
	...

0800c480 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800c480:	b410      	push	{r4}
 800c482:	b672      	cpsid	i
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 800c484:	7f03      	ldrb	r3, [r0, #28]
 800c486:	2b07      	cmp	r3, #7
 800c488:	d80e      	bhi.n	800c4a8 <wakeup+0x28>
 800c48a:	e8df f003 	tbb	[pc, r3]
 800c48e:	0d1d      	.short	0x0d1d
 800c490:	0408210d 	.word	0x0408210d
 800c494:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800c496:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800c498:	6893      	ldr	r3, [r2, #8]
 800c49a:	3301      	adds	r3, #1
 800c49c:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800c49e:	e890 000c 	ldmia.w	r0, {r2, r3}
 800c4a2:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800c4a4:	6802      	ldr	r2, [r0, #0]
 800c4a6:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800c4a8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c4ac:	2200      	movs	r2, #0
 800c4ae:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 800c4b0:	4b09      	ldr	r3, [pc, #36]	; (800c4d8 <wakeup+0x58>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800c4b2:	6244      	str	r4, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c4b4:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800c4b6:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800c4b8:	689a      	ldr	r2, [r3, #8]
 800c4ba:	428a      	cmp	r2, r1
 800c4bc:	d2fb      	bcs.n	800c4b6 <wakeup+0x36>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800c4be:	685a      	ldr	r2, [r3, #4]
 800c4c0:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800c4c2:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800c4c4:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800c4c6:	6058      	str	r0, [r3, #4]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800c4c8:	b662      	cpsie	i
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 800c4ca:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c4ce:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 800c4d0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800c4d2:	2200      	movs	r2, #0
 800c4d4:	601a      	str	r2, [r3, #0]
    break;
 800c4d6:	e7e7      	b.n	800c4a8 <wakeup+0x28>
 800c4d8:	20000838 	.word	0x20000838
 800c4dc:	00000000 	.word	0x00000000

0800c4e0 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800c4e0:	4b03      	ldr	r3, [pc, #12]	; (800c4f0 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800c4e2:	2200      	movs	r2, #0
 800c4e4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800c4e6:	605b      	str	r3, [r3, #4]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 800c4e8:	611b      	str	r3, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 800c4ea:	615b      	str	r3, [r3, #20]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800c4ec:	609a      	str	r2, [r3, #8]
 800c4ee:	4770      	bx	lr
 800c4f0:	20000838 	.word	0x20000838
	...

0800c500 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c500:	2200      	movs	r2, #0
 800c502:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 800c504:	4b08      	ldr	r3, [pc, #32]	; (800c528 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800c506:	b410      	push	{r4}
 800c508:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c50a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800c50c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800c50e:	689a      	ldr	r2, [r3, #8]
 800c510:	428a      	cmp	r2, r1
 800c512:	d2fb      	bcs.n	800c50c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800c514:	685a      	ldr	r2, [r3, #4]
 800c516:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800c518:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 800c51a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800c51c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800c51e:	605c      	str	r4, [r3, #4]

  return tp;
}
 800c520:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c524:	4770      	bx	lr
 800c526:	bf00      	nop
 800c528:	20000838 	.word	0x20000838
 800c52c:	00000000 	.word	0x00000000

0800c530 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 800c530:	4b08      	ldr	r3, [pc, #32]	; (800c554 <chSchGoSleepS+0x24>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800c532:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800c534:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 800c536:	6999      	ldr	r1, [r3, #24]

  tqp->p_next = tp->p_next;
 800c538:	6814      	ldr	r4, [r2, #0]
  otp->p_state = newstate;
 800c53a:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c53c:	2501      	movs	r5, #1
  otp = currp;
  otp->p_state = newstate;
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c53e:	2004      	movs	r0, #4
 800c540:	77c8      	strb	r0, [r1, #31]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800c542:	6063      	str	r3, [r4, #4]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c544:	7715      	strb	r5, [r2, #28]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800c546:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 800c548:	4610      	mov	r0, r2
}
 800c54a:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800c54c:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800c54e:	f7ff bddf 	b.w	800c110 <_port_switch>
 800c552:	bf00      	nop
 800c554:	20000838 	.word	0x20000838
	...

0800c560 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800c560:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800c562:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800c564:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800c566:	d012      	beq.n	800c58e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800c568:	4c0c      	ldr	r4, [pc, #48]	; (800c59c <chSchGoSleepTimeoutS+0x3c>)
 800c56a:	4a0d      	ldr	r2, [pc, #52]	; (800c5a0 <chSchGoSleepTimeoutS+0x40>)
 800c56c:	69a3      	ldr	r3, [r4, #24]
 800c56e:	4605      	mov	r5, r0
 800c570:	a801      	add	r0, sp, #4
 800c572:	f7ff ff4d 	bl	800c410 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800c576:	4628      	mov	r0, r5
 800c578:	f7ff ffda 	bl	800c530 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800c57c:	9b04      	ldr	r3, [sp, #16]
 800c57e:	b113      	cbz	r3, 800c586 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 800c580:	a801      	add	r0, sp, #4
 800c582:	f7ff ff65 	bl	800c450 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 800c586:	69a3      	ldr	r3, [r4, #24]
}
 800c588:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800c58a:	b007      	add	sp, #28
 800c58c:	bd30      	pop	{r4, r5, pc}
 800c58e:	4c03      	ldr	r4, [pc, #12]	; (800c59c <chSchGoSleepTimeoutS+0x3c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800c590:	f7ff ffce 	bl	800c530 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 800c594:	69a3      	ldr	r3, [r4, #24]
}
 800c596:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800c598:	b007      	add	sp, #28
 800c59a:	bd30      	pop	{r4, r5, pc}
 800c59c:	20000838 	.word	0x20000838
 800c5a0:	0800c481 	.word	0x0800c481
	...

0800c5b0 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800c5b0:	4b14      	ldr	r3, [pc, #80]	; (800c604 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800c5b2:	b470      	push	{r4, r5, r6}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800c5b4:	699e      	ldr	r6, [r3, #24]
 800c5b6:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800c5b8:	4605      	mov	r5, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800c5ba:	68b0      	ldr	r0, [r6, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 800c5bc:	6269      	str	r1, [r5, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800c5be:	4284      	cmp	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c5c0:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800c5c4:	d80b      	bhi.n	800c5de <chSchWakeupS+0x2e>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c5c6:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800c5c8:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800c5ca:	689a      	ldr	r2, [r3, #8]
 800c5cc:	4294      	cmp	r4, r2
 800c5ce:	d9fb      	bls.n	800c5c8 <chSchWakeupS+0x18>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800c5d0:	685a      	ldr	r2, [r3, #4]
 800c5d2:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800c5d4:	602b      	str	r3, [r5, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800c5d6:	6015      	str	r5, [r2, #0]
  cp->p_prev = tp;
 800c5d8:	605d      	str	r5, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800c5da:	bc70      	pop	{r4, r5, r6}
 800c5dc:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c5de:	7732      	strb	r2, [r6, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 800c5e0:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
 800c5e2:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 800c5e4:	6891      	ldr	r1, [r2, #8]
 800c5e6:	4288      	cmp	r0, r1
 800c5e8:	d9fb      	bls.n	800c5e2 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800c5ea:	6850      	ldr	r0, [r2, #4]
 800c5ec:	6070      	str	r0, [r6, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800c5ee:	2401      	movs	r4, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800c5f0:	6032      	str	r2, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800c5f2:	6006      	str	r6, [r0, #0]
  cp->p_prev = tp;
 800c5f4:	6056      	str	r6, [r2, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800c5f6:	772c      	strb	r4, [r5, #28]
    chSysSwitch(ntp, otp);
 800c5f8:	4631      	mov	r1, r6
 800c5fa:	4628      	mov	r0, r5
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 800c5fc:	619d      	str	r5, [r3, #24]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800c5fe:	bc70      	pop	{r4, r5, r6}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 800c600:	f7ff bd86 	b.w	800c110 <_port_switch>
 800c604:	20000838 	.word	0x20000838
	...

0800c610 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800c610:	4b08      	ldr	r3, [pc, #32]	; (800c634 <chSchIsPreemptionRequired+0x24>)
  tprio_t p2 = currp->p_prio;
 800c612:	699a      	ldr	r2, [r3, #24]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800c614:	681b      	ldr	r3, [r3, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 800c616:	7fd1      	ldrb	r1, [r2, #31]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800c618:	689b      	ldr	r3, [r3, #8]
  tprio_t p2 = currp->p_prio;
 800c61a:	6890      	ldr	r0, [r2, #8]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 800c61c:	b921      	cbnz	r1, 800c628 <chSchIsPreemptionRequired+0x18>
 800c61e:	4283      	cmp	r3, r0
 800c620:	bf34      	ite	cc
 800c622:	2000      	movcc	r0, #0
 800c624:	2001      	movcs	r0, #1
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 800c626:	4770      	bx	lr
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 800c628:	4283      	cmp	r3, r0
 800c62a:	bf94      	ite	ls
 800c62c:	2000      	movls	r0, #0
 800c62e:	2001      	movhi	r0, #1
 800c630:	4770      	bx	lr
 800c632:	bf00      	nop
 800c634:	20000838 	.word	0x20000838
	...

0800c640 <chSchDoRescheduleBehind>:
 * @special
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
 800c640:	4a0e      	ldr	r2, [pc, #56]	; (800c67c <chSchDoRescheduleBehind+0x3c>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800c642:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 800c644:	b4f0      	push	{r4, r5, r6, r7}

  tqp->p_next = tp->p_next;
 800c646:	6803      	ldr	r3, [r0, #0]
  thread_t *otp;

  otp = currp;
 800c648:	6994      	ldr	r4, [r2, #24]
 800c64a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c64c:	2701      	movs	r7, #1
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c64e:	2604      	movs	r6, #4
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c650:	2500      	movs	r5, #0
 800c652:	68a1      	ldr	r1, [r4, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800c654:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c656:	7707      	strb	r7, [r0, #28]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800c658:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c65a:	77e6      	strb	r6, [r4, #31]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c65c:	7725      	strb	r5, [r4, #28]
 800c65e:	e000      	b.n	800c662 <chSchDoRescheduleBehind+0x22>
 800c660:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 800c662:	689a      	ldr	r2, [r3, #8]
 800c664:	428a      	cmp	r2, r1
 800c666:	d2fb      	bcs.n	800c660 <chSchDoRescheduleBehind+0x20>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800c668:	685a      	ldr	r2, [r3, #4]
 800c66a:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800c66c:	6023      	str	r3, [r4, #0]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 800c66e:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800c670:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800c672:	605c      	str	r4, [r3, #4]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
}
 800c674:	bcf0      	pop	{r4, r5, r6, r7}
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 800c676:	f7ff bd4b 	b.w	800c110 <_port_switch>
 800c67a:	bf00      	nop
 800c67c:	20000838 	.word	0x20000838

0800c680 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 800c680:	4a0d      	ldr	r2, [pc, #52]	; (800c6b8 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800c682:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800c684:	b470      	push	{r4, r5, r6}

  tqp->p_next = tp->p_next;
 800c686:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 800c688:	6994      	ldr	r4, [r2, #24]
 800c68a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c68c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 800c68e:	2500      	movs	r5, #0
 800c690:	68a1      	ldr	r1, [r4, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800c692:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c694:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800c696:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 800c698:	7725      	strb	r5, [r4, #28]
 800c69a:	e000      	b.n	800c69e <chSchDoRescheduleAhead+0x1e>
 800c69c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800c69e:	689a      	ldr	r2, [r3, #8]
 800c6a0:	428a      	cmp	r2, r1
 800c6a2:	d8fb      	bhi.n	800c69c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 800c6a4:	685a      	ldr	r2, [r3, #4]
 800c6a6:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800c6a8:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800c6aa:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 800c6ac:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 800c6ae:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
}
 800c6b0:	bc70      	pop	{r4, r5, r6}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800c6b2:	f7ff bd2d 	b.w	800c110 <_port_switch>
 800c6b6:	bf00      	nop
 800c6b8:	20000838 	.word	0x20000838
 800c6bc:	00000000 	.word	0x00000000

0800c6c0 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 800c6c0:	4b04      	ldr	r3, [pc, #16]	; (800c6d4 <chSchRescheduleS+0x14>)
 800c6c2:	681a      	ldr	r2, [r3, #0]
 800c6c4:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 800c6c6:	6892      	ldr	r2, [r2, #8]
 800c6c8:	689b      	ldr	r3, [r3, #8]
 800c6ca:	429a      	cmp	r2, r3
 800c6cc:	d800      	bhi.n	800c6d0 <chSchRescheduleS+0x10>
 800c6ce:	4770      	bx	lr
    chSchDoRescheduleAhead();
 800c6d0:	f7ff bfd6 	b.w	800c680 <chSchDoRescheduleAhead>
 800c6d4:	20000838 	.word	0x20000838
	...

0800c6e0 <chSchDoReschedule>:
void chSchDoReschedule(void) {

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
 800c6e0:	4b03      	ldr	r3, [pc, #12]	; (800c6f0 <chSchDoReschedule+0x10>)
 800c6e2:	699b      	ldr	r3, [r3, #24]
 800c6e4:	7fdb      	ldrb	r3, [r3, #31]
 800c6e6:	b10b      	cbz	r3, 800c6ec <chSchDoReschedule+0xc>
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 800c6e8:	f7ff bfca 	b.w	800c680 <chSchDoRescheduleAhead>
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 800c6ec:	f7ff bfa8 	b.w	800c640 <chSchDoRescheduleBehind>
 800c6f0:	20000838 	.word	0x20000838
	...

0800c700 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 800c700:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c704:	4c11      	ldr	r4, [pc, #68]	; (800c74c <_thread_init+0x4c>)
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800c706:	6401      	str	r1, [r0, #64]	; 0x40
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c708:	6966      	ldr	r6, [r4, #20]
 800c70a:	6146      	str	r6, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800c70c:	2200      	movs	r2, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800c70e:	f100 052c 	add.w	r5, r0, #44	; 0x2c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800c712:	f04f 0802 	mov.w	r8, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c716:	f04f 0c04 	mov.w	ip, #4
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800c71a:	f04f 0e01 	mov.w	lr, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800c71e:	f100 0728 	add.w	r7, r0, #40	; 0x28
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800c722:	6081      	str	r1, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c724:	6104      	str	r4, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800c726:	f880 801c 	strb.w	r8, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c72a:	f880 c01f 	strb.w	ip, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800c72e:	f880 e01e 	strb.w	lr, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800c732:	7742      	strb	r2, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800c734:	63c2      	str	r2, [r0, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800c736:	6382      	str	r2, [r0, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
 800c738:	6202      	str	r2, [r0, #32]
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800c73a:	6182      	str	r2, [r0, #24]
  REG_INSERT(tp);
 800c73c:	6130      	str	r0, [r6, #16]
 800c73e:	6160      	str	r0, [r4, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800c740:	6287      	str	r7, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800c742:	62c5      	str	r5, [r0, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 800c744:	6305      	str	r5, [r0, #48]	; 0x30
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 800c746:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c74a:	bf00      	nop
 800c74c:	20000838 	.word	0x20000838

0800c750 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 800c750:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c754:	3964      	subs	r1, #100	; 0x64
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c756:	4f18      	ldr	r7, [pc, #96]	; (800c7b8 <chThdCreateI+0x68>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c758:	f8df 9060 	ldr.w	r9, [pc, #96]	; 800c7bc <chThdCreateI+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c75c:	f8d7 e014 	ldr.w	lr, [r7, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c760:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800c762:	4401      	add	r1, r0
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800c764:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c766:	60c1      	str	r1, [r0, #12]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800c768:	f04f 0b02 	mov.w	fp, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c76c:	640b      	str	r3, [r1, #64]	; 0x40

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c76e:	f04f 0a04 	mov.w	sl, #4
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800c772:	f100 032c 	add.w	r3, r0, #44	; 0x2c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800c776:	f04f 0801 	mov.w	r8, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800c77a:	f100 0c28 	add.w	ip, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c77e:	644e      	str	r6, [r1, #68]	; 0x44
 800c780:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800c784:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c786:	6107      	str	r7, [r0, #16]
 800c788:	f8c0 e014 	str.w	lr, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800c78c:	6402      	str	r2, [r0, #64]	; 0x40
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800c78e:	f880 b01c 	strb.w	fp, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c792:	f880 a01f 	strb.w	sl, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800c796:	f880 801e 	strb.w	r8, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800c79a:	7745      	strb	r5, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800c79c:	63c5      	str	r5, [r0, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800c79e:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
 800c7a0:	6205      	str	r5, [r0, #32]
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800c7a2:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 800c7a4:	f8ce 0010 	str.w	r0, [lr, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800c7a8:	f8c0 c028 	str.w	ip, [r0, #40]	; 0x28
 800c7ac:	6178      	str	r0, [r7, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800c7ae:	62c3      	str	r3, [r0, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 800c7b0:	6303      	str	r3, [r0, #48]	; 0x30
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
}
 800c7b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c7b6:	bf00      	nop
 800c7b8:	20000838 	.word	0x20000838
 800c7bc:	0800c129 	.word	0x0800c129

0800c7c0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 800c7c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c7c4:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800c7c6:	b672      	cpsid	i
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c7c8:	4e1a      	ldr	r6, [pc, #104]	; (800c834 <chThdCreateStatic+0x74>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c7ca:	f8df a06c 	ldr.w	sl, [pc, #108]	; 800c838 <chThdCreateStatic+0x78>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c7ce:	6977      	ldr	r7, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c7d0:	3964      	subs	r1, #100	; 0x64
 800c7d2:	4401      	add	r1, r0
 800c7d4:	60c1      	str	r1, [r0, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800c7d6:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c7d8:	640b      	str	r3, [r1, #64]	; 0x40
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800c7da:	f100 0b2c 	add.w	fp, r0, #44	; 0x2c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800c7de:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800c7e2:	f100 0e28 	add.w	lr, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c7e6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c7e8:	644b      	str	r3, [r1, #68]	; 0x44
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800c7ea:	f04f 0902 	mov.w	r9, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c7ee:	f04f 0804 	mov.w	r8, #4

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800c7f2:	f8c1 a060 	str.w	sl, [r1, #96]	; 0x60
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800c7f6:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c7f8:	6106      	str	r6, [r0, #16]
 800c7fa:	6147      	str	r7, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800c7fc:	6402      	str	r2, [r0, #64]	; 0x40
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800c7fe:	f880 901c 	strb.w	r9, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800c802:	f880 801f 	strb.w	r8, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800c806:	f880 c01e 	strb.w	ip, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800c80a:	7745      	strb	r5, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800c80c:	63c5      	str	r5, [r0, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800c80e:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
 800c810:	6205      	str	r5, [r0, #32]
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800c812:	6185      	str	r5, [r0, #24]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 800c814:	4629      	mov	r1, r5
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800c816:	6138      	str	r0, [r7, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800c818:	f8c0 e028 	str.w	lr, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800c81c:	f8c0 b02c 	str.w	fp, [r0, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 800c820:	f8c0 b030 	str.w	fp, [r0, #48]	; 0x30
 800c824:	6170      	str	r0, [r6, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 800c826:	f7ff fec3 	bl	800c5b0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800c82a:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 800c82c:	4620      	mov	r0, r4
 800c82e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c832:	bf00      	nop
 800c834:	20000838 	.word	0x20000838
 800c838:	0800c129 	.word	0x0800c129
 800c83c:	00000000 	.word	0x00000000

0800c840 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 800c840:	b508      	push	{r3, lr}
 800c842:	4601      	mov	r1, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800c844:	b672      	cpsid	i
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800c846:	2008      	movs	r0, #8
 800c848:	f7ff fe8a 	bl	800c560 <chSchGoSleepTimeoutS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800c84c:	b662      	cpsie	i
 800c84e:	bd08      	pop	{r3, pc}

0800c850 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 800c850:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 800c852:	4b0e      	ldr	r3, [pc, #56]	; (800c88c <chThdExitS+0x3c>)
 800c854:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800c856:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  tp->p_u.exitcode = msg;
 800c858:	6260      	str	r0, [r4, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800c85a:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800c85e:	429d      	cmp	r5, r3
 800c860:	d007      	beq.n	800c872 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 800c862:	681a      	ldr	r2, [r3, #0]
 800c864:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800c866:	4618      	mov	r0, r3
 800c868:	f7ff fe4a 	bl	800c500 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800c86c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800c86e:	42ab      	cmp	r3, r5
 800c870:	d1f7      	bne.n	800c862 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 800c872:	7f63      	ldrb	r3, [r4, #29]
 800c874:	079b      	lsls	r3, r3, #30
 800c876:	d104      	bne.n	800c882 <chThdExitS+0x32>
    REG_REMOVE(tp);
 800c878:	6963      	ldr	r3, [r4, #20]
 800c87a:	6922      	ldr	r2, [r4, #16]
 800c87c:	611a      	str	r2, [r3, #16]
 800c87e:	6922      	ldr	r2, [r4, #16]
 800c880:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800c882:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 800c884:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800c888:	f7ff be52 	b.w	800c530 <chSchGoSleepS>
 800c88c:	20000838 	.word	0x20000838

0800c890 <chThdExit>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800c890:	b672      	cpsid	i
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 800c892:	f7ff bfdd 	b.w	800c850 <chThdExitS>
 800c896:	bf00      	nop
	...

0800c8a0 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 800c8a0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c8a2:	4c05      	ldr	r4, [pc, #20]	; (800c8b8 <chThdSuspendS+0x18>)
 800c8a4:	69a3      	ldr	r3, [r4, #24]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 800c8a6:	6003      	str	r3, [r0, #0]
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 800c8a8:	4602      	mov	r2, r0
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->p_u.wttrp = trp;
 800c8aa:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 800c8ac:	2003      	movs	r0, #3
 800c8ae:	f7ff fe3f 	bl	800c530 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800c8b2:	69a3      	ldr	r3, [r4, #24]
}
 800c8b4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800c8b6:	bd10      	pop	{r4, pc}
 800c8b8:	20000838 	.word	0x20000838
 800c8bc:	00000000 	.word	0x00000000

0800c8c0 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 800c8c0:	6803      	ldr	r3, [r0, #0]
 800c8c2:	b12b      	cbz	r3, 800c8d0 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 800c8c4:	2200      	movs	r2, #0
 800c8c6:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800c8c8:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 800c8ca:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800c8cc:	f7ff be18 	b.w	800c500 <chSchReadyI>
 800c8d0:	4770      	bx	lr
 800c8d2:	bf00      	nop
	...

0800c8e0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 800c8e0:	b169      	cbz	r1, 800c8fe <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800c8e2:	4b08      	ldr	r3, [pc, #32]	; (800c904 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 800c8e4:	b410      	push	{r4}
 800c8e6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800c8e8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800c8ea:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800c8ec:	2004      	movs	r0, #4
 800c8ee:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 800c8f2:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 800c8f4:	6053      	str	r3, [r2, #4]
}
 800c8f6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800c8fa:	f7ff be31 	b.w	800c560 <chSchGoSleepTimeoutS>
}
 800c8fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800c902:	4770      	bx	lr
 800c904:	20000838 	.word	0x20000838
	...

0800c910 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800c910:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800c912:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 800c914:	4298      	cmp	r0, r3
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800c916:	4604      	mov	r4, r0
 800c918:	460d      	mov	r5, r1

  while (queue_notempty(tqp)) {
 800c91a:	d009      	beq.n	800c930 <chThdDequeueAllI+0x20>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800c91c:	681a      	ldr	r2, [r3, #0]
 800c91e:	6022      	str	r2, [r4, #0]
  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
  (void) chSchReadyI(tp);
 800c920:	4618      	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
 800c922:	6054      	str	r4, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 800c924:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800c926:	f7ff fdeb 	bl	800c500 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800c92a:	6823      	ldr	r3, [r4, #0]
 800c92c:	429c      	cmp	r4, r3
 800c92e:	d1f5      	bne.n	800c91c <chThdDequeueAllI+0xc>
 800c930:	bd38      	pop	{r3, r4, r5, pc}
 800c932:	bf00      	nop
	...

0800c940 <chTMStartMeasurementX>:
 800c940:	4b01      	ldr	r3, [pc, #4]	; (800c948 <chTMStartMeasurementX+0x8>)
 800c942:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 800c944:	6083      	str	r3, [r0, #8]
 800c946:	4770      	bx	lr
 800c948:	e0001000 	.word	0xe0001000
 800c94c:	00000000 	.word	0x00000000

0800c950 <chTMStopMeasurementX>:
 800c950:	4b0f      	ldr	r3, [pc, #60]	; (800c990 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800c952:	4910      	ldr	r1, [pc, #64]	; (800c994 <chTMStopMeasurementX+0x44>)
 800c954:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800c956:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800c958:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800c95a:	6f8f      	ldr	r7, [r1, #120]	; 0x78

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800c95c:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 800c95e:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800c960:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800c964:	1ad3      	subs	r3, r2, r3
 800c966:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 800c968:	18e4      	adds	r4, r4, r3
 800c96a:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800c96e:	3601      	adds	r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 800c970:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800c972:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 800c974:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800c976:	e9c0 4504 	strd	r4, r5, [r0, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 800c97a:	d805      	bhi.n	800c988 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 800c97c:	6802      	ldr	r2, [r0, #0]
 800c97e:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 800c980:	bf38      	it	cc
 800c982:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800c984:	bcf0      	pop	{r4, r5, r6, r7}
 800c986:	4770      	bx	lr
  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 800c988:	6043      	str	r3, [r0, #4]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800c98a:	bcf0      	pop	{r4, r5, r6, r7}
 800c98c:	4770      	bx	lr
 800c98e:	bf00      	nop
 800c990:	e0001000 	.word	0xe0001000
 800c994:	20000838 	.word	0x20000838
	...

0800c9a0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 800c9a0:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 800c9a2:	4c0c      	ldr	r4, [pc, #48]	; (800c9d4 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 800c9a4:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 800c9a6:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800c9a8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800c9ac:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800c9ae:	2600      	movs	r6, #0
 800c9b0:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 800c9b2:	67a3      	str	r3, [r4, #120]	; 0x78
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 800c9b4:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 800c9b6:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 800c9b8:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800c9ba:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800c9bc:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800c9c0:	f7ff ffbe 	bl	800c940 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800c9c4:	4668      	mov	r0, sp
 800c9c6:	f7ff ffc3 	bl	800c950 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800c9ca:	9b02      	ldr	r3, [sp, #8]
 800c9cc:	67a3      	str	r3, [r4, #120]	; 0x78
}
 800c9ce:	b006      	add	sp, #24
 800c9d0:	bdd0      	pop	{r4, r6, r7, pc}
 800c9d2:	bf00      	nop
 800c9d4:	20000838 	.word	0x20000838
	...

0800c9e0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 800c9e0:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800c9e2:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800c9e4:	6040      	str	r0, [r0, #4]
 800c9e6:	6083      	str	r3, [r0, #8]
 800c9e8:	4770      	bx	lr
 800c9ea:	bf00      	nop
 800c9ec:	0000      	movs	r0, r0
	...

0800c9f0 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 800c9f0:	4b30      	ldr	r3, [pc, #192]	; (800cab4 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800c9f2:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 800c9f4:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 800c9f6:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800c9f8:	2a00      	cmp	r2, #0
 800c9fa:	d055      	beq.n	800caa8 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800c9fc:	68a1      	ldr	r1, [r4, #8]
 800c9fe:	6893      	ldr	r3, [r2, #8]
 800ca00:	4299      	cmp	r1, r3
 800ca02:	4605      	mov	r5, r0
 800ca04:	d906      	bls.n	800ca14 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800ca06:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 800ca08:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800ca0a:	2b06      	cmp	r3, #6
 800ca0c:	d033      	beq.n	800ca76 <chMtxLockS+0x86>
 800ca0e:	2b07      	cmp	r3, #7
 800ca10:	d01d      	beq.n	800ca4e <chMtxLockS+0x5e>
 800ca12:	b19b      	cbz	r3, 800ca3c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800ca14:	462b      	mov	r3, r5
 800ca16:	e003      	b.n	800ca20 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800ca18:	6899      	ldr	r1, [r3, #8]
 800ca1a:	68a2      	ldr	r2, [r4, #8]
 800ca1c:	4291      	cmp	r1, r2
 800ca1e:	d302      	bcc.n	800ca26 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800ca20:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800ca22:	429d      	cmp	r5, r3
 800ca24:	d1f8      	bne.n	800ca18 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800ca26:	685a      	ldr	r2, [r3, #4]
 800ca28:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800ca2a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800ca2c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800ca2e:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 800ca30:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800ca32:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 800ca34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800ca38:	f7ff bd7a 	b.w	800c530 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800ca3c:	e892 000a 	ldmia.w	r2, {r1, r3}
 800ca40:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800ca42:	6811      	ldr	r1, [r2, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800ca44:	4610      	mov	r0, r2
 800ca46:	604b      	str	r3, [r1, #4]
 800ca48:	f7ff fd5a 	bl	800c500 <chSchReadyI>
          break;
 800ca4c:	e7e2      	b.n	800ca14 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800ca4e:	e892 0009 	ldmia.w	r2, {r0, r3}
 800ca52:	6018      	str	r0, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800ca54:	6a56      	ldr	r6, [r2, #36]	; 0x24
  tp->p_next->p_prev = tp->p_prev;
 800ca56:	6810      	ldr	r0, [r2, #0]
 800ca58:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800ca5a:	4633      	mov	r3, r6
 800ca5c:	e002      	b.n	800ca64 <chMtxLockS+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800ca5e:	6898      	ldr	r0, [r3, #8]
 800ca60:	4288      	cmp	r0, r1
 800ca62:	d302      	bcc.n	800ca6a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800ca64:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800ca66:	429e      	cmp	r6, r3
 800ca68:	d1f9      	bne.n	800ca5e <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800ca6a:	6859      	ldr	r1, [r3, #4]
 800ca6c:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800ca6e:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800ca70:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 800ca72:	605a      	str	r2, [r3, #4]
 800ca74:	e7ce      	b.n	800ca14 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800ca76:	e892 0009 	ldmia.w	r2, {r0, r3}
 800ca7a:	6018      	str	r0, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800ca7c:	6a56      	ldr	r6, [r2, #36]	; 0x24
  tp->p_next->p_prev = tp->p_prev;
 800ca7e:	6810      	ldr	r0, [r2, #0]
 800ca80:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800ca82:	4633      	mov	r3, r6
 800ca84:	e002      	b.n	800ca8c <chMtxLockS+0x9c>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800ca86:	6898      	ldr	r0, [r3, #8]
 800ca88:	4288      	cmp	r0, r1
 800ca8a:	d302      	bcc.n	800ca92 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800ca8c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800ca8e:	429e      	cmp	r6, r3
 800ca90:	d1f9      	bne.n	800ca86 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800ca92:	6859      	ldr	r1, [r3, #4]
 800ca94:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800ca96:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800ca98:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 800ca9a:	605a      	str	r2, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 800ca9c:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800ca9e:	68a1      	ldr	r1, [r4, #8]
 800caa0:	6893      	ldr	r3, [r2, #8]
 800caa2:	428b      	cmp	r3, r1
 800caa4:	d3af      	bcc.n	800ca06 <chMtxLockS+0x16>
 800caa6:	e7b5      	b.n	800ca14 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 800caa8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800caaa:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 800caac:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 800caae:	63e0      	str	r0, [r4, #60]	; 0x3c
 800cab0:	bd70      	pop	{r4, r5, r6, pc}
 800cab2:	bf00      	nop
 800cab4:	20000838 	.word	0x20000838
	...

0800cac0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 800cac0:	b508      	push	{r3, lr}
 800cac2:	b672      	cpsid	i

  chSysLock();
  chMtxLockS(mp);
 800cac4:	f7ff ff94 	bl	800c9f0 <chMtxLockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cac8:	b662      	cpsie	i
 800caca:	bd08      	pop	{r3, pc}
 800cacc:	0000      	movs	r0, r0
	...

0800cad0 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 800cad0:	4b14      	ldr	r3, [pc, #80]	; (800cb24 <chMtxUnlock+0x54>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 800cad2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 800cad4:	699d      	ldr	r5, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cad6:	b672      	cpsid	i
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800cad8:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800cada:	68c3      	ldr	r3, [r0, #12]
 800cadc:	63eb      	str	r3, [r5, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800cade:	42a0      	cmp	r0, r4
 800cae0:	d01b      	beq.n	800cb1a <chMtxUnlock+0x4a>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 800cae2:	6c29      	ldr	r1, [r5, #64]	; 0x40
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800cae4:	b14b      	cbz	r3, 800cafa <chMtxUnlock+0x2a>
 800cae6:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800cae8:	4293      	cmp	r3, r2
 800caea:	d003      	beq.n	800caf4 <chMtxUnlock+0x24>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800caec:	6892      	ldr	r2, [r2, #8]
 800caee:	4291      	cmp	r1, r2
 800caf0:	bf38      	it	cc
 800caf2:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 800caf4:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800caf6:	2b00      	cmp	r3, #0
 800caf8:	d1f5      	bne.n	800cae6 <chMtxUnlock+0x16>
 800cafa:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800cafc:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 800cafe:	6be6      	ldr	r6, [r4, #60]	; 0x3c
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800cb00:	60a9      	str	r1, [r5, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800cb02:	4620      	mov	r0, r4
 800cb04:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800cb06:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 800cb08:	609c      	str	r4, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 800cb0a:	60de      	str	r6, [r3, #12]
      tp->p_mtxlist = mp;
 800cb0c:	63e3      	str	r3, [r4, #60]	; 0x3c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800cb0e:	f7ff fcf7 	bl	800c500 <chSchReadyI>
      chSchRescheduleS();
 800cb12:	f7ff fdd5 	bl	800c6c0 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cb16:	b662      	cpsie	i
 800cb18:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->m_owner = NULL;
 800cb1a:	2300      	movs	r3, #0
 800cb1c:	6083      	str	r3, [r0, #8]
 800cb1e:	b662      	cpsie	i
 800cb20:	bd70      	pop	{r4, r5, r6, pc}
 800cb22:	bf00      	nop
 800cb24:	20000838 	.word	0x20000838
	...

0800cb30 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800cb30:	6b83      	ldr	r3, [r0, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800cb32:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800cb34:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800cb36:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800cb38:	6381      	str	r1, [r0, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800cb3a:	d00a      	beq.n	800cb52 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800cb3c:	2a0b      	cmp	r2, #11
 800cb3e:	d000      	beq.n	800cb42 <chEvtSignalI+0x12>
 800cb40:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 800cb42:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800cb44:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800cb46:	428b      	cmp	r3, r1
 800cb48:	d1fa      	bne.n	800cb40 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800cb4a:	2300      	movs	r3, #0
 800cb4c:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 800cb4e:	f7ff bcd7 	b.w	800c500 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800cb52:	6a43      	ldr	r3, [r0, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800cb54:	4219      	tst	r1, r3
 800cb56:	d1f8      	bne.n	800cb4a <chEvtSignalI+0x1a>
 800cb58:	4770      	bx	lr
 800cb5a:	bf00      	nop
 800cb5c:	0000      	movs	r0, r0
	...

0800cb60 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 800cb60:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 800cb62:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800cb64:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 800cb66:	4606      	mov	r6, r0
 800cb68:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800cb6a:	d00d      	beq.n	800cb88 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->el_flags |= flags;
 800cb6c:	68e3      	ldr	r3, [r4, #12]
 800cb6e:	432b      	orrs	r3, r5
 800cb70:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800cb72:	b115      	cbz	r5, 800cb7a <chEvtBroadcastFlagsI+0x1a>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 800cb74:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800cb76:	4213      	tst	r3, r2
 800cb78:	d003      	beq.n	800cb82 <chEvtBroadcastFlagsI+0x22>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 800cb7a:	6860      	ldr	r0, [r4, #4]
 800cb7c:	68a1      	ldr	r1, [r4, #8]
 800cb7e:	f7ff ffd7 	bl	800cb30 <chEvtSignalI>
    }
    elp = elp->el_next;
 800cb82:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800cb84:	42a6      	cmp	r6, r4
 800cb86:	d1f1      	bne.n	800cb6c <chEvtBroadcastFlagsI+0xc>
 800cb88:	bd70      	pop	{r4, r5, r6, pc}
 800cb8a:	bf00      	nop
 800cb8c:	0000      	movs	r0, r0
	...

0800cb90 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 800cb90:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cb92:	b672      	cpsid	i

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 800cb94:	f7ff ffcc 	bl	800cb30 <chEvtSignalI>
  chSchRescheduleS();
 800cb98:	f7ff fd92 	bl	800c6c0 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cb9c:	b662      	cpsie	i
 800cb9e:	bd08      	pop	{r3, pc}

0800cba0 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 800cba0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 800cba2:	4b0a      	ldr	r3, [pc, #40]	; (800cbcc <chEvtWaitAny+0x2c>)
 800cba4:	699d      	ldr	r5, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cba6:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800cba8:	6bab      	ldr	r3, [r5, #56]	; 0x38
  if (m == (eventmask_t)0) {
 800cbaa:	ea10 0403 	ands.w	r4, r0, r3
 800cbae:	d106      	bne.n	800cbbe <chEvtWaitAny+0x1e>
 800cbb0:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 800cbb2:	6268      	str	r0, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 800cbb4:	200a      	movs	r0, #10
 800cbb6:	f7ff fcbb 	bl	800c530 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800cbba:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800cbbc:	401c      	ands	r4, r3
  }
  ctp->p_epending &= ~m;
 800cbbe:	ea23 0304 	bic.w	r3, r3, r4
 800cbc2:	63ab      	str	r3, [r5, #56]	; 0x38
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cbc4:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 800cbc6:	4620      	mov	r0, r4
 800cbc8:	bd38      	pop	{r3, r4, r5, pc}
 800cbca:	bf00      	nop
 800cbcc:	20000838 	.word	0x20000838

0800cbd0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 800cbd0:	b430      	push	{r4, r5}
 800cbd2:	9c02      	ldr	r4, [sp, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 800cbd4:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800cbd6:	2500      	movs	r5, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800cbd8:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800cbda:	6085      	str	r5, [r0, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800cbdc:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800cbde:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800cbe0:	6040      	str	r0, [r0, #4]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800cbe2:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 800cbe4:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 800cbe6:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 800cbe8:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
}
 800cbea:	bc30      	pop	{r4, r5}
 800cbec:	4770      	bx	lr
 800cbee:	bf00      	nop

0800cbf0 <chIQResetI>:

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 800cbf0:	2100      	movs	r1, #0
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 800cbf2:	68c2      	ldr	r2, [r0, #12]
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 800cbf4:	6081      	str	r1, [r0, #8]
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 800cbf6:	6182      	str	r2, [r0, #24]
  iqp->q_wrptr = iqp->q_buffer;
 800cbf8:	6142      	str	r2, [r0, #20]
  iqp->q_counter = 0;
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800cbfa:	f06f 0101 	mvn.w	r1, #1
 800cbfe:	f7ff be87 	b.w	800c910 <chThdDequeueAllI>
 800cc02:	bf00      	nop
	...

0800cc10 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 800cc10:	b538      	push	{r3, r4, r5, lr}
 800cc12:	460d      	mov	r5, r1
 800cc14:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cc16:	b672      	cpsid	i
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 800cc18:	69c3      	ldr	r3, [r0, #28]
 800cc1a:	b12b      	cbz	r3, 800cc28 <chIQGetTimeout+0x18>
    iqp->q_notify(iqp);
 800cc1c:	4798      	blx	r3
 800cc1e:	e003      	b.n	800cc28 <chIQGetTimeout+0x18>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800cc20:	f7ff fe5e 	bl	800c8e0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 800cc24:	2800      	cmp	r0, #0
 800cc26:	db11      	blt.n	800cc4c <chIQGetTimeout+0x3c>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800cc28:	68a3      	ldr	r3, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800cc2a:	4620      	mov	r0, r4
 800cc2c:	4629      	mov	r1, r5
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 800cc2e:	2b00      	cmp	r3, #0
 800cc30:	d0f6      	beq.n	800cc20 <chIQGetTimeout+0x10>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800cc32:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800cc34:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800cc36:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800cc38:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800cc3a:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800cc3c:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800cc3e:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800cc40:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800cc42:	bf28      	it	cs
 800cc44:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800cc46:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800cc48:	bf28      	it	cs
 800cc4a:	61a3      	strcs	r3, [r4, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cc4c:	b662      	cpsie	i
  }
  chSysUnlock();

  return (msg_t)b;
}
 800cc4e:	bd38      	pop	{r3, r4, r5, pc}

0800cc50 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 800cc50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800cc54:	4604      	mov	r4, r0
 800cc56:	4688      	mov	r8, r1
 800cc58:	4691      	mov	r9, r2
 800cc5a:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 800cc5c:	69c7      	ldr	r7, [r0, #28]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cc5e:	b672      	cpsid	i
  size_t r = 0;
 800cc60:	2600      	movs	r6, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 800cc62:	b12f      	cbz	r7, 800cc70 <chIQReadTimeout+0x20>
      nfy(iqp);
 800cc64:	4620      	mov	r0, r4
 800cc66:	47b8      	blx	r7
 800cc68:	e002      	b.n	800cc70 <chIQReadTimeout+0x20>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800cc6a:	f7ff fe39 	bl	800c8e0 <chThdEnqueueTimeoutS>
 800cc6e:	b9c8      	cbnz	r0, 800cca4 <chIQReadTimeout+0x54>
 800cc70:	68a3      	ldr	r3, [r4, #8]
 800cc72:	4620      	mov	r0, r4
 800cc74:	4629      	mov	r1, r5
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 800cc76:	2b00      	cmp	r3, #0
 800cc78:	d0f7      	beq.n	800cc6a <chIQReadTimeout+0x1a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800cc7a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800cc7c:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800cc7e:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800cc80:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 800cc82:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800cc84:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800cc86:	7813      	ldrb	r3, [r2, #0]
 800cc88:	f808 3b01 	strb.w	r3, [r8], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 800cc8c:	6923      	ldr	r3, [r4, #16]
 800cc8e:	69a2      	ldr	r2, [r4, #24]
 800cc90:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 800cc92:	bf24      	itt	cs
 800cc94:	68e3      	ldrcs	r3, [r4, #12]
 800cc96:	61a3      	strcs	r3, [r4, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cc98:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 800cc9a:	3601      	adds	r6, #1
    if (--n == 0U) {
 800cc9c:	45b1      	cmp	r9, r6
 800cc9e:	d002      	beq.n	800cca6 <chIQReadTimeout+0x56>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cca0:	b672      	cpsid	i
 800cca2:	e7de      	b.n	800cc62 <chIQReadTimeout+0x12>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cca4:	b662      	cpsie	i
      return r;
    }

    chSysLock();
  }
}
 800cca6:	4630      	mov	r0, r6
 800cca8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800ccac:	0000      	movs	r0, r0
	...

0800ccb0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 800ccb0:	b430      	push	{r4, r5}
 800ccb2:	9c02      	ldr	r4, [sp, #8]
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 800ccb4:	6204      	str	r4, [r0, #32]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800ccb6:	188d      	adds	r5, r1, r2
 800ccb8:	6105      	str	r5, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800ccba:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800ccbc:	6040      	str	r0, [r0, #4]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800ccbe:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 800ccc0:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 800ccc2:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 800ccc4:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 800ccc6:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
}
 800ccc8:	bc30      	pop	{r4, r5}
 800ccca:	4770      	bx	lr
 800cccc:	0000      	movs	r0, r0
	...

0800ccd0 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 800ccd0:	b410      	push	{r4}

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 800ccd2:	6902      	ldr	r2, [r0, #16]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 800ccd4:	68c4      	ldr	r4, [r0, #12]
 800ccd6:	6184      	str	r4, [r0, #24]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 800ccd8:	1b12      	subs	r2, r2, r4
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
 800ccda:	6144      	str	r4, [r0, #20]
  oqp->q_counter = chQSizeX(oqp);
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 800ccdc:	f06f 0101 	mvn.w	r1, #1

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 800cce0:	6082      	str	r2, [r0, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
}
 800cce2:	f85d 4b04 	ldr.w	r4, [sp], #4
  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 800cce6:	f7ff be13 	b.w	800c910 <chThdDequeueAllI>
 800ccea:	bf00      	nop
 800ccec:	0000      	movs	r0, r0
	...

0800ccf0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 800ccf0:	b570      	push	{r4, r5, r6, lr}
 800ccf2:	4604      	mov	r4, r0
 800ccf4:	460e      	mov	r6, r1
 800ccf6:	4615      	mov	r5, r2
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ccf8:	b672      	cpsid	i
 800ccfa:	e003      	b.n	800cd04 <chOQPutTimeout+0x14>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 800ccfc:	f7ff fdf0 	bl	800c8e0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 800cd00:	2800      	cmp	r0, #0
 800cd02:	db18      	blt.n	800cd36 <chOQPutTimeout+0x46>
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800cd04:	68a3      	ldr	r3, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 800cd06:	4620      	mov	r0, r4
 800cd08:	4629      	mov	r1, r5
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800cd0a:	2b00      	cmp	r3, #0
 800cd0c:	d0f6      	beq.n	800ccfc <chOQPutTimeout+0xc>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 800cd0e:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800cd10:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800cd12:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800cd14:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 800cd16:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800cd18:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800cd1a:	7016      	strb	r6, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800cd1c:	6923      	ldr	r3, [r4, #16]
 800cd1e:	6962      	ldr	r2, [r4, #20]
 800cd20:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 800cd22:	bf24      	itt	cs
 800cd24:	68e3      	ldrcs	r3, [r4, #12]
 800cd26:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 800cd28:	69e3      	ldr	r3, [r4, #28]
 800cd2a:	b10b      	cbz	r3, 800cd30 <chOQPutTimeout+0x40>
    oqp->q_notify(oqp);
 800cd2c:	4620      	mov	r0, r4
 800cd2e:	4798      	blx	r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cd30:	b662      	cpsie	i
  }
  chSysUnlock();

  return Q_OK;
 800cd32:	2000      	movs	r0, #0
}
 800cd34:	bd70      	pop	{r4, r5, r6, pc}
 800cd36:	b662      	cpsie	i
  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
 800cd38:	bd70      	pop	{r4, r5, r6, pc}
 800cd3a:	bf00      	nop
 800cd3c:	0000      	movs	r0, r0
	...

0800cd40 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 800cd40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800cd44:	4604      	mov	r4, r0
 800cd46:	460d      	mov	r5, r1
 800cd48:	4616      	mov	r6, r2
 800cd4a:	4699      	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
 800cd4c:	f8d0 801c 	ldr.w	r8, [r0, #28]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cd50:	b672      	cpsid	i
  size_t w = 0;
 800cd52:	2700      	movs	r7, #0
 800cd54:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800cd56:	f105 0a01 	add.w	sl, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 800cd5a:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800cd5c:	b1f3      	cbz	r3, 800cd9c <chOQWriteTimeout+0x5c>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800cd5e:	6962      	ldr	r2, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800cd60:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800cd62:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800cd64:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 800cd66:	6161      	str	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800cd68:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800cd6a:	782b      	ldrb	r3, [r5, #0]
 800cd6c:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800cd6e:	6923      	ldr	r3, [r4, #16]
 800cd70:	6962      	ldr	r2, [r4, #20]
 800cd72:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 800cd74:	bf24      	itt	cs
 800cd76:	68e3      	ldrcs	r3, [r4, #12]
 800cd78:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 800cd7a:	f1b8 0f00 	cmp.w	r8, #0
 800cd7e:	d000      	beq.n	800cd82 <chOQWriteTimeout+0x42>
      nfy(oqp);
 800cd80:	47c0      	blx	r8
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cd82:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 800cd84:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 800cd86:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 800cd8a:	d00e      	beq.n	800cdaa <chOQWriteTimeout+0x6a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cd8c:	b672      	cpsid	i
 800cd8e:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800cd90:	4655      	mov	r5, sl
 800cd92:	f105 0a01 	add.w	sl, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 800cd96:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800cd98:	2b00      	cmp	r3, #0
 800cd9a:	d1e0      	bne.n	800cd5e <chOQWriteTimeout+0x1e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800cd9c:	4620      	mov	r0, r4
 800cd9e:	4649      	mov	r1, r9
 800cda0:	f7ff fd9e 	bl	800c8e0 <chThdEnqueueTimeoutS>
 800cda4:	2800      	cmp	r0, #0
 800cda6:	d0d5      	beq.n	800cd54 <chOQWriteTimeout+0x14>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cda8:	b662      	cpsie	i
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 800cdaa:	4638      	mov	r0, r7
 800cdac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800cdb0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800cdb0:	4a05      	ldr	r2, [pc, #20]	; (800cdc8 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800cdb2:	4b06      	ldr	r3, [pc, #24]	; (800cdcc <_core_init+0x1c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800cdb4:	4806      	ldr	r0, [pc, #24]	; (800cdd0 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800cdb6:	4907      	ldr	r1, [pc, #28]	; (800cdd4 <_core_init+0x24>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800cdb8:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800cdbc:	f023 0307 	bic.w	r3, r3, #7
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800cdc0:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800cdc2:	600b      	str	r3, [r1, #0]
 800cdc4:	4770      	bx	lr
 800cdc6:	bf00      	nop
 800cdc8:	2000577f 	.word	0x2000577f
 800cdcc:	20020000 	.word	0x20020000
 800cdd0:	20000a94 	.word	0x20000a94
 800cdd4:	20000a90 	.word	0x20000a90
	...

0800cde0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 800cde0:	b410      	push	{r4}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cde2:	b672      	cpsid	i

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800cde4:	4c08      	ldr	r4, [pc, #32]	; (800ce08 <chCoreAlloc+0x28>)
 800cde6:	4b09      	ldr	r3, [pc, #36]	; (800ce0c <chCoreAlloc+0x2c>)
 800cde8:	6822      	ldr	r2, [r4, #0]
 800cdea:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 800cdec:	1dc3      	adds	r3, r0, #7
 800cdee:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800cdf2:	1a89      	subs	r1, r1, r2
 800cdf4:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 800cdf6:	bf9d      	ittte	ls
 800cdf8:	189b      	addls	r3, r3, r2
 800cdfa:	6023      	strls	r3, [r4, #0]

  return p;
 800cdfc:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 800cdfe:	2000      	movhi	r0, #0
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ce00:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800ce02:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ce06:	4770      	bx	lr
 800ce08:	20000a94 	.word	0x20000a94
 800ce0c:	20000a90 	.word	0x20000a90

0800ce10 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 800ce10:	4b04      	ldr	r3, [pc, #16]	; (800ce24 <_heap_init+0x14>)
 800ce12:	4a05      	ldr	r2, [pc, #20]	; (800ce28 <_heap_init+0x18>)
 800ce14:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 800ce16:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = NULL;
 800ce1a:	2200      	movs	r2, #0
 800ce1c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 800ce1e:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 800ce20:	f7ff bdde 	b.w	800c9e0 <chMtxObjectInit>
 800ce24:	20000a98 	.word	0x20000a98
 800ce28:	0800cde1 	.word	0x0800cde1
 800ce2c:	00000000 	.word	0x00000000

0800ce30 <PendSV_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 800ce30:	4a05      	ldr	r2, [pc, #20]	; (800ce48 <PendSV_Handler+0x18>)
 800ce32:	6853      	ldr	r3, [r2, #4]
 800ce34:	f023 0301 	bic.w	r3, r3, #1
 800ce38:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800ce3a:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800ce3e:	3368      	adds	r3, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800ce40:	f383 8809 	msr	PSP, r3
 800ce44:	4770      	bx	lr
 800ce46:	bf00      	nop
 800ce48:	e000ef30 	.word	0xe000ef30
 800ce4c:	00000000 	.word	0x00000000

0800ce50 <_port_irq_epilogue>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ce50:	b672      	cpsid	i
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 800ce52:	4b11      	ldr	r3, [pc, #68]	; (800ce98 <_port_irq_epilogue+0x48>)
 800ce54:	685b      	ldr	r3, [r3, #4]
 800ce56:	051b      	lsls	r3, r3, #20
 800ce58:	d401      	bmi.n	800ce5e <_port_irq_epilogue+0xe>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ce5a:	b662      	cpsie	i
 800ce5c:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 800ce5e:	b510      	push	{r4, lr}
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 800ce60:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800ce64:	f3ef 8409 	mrs	r4, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800ce68:	4b0c      	ldr	r3, [pc, #48]	; (800ce9c <_port_irq_epilogue+0x4c>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800ce6a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800ce6e:	68db      	ldr	r3, [r3, #12]
 800ce70:	f844 3c08 	str.w	r3, [r4, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800ce74:	f844 2c4c 	str.w	r2, [r4, #-76]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800ce78:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800ce7c:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800ce80:	f7ff fbc6 	bl	800c610 <chSchIsPreemptionRequired>
 800ce84:	b118      	cbz	r0, 800ce8e <_port_irq_epilogue+0x3e>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800ce86:	4b06      	ldr	r3, [pc, #24]	; (800cea0 <_port_irq_epilogue+0x50>)
 800ce88:	f844 3c50 	str.w	r3, [r4, #-80]
 800ce8c:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800ce8e:	4b05      	ldr	r3, [pc, #20]	; (800cea4 <_port_irq_epilogue+0x54>)
 800ce90:	f844 3c50 	str.w	r3, [r4, #-80]
 800ce94:	bd10      	pop	{r4, pc}
 800ce96:	bf00      	nop
 800ce98:	e000ed00 	.word	0xe000ed00
 800ce9c:	e000ef30 	.word	0xe000ef30
 800cea0:	0800c135 	.word	0x0800c135
 800cea4:	0800c138 	.word	0x0800c138
	...

0800ceb0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 800ceb0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 800ceb2:	f000 ff2d 	bl	800dd10 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800ceb6:	480c      	ldr	r0, [pc, #48]	; (800cee8 <halInit+0x38>)
 800ceb8:	f001 fc22 	bl	800e700 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800cebc:	f000 f820 	bl	800cf00 <adcInit>
#endif
#if (HAL_USE_CAN == TRUE) || defined(__DOXYGEN__)
  canInit();
 800cec0:	f000 f836 	bl	800cf30 <canInit>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
 800cec4:	f000 f864 	bl	800cf90 <extInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 800cec8:	f000 f892 	bl	800cff0 <i2cInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 800cecc:	f000 f8a0 	bl	800d010 <pwmInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 800ced0:	f000 fa4e 	bl	800d370 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 800ced4:	f000 fa5c 	bl	800d390 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 800ced8:	f000 f952 	bl	800d180 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 800cedc:	f002 fc98 	bl	800f810 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 800cee0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800cee4:	f000 b804 	b.w	800cef0 <stInit>
 800cee8:	08010ca0 	.word	0x08010ca0
 800ceec:	00000000 	.word	0x00000000

0800cef0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 800cef0:	f000 bfbe 	b.w	800de70 <st_lld_init>
	...

0800cf00 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 800cf00:	f000 bfc6 	b.w	800de90 <adc_lld_init>
	...

0800cf10 <adcObjectInit>:
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 800cf10:	2300      	movs	r3, #0
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 800cf12:	2201      	movs	r2, #1
 800cf14:	7002      	strb	r2, [r0, #0]
  adcp->config   = NULL;
 800cf16:	6043      	str	r3, [r0, #4]
  adcp->samples  = NULL;
 800cf18:	6083      	str	r3, [r0, #8]
  adcp->depth    = 0;
 800cf1a:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = NULL;
 800cf1c:	6103      	str	r3, [r0, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 800cf1e:	6143      	str	r3, [r0, #20]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 800cf20:	3018      	adds	r0, #24
 800cf22:	f7ff bd5d 	b.w	800c9e0 <chMtxObjectInit>
 800cf26:	bf00      	nop
	...

0800cf30 <canInit>:
 *
 * @init
 */
void canInit(void) {

  can_lld_init();
 800cf30:	f001 bbce 	b.w	800e6d0 <can_lld_init>
	...

0800cf40 <canObjectInit>:
 *
 * @param[out] canp     pointer to the @p CANDriver object
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {
 800cf40:	b5f0      	push	{r4, r5, r6, r7, lr}

  canp->state    = CAN_STOP;
  canp->config   = NULL;
  osalThreadQueueObjectInit(&canp->txqueue);
 800cf42:	f100 0208 	add.w	r2, r0, #8
  osalThreadQueueObjectInit(&canp->rxqueue);
 800cf46:	f100 0310 	add.w	r3, r0, #16
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 800cf4a:	f04f 0c01 	mov.w	ip, #1
  canp->config   = NULL;
 800cf4e:	f04f 0e00 	mov.w	lr, #0
  osalThreadQueueObjectInit(&canp->txqueue);
  osalThreadQueueObjectInit(&canp->rxqueue);
  osalEventObjectInit(&canp->rxfull_event);
 800cf52:	f100 0718 	add.w	r7, r0, #24
  osalEventObjectInit(&canp->txempty_event);
 800cf56:	f100 061c 	add.w	r6, r0, #28
  osalEventObjectInit(&canp->error_event);
 800cf5a:	f100 0520 	add.w	r5, r0, #32
#if CAN_USE_SLEEP_MODE == TRUE
  osalEventObjectInit(&canp->sleep_event);
 800cf5e:	f100 0424 	add.w	r4, r0, #36	; 0x24
  osalEventObjectInit(&canp->wakeup_event);
 800cf62:	f100 0128 	add.w	r1, r0, #40	; 0x28
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 800cf66:	f880 c000 	strb.w	ip, [r0]
  canp->config   = NULL;
 800cf6a:	f8c0 e004 	str.w	lr, [r0, #4]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 800cf6e:	6187      	str	r7, [r0, #24]
 800cf70:	61c6      	str	r6, [r0, #28]
 800cf72:	6205      	str	r5, [r0, #32]
 800cf74:	6244      	str	r4, [r0, #36]	; 0x24
 800cf76:	6281      	str	r1, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800cf78:	6082      	str	r2, [r0, #8]
  tqp->p_prev = (thread_t *)tqp;
 800cf7a:	60c2      	str	r2, [r0, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800cf7c:	6103      	str	r3, [r0, #16]
  tqp->p_prev = (thread_t *)tqp;
 800cf7e:	6143      	str	r3, [r0, #20]
 800cf80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cf82:	bf00      	nop
	...

0800cf90 <extInit>:
 *
 * @init
 */
void extInit(void) {

  ext_lld_init();
 800cf90:	f001 b9c6 	b.w	800e320 <ext_lld_init>
	...

0800cfa0 <extObjectInit>:
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
 800cfa0:	2201      	movs	r2, #1
  extp->config = NULL;
 800cfa2:	2300      	movs	r3, #0
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
 800cfa4:	7002      	strb	r2, [r0, #0]
  extp->config = NULL;
 800cfa6:	6043      	str	r3, [r0, #4]
 800cfa8:	4770      	bx	lr
 800cfaa:	bf00      	nop
 800cfac:	0000      	movs	r0, r0
	...

0800cfb0 <extStart>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] config    pointer to the @p EXTConfig object
 *
 * @api
 */
void extStart(EXTDriver *extp, const EXTConfig *config) {
 800cfb0:	b510      	push	{r4, lr}
 800cfb2:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cfb4:	b672      	cpsid	i
  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
 800cfb6:	6041      	str	r1, [r0, #4]
  ext_lld_start(extp);
 800cfb8:	f001 fa22 	bl	800e400 <ext_lld_start>
  extp->state = EXT_ACTIVE;
 800cfbc:	2302      	movs	r3, #2
 800cfbe:	7023      	strb	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cfc0:	b662      	cpsie	i
 800cfc2:	bd10      	pop	{r4, pc}
	...

0800cfd0 <extChannelEnable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be enabled
 *
 * @api
 */
void extChannelEnable(EXTDriver *extp, expchannel_t channel) {
 800cfd0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cfd2:	b672      	cpsid	i
  osalSysLock();
  osalDbgAssert((extp->state == EXT_ACTIVE) &&
                ((extp->config->channels[channel].mode &
                  EXT_CH_MODE_EDGES_MASK) != EXT_CH_MODE_DISABLED),
                "invalid state");
  extChannelEnableI(extp, channel);
 800cfd4:	f001 f9ac 	bl	800e330 <ext_lld_channel_enable>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cfd8:	b662      	cpsie	i
 800cfda:	bd08      	pop	{r3, pc}
 800cfdc:	0000      	movs	r0, r0
	...

0800cfe0 <extChannelDisable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be disabled
 *
 * @api
 */
void extChannelDisable(EXTDriver *extp, expchannel_t channel) {
 800cfe0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800cfe2:	b672      	cpsid	i
  osalSysLock();
  osalDbgAssert((extp->state == EXT_ACTIVE) &&
                ((extp->config->channels[channel].mode &
                  EXT_CH_MODE_EDGES_MASK) != EXT_CH_MODE_DISABLED),
                "invalid state");
  extChannelDisableI(extp, channel);
 800cfe4:	f001 f9f4 	bl	800e3d0 <ext_lld_channel_disable>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800cfe8:	b662      	cpsie	i
 800cfea:	bd08      	pop	{r3, pc}
 800cfec:	0000      	movs	r0, r0
	...

0800cff0 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 800cff0:	f001 bde6 	b.w	800ebc0 <i2c_lld_init>
	...

0800d000 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 800d000:	2201      	movs	r2, #1
  i2cp->config = NULL;
 800d002:	2300      	movs	r3, #0
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 800d004:	7002      	strb	r2, [r0, #0]
  i2cp->config = NULL;
 800d006:	6043      	str	r3, [r0, #4]
 800d008:	300c      	adds	r0, #12
 800d00a:	f7ff bce9 	b.w	800c9e0 <chMtxObjectInit>
 800d00e:	bf00      	nop

0800d010 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
 800d010:	f002 bbe6 	b.w	800f7e0 <pwm_lld_init>
	...

0800d020 <pwmObjectInit>:
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 800d020:	2300      	movs	r3, #0
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 800d022:	2201      	movs	r2, #1
 800d024:	7002      	strb	r2, [r0, #0]
  pwmp->config   = NULL;
 800d026:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 800d028:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 800d02a:	7403      	strb	r3, [r0, #16]
 800d02c:	4770      	bx	lr
 800d02e:	bf00      	nop

0800d030 <onotify>:
/**
 * @brief   Notification of data inserted into the output queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void onotify(io_queue_t *qp) {
 800d030:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = qGetLink(qp);
 800d032:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800d034:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800d038:	6813      	ldr	r3, [r2, #0]
 800d03a:	7819      	ldrb	r1, [r3, #0]
 800d03c:	2904      	cmp	r1, #4
 800d03e:	d000      	beq.n	800d042 <onotify+0x12>
 800d040:	bd10      	pop	{r4, pc}
 800d042:	7a21      	ldrb	r1, [r4, #8]
 800d044:	2902      	cmp	r1, #2
 800d046:	d1fb      	bne.n	800d040 <onotify+0x10>
    return;
  }

  /* If there is not an ongoing transaction and the output queue contains
     data then a new transaction is started.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800d048:	7911      	ldrb	r1, [r2, #4]
 800d04a:	891a      	ldrh	r2, [r3, #8]
 800d04c:	2301      	movs	r3, #1
 800d04e:	408b      	lsls	r3, r1
 800d050:	4213      	tst	r3, r2
 800d052:	d1f5      	bne.n	800d040 <onotify+0x10>
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800d054:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800d056:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800d058:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800d05a:	1ad3      	subs	r3, r2, r3
    if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 800d05c:	1a5b      	subs	r3, r3, r1
 800d05e:	d0ef      	beq.n	800d040 <onotify+0x10>
 800d060:	b662      	cpsie	i
      osalSysUnlock();

      usbPrepareQueuedTransmit(sdup->config->usbp,
 800d062:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800d066:	6810      	ldr	r0, [r2, #0]
 800d068:	7911      	ldrb	r1, [r2, #4]
 800d06a:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800d06e:	f000 f9e7 	bl	800d440 <usbPrepareQueuedTransmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d072:	b672      	cpsid	i
                               sdup->config->bulk_in,
                               &sdup->oqueue, n);

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 800d074:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
    }
  }
}
 800d078:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usbPrepareQueuedTransmit(sdup->config->usbp,
                               sdup->config->bulk_in,
                               &sdup->oqueue, n);

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 800d07c:	6818      	ldr	r0, [r3, #0]
 800d07e:	7919      	ldrb	r1, [r3, #4]
 800d080:	f000 ba06 	b.w	800d490 <usbStartTransmitI>
	...

0800d090 <inotify>:
/**
 * @brief   Notification of data removed from the input queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void inotify(io_queue_t *qp) {
 800d090:	b510      	push	{r4, lr}
  size_t n, maxsize;
  SerialUSBDriver *sdup = qGetLink(qp);
 800d092:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800d094:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800d098:	6813      	ldr	r3, [r2, #0]
 800d09a:	7819      	ldrb	r1, [r3, #0]
 800d09c:	2904      	cmp	r1, #4
 800d09e:	d000      	beq.n	800d0a2 <inotify+0x12>
 800d0a0:	bd10      	pop	{r4, pc}
 800d0a2:	7a21      	ldrb	r1, [r4, #8]
 800d0a4:	2902      	cmp	r1, #2
 800d0a6:	d1fb      	bne.n	800d0a0 <inotify+0x10>
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800d0a8:	7951      	ldrb	r1, [r2, #5]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800d0aa:	8958      	ldrh	r0, [r3, #10]
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800d0ac:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800d0b0:	2201      	movs	r2, #1
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800d0b2:	68db      	ldr	r3, [r3, #12]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800d0b4:	408a      	lsls	r2, r1
 800d0b6:	4202      	tst	r2, r0
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800d0b8:	8a5b      	ldrh	r3, [r3, #18]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800d0ba:	d1f1      	bne.n	800d0a0 <inotify+0x10>
 */
static inline size_t chIQGetEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 800d0bc:	69a2      	ldr	r2, [r4, #24]
 800d0be:	69e1      	ldr	r1, [r4, #28]
 800d0c0:	6960      	ldr	r0, [r4, #20]
 800d0c2:	1a89      	subs	r1, r1, r2
 800d0c4:	1a0a      	subs	r2, r1, r0
    if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 800d0c6:	4293      	cmp	r3, r2
 800d0c8:	d8ea      	bhi.n	800d0a0 <inotify+0x10>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d0ca:	b662      	cpsie	i
      osalSysUnlock();

      n = (n / maxsize) * maxsize;
 800d0cc:	fbb2 f2f3 	udiv	r2, r2, r3
      usbPrepareQueuedReceive(sdup->config->usbp,
 800d0d0:	f8d4 1254 	ldr.w	r1, [r4, #596]	; 0x254
 800d0d4:	fb03 f302 	mul.w	r3, r3, r2
 800d0d8:	6808      	ldr	r0, [r1, #0]
 800d0da:	7949      	ldrb	r1, [r1, #5]
 800d0dc:	f104 020c 	add.w	r2, r4, #12
 800d0e0:	f000 f99e 	bl	800d420 <usbPrepareQueuedReceive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d0e4:	b672      	cpsid	i
                              sdup->config->bulk_out,
                              &sdup->iqueue, n);

      osalSysLock();
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 800d0e6:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
    }
  }
}
 800d0ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usbPrepareQueuedReceive(sdup->config->usbp,
                              sdup->config->bulk_out,
                              &sdup->iqueue, n);

      osalSysLock();
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 800d0ee:	6818      	ldr	r0, [r3, #0]
 800d0f0:	7959      	ldrb	r1, [r3, #5]
 800d0f2:	f000 b9b5 	b.w	800d460 <usbStartReceiveI>
 800d0f6:	bf00      	nop
	...

0800d100 <readt>:
  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp, n, timeout);
 800d100:	300c      	adds	r0, #12
 800d102:	f7ff bda5 	b.w	800cc50 <chIQReadTimeout>
 800d106:	bf00      	nop
	...

0800d110 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp,
 800d110:	300c      	adds	r0, #12
 800d112:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d116:	f7ff bd9b 	b.w	800cc50 <chIQReadTimeout>
 800d11a:	bf00      	nop
 800d11c:	0000      	movs	r0, r0
	...

0800d120 <writet>:
  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
 800d120:	3030      	adds	r0, #48	; 0x30
 800d122:	f7ff be0d 	b.w	800cd40 <chOQWriteTimeout>
 800d126:	bf00      	nop
	...

0800d130 <write>:
 * Interface implementation.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp,
 800d130:	3030      	adds	r0, #48	; 0x30
 800d132:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d136:	f7ff be03 	b.w	800cd40 <chOQWriteTimeout>
 800d13a:	bf00      	nop
 800d13c:	0000      	movs	r0, r0
	...

0800d140 <gett>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
 800d140:	300c      	adds	r0, #12
 800d142:	f7ff bd65 	b.w	800cc10 <chIQGetTimeout>
 800d146:	bf00      	nop
	...

0800d150 <get>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, TIME_INFINITE);
 800d150:	300c      	adds	r0, #12
 800d152:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800d156:	f7ff bd5b 	b.w	800cc10 <chIQGetTimeout>
 800d15a:	bf00      	nop
 800d15c:	0000      	movs	r0, r0
	...

0800d160 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
 800d160:	3030      	adds	r0, #48	; 0x30
 800d162:	f7ff bdc5 	b.w	800ccf0 <chOQPutTimeout>
 800d166:	bf00      	nop
	...

0800d170 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
 800d170:	3030      	adds	r0, #48	; 0x30
 800d172:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800d176:	f7ff bdbb 	b.w	800ccf0 <chOQPutTimeout>
 800d17a:	bf00      	nop
 800d17c:	0000      	movs	r0, r0
	...

0800d180 <sduInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
 800d180:	4770      	bx	lr
 800d182:	bf00      	nop
	...

0800d190 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800d190:	b510      	push	{r4, lr}

  sdup->vmt = &vmt;
 800d192:	4603      	mov	r3, r0
 800d194:	4a0e      	ldr	r2, [pc, #56]	; (800d1d0 <sduObjectInit+0x40>)
 800d196:	f843 2b04 	str.w	r2, [r3], #4
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800d19a:	b082      	sub	sp, #8
 800d19c:	4604      	mov	r4, r0

  sdup->vmt = &vmt;
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 800d19e:	2201      	movs	r2, #1
  iqObjectInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
 800d1a0:	9000      	str	r0, [sp, #0]
 800d1a2:	f104 0154 	add.w	r1, r4, #84	; 0x54
 800d1a6:	6043      	str	r3, [r0, #4]
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 800d1a8:	7202      	strb	r2, [r0, #8]
  iqObjectInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
 800d1aa:	4b0a      	ldr	r3, [pc, #40]	; (800d1d4 <sduObjectInit+0x44>)
 800d1ac:	300c      	adds	r0, #12
 800d1ae:	f44f 7280 	mov.w	r2, #256	; 0x100
 800d1b2:	f7ff fd0d 	bl	800cbd0 <chIQObjectInit>
  oqObjectInit(&sdup->oqueue, sdup->ob, SERIAL_USB_BUFFERS_SIZE, onotify, sdup);
 800d1b6:	9400      	str	r4, [sp, #0]
 800d1b8:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800d1bc:	f504 71aa 	add.w	r1, r4, #340	; 0x154
 800d1c0:	f44f 7280 	mov.w	r2, #256	; 0x100
 800d1c4:	4b04      	ldr	r3, [pc, #16]	; (800d1d8 <sduObjectInit+0x48>)
 800d1c6:	f7ff fd73 	bl	800ccb0 <chOQObjectInit>
}
 800d1ca:	b002      	add	sp, #8
 800d1cc:	bd10      	pop	{r4, pc}
 800d1ce:	bf00      	nop
 800d1d0:	08010b40 	.word	0x08010b40
 800d1d4:	0800d091 	.word	0x0800d091
 800d1d8:	0800d031 	.word	0x0800d031
 800d1dc:	00000000 	.word	0x00000000

0800d1e0 <sduStart>:
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
  USBDriver *usbp = config->usbp;
 800d1e0:	680b      	ldr	r3, [r1, #0]
 800d1e2:	b672      	cpsid	i
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800d1e4:	790a      	ldrb	r2, [r1, #4]
 800d1e6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800d1ea:	6190      	str	r0, [r2, #24]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800d1ec:	794a      	ldrb	r2, [r1, #5]
 800d1ee:	3209      	adds	r2, #9
 800d1f0:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 800d1f4:	798a      	ldrb	r2, [r1, #6]
 800d1f6:	b112      	cbz	r2, 800d1fe <sduStart+0x1e>
    usbp->in_params[config->int_in - 1U]  = sdup;
 800d1f8:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800d1fc:	6198      	str	r0, [r3, #24]
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 800d1fe:	2302      	movs	r3, #2
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  usbp->out_params[config->bulk_out - 1U] = sdup;
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
  }
  sdup->config = config;
 800d200:	f8c0 1254 	str.w	r1, [r0, #596]	; 0x254
  sdup->state = SDU_READY;
 800d204:	7203      	strb	r3, [r0, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d206:	b662      	cpsie	i
 800d208:	4770      	bx	lr
 800d20a:	bf00      	nop
 800d20c:	0000      	movs	r0, r0
	...

0800d210 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800d210:	b570      	push	{r4, r5, r6, lr}
  USBDriver *usbp = sdup->config->usbp;
 800d212:	f8d0 3254 	ldr.w	r3, [r0, #596]	; 0x254

  iqResetI(&sdup->iqueue);
 800d216:	f100 060c 	add.w	r6, r0, #12
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800d21a:	4604      	mov	r4, r0
  USBDriver *usbp = sdup->config->usbp;

  iqResetI(&sdup->iqueue);
 800d21c:	4630      	mov	r0, r6
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
  USBDriver *usbp = sdup->config->usbp;
 800d21e:	681d      	ldr	r5, [r3, #0]

  iqResetI(&sdup->iqueue);
 800d220:	f7ff fce6 	bl	800cbf0 <chIQResetI>
  oqResetI(&sdup->oqueue);
 800d224:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800d228:	f7ff fd52 	bl	800ccd0 <chOQResetI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800d22c:	1d20      	adds	r0, r4, #4
 800d22e:	2101      	movs	r1, #1
 800d230:	f7ff fc96 	bl	800cb60 <chEvtBroadcastFlagsI>
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 800d234:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800d238:	7959      	ldrb	r1, [r3, #5]
 800d23a:	eb05 0381 	add.w	r3, r5, r1, lsl #2
  iqResetI(&sdup->iqueue);
  oqResetI(&sdup->oqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 800d23e:	4628      	mov	r0, r5
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 800d240:	68db      	ldr	r3, [r3, #12]
  iqResetI(&sdup->iqueue);
  oqResetI(&sdup->oqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 800d242:	4632      	mov	r2, r6
 800d244:	8a5b      	ldrh	r3, [r3, #18]
 800d246:	f000 f8eb 	bl	800d420 <usbPrepareQueuedReceive>
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 800d24a:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800d24e:	4628      	mov	r0, r5
 800d250:	7959      	ldrb	r1, [r3, #5]
}
 800d252:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 800d256:	f000 b903 	b.w	800d460 <usbStartReceiveI>
 800d25a:	bf00      	nop
 800d25c:	0000      	movs	r0, r0
	...

0800d260 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 800d260:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 800d264:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800d268:	2b20      	cmp	r3, #32
 800d26a:	d001      	beq.n	800d270 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 800d26c:	2000      	movs	r0, #0
    }
  }
  return false;
}
 800d26e:	4770      	bx	lr
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
    switch (usbp->setup[1]) {
 800d270:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 800d274:	2b21      	cmp	r3, #33	; 0x21
 800d276:	d003      	beq.n	800d280 <sduRequestsHook+0x20>
 800d278:	2b22      	cmp	r3, #34	; 0x22
 800d27a:	d009      	beq.n	800d290 <sduRequestsHook+0x30>
 800d27c:	2b20      	cmp	r3, #32
 800d27e:	d1f5      	bne.n	800d26c <sduRequestsHook+0xc>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800d280:	4b06      	ldr	r3, [pc, #24]	; (800d29c <sduRequestsHook+0x3c>)
 800d282:	6383      	str	r3, [r0, #56]	; 0x38
 800d284:	2207      	movs	r2, #7
 800d286:	2300      	movs	r3, #0
 800d288:	63c2      	str	r2, [r0, #60]	; 0x3c
 800d28a:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 800d28c:	2001      	movs	r0, #1
 800d28e:	4770      	bx	lr
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800d290:	2300      	movs	r3, #0
 800d292:	6383      	str	r3, [r0, #56]	; 0x38
 800d294:	63c3      	str	r3, [r0, #60]	; 0x3c
 800d296:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 800d298:	2001      	movs	r0, #1
 800d29a:	4770      	bx	lr
 800d29c:	20000800 	.word	0x20000800

0800d2a0 <sduDataTransmitted>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800d2a0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800d2a4:	b570      	push	{r4, r5, r6, lr}
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800d2a6:	699c      	ldr	r4, [r3, #24]

  if (sdup == NULL) {
 800d2a8:	b19c      	cbz	r4, 800d2d2 <sduDataTransmitted+0x32>
 800d2aa:	460e      	mov	r6, r1
 800d2ac:	4605      	mov	r5, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d2ae:	b672      	cpsid	i
 800d2b0:	2108      	movs	r1, #8
 800d2b2:	1d20      	adds	r0, r4, #4
 800d2b4:	f7ff fc54 	bl	800cb60 <chEvtBroadcastFlagsI>
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800d2b8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800d2ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800d2bc:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800d2be:	1ad3      	subs	r3, r2, r3

  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 800d2c0:	1a5b      	subs	r3, r3, r1
 800d2c2:	d10b      	bne.n	800d2dc <sduDataTransmitted+0x3c>
    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800d2c4:	eb05 0386 	add.w	r3, r5, r6, lsl #2
 800d2c8:	68db      	ldr	r3, [r3, #12]
 800d2ca:	695a      	ldr	r2, [r3, #20]
 800d2cc:	6852      	ldr	r2, [r2, #4]
 800d2ce:	b90a      	cbnz	r2, 800d2d4 <sduDataTransmitted+0x34>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d2d0:	b662      	cpsie	i
 800d2d2:	bd70      	pop	{r4, r5, r6, pc}
           ((usbp->epc[ep]->in_state->txsize &
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 800d2d4:	8a1b      	ldrh	r3, [r3, #16]
 800d2d6:	3b01      	subs	r3, #1
    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800d2d8:	4013      	ands	r3, r2
 800d2da:	d1f9      	bne.n	800d2d0 <sduDataTransmitted+0x30>
 800d2dc:	b662      	cpsie	i
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    osalSysUnlockFromISR();

    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, 0);
 800d2de:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800d2e2:	4628      	mov	r0, r5
 800d2e4:	4631      	mov	r1, r6
 800d2e6:	f000 f8ab 	bl	800d440 <usbPrepareQueuedTransmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d2ea:	b672      	cpsid	i

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
 800d2ec:	4628      	mov	r0, r5
 800d2ee:	4631      	mov	r1, r6
 800d2f0:	f000 f8ce 	bl	800d490 <usbStartTransmitI>
 800d2f4:	e7ec      	b.n	800d2d0 <sduDataTransmitted+0x30>
 800d2f6:	bf00      	nop
	...

0800d300 <sduDataReceived>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800d300:	f101 0309 	add.w	r3, r1, #9
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 800d304:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800d308:	f850 6023 	ldr.w	r6, [r0, r3, lsl #2]

  if (sdup == NULL) {
 800d30c:	b196      	cbz	r6, 800d334 <sduDataReceived+0x34>
 800d30e:	4680      	mov	r8, r0
 800d310:	460f      	mov	r7, r1
 800d312:	b672      	cpsid	i
 800d314:	2104      	movs	r1, #4
 800d316:	1870      	adds	r0, r6, r1
 800d318:	f7ff fc22 	bl	800cb60 <chEvtBroadcastFlagsI>
  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Writes to the input queue can only happen when there is enough space
     to hold at least one packet.*/
  maxsize = usbp->epc[ep]->out_maxsize;
 800d31c:	eb08 0387 	add.w	r3, r8, r7, lsl #2
 */
static inline size_t chIQGetEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 800d320:	69b4      	ldr	r4, [r6, #24]
 800d322:	68da      	ldr	r2, [r3, #12]
 800d324:	69f5      	ldr	r5, [r6, #28]
 800d326:	6973      	ldr	r3, [r6, #20]
 800d328:	8a51      	ldrh	r1, [r2, #18]
 800d32a:	1b2d      	subs	r5, r5, r4
 800d32c:	1aec      	subs	r4, r5, r3
  if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 800d32e:	42a1      	cmp	r1, r4
 800d330:	d902      	bls.n	800d338 <sduDataReceived+0x38>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d332:	b662      	cpsie	i
 800d334:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d338:	b662      	cpsie	i
    /* The endpoint cannot be busy, we are in the context of the callback,
       so a packet is in the buffer for sure.*/
    osalSysUnlockFromISR();

    n = (n / maxsize) * maxsize;
 800d33a:	fbb4 f3f1 	udiv	r3, r4, r1
    usbPrepareQueuedReceive(usbp, ep, &sdup->iqueue, n);
 800d33e:	f106 020c 	add.w	r2, r6, #12
 800d342:	fb01 f303 	mul.w	r3, r1, r3
 800d346:	4640      	mov	r0, r8
 800d348:	4639      	mov	r1, r7
 800d34a:	f000 f869 	bl	800d420 <usbPrepareQueuedReceive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d34e:	b672      	cpsid	i

    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, ep);
 800d350:	4640      	mov	r0, r8
 800d352:	4639      	mov	r1, r7
 800d354:	f000 f884 	bl	800d460 <usbStartReceiveI>
 800d358:	e7eb      	b.n	800d332 <sduDataReceived+0x32>
 800d35a:	bf00      	nop
 800d35c:	0000      	movs	r0, r0
	...

0800d360 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 800d360:	4770      	bx	lr
 800d362:	bf00      	nop
	...

0800d370 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
 800d370:	f002 b9d6 	b.w	800f720 <spi_lld_init>
	...

0800d380 <spiObjectInit>:
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
  spip->config = NULL;
 800d380:	2300      	movs	r3, #0
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 800d382:	2201      	movs	r2, #1
 800d384:	7002      	strb	r2, [r0, #0]
  spip->config = NULL;
 800d386:	6043      	str	r3, [r0, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 800d388:	6083      	str	r3, [r0, #8]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 800d38a:	300c      	adds	r0, #12
 800d38c:	f7ff bb28 	b.w	800c9e0 <chMtxObjectInit>

0800d390 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 800d390:	f001 bdfe 	b.w	800ef90 <usb_lld_init>
	...

0800d3a0 <usbObjectInit>:
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 800d3a0:	2300      	movs	r3, #0
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 800d3a2:	2201      	movs	r2, #1
 800d3a4:	7002      	strb	r2, [r0, #0]
  usbp->config       = NULL;
 800d3a6:	6043      	str	r3, [r0, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800d3a8:	61c3      	str	r3, [r0, #28]
    usbp->out_params[i] = NULL;
 800d3aa:	6283      	str	r3, [r0, #40]	; 0x28
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800d3ac:	6203      	str	r3, [r0, #32]
    usbp->out_params[i] = NULL;
 800d3ae:	62c3      	str	r3, [r0, #44]	; 0x2c
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800d3b0:	6243      	str	r3, [r0, #36]	; 0x24
    usbp->out_params[i] = NULL;
 800d3b2:	6303      	str	r3, [r0, #48]	; 0x30
  }
  usbp->transmitting = 0;
 800d3b4:	8103      	strh	r3, [r0, #8]
  usbp->receiving    = 0;
 800d3b6:	8143      	strh	r3, [r0, #10]
 800d3b8:	4770      	bx	lr
 800d3ba:	bf00      	nop
 800d3bc:	0000      	movs	r0, r0
	...

0800d3c0 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 800d3c0:	b510      	push	{r4, lr}
 800d3c2:	4604      	mov	r4, r0
 800d3c4:	b672      	cpsid	i
  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 800d3c6:	2300      	movs	r3, #0
 800d3c8:	60c3      	str	r3, [r0, #12]
 800d3ca:	6103      	str	r3, [r0, #16]
 800d3cc:	6143      	str	r3, [r0, #20]
 800d3ce:	6183      	str	r3, [r0, #24]
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 800d3d0:	6041      	str	r1, [r0, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 800d3d2:	f001 fdf5 	bl	800efc0 <usb_lld_start>
  usbp->state = USB_READY;
 800d3d6:	2302      	movs	r3, #2
 800d3d8:	7023      	strb	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d3da:	b662      	cpsie	i
 800d3dc:	bd10      	pop	{r4, pc}
 800d3de:	bf00      	nop

0800d3e0 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 800d3e0:	b570      	push	{r4, r5, r6, lr}
 800d3e2:	4606      	mov	r6, r0
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 800d3e4:	6950      	ldr	r0, [r2, #20]
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 800d3e6:	4614      	mov	r4, r2
 800d3e8:	460d      	mov	r5, r1
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 800d3ea:	b118      	cbz	r0, 800d3f4 <usbInitEndpointI+0x14>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 800d3ec:	2100      	movs	r1, #0
 800d3ee:	2214      	movs	r2, #20
 800d3f0:	f003 fb3e 	bl	8010a70 <memset>
  }
  if (epcp->out_state != NULL) {
 800d3f4:	69a0      	ldr	r0, [r4, #24]
 800d3f6:	b118      	cbz	r0, 800d400 <usbInitEndpointI+0x20>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800d3f8:	2100      	movs	r1, #0
 800d3fa:	2214      	movs	r2, #20
 800d3fc:	f003 fb38 	bl	8010a70 <memset>
  }

  usbp->epc[ep] = epcp;
 800d400:	eb06 0385 	add.w	r3, r6, r5, lsl #2

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800d404:	4630      	mov	r0, r6
  }
  if (epcp->out_state != NULL) {
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
  }

  usbp->epc[ep] = epcp;
 800d406:	60dc      	str	r4, [r3, #12]

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800d408:	4629      	mov	r1, r5
}
 800d40a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }

  usbp->epc[ep] = epcp;

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800d40e:	f001 bec7 	b.w	800f1a0 <usb_lld_init_endpoint>
 800d412:	bf00      	nop
	...

0800d420 <usbPrepareQueuedReceive>:
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
 800d420:	b470      	push	{r4, r5, r6}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800d422:	eb00 0481 	add.w	r4, r0, r1, lsl #2

  osp->rxqueued           = true;
 800d426:	2601      	movs	r6, #1
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800d428:	68e4      	ldr	r4, [r4, #12]
 800d42a:	69a4      	ldr	r4, [r4, #24]

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800d42c:	2500      	movs	r5, #0
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
 800d42e:	60e2      	str	r2, [r4, #12]
  osp->rxsize             = n;
 800d430:	6063      	str	r3, [r4, #4]
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
 800d432:	7026      	strb	r6, [r4, #0]
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800d434:	60a5      	str	r5, [r4, #8]

  usb_lld_prepare_receive(usbp, ep);
}
 800d436:	bc70      	pop	{r4, r5, r6}
  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 800d438:	f001 bf92 	b.w	800f360 <usb_lld_prepare_receive>
 800d43c:	0000      	movs	r0, r0
	...

0800d440 <usbPrepareQueuedTransmit>:
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
 800d440:	b470      	push	{r4, r5, r6}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800d442:	eb00 0481 	add.w	r4, r0, r1, lsl #2

  isp->txqueued           = true;
 800d446:	2601      	movs	r6, #1
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800d448:	68e4      	ldr	r4, [r4, #12]
 800d44a:	6964      	ldr	r4, [r4, #20]

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;
 800d44c:	2500      	movs	r5, #0
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
 800d44e:	60e2      	str	r2, [r4, #12]
  isp->txsize             = n;
 800d450:	6063      	str	r3, [r4, #4]
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
 800d452:	7026      	strb	r6, [r4, #0]
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;
 800d454:	60a5      	str	r5, [r4, #8]

  usb_lld_prepare_transmit(usbp, ep);
}
 800d456:	bc70      	pop	{r4, r5, r6}
  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800d458:	f001 bffa 	b.w	800f450 <usb_lld_prepare_transmit>
 800d45c:	0000      	movs	r0, r0
	...

0800d460 <usbStartReceiveI>:
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 800d460:	2201      	movs	r2, #1
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {
 800d462:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 800d464:	fa02 f301 	lsl.w	r3, r2, r1
 800d468:	8944      	ldrh	r4, [r0, #10]
 800d46a:	b29b      	uxth	r3, r3
 800d46c:	ea13 0604 	ands.w	r6, r3, r4
 800d470:	d001      	beq.n	800d476 <usbStartReceiveI+0x16>
    return true;
 800d472:	4610      	mov	r0, r2
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_out(usbp, ep);
  return false;
}
 800d474:	bd70      	pop	{r4, r5, r6, pc}

  if (usbGetReceiveStatusI(usbp, ep)) {
    return true;
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800d476:	4323      	orrs	r3, r4
 800d478:	8143      	strh	r3, [r0, #10]
  usb_lld_start_out(usbp, ep);
 800d47a:	f002 f8e9 	bl	800f650 <usb_lld_start_out>
  return false;
 800d47e:	4630      	mov	r0, r6
 800d480:	bd70      	pop	{r4, r5, r6, pc}
 800d482:	bf00      	nop
	...

0800d490 <usbStartTransmitI>:
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 800d490:	2201      	movs	r2, #1
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {
 800d492:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 800d494:	fa02 f301 	lsl.w	r3, r2, r1
 800d498:	8904      	ldrh	r4, [r0, #8]
 800d49a:	b29b      	uxth	r3, r3
 800d49c:	ea13 0604 	ands.w	r6, r3, r4
 800d4a0:	d001      	beq.n	800d4a6 <usbStartTransmitI+0x16>
    return true;
 800d4a2:	4610      	mov	r0, r2
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_in(usbp, ep);
  return false;
}
 800d4a4:	bd70      	pop	{r4, r5, r6, pc}

  if (usbGetTransmitStatusI(usbp, ep)) {
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800d4a6:	4323      	orrs	r3, r4
 800d4a8:	8103      	strh	r3, [r0, #8]
  usb_lld_start_in(usbp, ep);
 800d4aa:	f002 f8e1 	bl	800f670 <usb_lld_start_in>
  return false;
 800d4ae:	4630      	mov	r0, r6
 800d4b0:	bd70      	pop	{r4, r5, r6, pc}
 800d4b2:	bf00      	nop
	...

0800d4c0 <_usb_reset>:
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
  usbp->status        = 0;
 800d4c0:	2200      	movs	r2, #0
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
 800d4c2:	2102      	movs	r1, #2
 800d4c4:	7001      	strb	r1, [r0, #0]
  usbp->status        = 0;
 800d4c6:	f8a0 204c 	strh.w	r2, [r0, #76]	; 0x4c
  usbp->address       = 0;
 800d4ca:	f880 204e 	strb.w	r2, [r0, #78]	; 0x4e
  usbp->configuration = 0;
 800d4ce:	f880 204f 	strb.w	r2, [r0, #79]	; 0x4f
  usbp->transmitting  = 0;
 800d4d2:	8102      	strh	r2, [r0, #8]
  usbp->receiving     = 0;
 800d4d4:	8142      	strh	r2, [r0, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 800d4d6:	60c2      	str	r2, [r0, #12]
 800d4d8:	6102      	str	r2, [r0, #16]
 800d4da:	6142      	str	r2, [r0, #20]
 800d4dc:	6182      	str	r2, [r0, #24]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800d4de:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

  /* Low level reset.*/
  usb_lld_reset(usbp);
 800d4e2:	f001 bde5 	b.w	800f0b0 <usb_lld_reset>
 800d4e6:	bf00      	nop
	...

0800d4f0 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800d4f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800d4f2:	2300      	movs	r3, #0
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800d4f4:	4604      	mov	r4, r0
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800d4f6:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  usbReadSetup(usbp, ep, usbp->setup);
 800d4fa:	f100 0244 	add.w	r2, r0, #68	; 0x44
 800d4fe:	f001 ff1f 	bl	800f340 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 800d502:	6863      	ldr	r3, [r4, #4]
 800d504:	689b      	ldr	r3, [r3, #8]
 800d506:	b34b      	cbz	r3, 800d55c <_usb_ep0setup+0x6c>
      !(usbp->config->requests_hook_cb(usbp))) {
 800d508:	4620      	mov	r0, r4
 800d50a:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 800d50c:	b330      	cbz	r0, 800d55c <_usb_ep0setup+0x6c>
 800d50e:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 800d510:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800d514:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 800d518:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 800d51c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 800d520:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 800d522:	bf3c      	itt	cc
 800d524:	63e2      	strcc	r2, [r4, #60]	; 0x3c
 800d526:	4615      	movcc	r5, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800d528:	f013 0f80 	tst.w	r3, #128	; 0x80
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800d52c:	68e3      	ldr	r3, [r4, #12]
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800d52e:	f040 8081 	bne.w	800d634 <_usb_ep0setup+0x144>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 800d532:	2d00      	cmp	r5, #0
 800d534:	d169      	bne.n	800d60a <_usb_ep0setup+0x11a>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800d536:	695b      	ldr	r3, [r3, #20]
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 800d538:	2205      	movs	r2, #5
 800d53a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800d53e:	4620      	mov	r0, r4
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800d540:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 800d542:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800d544:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800d546:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800d548:	4629      	mov	r1, r5
 800d54a:	f001 ff81 	bl	800f450 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d54e:	b672      	cpsid	i
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 800d550:	4620      	mov	r0, r4
 800d552:	4629      	mov	r1, r5
 800d554:	f7ff ff9c 	bl	800d490 <usbStartTransmitI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d558:	b662      	cpsie	i
 800d55a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800d55c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d560:	f013 0760 	ands.w	r7, r3, #96	; 0x60
 800d564:	d011      	beq.n	800d58a <_usb_ep0setup+0x9a>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 800d566:	4620      	mov	r0, r4
 800d568:	2100      	movs	r1, #0
 800d56a:	f002 f8a9 	bl	800f6c0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800d56e:	4620      	mov	r0, r4
 800d570:	2100      	movs	r1, #0
 800d572:	f002 f895 	bl	800f6a0 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800d576:	6863      	ldr	r3, [r4, #4]
 800d578:	681b      	ldr	r3, [r3, #0]
 800d57a:	b113      	cbz	r3, 800d582 <_usb_ep0setup+0x92>
 800d57c:	4620      	mov	r0, r4
 800d57e:	2105      	movs	r1, #5
 800d580:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800d582:	2306      	movs	r3, #6
 800d584:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return;
 800d588:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 800d58a:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800d58e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 800d592:	ea42 2605 	orr.w	r6, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800d596:	f5b6 7f40 	cmp.w	r6, #768	; 0x300
 800d59a:	f000 80f6 	beq.w	800d78a <_usb_ep0setup+0x29a>
 800d59e:	d916      	bls.n	800d5ce <_usb_ep0setup+0xde>
 800d5a0:	f5b6 6fc0 	cmp.w	r6, #1536	; 0x600
 800d5a4:	f000 80d8 	beq.w	800d758 <_usb_ep0setup+0x268>
 800d5a8:	d96d      	bls.n	800d686 <_usb_ep0setup+0x196>
 800d5aa:	f5b6 6f10 	cmp.w	r6, #2304	; 0x900
 800d5ae:	d07d      	beq.n	800d6ac <_usb_ep0setup+0x1bc>
 800d5b0:	f640 4202 	movw	r2, #3074	; 0xc02
 800d5b4:	4296      	cmp	r6, r2
 800d5b6:	f000 80fb 	beq.w	800d7b0 <_usb_ep0setup+0x2c0>
 800d5ba:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 800d5be:	d1d2      	bne.n	800d566 <_usb_ep0setup+0x76>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 800d5c0:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 800d5c4:	2501      	movs	r5, #1
 800d5c6:	6427      	str	r7, [r4, #64]	; 0x40
 800d5c8:	63a2      	str	r2, [r4, #56]	; 0x38
 800d5ca:	63e5      	str	r5, [r4, #60]	; 0x3c
 800d5cc:	e7a2      	b.n	800d514 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800d5ce:	2e02      	cmp	r6, #2
 800d5d0:	f000 80ab 	beq.w	800d72a <_usb_ep0setup+0x23a>
 800d5d4:	f240 80a0 	bls.w	800d718 <_usb_ep0setup+0x228>
 800d5d8:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 800d5dc:	f000 808c 	beq.w	800d6f8 <_usb_ep0setup+0x208>
 800d5e0:	f5b6 7f81 	cmp.w	r6, #258	; 0x102
 800d5e4:	d1bf      	bne.n	800d566 <_usb_ep0setup+0x76>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800d5e6:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800d5ea:	2a00      	cmp	r2, #0
 800d5ec:	d1bb      	bne.n	800d566 <_usb_ep0setup+0x76>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800d5ee:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 800d5f2:	f012 010f 	ands.w	r1, r2, #15
 800d5f6:	d054      	beq.n	800d6a2 <_usb_ep0setup+0x1b2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800d5f8:	0612      	lsls	r2, r2, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800d5fa:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800d5fc:	f100 8100 	bmi.w	800d800 <_usb_ep0setup+0x310>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 800d600:	f002 f86e 	bl	800f6e0 <usb_lld_clear_out>
 800d604:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d608:	e04b      	b.n	800d6a2 <_usb_ep0setup+0x1b2>
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800d60a:	699b      	ldr	r3, [r3, #24]
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
 800d60c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800d60e:	2600      	movs	r6, #0
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 800d610:	2104      	movs	r1, #4
 800d612:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 800d616:	4620      	mov	r0, r4
 800d618:	4631      	mov	r1, r6
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
 800d61a:	60da      	str	r2, [r3, #12]
  osp->rxsize             = n;
 800d61c:	605d      	str	r5, [r3, #4]
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800d61e:	701e      	strb	r6, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800d620:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 800d622:	f001 fe9d 	bl	800f360 <usb_lld_prepare_receive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d626:	b672      	cpsid	i
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      (void) usbStartReceiveI(usbp, 0);
 800d628:	4620      	mov	r0, r4
 800d62a:	4631      	mov	r1, r6
 800d62c:	f7ff ff18 	bl	800d460 <usbStartReceiveI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d630:	b662      	cpsie	i
 800d632:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 800d634:	b1a5      	cbz	r5, 800d660 <_usb_ep0setup+0x170>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800d636:	695b      	ldr	r3, [r3, #20]
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
 800d638:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800d63a:	2600      	movs	r6, #0
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 800d63c:	2101      	movs	r1, #1
 800d63e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800d642:	4620      	mov	r0, r4
 800d644:	4631      	mov	r1, r6
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
 800d646:	60da      	str	r2, [r3, #12]
  isp->txsize             = n;
 800d648:	605d      	str	r5, [r3, #4]
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800d64a:	701e      	strb	r6, [r3, #0]
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;
 800d64c:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800d64e:	f001 feff 	bl	800f450 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d652:	b672      	cpsid	i
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 800d654:	4620      	mov	r0, r4
 800d656:	4631      	mov	r1, r6
 800d658:	f7ff ff1a 	bl	800d490 <usbStartTransmitI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d65c:	b662      	cpsie	i
 800d65e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800d660:	699b      	ldr	r3, [r3, #24]
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 800d662:	2203      	movs	r2, #3
 800d664:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 800d668:	4620      	mov	r0, r4
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800d66a:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 800d66c:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 800d66e:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 800d670:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 800d672:	4629      	mov	r1, r5
 800d674:	f001 fe74 	bl	800f360 <usb_lld_prepare_receive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d678:	b672      	cpsid	i
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareReceive(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartReceiveI(usbp, 0);
 800d67a:	4620      	mov	r0, r4
 800d67c:	4629      	mov	r1, r5
 800d67e:	f7ff feef 	bl	800d460 <usbStartReceiveI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d682:	b662      	cpsie	i
 800d684:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800d686:	f240 3202 	movw	r2, #770	; 0x302
 800d68a:	4296      	cmp	r6, r2
 800d68c:	d021      	beq.n	800d6d2 <_usb_ep0setup+0x1e2>
 800d68e:	f5b6 6fa0 	cmp.w	r6, #1280	; 0x500
 800d692:	f47f af68 	bne.w	800d566 <_usb_ep0setup+0x76>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800d696:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
 800d69a:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800d69e:	f000 809d 	beq.w	800d7dc <_usb_ep0setup+0x2ec>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800d6a2:	2500      	movs	r5, #0
 800d6a4:	63a5      	str	r5, [r4, #56]	; 0x38
 800d6a6:	63e5      	str	r5, [r4, #60]	; 0x3c
 800d6a8:	6425      	str	r5, [r4, #64]	; 0x40
 800d6aa:	e733      	b.n	800d514 <_usb_ep0setup+0x24>
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 800d6ac:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800d6b0:	f884 204f 	strb.w	r2, [r4, #79]	; 0x4f
    if (usbp->configuration == 0U) {
 800d6b4:	2a00      	cmp	r2, #0
 800d6b6:	f040 8082 	bne.w	800d7be <_usb_ep0setup+0x2ce>
      usbp->state = USB_SELECTED;
 800d6ba:	2203      	movs	r2, #3
 800d6bc:	7022      	strb	r2, [r4, #0]
    }
    else {
      usbp->state = USB_ACTIVE;
    }
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800d6be:	6862      	ldr	r2, [r4, #4]
 800d6c0:	6812      	ldr	r2, [r2, #0]
 800d6c2:	2a00      	cmp	r2, #0
 800d6c4:	d0ed      	beq.n	800d6a2 <_usb_ep0setup+0x1b2>
 800d6c6:	4620      	mov	r0, r4
 800d6c8:	2102      	movs	r1, #2
 800d6ca:	4790      	blx	r2
 800d6cc:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d6d0:	e7e7      	b.n	800d6a2 <_usb_ep0setup+0x1b2>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800d6d2:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800d6d6:	2a00      	cmp	r2, #0
 800d6d8:	f47f af45 	bne.w	800d566 <_usb_ep0setup+0x76>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800d6dc:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 800d6e0:	f012 010f 	ands.w	r1, r2, #15
 800d6e4:	d0dd      	beq.n	800d6a2 <_usb_ep0setup+0x1b2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800d6e6:	0613      	lsls	r3, r2, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800d6e8:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800d6ea:	f100 808e 	bmi.w	800d80a <_usb_ep0setup+0x31a>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 800d6ee:	f001 ffd7 	bl	800f6a0 <usb_lld_stall_out>
 800d6f2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d6f6:	e7d4      	b.n	800d6a2 <_usb_ep0setup+0x1b2>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800d6f8:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800d6fc:	2a01      	cmp	r2, #1
 800d6fe:	f47f af32 	bne.w	800d566 <_usb_ep0setup+0x76>
      usbp->status &= ~2U;
 800d702:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800d706:	63a7      	str	r7, [r4, #56]	; 0x38
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 800d708:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800d70c:	63e7      	str	r7, [r4, #60]	; 0x3c
 800d70e:	6427      	str	r7, [r4, #64]	; 0x40
 800d710:	463d      	mov	r5, r7
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 800d712:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 800d716:	e6fd      	b.n	800d514 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800d718:	2e00      	cmp	r6, #0
 800d71a:	d146      	bne.n	800d7aa <_usb_ep0setup+0x2ba>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 800d71c:	f104 024c 	add.w	r2, r4, #76	; 0x4c
 800d720:	2502      	movs	r5, #2
 800d722:	6426      	str	r6, [r4, #64]	; 0x40
 800d724:	63a2      	str	r2, [r4, #56]	; 0x38
 800d726:	63e5      	str	r5, [r4, #60]	; 0x3c
 800d728:	e6f4      	b.n	800d514 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800d72a:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
 800d72e:	f011 0f80 	tst.w	r1, #128	; 0x80
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800d732:	4620      	mov	r0, r4
 800d734:	f001 010f 	and.w	r1, r1, #15
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800d738:	d144      	bne.n	800d7c4 <_usb_ep0setup+0x2d4>
      default:
        return false;
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 800d73a:	f001 fde1 	bl	800f300 <usb_lld_get_status_out>
 800d73e:	2801      	cmp	r0, #1
 800d740:	d044      	beq.n	800d7cc <_usb_ep0setup+0x2dc>
 800d742:	2802      	cmp	r0, #2
 800d744:	f47f af0f 	bne.w	800d566 <_usb_ep0setup+0x76>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800d748:	4b32      	ldr	r3, [pc, #200]	; (800d814 <_usb_ep0setup+0x324>)
 800d74a:	63a3      	str	r3, [r4, #56]	; 0x38
 800d74c:	63e0      	str	r0, [r4, #60]	; 0x3c
 800d74e:	6427      	str	r7, [r4, #64]	; 0x40
 800d750:	4605      	mov	r5, r0
 800d752:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d756:	e6dd      	b.n	800d514 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800d758:	6862      	ldr	r2, [r4, #4]

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800d75a:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 800d75e:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800d762:	6855      	ldr	r5, [r2, #4]
 800d764:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 800d768:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800d76c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800d770:	4620      	mov	r0, r4
 800d772:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 800d774:	2800      	cmp	r0, #0
 800d776:	f43f aef6 	beq.w	800d566 <_usb_ep0setup+0x76>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800d77a:	6843      	ldr	r3, [r0, #4]
 800d77c:	6805      	ldr	r5, [r0, #0]
 800d77e:	63e5      	str	r5, [r4, #60]	; 0x3c
 800d780:	63a3      	str	r3, [r4, #56]	; 0x38
 800d782:	6427      	str	r7, [r4, #64]	; 0x40
 800d784:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d788:	e6c4      	b.n	800d514 <_usb_ep0setup+0x24>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800d78a:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800d78e:	2a01      	cmp	r2, #1
 800d790:	f47f aee9 	bne.w	800d566 <_usb_ep0setup+0x76>
      usbp->status |= 2U;
 800d794:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800d798:	63a7      	str	r7, [r4, #56]	; 0x38
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 800d79a:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800d79e:	63e7      	str	r7, [r4, #60]	; 0x3c
 800d7a0:	6427      	str	r7, [r4, #64]	; 0x40
 800d7a2:	463d      	mov	r5, r7
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 800d7a4:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 800d7a8:	e6b4      	b.n	800d514 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800d7aa:	2e01      	cmp	r6, #1
 800d7ac:	f47f aedb 	bne.w	800d566 <_usb_ep0setup+0x76>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 800d7b0:	4a19      	ldr	r2, [pc, #100]	; (800d818 <_usb_ep0setup+0x328>)
 800d7b2:	63a2      	str	r2, [r4, #56]	; 0x38
 800d7b4:	2502      	movs	r5, #2
 800d7b6:	2200      	movs	r2, #0
 800d7b8:	63e5      	str	r5, [r4, #60]	; 0x3c
 800d7ba:	6422      	str	r2, [r4, #64]	; 0x40
 800d7bc:	e6aa      	b.n	800d514 <_usb_ep0setup+0x24>
    usbp->configuration = usbp->setup[2];
    if (usbp->configuration == 0U) {
      usbp->state = USB_SELECTED;
    }
    else {
      usbp->state = USB_ACTIVE;
 800d7be:	2204      	movs	r2, #4
 800d7c0:	7022      	strb	r2, [r4, #0]
 800d7c2:	e77c      	b.n	800d6be <_usb_ep0setup+0x1ce>
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800d7c4:	f001 fdac 	bl	800f320 <usb_lld_get_status_in>
 800d7c8:	2801      	cmp	r0, #1
 800d7ca:	d1ba      	bne.n	800d742 <_usb_ep0setup+0x252>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800d7cc:	4b13      	ldr	r3, [pc, #76]	; (800d81c <_usb_ep0setup+0x32c>)
 800d7ce:	63a3      	str	r3, [r4, #56]	; 0x38
 800d7d0:	63e6      	str	r6, [r4, #60]	; 0x3c
 800d7d2:	6427      	str	r7, [r4, #64]	; 0x40
 800d7d4:	4635      	mov	r5, r6
 800d7d6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d7da:	e69b      	b.n	800d514 <_usb_ep0setup+0x24>
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 800d7dc:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800d7e0:	f884 304e 	strb.w	r3, [r4, #78]	; 0x4e
  usb_lld_set_address(usbp);
 800d7e4:	4620      	mov	r0, r4
 800d7e6:	f001 fccb 	bl	800f180 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 800d7ea:	6863      	ldr	r3, [r4, #4]
 800d7ec:	681b      	ldr	r3, [r3, #0]
 800d7ee:	b113      	cbz	r3, 800d7f6 <_usb_ep0setup+0x306>
 800d7f0:	4620      	mov	r0, r4
 800d7f2:	2101      	movs	r1, #1
 800d7f4:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800d7f6:	2203      	movs	r2, #3
 800d7f8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d7fc:	7022      	strb	r2, [r4, #0]
 800d7fe:	e750      	b.n	800d6a2 <_usb_ep0setup+0x1b2>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800d800:	f001 ff7e 	bl	800f700 <usb_lld_clear_in>
 800d804:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d808:	e74b      	b.n	800d6a2 <_usb_ep0setup+0x1b2>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800d80a:	f001 ff59 	bl	800f6c0 <usb_lld_stall_in>
 800d80e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d812:	e746      	b.n	800d6a2 <_usb_ep0setup+0x1b2>
 800d814:	08010b70 	.word	0x08010b70
 800d818:	08010b60 	.word	0x08010b60
 800d81c:	08010b80 	.word	0x08010b80

0800d820 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 800d820:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800d822:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 800d826:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800d828:	2b06      	cmp	r3, #6
 800d82a:	d815      	bhi.n	800d858 <_usb_ep0in+0x38>
 800d82c:	e8df f003 	tbb	[pc, r3]
 800d830:	041c3104 	.word	0x041c3104
 800d834:	1504      	.short	0x1504
 800d836:	04          	.byte	0x04
 800d837:	00          	.byte	0x00
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800d838:	2100      	movs	r1, #0
 800d83a:	f001 ff41 	bl	800f6c0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800d83e:	4620      	mov	r0, r4
 800d840:	2100      	movs	r1, #0
 800d842:	f001 ff2d 	bl	800f6a0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800d846:	6863      	ldr	r3, [r4, #4]
 800d848:	681b      	ldr	r3, [r3, #0]
 800d84a:	b113      	cbz	r3, 800d852 <_usb_ep0in+0x32>
 800d84c:	4620      	mov	r0, r4
 800d84e:	2105      	movs	r1, #5
 800d850:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800d852:	2306      	movs	r3, #6
 800d854:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800d858:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 800d85a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800d85c:	b103      	cbz	r3, 800d860 <_usb_ep0in+0x40>
      usbp->ep0endcb(usbp);
 800d85e:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800d860:	2300      	movs	r3, #0
 800d862:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return;
 800d866:	bd38      	pop	{r3, r4, r5, pc}
 800d868:	68c3      	ldr	r3, [r0, #12]
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800d86a:	699b      	ldr	r3, [r3, #24]

  osp->rxqueued           = false;
 800d86c:	2500      	movs	r5, #0
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 800d86e:	2203      	movs	r2, #3
 800d870:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 800d874:	4629      	mov	r1, r5
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800d876:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 800d878:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 800d87a:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 800d87c:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 800d87e:	4620      	mov	r0, r4
 800d880:	f001 fd6e 	bl	800f360 <usb_lld_prepare_receive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d884:	b672      	cpsid	i
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareReceive(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, 0);
 800d886:	4620      	mov	r0, r4
 800d888:	4629      	mov	r1, r5
 800d88a:	f7ff fde9 	bl	800d460 <usbStartReceiveI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d88e:	b662      	cpsie	i
 800d890:	bd38      	pop	{r3, r4, r5, pc}

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800d892:	f890 204b 	ldrb.w	r2, [r0, #75]	; 0x4b
 800d896:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800d89a:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 800d89c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800d8a0:	428b      	cmp	r3, r1
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800d8a2:	68c3      	ldr	r3, [r0, #12]
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800d8a4:	d9e1      	bls.n	800d86a <_usb_ep0in+0x4a>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800d8a6:	8a1d      	ldrh	r5, [r3, #16]
 800d8a8:	fbb1 f2f5 	udiv	r2, r1, r5
 800d8ac:	fb05 1512 	mls	r5, r5, r2, r1
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800d8b0:	2d00      	cmp	r5, #0
 800d8b2:	d1da      	bne.n	800d86a <_usb_ep0in+0x4a>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800d8b4:	695b      	ldr	r3, [r3, #20]
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800d8b6:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800d8b8:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 800d8ba:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800d8bc:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800d8be:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800d8c0:	f001 fdc6 	bl	800f450 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d8c4:	b672      	cpsid	i
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 800d8c6:	4629      	mov	r1, r5
 800d8c8:	4620      	mov	r0, r4
 800d8ca:	f7ff fde1 	bl	800d490 <usbStartTransmitI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d8ce:	b662      	cpsie	i
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 800d8d0:	2302      	movs	r3, #2
 800d8d2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return;
 800d8d6:	bd38      	pop	{r3, r4, r5, pc}
	...

0800d8e0 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 800d8e0:	f890 2034 	ldrb.w	r2, [r0, #52]	; 0x34
 800d8e4:	2a06      	cmp	r2, #6
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 800d8e6:	b538      	push	{r3, r4, r5, lr}
 800d8e8:	d80a      	bhi.n	800d900 <_usb_ep0out+0x20>
 800d8ea:	2301      	movs	r3, #1
 800d8ec:	4093      	lsls	r3, r2
 800d8ee:	f013 0f67 	tst.w	r3, #103	; 0x67
 800d8f2:	4604      	mov	r4, r0
 800d8f4:	d111      	bne.n	800d91a <_usb_ep0out+0x3a>
 800d8f6:	f013 0508 	ands.w	r5, r3, #8
 800d8fa:	d102      	bne.n	800d902 <_usb_ep0out+0x22>
 800d8fc:	06db      	lsls	r3, r3, #27
 800d8fe:	d41d      	bmi.n	800d93c <_usb_ep0out+0x5c>
 800d900:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeI(usbp, 0) != 0U) {
 800d902:	68c3      	ldr	r3, [r0, #12]
 800d904:	699b      	ldr	r3, [r3, #24]
 800d906:	689b      	ldr	r3, [r3, #8]
 800d908:	2b00      	cmp	r3, #0
 800d90a:	d1f9      	bne.n	800d900 <_usb_ep0out+0x20>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800d90c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800d90e:	b103      	cbz	r3, 800d912 <_usb_ep0out+0x32>
      usbp->ep0endcb(usbp);
 800d910:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800d912:	2300      	movs	r3, #0
 800d914:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return;
 800d918:	bd38      	pop	{r3, r4, r5, pc}
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800d91a:	2100      	movs	r1, #0
 800d91c:	f001 fed0 	bl	800f6c0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800d920:	4620      	mov	r0, r4
 800d922:	2100      	movs	r1, #0
 800d924:	f001 febc 	bl	800f6a0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800d928:	6863      	ldr	r3, [r4, #4]
 800d92a:	681b      	ldr	r3, [r3, #0]
 800d92c:	b113      	cbz	r3, 800d934 <_usb_ep0out+0x54>
 800d92e:	4620      	mov	r0, r4
 800d930:	2105      	movs	r1, #5
 800d932:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800d934:	2306      	movs	r3, #6
 800d936:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800d93a:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800d93c:	68c3      	ldr	r3, [r0, #12]
 800d93e:	695b      	ldr	r3, [r3, #20]

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 800d940:	2205      	movs	r2, #5
 800d942:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800d946:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800d948:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 800d94a:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800d94c:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800d94e:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800d950:	f001 fd7e 	bl	800f450 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d954:	b672      	cpsid	i
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareTransmit(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, 0);
 800d956:	4620      	mov	r0, r4
 800d958:	4629      	mov	r1, r5
 800d95a:	f7ff fd99 	bl	800d490 <usbStartTransmitI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d95e:	b662      	cpsie	i
 800d960:	bd38      	pop	{r3, r4, r5, pc}
 800d962:	bf00      	nop
	...

0800d970 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800d970:	0943      	lsrs	r3, r0, #5
 800d972:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 800d974:	b410      	push	{r4}
 800d976:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800d97a:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800d97e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 800d982:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 800d986:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800d988:	f000 001f 	and.w	r0, r0, #31
 800d98c:	2201      	movs	r2, #1
 800d98e:	4082      	lsls	r2, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800d990:	b2c9      	uxtb	r1, r1
 800d992:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800d996:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 800d99a:	601a      	str	r2, [r3, #0]
}
 800d99c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d9a0:	4770      	bx	lr
 800d9a2:	bf00      	nop
	...

0800d9b0 <nvicSetSystemHandlerPriority>:
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {

  osalDbgCheck(handler <= 12);

  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 800d9b0:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800d9b4:	f500 406d 	add.w	r0, r0, #60672	; 0xed00
 800d9b8:	0109      	lsls	r1, r1, #4
 800d9ba:	b2c9      	uxtb	r1, r1
 800d9bc:	7601      	strb	r1, [r0, #24]
 800d9be:	4770      	bx	lr

0800d9c0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 800d9c0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800d9c2:	4b07      	ldr	r3, [pc, #28]	; (800d9e0 <Vector6C+0x20>)
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 800d9c4:	4a07      	ldr	r2, [pc, #28]	; (800d9e4 <Vector6C+0x24>)
OSAL_IRQ_HANDLER(Vector6C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800d9c6:	6819      	ldr	r1, [r3, #0]
 800d9c8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0;
 800d9cc:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 800d9ce:	6813      	ldr	r3, [r2, #0]
 800d9d0:	b10b      	cbz	r3, 800d9d6 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 800d9d2:	6850      	ldr	r0, [r2, #4]
 800d9d4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800d9d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800d9da:	f7ff ba39 	b.w	800ce50 <_port_irq_epilogue>
 800d9de:	bf00      	nop
 800d9e0:	40026000 	.word	0x40026000
 800d9e4:	20000ab8 	.word	0x20000ab8
	...

0800d9f0 <Vector70>:
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800d9f0:	4b08      	ldr	r3, [pc, #32]	; (800da14 <Vector70+0x24>)
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 800d9f2:	4809      	ldr	r0, [pc, #36]	; (800da18 <Vector70+0x28>)
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800d9f4:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 800d9f6:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800d9f8:	0989      	lsrs	r1, r1, #6
 800d9fa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 800d9fe:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
 800da00:	018c      	lsls	r4, r1, #6
 800da02:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 800da04:	b10a      	cbz	r2, 800da0a <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 800da06:	68c0      	ldr	r0, [r0, #12]
 800da08:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800da0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800da0e:	f7ff ba1f 	b.w	800ce50 <_port_irq_epilogue>
 800da12:	bf00      	nop
 800da14:	40026000 	.word	0x40026000
 800da18:	20000ab8 	.word	0x20000ab8
 800da1c:	00000000 	.word	0x00000000

0800da20 <Vector74>:
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800da20:	4b08      	ldr	r3, [pc, #32]	; (800da44 <Vector74+0x24>)
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 800da22:	4809      	ldr	r0, [pc, #36]	; (800da48 <Vector74+0x28>)
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800da24:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 800da26:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800da28:	0c09      	lsrs	r1, r1, #16
 800da2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 800da2e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
 800da30:	040c      	lsls	r4, r1, #16
 800da32:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 800da34:	b10a      	cbz	r2, 800da3a <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 800da36:	6940      	ldr	r0, [r0, #20]
 800da38:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800da3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800da3e:	f7ff ba07 	b.w	800ce50 <_port_irq_epilogue>
 800da42:	bf00      	nop
 800da44:	40026000 	.word	0x40026000
 800da48:	20000ab8 	.word	0x20000ab8
 800da4c:	00000000 	.word	0x00000000

0800da50 <Vector78>:
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800da50:	4b08      	ldr	r3, [pc, #32]	; (800da74 <Vector78+0x24>)
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 800da52:	4809      	ldr	r0, [pc, #36]	; (800da78 <Vector78+0x28>)
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800da54:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 800da56:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800da58:	0d89      	lsrs	r1, r1, #22
 800da5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 800da5e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
 800da60:	058c      	lsls	r4, r1, #22
 800da62:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 800da64:	b10a      	cbz	r2, 800da6a <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 800da66:	69c0      	ldr	r0, [r0, #28]
 800da68:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800da6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800da6e:	f7ff b9ef 	b.w	800ce50 <_port_irq_epilogue>
 800da72:	bf00      	nop
 800da74:	40026000 	.word	0x40026000
 800da78:	20000ab8 	.word	0x20000ab8
 800da7c:	00000000 	.word	0x00000000

0800da80 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 800da80:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800da82:	4b07      	ldr	r3, [pc, #28]	; (800daa0 <Vector7C+0x20>)
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 800da84:	4807      	ldr	r0, [pc, #28]	; (800daa4 <Vector7C+0x24>)
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800da86:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 800da88:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800da8a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0;
 800da8e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 800da90:	b10a      	cbz	r2, 800da96 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 800da92:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800da94:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800da96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800da9a:	f7ff b9d9 	b.w	800ce50 <_port_irq_epilogue>
 800da9e:	bf00      	nop
 800daa0:	40026000 	.word	0x40026000
 800daa4:	20000ab8 	.word	0x20000ab8
	...

0800dab0 <Vector80>:
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800dab0:	4b08      	ldr	r3, [pc, #32]	; (800dad4 <Vector80+0x24>)
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 800dab2:	4809      	ldr	r0, [pc, #36]	; (800dad8 <Vector80+0x28>)
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800dab4:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 800dab6:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800dab8:	0989      	lsrs	r1, r1, #6
 800daba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 800dabe:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
 800dac0:	018c      	lsls	r4, r1, #6
 800dac2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 800dac4:	b10a      	cbz	r2, 800daca <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 800dac6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800dac8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800daca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800dace:	f7ff b9bf 	b.w	800ce50 <_port_irq_epilogue>
 800dad2:	bf00      	nop
 800dad4:	40026000 	.word	0x40026000
 800dad8:	20000ab8 	.word	0x20000ab8
 800dadc:	00000000 	.word	0x00000000

0800dae0 <Vector84>:
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800dae0:	4b08      	ldr	r3, [pc, #32]	; (800db04 <Vector84+0x24>)
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 800dae2:	4809      	ldr	r0, [pc, #36]	; (800db08 <Vector84+0x28>)
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800dae4:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 800dae6:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800dae8:	0c09      	lsrs	r1, r1, #16
 800daea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 800daee:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
 800daf0:	040c      	lsls	r4, r1, #16
 800daf2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 800daf4:	b10a      	cbz	r2, 800dafa <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 800daf6:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800daf8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800dafa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800dafe:	f7ff b9a7 	b.w	800ce50 <_port_irq_epilogue>
 800db02:	bf00      	nop
 800db04:	40026000 	.word	0x40026000
 800db08:	20000ab8 	.word	0x20000ab8
 800db0c:	00000000 	.word	0x00000000

0800db10 <VectorFC>:
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800db10:	4b08      	ldr	r3, [pc, #32]	; (800db34 <VectorFC+0x24>)
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 800db12:	4809      	ldr	r0, [pc, #36]	; (800db38 <VectorFC+0x28>)
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800db14:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 800db16:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800db18:	0d89      	lsrs	r1, r1, #22
 800db1a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 800db1e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
 800db20:	058c      	lsls	r4, r1, #22
 800db22:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 800db24:	b10a      	cbz	r2, 800db2a <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 800db26:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 800db28:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800db2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800db2e:	f7ff b98f 	b.w	800ce50 <_port_irq_epilogue>
 800db32:	bf00      	nop
 800db34:	40026000 	.word	0x40026000
 800db38:	20000ab8 	.word	0x20000ab8
 800db3c:	00000000 	.word	0x00000000

0800db40 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 800db40:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800db42:	4b07      	ldr	r3, [pc, #28]	; (800db60 <Vector120+0x20>)
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 800db44:	4807      	ldr	r0, [pc, #28]	; (800db64 <Vector120+0x24>)
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800db46:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 800db48:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800db4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0;
 800db4e:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 800db50:	b10a      	cbz	r2, 800db56 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 800db52:	6c40      	ldr	r0, [r0, #68]	; 0x44
 800db54:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800db56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800db5a:	f7ff b979 	b.w	800ce50 <_port_irq_epilogue>
 800db5e:	bf00      	nop
 800db60:	40026400 	.word	0x40026400
 800db64:	20000ab8 	.word	0x20000ab8
	...

0800db70 <Vector124>:
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800db70:	4b08      	ldr	r3, [pc, #32]	; (800db94 <Vector124+0x24>)
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 800db72:	4809      	ldr	r0, [pc, #36]	; (800db98 <Vector124+0x28>)
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800db74:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 800db76:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800db78:	0989      	lsrs	r1, r1, #6
 800db7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 800db7e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
 800db80:	018c      	lsls	r4, r1, #6
 800db82:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 800db84:	b10a      	cbz	r2, 800db8a <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 800db86:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 800db88:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800db8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800db8e:	f7ff b95f 	b.w	800ce50 <_port_irq_epilogue>
 800db92:	bf00      	nop
 800db94:	40026400 	.word	0x40026400
 800db98:	20000ab8 	.word	0x20000ab8
 800db9c:	00000000 	.word	0x00000000

0800dba0 <Vector128>:
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800dba0:	4b08      	ldr	r3, [pc, #32]	; (800dbc4 <Vector128+0x24>)
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 800dba2:	4809      	ldr	r0, [pc, #36]	; (800dbc8 <Vector128+0x28>)
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800dba4:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 800dba6:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800dba8:	0c09      	lsrs	r1, r1, #16
 800dbaa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 800dbae:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
 800dbb0:	040c      	lsls	r4, r1, #16
 800dbb2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 800dbb4:	b10a      	cbz	r2, 800dbba <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 800dbb6:	6d40      	ldr	r0, [r0, #84]	; 0x54
 800dbb8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800dbba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800dbbe:	f7ff b947 	b.w	800ce50 <_port_irq_epilogue>
 800dbc2:	bf00      	nop
 800dbc4:	40026400 	.word	0x40026400
 800dbc8:	20000ab8 	.word	0x20000ab8
 800dbcc:	00000000 	.word	0x00000000

0800dbd0 <Vector12C>:
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800dbd0:	4b08      	ldr	r3, [pc, #32]	; (800dbf4 <Vector12C+0x24>)
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 800dbd2:	4809      	ldr	r0, [pc, #36]	; (800dbf8 <Vector12C+0x28>)
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800dbd4:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 800dbd6:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800dbd8:	0d89      	lsrs	r1, r1, #22
 800dbda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 800dbde:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
 800dbe0:	058c      	lsls	r4, r1, #22
 800dbe2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 800dbe4:	b10a      	cbz	r2, 800dbea <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 800dbe6:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 800dbe8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800dbea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800dbee:	f7ff b92f 	b.w	800ce50 <_port_irq_epilogue>
 800dbf2:	bf00      	nop
 800dbf4:	40026400 	.word	0x40026400
 800dbf8:	20000ab8 	.word	0x20000ab8
 800dbfc:	00000000 	.word	0x00000000

0800dc00 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 800dc00:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800dc02:	4b07      	ldr	r3, [pc, #28]	; (800dc20 <Vector130+0x20>)
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 800dc04:	4807      	ldr	r0, [pc, #28]	; (800dc24 <Vector130+0x24>)
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800dc06:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 800dc08:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800dc0a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0;
 800dc0e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 800dc10:	b10a      	cbz	r2, 800dc16 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 800dc12:	6e40      	ldr	r0, [r0, #100]	; 0x64
 800dc14:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800dc16:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800dc1a:	f7ff b919 	b.w	800ce50 <_port_irq_epilogue>
 800dc1e:	bf00      	nop
 800dc20:	40026400 	.word	0x40026400
 800dc24:	20000ab8 	.word	0x20000ab8
	...

0800dc30 <Vector150>:
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800dc30:	4b08      	ldr	r3, [pc, #32]	; (800dc54 <Vector150+0x24>)
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 800dc32:	4809      	ldr	r0, [pc, #36]	; (800dc58 <Vector150+0x28>)
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800dc34:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 800dc36:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800dc38:	0989      	lsrs	r1, r1, #6
 800dc3a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector150) {
 800dc3e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
 800dc40:	018c      	lsls	r4, r1, #6
 800dc42:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 800dc44:	b10a      	cbz	r2, 800dc4a <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 800dc46:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 800dc48:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800dc4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800dc4e:	f7ff b8ff 	b.w	800ce50 <_port_irq_epilogue>
 800dc52:	bf00      	nop
 800dc54:	40026400 	.word	0x40026400
 800dc58:	20000ab8 	.word	0x20000ab8
 800dc5c:	00000000 	.word	0x00000000

0800dc60 <Vector154>:
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800dc60:	4b08      	ldr	r3, [pc, #32]	; (800dc84 <Vector154+0x24>)
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 800dc62:	4809      	ldr	r0, [pc, #36]	; (800dc88 <Vector154+0x28>)
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800dc64:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 800dc66:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800dc68:	0c09      	lsrs	r1, r1, #16
 800dc6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector154) {
 800dc6e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
 800dc70:	040c      	lsls	r4, r1, #16
 800dc72:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 800dc74:	b10a      	cbz	r2, 800dc7a <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 800dc76:	6f40      	ldr	r0, [r0, #116]	; 0x74
 800dc78:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800dc7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800dc7e:	f7ff b8e7 	b.w	800ce50 <_port_irq_epilogue>
 800dc82:	bf00      	nop
 800dc84:	40026400 	.word	0x40026400
 800dc88:	20000ab8 	.word	0x20000ab8
 800dc8c:	00000000 	.word	0x00000000

0800dc90 <Vector158>:
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800dc90:	4b08      	ldr	r3, [pc, #32]	; (800dcb4 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 800dc92:	4809      	ldr	r0, [pc, #36]	; (800dcb8 <Vector158+0x28>)
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800dc94:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 800dc96:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800dc98:	0d89      	lsrs	r1, r1, #22
 800dc9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector158) {
 800dc9e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
 800dca0:	058c      	lsls	r4, r1, #22
 800dca2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 800dca4:	b10a      	cbz	r2, 800dcaa <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 800dca6:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 800dca8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800dcaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800dcae:	f7ff b8cf 	b.w	800ce50 <_port_irq_epilogue>
 800dcb2:	bf00      	nop
 800dcb4:	40026400 	.word	0x40026400
 800dcb8:	20000ab8 	.word	0x20000ab8
 800dcbc:	00000000 	.word	0x00000000

0800dcc0 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 800dcc0:	4b0d      	ldr	r3, [pc, #52]	; (800dcf8 <dmaInit+0x38>)
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 800dcc2:	b430      	push	{r4, r5}
  int i;

  dma_streams_mask = 0;
 800dcc4:	2200      	movs	r2, #0
 800dcc6:	4d0d      	ldr	r5, [pc, #52]	; (800dcfc <dmaInit+0x3c>)
 800dcc8:	4c0d      	ldr	r4, [pc, #52]	; (800dd00 <dmaInit+0x40>)
 800dcca:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
 800dccc:	4611      	mov	r1, r2
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800dcce:	4613      	mov	r3, r2
    _stm32_dma_streams[i].stream->CR = 0;
 800dcd0:	58a8      	ldr	r0, [r5, r2]
 800dcd2:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 800dcd4:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800dcd8:	3301      	adds	r3, #1
 800dcda:	2b10      	cmp	r3, #16
 800dcdc:	f102 020c 	add.w	r2, r2, #12
 800dce0:	d1f6      	bne.n	800dcd0 <dmaInit+0x10>
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 800dce2:	4908      	ldr	r1, [pc, #32]	; (800dd04 <dmaInit+0x44>)
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
 800dce4:	4a08      	ldr	r2, [pc, #32]	; (800dd08 <dmaInit+0x48>)
  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 800dce6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800dcea:	608b      	str	r3, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
  DMA2->HIFCR = 0xFFFFFFFF;
}
 800dcec:	bc30      	pop	{r4, r5}
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
  DMA1->HIFCR = 0xFFFFFFFF;
 800dcee:	60cb      	str	r3, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 800dcf0:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 800dcf2:	60d3      	str	r3, [r2, #12]
}
 800dcf4:	4770      	bx	lr
 800dcf6:	bf00      	nop
 800dcf8:	20000b38 	.word	0x20000b38
 800dcfc:	08010b90 	.word	0x08010b90
 800dd00:	20000ab8 	.word	0x20000ab8
 800dd04:	40026000 	.word	0x40026000
 800dd08:	40026400 	.word	0x40026400
 800dd0c:	00000000 	.word	0x00000000

0800dd10 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 800dd10:	4b17      	ldr	r3, [pc, #92]	; (800dd70 <hal_lld_init+0x60>)
 800dd12:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800dd16:	691a      	ldr	r2, [r3, #16]
 800dd18:	2200      	movs	r2, #0
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 800dd1a:	b410      	push	{r4}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 800dd1c:	6119      	str	r1, [r3, #16]
 800dd1e:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 800dd20:	6958      	ldr	r0, [r3, #20]
 800dd22:	6159      	str	r1, [r3, #20]
 800dd24:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800dd26:	6a18      	ldr	r0, [r3, #32]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800dd28:	4c12      	ldr	r4, [pc, #72]	; (800dd74 <hal_lld_init+0x64>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800dd2a:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 800dd2e:	6218      	str	r0, [r3, #32]
 800dd30:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 800dd32:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800dd34:	6259      	str	r1, [r3, #36]	; 0x24
 800dd36:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800dd38:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800dd3a:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 800dd3e:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800dd40:	6821      	ldr	r1, [r4, #0]
 800dd42:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800dd46:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800dd48:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800dd4a:	f401 7140 	and.w	r1, r1, #768	; 0x300
 800dd4e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800dd52:	d003      	beq.n	800dd5c <hal_lld_init+0x4c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800dd54:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800dd58:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800dd5a:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800dd5c:	4a05      	ldr	r2, [pc, #20]	; (800dd74 <hal_lld_init+0x64>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800dd5e:	f85d 4b04 	ldr.w	r4, [sp], #4

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800dd62:	6853      	ldr	r3, [r2, #4]
 800dd64:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800dd68:	6053      	str	r3, [r2, #4]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800dd6a:	f7ff bfa9 	b.w	800dcc0 <dmaInit>
 800dd6e:	bf00      	nop
 800dd70:	40023800 	.word	0x40023800
 800dd74:	40007000 	.word	0x40007000
	...

0800dd80 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800dd80:	492c      	ldr	r1, [pc, #176]	; (800de34 <stm32_clock_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800dd82:	4b2d      	ldr	r3, [pc, #180]	; (800de38 <stm32_clock_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800dd84:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800dd88:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800dd8c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800dd8e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800dd90:	680b      	ldr	r3, [r1, #0]
 800dd92:	f043 0301 	orr.w	r3, r3, #1
 800dd96:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800dd98:	680a      	ldr	r2, [r1, #0]
 800dd9a:	4b26      	ldr	r3, [pc, #152]	; (800de34 <stm32_clock_init+0xb4>)
 800dd9c:	0790      	lsls	r0, r2, #30
 800dd9e:	d5fb      	bpl.n	800dd98 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800dda0:	689a      	ldr	r2, [r3, #8]
 800dda2:	f022 0203 	bic.w	r2, r2, #3
 800dda6:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800dda8:	689a      	ldr	r2, [r3, #8]
 800ddaa:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800ddac:	4619      	mov	r1, r3
 800ddae:	688b      	ldr	r3, [r1, #8]
 800ddb0:	4a20      	ldr	r2, [pc, #128]	; (800de34 <stm32_clock_init+0xb4>)
 800ddb2:	f013 030c 	ands.w	r3, r3, #12
 800ddb6:	d1fa      	bne.n	800ddae <stm32_clock_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800ddb8:	6811      	ldr	r1, [r2, #0]
 800ddba:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800ddbe:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800ddc0:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 800ddc2:	6813      	ldr	r3, [r2, #0]
 800ddc4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800ddc8:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800ddca:	6811      	ldr	r1, [r2, #0]
 800ddcc:	4b19      	ldr	r3, [pc, #100]	; (800de34 <stm32_clock_init+0xb4>)
 800ddce:	0389      	lsls	r1, r1, #14
 800ddd0:	d5fb      	bpl.n	800ddca <stm32_clock_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800ddd2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800ddd4:	f042 0201 	orr.w	r2, r2, #1
 800ddd8:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800ddda:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800dddc:	4915      	ldr	r1, [pc, #84]	; (800de34 <stm32_clock_init+0xb4>)
 800ddde:	0790      	lsls	r0, r2, #30
 800dde0:	d5fb      	bpl.n	800ddda <stm32_clock_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800dde2:	4b16      	ldr	r3, [pc, #88]	; (800de3c <stm32_clock_init+0xbc>)
 800dde4:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800dde6:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800dde8:	4a13      	ldr	r2, [pc, #76]	; (800de38 <stm32_clock_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800ddea:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800ddee:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800ddf0:	6853      	ldr	r3, [r2, #4]
 800ddf2:	0459      	lsls	r1, r3, #17
 800ddf4:	d5fc      	bpl.n	800ddf0 <stm32_clock_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800ddf6:	490f      	ldr	r1, [pc, #60]	; (800de34 <stm32_clock_init+0xb4>)
 800ddf8:	680a      	ldr	r2, [r1, #0]
 800ddfa:	4b0e      	ldr	r3, [pc, #56]	; (800de34 <stm32_clock_init+0xb4>)
 800ddfc:	0192      	lsls	r2, r2, #6
 800ddfe:	d5fb      	bpl.n	800ddf8 <stm32_clock_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800de00:	4a0f      	ldr	r2, [pc, #60]	; (800de40 <stm32_clock_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800de02:	4910      	ldr	r1, [pc, #64]	; (800de44 <stm32_clock_init+0xc4>)
 800de04:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800de06:	f240 7105 	movw	r1, #1797	; 0x705
 800de0a:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800de0c:	689a      	ldr	r2, [r3, #8]
 800de0e:	f042 0202 	orr.w	r2, r2, #2
 800de12:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800de14:	461a      	mov	r2, r3
 800de16:	6893      	ldr	r3, [r2, #8]
 800de18:	4906      	ldr	r1, [pc, #24]	; (800de34 <stm32_clock_init+0xb4>)
 800de1a:	f003 030c 	and.w	r3, r3, #12
 800de1e:	2b08      	cmp	r3, #8
 800de20:	d1f9      	bne.n	800de16 <stm32_clock_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800de22:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 800de24:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800de28:	644b      	str	r3, [r1, #68]	; 0x44
 800de2a:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 800de2c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800de30:	664b      	str	r3, [r1, #100]	; 0x64
 800de32:	4770      	bx	lr
 800de34:	40023800 	.word	0x40023800
 800de38:	40007000 	.word	0x40007000
 800de3c:	07405408 	.word	0x07405408
 800de40:	40023c00 	.word	0x40023c00
 800de44:	38089400 	.word	0x38089400
	...

0800de50 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 800de50:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800de52:	b672      	cpsid	i
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 800de54:	f7fe fa94 	bl	800c380 <chSysTimerHandlerI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800de58:	b662      	cpsie	i
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 800de5a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 800de5e:	f7fe bff7 	b.w	800ce50 <_port_irq_epilogue>
 800de62:	bf00      	nop
	...

0800de70 <st_lld_init>:
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 800de70:	4b05      	ldr	r3, [pc, #20]	; (800de88 <st_lld_init+0x18>)
 800de72:	f244 109f 	movw	r0, #16799	; 0x419f
  SysTick->VAL = 0;
 800de76:	2100      	movs	r1, #0
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 800de78:	2207      	movs	r2, #7
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 800de7a:	6058      	str	r0, [r3, #4]
  SysTick->VAL = 0;
 800de7c:	6099      	str	r1, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 800de7e:	200b      	movs	r0, #11
 800de80:	2108      	movs	r1, #8
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 800de82:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 800de84:	f7ff bd94 	b.w	800d9b0 <nvicSetSystemHandlerPriority>
 800de88:	e000e010 	.word	0xe000e010
 800de8c:	00000000 	.word	0x00000000

0800de90 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 800de90:	b510      	push	{r4, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 800de92:	4c08      	ldr	r4, [pc, #32]	; (800deb4 <adc_lld_init+0x24>)
 800de94:	4620      	mov	r0, r4
 800de96:	f7ff f83b 	bl	800cf10 <adcObjectInit>
  ADCD1.adc = ADC1;
 800de9a:	4907      	ldr	r1, [pc, #28]	; (800deb8 <adc_lld_init+0x28>)
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 800de9c:	4a07      	ldr	r2, [pc, #28]	; (800debc <adc_lld_init+0x2c>)
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 800de9e:	4b08      	ldr	r3, [pc, #32]	; (800dec0 <adc_lld_init+0x30>)
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 800dea0:	62a1      	str	r1, [r4, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 800dea2:	62e2      	str	r2, [r4, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 800dea4:	6323      	str	r3, [r4, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(ADC_IRQn, STM32_ADC_IRQ_PRIORITY);
 800dea6:	2012      	movs	r0, #18
 800dea8:	2106      	movs	r1, #6
}
 800deaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(ADC_IRQn, STM32_ADC_IRQ_PRIORITY);
 800deae:	f7ff bd5f 	b.w	800d970 <nvicEnableVector>
 800deb2:	bf00      	nop
 800deb4:	20000b3c 	.word	0x20000b3c
 800deb8:	40012000 	.word	0x40012000
 800debc:	08010c20 	.word	0x08010c20
 800dec0:	00022c16 	.word	0x00022c16
	...

0800ded0 <adc_lld_stop_conversion>:
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800ded0:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800ded2:	680a      	ldr	r2, [r1, #0]
 800ded4:	6813      	ldr	r3, [r2, #0]
 800ded6:	f023 031f 	bic.w	r3, r3, #31
 800deda:	6013      	str	r3, [r2, #0]
 800dedc:	6813      	ldr	r3, [r2, #0]
 800dede:	f013 0301 	ands.w	r3, r3, #1
 800dee2:	d1fb      	bne.n	800dedc <adc_lld_stop_conversion+0xc>
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 800dee4:	b430      	push	{r4, r5}

  dmaStreamDisable(adcp->dmastp);
 800dee6:	7a0d      	ldrb	r5, [r1, #8]
 800dee8:	684c      	ldr	r4, [r1, #4]
  adcp->adc->CR1 = 0;
 800deea:	6a82      	ldr	r2, [r0, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800deec:	213d      	movs	r1, #61	; 0x3d
 800deee:	40a9      	lsls	r1, r5
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 800def0:	2001      	movs	r0, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800def2:	6021      	str	r1, [r4, #0]
  adcp->adc->CR1 = 0;
 800def4:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
}
 800def6:	bc30      	pop	{r4, r5}
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
 800def8:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800defa:	6090      	str	r0, [r2, #8]
}
 800defc:	4770      	bx	lr
 800defe:	bf00      	nop

0800df00 <Vector88>:
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 800df00:	4b16      	ldr	r3, [pc, #88]	; (800df5c <Vector88+0x5c>)
 800df02:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
 800df04:	2100      	movs	r1, #0
 800df06:	6019      	str	r1, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 800df08:	0693      	lsls	r3, r2, #26
 800df0a:	d524      	bpl.n	800df56 <Vector88+0x56>
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector88) {
 800df0c:	b510      	push	{r4, lr}
#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
  ADC1->SR = 0;
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 800df0e:	4c14      	ldr	r4, [pc, #80]	; (800df60 <Vector88+0x60>)
 800df10:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800df12:	681b      	ldr	r3, [r3, #0]
 800df14:	685b      	ldr	r3, [r3, #4]
 800df16:	b1d3      	cbz	r3, 800df4e <Vector88+0x4e>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 800df18:	6923      	ldr	r3, [r4, #16]
 800df1a:	b1c3      	cbz	r3, 800df4e <Vector88+0x4e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800df1c:	4620      	mov	r0, r4
 800df1e:	f7ff ffd7 	bl	800ded0 <adc_lld_stop_conversion>
 800df22:	6923      	ldr	r3, [r4, #16]
 800df24:	689b      	ldr	r3, [r3, #8]
 800df26:	b14b      	cbz	r3, 800df3c <Vector88+0x3c>
 800df28:	2205      	movs	r2, #5
 800df2a:	7022      	strb	r2, [r4, #0]
 800df2c:	4620      	mov	r0, r4
 800df2e:	2101      	movs	r1, #1
 800df30:	4798      	blx	r3
 800df32:	7823      	ldrb	r3, [r4, #0]
 800df34:	2b05      	cmp	r3, #5
 800df36:	bf04      	itt	eq
 800df38:	2302      	moveq	r3, #2
 800df3a:	7023      	strbeq	r3, [r4, #0]
 800df3c:	2300      	movs	r3, #0
 800df3e:	6123      	str	r3, [r4, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800df40:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800df42:	4808      	ldr	r0, [pc, #32]	; (800df64 <Vector88+0x64>)
 800df44:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800df48:	f7fe fcba 	bl	800c8c0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800df4c:	b662      	cpsie	i
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
}
 800df4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 800df52:	f7fe bf7d 	b.w	800ce50 <_port_irq_epilogue>
 800df56:	f7fe bf7b 	b.w	800ce50 <_port_irq_epilogue>
 800df5a:	bf00      	nop
 800df5c:	40012000 	.word	0x40012000
 800df60:	20000b3c 	.word	0x20000b3c
 800df64:	20000b50 	.word	0x20000b50
	...

0800df70 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 800df70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800df72:	4806      	ldr	r0, [pc, #24]	; (800df8c <Vector58+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 800df74:	4a06      	ldr	r2, [pc, #24]	; (800df90 <Vector58+0x20>)
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800df76:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 800df78:	2101      	movs	r1, #1
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800df7a:	685b      	ldr	r3, [r3, #4]
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 800df7c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800df7e:	2100      	movs	r1, #0
 800df80:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800df82:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
  EXTD1.config->channels[0].cb(&EXTD1, 0);

  OSAL_IRQ_EPILOGUE();
 800df86:	f7fe bf63 	b.w	800ce50 <_port_irq_epilogue>
 800df8a:	bf00      	nop
 800df8c:	20000b70 	.word	0x20000b70
 800df90:	40013c00 	.word	0x40013c00
	...

0800dfa0 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 800dfa0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800dfa2:	4806      	ldr	r0, [pc, #24]	; (800dfbc <Vector5C+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 800dfa4:	4a06      	ldr	r2, [pc, #24]	; (800dfc0 <Vector5C+0x20>)
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800dfa6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 800dfa8:	2102      	movs	r1, #2
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800dfaa:	68db      	ldr	r3, [r3, #12]
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 800dfac:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800dfae:	2101      	movs	r1, #1
 800dfb0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800dfb2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
  EXTD1.config->channels[1].cb(&EXTD1, 1);

  OSAL_IRQ_EPILOGUE();
 800dfb6:	f7fe bf4b 	b.w	800ce50 <_port_irq_epilogue>
 800dfba:	bf00      	nop
 800dfbc:	20000b70 	.word	0x20000b70
 800dfc0:	40013c00 	.word	0x40013c00
	...

0800dfd0 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector60) {
 800dfd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800dfd2:	4806      	ldr	r0, [pc, #24]	; (800dfec <Vector60+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 800dfd4:	4a06      	ldr	r2, [pc, #24]	; (800dff0 <Vector60+0x20>)
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800dfd6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 800dfd8:	2104      	movs	r1, #4
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800dfda:	695b      	ldr	r3, [r3, #20]
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 800dfdc:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800dfde:	2102      	movs	r1, #2
 800dfe0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800dfe2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
  EXTD1.config->channels[2].cb(&EXTD1, 2);

  OSAL_IRQ_EPILOGUE();
 800dfe6:	f7fe bf33 	b.w	800ce50 <_port_irq_epilogue>
 800dfea:	bf00      	nop
 800dfec:	20000b70 	.word	0x20000b70
 800dff0:	40013c00 	.word	0x40013c00
	...

0800e000 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector64) {
 800e000:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800e002:	4806      	ldr	r0, [pc, #24]	; (800e01c <Vector64+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 800e004:	4a06      	ldr	r2, [pc, #24]	; (800e020 <Vector64+0x20>)
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800e006:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 800e008:	2108      	movs	r1, #8
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800e00a:	69db      	ldr	r3, [r3, #28]
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 800e00c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800e00e:	2103      	movs	r1, #3
 800e010:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e012:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
  EXTD1.config->channels[3].cb(&EXTD1, 3);

  OSAL_IRQ_EPILOGUE();
 800e016:	f7fe bf1b 	b.w	800ce50 <_port_irq_epilogue>
 800e01a:	bf00      	nop
 800e01c:	20000b70 	.word	0x20000b70
 800e020:	40013c00 	.word	0x40013c00
	...

0800e030 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector68) {
 800e030:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 800e032:	4806      	ldr	r0, [pc, #24]	; (800e04c <Vector68+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 800e034:	4a06      	ldr	r2, [pc, #24]	; (800e050 <Vector68+0x20>)
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 800e036:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 800e038:	2110      	movs	r1, #16
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 800e03a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 800e03c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 800e03e:	2104      	movs	r1, #4
 800e040:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e042:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
  EXTD1.config->channels[4].cb(&EXTD1, 4);

  OSAL_IRQ_EPILOGUE();
 800e046:	f7fe bf03 	b.w	800ce50 <_port_irq_epilogue>
 800e04a:	bf00      	nop
 800e04c:	20000b70 	.word	0x20000b70
 800e050:	40013c00 	.word	0x40013c00
	...

0800e060 <Vector9C>:
OSAL_IRQ_HANDLER(Vector9C) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
 800e060:	4b18      	ldr	r3, [pc, #96]	; (800e0c4 <Vector9C+0x64>)
/**
 * @brief   EXTI[5]...EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector9C) {
 800e062:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
 800e064:	695c      	ldr	r4, [r3, #20]
 800e066:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
 800e06a:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 5))
 800e06c:	06a3      	lsls	r3, r4, #26
 800e06e:	d422      	bmi.n	800e0b6 <Vector9C+0x56>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
 800e070:	0660      	lsls	r0, r4, #25
 800e072:	d41a      	bmi.n	800e0aa <Vector9C+0x4a>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
 800e074:	0621      	lsls	r1, r4, #24
 800e076:	d412      	bmi.n	800e09e <Vector9C+0x3e>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
  if (pr & (1 << 8))
 800e078:	05e2      	lsls	r2, r4, #23
 800e07a:	d40a      	bmi.n	800e092 <Vector9C+0x32>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
  if (pr & (1 << 9))
 800e07c:	05a3      	lsls	r3, r4, #22
 800e07e:	d504      	bpl.n	800e08a <Vector9C+0x2a>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 800e080:	4811      	ldr	r0, [pc, #68]	; (800e0c8 <Vector9C+0x68>)
 800e082:	6843      	ldr	r3, [r0, #4]
 800e084:	2109      	movs	r1, #9
 800e086:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800e088:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e08a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 8))
    EXTD1.config->channels[8].cb(&EXTD1, 8);
  if (pr & (1 << 9))
    EXTD1.config->channels[9].cb(&EXTD1, 9);

  OSAL_IRQ_EPILOGUE();
 800e08e:	f7fe bedf 	b.w	800ce50 <_port_irq_epilogue>
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
    EXTD1.config->channels[7].cb(&EXTD1, 7);
  if (pr & (1 << 8))
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 800e092:	480d      	ldr	r0, [pc, #52]	; (800e0c8 <Vector9C+0x68>)
 800e094:	6843      	ldr	r3, [r0, #4]
 800e096:	2108      	movs	r1, #8
 800e098:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e09a:	4798      	blx	r3
 800e09c:	e7ee      	b.n	800e07c <Vector9C+0x1c>
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 800e09e:	480a      	ldr	r0, [pc, #40]	; (800e0c8 <Vector9C+0x68>)
 800e0a0:	6843      	ldr	r3, [r0, #4]
 800e0a2:	2107      	movs	r1, #7
 800e0a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e0a6:	4798      	blx	r3
 800e0a8:	e7e6      	b.n	800e078 <Vector9C+0x18>
  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
  EXTI->PR = pr;
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 800e0aa:	4807      	ldr	r0, [pc, #28]	; (800e0c8 <Vector9C+0x68>)
 800e0ac:	6843      	ldr	r3, [r0, #4]
 800e0ae:	2106      	movs	r1, #6
 800e0b0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800e0b2:	4798      	blx	r3
 800e0b4:	e7de      	b.n	800e074 <Vector9C+0x14>
  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
  EXTI->PR = pr;
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 800e0b6:	4804      	ldr	r0, [pc, #16]	; (800e0c8 <Vector9C+0x68>)
 800e0b8:	6843      	ldr	r3, [r0, #4]
 800e0ba:	2105      	movs	r1, #5
 800e0bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e0be:	4798      	blx	r3
 800e0c0:	e7d6      	b.n	800e070 <Vector9C+0x10>
 800e0c2:	bf00      	nop
 800e0c4:	40013c00 	.word	0x40013c00
 800e0c8:	20000b70 	.word	0x20000b70
 800e0cc:	00000000 	.word	0x00000000

0800e0d0 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
 800e0d0:	4b1c      	ldr	r3, [pc, #112]	; (800e144 <VectorE0+0x74>)
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 800e0d2:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
 800e0d4:	695c      	ldr	r4, [r3, #20]
 800e0d6:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                   (1 << 15));
  EXTI->PR = pr;
 800e0da:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 10))
 800e0dc:	0562      	lsls	r2, r4, #21
 800e0de:	d42a      	bmi.n	800e136 <VectorE0+0x66>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
 800e0e0:	0523      	lsls	r3, r4, #20
 800e0e2:	d422      	bmi.n	800e12a <VectorE0+0x5a>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
 800e0e4:	04e0      	lsls	r0, r4, #19
 800e0e6:	d41a      	bmi.n	800e11e <VectorE0+0x4e>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
 800e0e8:	04a1      	lsls	r1, r4, #18
 800e0ea:	d412      	bmi.n	800e112 <VectorE0+0x42>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
  if (pr & (1 << 14))
 800e0ec:	0462      	lsls	r2, r4, #17
 800e0ee:	d40a      	bmi.n	800e106 <VectorE0+0x36>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
  if (pr & (1 << 15))
 800e0f0:	0423      	lsls	r3, r4, #16
 800e0f2:	d504      	bpl.n	800e0fe <VectorE0+0x2e>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 800e0f4:	4814      	ldr	r0, [pc, #80]	; (800e148 <VectorE0+0x78>)
 800e0f6:	6843      	ldr	r3, [r0, #4]
 800e0f8:	210f      	movs	r1, #15
 800e0fa:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800e0fc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e0fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 14))
    EXTD1.config->channels[14].cb(&EXTD1, 14);
  if (pr & (1 << 15))
    EXTD1.config->channels[15].cb(&EXTD1, 15);

  OSAL_IRQ_EPILOGUE();
 800e102:	f7fe bea5 	b.w	800ce50 <_port_irq_epilogue>
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
    EXTD1.config->channels[13].cb(&EXTD1, 13);
  if (pr & (1 << 14))
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 800e106:	4810      	ldr	r0, [pc, #64]	; (800e148 <VectorE0+0x78>)
 800e108:	6843      	ldr	r3, [r0, #4]
 800e10a:	210e      	movs	r1, #14
 800e10c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e10e:	4798      	blx	r3
 800e110:	e7ee      	b.n	800e0f0 <VectorE0+0x20>
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 800e112:	480d      	ldr	r0, [pc, #52]	; (800e148 <VectorE0+0x78>)
 800e114:	6843      	ldr	r3, [r0, #4]
 800e116:	210d      	movs	r1, #13
 800e118:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800e11a:	4798      	blx	r3
 800e11c:	e7e6      	b.n	800e0ec <VectorE0+0x1c>
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 800e11e:	480a      	ldr	r0, [pc, #40]	; (800e148 <VectorE0+0x78>)
 800e120:	6843      	ldr	r3, [r0, #4]
 800e122:	210c      	movs	r1, #12
 800e124:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e126:	4798      	blx	r3
 800e128:	e7de      	b.n	800e0e8 <VectorE0+0x18>
                   (1 << 15));
  EXTI->PR = pr;
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 800e12a:	4807      	ldr	r0, [pc, #28]	; (800e148 <VectorE0+0x78>)
 800e12c:	6843      	ldr	r3, [r0, #4]
 800e12e:	210b      	movs	r1, #11
 800e130:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e132:	4798      	blx	r3
 800e134:	e7d6      	b.n	800e0e4 <VectorE0+0x14>

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
                   (1 << 15));
  EXTI->PR = pr;
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 800e136:	4804      	ldr	r0, [pc, #16]	; (800e148 <VectorE0+0x78>)
 800e138:	6843      	ldr	r3, [r0, #4]
 800e13a:	210a      	movs	r1, #10
 800e13c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e13e:	4798      	blx	r3
 800e140:	e7ce      	b.n	800e0e0 <VectorE0+0x10>
 800e142:	bf00      	nop
 800e144:	40013c00 	.word	0x40013c00
 800e148:	20000b70 	.word	0x20000b70
 800e14c:	00000000 	.word	0x00000000

0800e150 <Vector44>:
/**
 * @brief   EXTI[16] interrupt handler (PVD).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector44) {
 800e150:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 800e152:	4807      	ldr	r0, [pc, #28]	; (800e170 <Vector44+0x20>)
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 800e154:	4a07      	ldr	r2, [pc, #28]	; (800e174 <Vector44+0x24>)
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 800e156:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 800e158:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 800e15c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 800e160:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 800e162:	2110      	movs	r1, #16
 800e164:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e166:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
  EXTD1.config->channels[16].cb(&EXTD1, 16);

  OSAL_IRQ_EPILOGUE();
 800e16a:	f7fe be71 	b.w	800ce50 <_port_irq_epilogue>
 800e16e:	bf00      	nop
 800e170:	20000b70 	.word	0x20000b70
 800e174:	40013c00 	.word	0x40013c00
	...

0800e180 <VectorE4>:
/**
 * @brief   EXTI[17] interrupt handler (RTC_ALARM).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE4) {
 800e180:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800e182:	4807      	ldr	r0, [pc, #28]	; (800e1a0 <VectorE4+0x20>)
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 800e184:	4a07      	ldr	r2, [pc, #28]	; (800e1a4 <VectorE4+0x24>)
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800e186:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 800e188:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800e18c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 800e190:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800e192:	2111      	movs	r1, #17
 800e194:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e196:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
  EXTD1.config->channels[17].cb(&EXTD1, 17);

  OSAL_IRQ_EPILOGUE();
 800e19a:	f7fe be59 	b.w	800ce50 <_port_irq_epilogue>
 800e19e:	bf00      	nop
 800e1a0:	20000b70 	.word	0x20000b70
 800e1a4:	40013c00 	.word	0x40013c00
	...

0800e1b0 <VectorE8>:
/**
 * @brief   EXTI[18] interrupt handler (OTG_FS_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE8) {
 800e1b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800e1b2:	4807      	ldr	r0, [pc, #28]	; (800e1d0 <VectorE8+0x20>)
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 800e1b4:	4a07      	ldr	r2, [pc, #28]	; (800e1d4 <VectorE8+0x24>)
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800e1b6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 800e1b8:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800e1bc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 800e1c0:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800e1c2:	2112      	movs	r1, #18
 800e1c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e1c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
  EXTD1.config->channels[18].cb(&EXTD1, 18);

  OSAL_IRQ_EPILOGUE();
 800e1ca:	f7fe be41 	b.w	800ce50 <_port_irq_epilogue>
 800e1ce:	bf00      	nop
 800e1d0:	20000b70 	.word	0x20000b70
 800e1d4:	40013c00 	.word	0x40013c00
	...

0800e1e0 <Vector138>:
/**
 * @brief   EXTI[19] interrupt handler (ETH_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector138) {
 800e1e0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800e1e2:	4807      	ldr	r0, [pc, #28]	; (800e200 <Vector138+0x20>)
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 800e1e4:	4a07      	ldr	r2, [pc, #28]	; (800e204 <Vector138+0x24>)
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800e1e6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 800e1e8:	f44f 2100 	mov.w	r1, #524288	; 0x80000
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800e1ec:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 800e1f0:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800e1f2:	2113      	movs	r1, #19
 800e1f4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e1f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
  EXTD1.config->channels[19].cb(&EXTD1, 19);

  OSAL_IRQ_EPILOGUE();
 800e1fa:	f7fe be29 	b.w	800ce50 <_port_irq_epilogue>
 800e1fe:	bf00      	nop
 800e200:	20000b70 	.word	0x20000b70
 800e204:	40013c00 	.word	0x40013c00
	...

0800e210 <Vector170>:
/**
 * @brief   EXTI[20] interrupt handler (OTG_HS_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector170) {
 800e210:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 800e212:	4807      	ldr	r0, [pc, #28]	; (800e230 <Vector170+0x20>)
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 800e214:	4a07      	ldr	r2, [pc, #28]	; (800e234 <Vector170+0x24>)
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 800e216:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 800e218:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 800e21c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 800e220:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 800e222:	2114      	movs	r1, #20
 800e224:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e226:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
  EXTD1.config->channels[20].cb(&EXTD1, 20);

  OSAL_IRQ_EPILOGUE();
 800e22a:	f7fe be11 	b.w	800ce50 <_port_irq_epilogue>
 800e22e:	bf00      	nop
 800e230:	20000b70 	.word	0x20000b70
 800e234:	40013c00 	.word	0x40013c00
	...

0800e240 <Vector48>:
/**
 * @brief   EXTI[21] interrupt handler (TAMPER_STAMP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector48) {
 800e240:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 800e242:	4807      	ldr	r0, [pc, #28]	; (800e260 <Vector48+0x20>)
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 800e244:	4a07      	ldr	r2, [pc, #28]	; (800e264 <Vector48+0x24>)
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 800e246:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 800e248:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 800e24c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 800e250:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 800e252:	2115      	movs	r1, #21
 800e254:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e256:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
  EXTD1.config->channels[21].cb(&EXTD1, 21);

  OSAL_IRQ_EPILOGUE();
 800e25a:	f7fe bdf9 	b.w	800ce50 <_port_irq_epilogue>
 800e25e:	bf00      	nop
 800e260:	20000b70 	.word	0x20000b70
 800e264:	40013c00 	.word	0x40013c00
	...

0800e270 <Vector4C>:
/**
 * @brief   EXTI[22] interrupt handler (RTC_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector4C) {
 800e270:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800e272:	4807      	ldr	r0, [pc, #28]	; (800e290 <Vector4C+0x20>)
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 800e274:	4a07      	ldr	r2, [pc, #28]	; (800e294 <Vector4C+0x24>)
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800e276:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 800e278:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800e27c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 800e280:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800e282:	2116      	movs	r1, #22
 800e284:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800e286:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
  EXTD1.config->channels[22].cb(&EXTD1, 22);

  OSAL_IRQ_EPILOGUE();
 800e28a:	f7fe bde1 	b.w	800ce50 <_port_irq_epilogue>
 800e28e:	bf00      	nop
 800e290:	20000b70 	.word	0x20000b70
 800e294:	40013c00 	.word	0x40013c00
	...

0800e2a0 <ext_lld_exti_irq_enable>:
 *
 * @notapi
 */
void ext_lld_exti_irq_enable(void) {

  nvicEnableVector(EXTI0_IRQn, STM32_EXT_EXTI0_IRQ_PRIORITY);
 800e2a0:	2006      	movs	r0, #6
/**
 * @brief   Enables EXTI IRQ sources.
 *
 * @notapi
 */
void ext_lld_exti_irq_enable(void) {
 800e2a2:	b508      	push	{r3, lr}

  nvicEnableVector(EXTI0_IRQn, STM32_EXT_EXTI0_IRQ_PRIORITY);
 800e2a4:	4601      	mov	r1, r0
 800e2a6:	f7ff fb63 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_EXT_EXTI1_IRQ_PRIORITY);
 800e2aa:	2007      	movs	r0, #7
 800e2ac:	2106      	movs	r1, #6
 800e2ae:	f7ff fb5f 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_EXT_EXTI2_IRQ_PRIORITY);
 800e2b2:	2008      	movs	r0, #8
 800e2b4:	2106      	movs	r1, #6
 800e2b6:	f7ff fb5b 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_EXT_EXTI3_IRQ_PRIORITY);
 800e2ba:	2009      	movs	r0, #9
 800e2bc:	2106      	movs	r1, #6
 800e2be:	f7ff fb57 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_EXT_EXTI4_IRQ_PRIORITY);
 800e2c2:	200a      	movs	r0, #10
 800e2c4:	2106      	movs	r1, #6
 800e2c6:	f7ff fb53 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_EXT_EXTI5_9_IRQ_PRIORITY);
 800e2ca:	2017      	movs	r0, #23
 800e2cc:	2106      	movs	r1, #6
 800e2ce:	f7ff fb4f 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_EXT_EXTI10_15_IRQ_PRIORITY);
 800e2d2:	2028      	movs	r0, #40	; 0x28
 800e2d4:	2106      	movs	r1, #6
 800e2d6:	f7ff fb4b 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(PVD_IRQn, STM32_EXT_EXTI16_IRQ_PRIORITY);
 800e2da:	2001      	movs	r0, #1
 800e2dc:	2106      	movs	r1, #6
 800e2de:	f7ff fb47 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(RTC_Alarm_IRQn, STM32_EXT_EXTI17_IRQ_PRIORITY);
 800e2e2:	2029      	movs	r0, #41	; 0x29
 800e2e4:	210f      	movs	r1, #15
 800e2e6:	f7ff fb43 	bl	800d970 <nvicEnableVector>
  nvicEnableVector(OTG_FS_WKUP_IRQn, STM32_EXT_EXTI18_IRQ_PRIORITY);
 800e2ea:	202a      	movs	r0, #42	; 0x2a
 800e2ec:	2106      	movs	r1, #6
 800e2ee:	f7ff fb3f 	bl	800d970 <nvicEnableVector>
#if STM32_HAS_ETH
  nvicEnableVector(ETH_WKUP_IRQn, STM32_EXT_EXTI19_IRQ_PRIORITY);
 800e2f2:	203e      	movs	r0, #62	; 0x3e
 800e2f4:	2106      	movs	r1, #6
 800e2f6:	f7ff fb3b 	bl	800d970 <nvicEnableVector>
#endif
#if STM32_HAS_OTG2
  nvicEnableVector(OTG_HS_WKUP_IRQn, STM32_EXT_EXTI20_IRQ_PRIORITY);
 800e2fa:	204c      	movs	r0, #76	; 0x4c
 800e2fc:	2106      	movs	r1, #6
 800e2fe:	f7ff fb37 	bl	800d970 <nvicEnableVector>
#endif
#if !defined(STM32F401xx)
  nvicEnableVector(TAMP_STAMP_IRQn, STM32_EXT_EXTI21_IRQ_PRIORITY);
 800e302:	2002      	movs	r0, #2
 800e304:	210f      	movs	r1, #15
 800e306:	f7ff fb33 	bl	800d970 <nvicEnableVector>
#endif /* !defined(STM32F401xx) */
  nvicEnableVector(RTC_WKUP_IRQn, STM32_EXT_EXTI22_IRQ_PRIORITY);
 800e30a:	2003      	movs	r0, #3
 800e30c:	210f      	movs	r1, #15
}
 800e30e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  nvicEnableVector(OTG_HS_WKUP_IRQn, STM32_EXT_EXTI20_IRQ_PRIORITY);
#endif
#if !defined(STM32F401xx)
  nvicEnableVector(TAMP_STAMP_IRQn, STM32_EXT_EXTI21_IRQ_PRIORITY);
#endif /* !defined(STM32F401xx) */
  nvicEnableVector(RTC_WKUP_IRQn, STM32_EXT_EXTI22_IRQ_PRIORITY);
 800e312:	f7ff bb2d 	b.w	800d970 <nvicEnableVector>
 800e316:	bf00      	nop
	...

0800e320 <ext_lld_init>:
 * @notapi
 */
void ext_lld_init(void) {

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
 800e320:	4801      	ldr	r0, [pc, #4]	; (800e328 <ext_lld_init+0x8>)
 800e322:	f7fe be3d 	b.w	800cfa0 <extObjectInit>
 800e326:	bf00      	nop
 800e328:	20000b70 	.word	0x20000b70
 800e32c:	00000000 	.word	0x00000000

0800e330 <ext_lld_channel_enable>:
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
 800e330:	290f      	cmp	r1, #15
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be enabled
 *
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {
 800e332:	b4f0      	push	{r4, r5, r6, r7}

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
 800e334:	d920      	bls.n	800e378 <ext_lld_channel_enable+0x48>
 800e336:	6842      	ldr	r2, [r0, #4]
 800e338:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 800e33c:	07c3      	lsls	r3, r0, #31
 800e33e:	d534      	bpl.n	800e3aa <ext_lld_channel_enable+0x7a>
      EXTI->RTSR |= (1 << channel);
 800e340:	4d22      	ldr	r5, [pc, #136]	; (800e3cc <ext_lld_channel_enable+0x9c>)
 800e342:	2301      	movs	r3, #1
 800e344:	68ac      	ldr	r4, [r5, #8]
 800e346:	408b      	lsls	r3, r1
 800e348:	431c      	orrs	r4, r3
 800e34a:	60ac      	str	r4, [r5, #8]
 800e34c:	43dc      	mvns	r4, r3
    else
      EXTI->RTSR &= ~(1 << channel);
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
      EXTI->FTSR |= (1 << channel);
 800e34e:	4d1f      	ldr	r5, [pc, #124]	; (800e3cc <ext_lld_channel_enable+0x9c>)
    else
      EXTI->FTSR &= ~(1 << channel);

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 800e350:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
      EXTI->RTSR |= (1 << channel);
    else
      EXTI->RTSR &= ~(1 << channel);
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
 800e354:	f010 0f02 	tst.w	r0, #2
      EXTI->FTSR |= (1 << channel);
 800e358:	68e8      	ldr	r0, [r5, #12]
    else
      EXTI->FTSR &= ~(1 << channel);

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 800e35a:	684a      	ldr	r2, [r1, #4]
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
      EXTI->RTSR |= (1 << channel);
    else
      EXTI->RTSR &= ~(1 << channel);
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
      EXTI->FTSR |= (1 << channel);
 800e35c:	bf14      	ite	ne
 800e35e:	4318      	orrne	r0, r3
    else
      EXTI->FTSR &= ~(1 << channel);
 800e360:	4020      	andeq	r0, r4
 800e362:	60e8      	str	r0, [r5, #12]

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 800e364:	b34a      	cbz	r2, 800e3ba <ext_lld_channel_enable+0x8a>
      EXTI->IMR |= (1 << channel);
 800e366:	4a19      	ldr	r2, [pc, #100]	; (800e3cc <ext_lld_channel_enable+0x9c>)
 800e368:	6811      	ldr	r1, [r2, #0]
 800e36a:	430b      	orrs	r3, r1
 800e36c:	6013      	str	r3, [r2, #0]
      EXTI->EMR &= ~(1 << channel);
 800e36e:	6853      	ldr	r3, [r2, #4]
 800e370:	4023      	ands	r3, r4
 800e372:	6053      	str	r3, [r2, #4]
      EXTI->EMR2 |= (1 << (32 - channel));
      EXTI->IMR2 &= ~(1 << (32 - channel));
    }
  }
#endif
}
 800e374:	bcf0      	pop	{r4, r5, r6, r7}
 800e376:	4770      	bx	lr
 800e378:	f021 0303 	bic.w	r3, r1, #3

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
    uint32_t port = ((extp->config->channels[channel].mode &
 800e37c:	6842      	ldr	r2, [r0, #4]
 800e37e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800e382:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
 800e386:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 800e38a:	689f      	ldr	r7, [r3, #8]
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 800e38c:	f001 0403 	and.w	r4, r1, #3
 800e390:	00a4      	lsls	r4, r4, #2
 800e392:	260f      	movs	r6, #15
 800e394:	40a6      	lsls	r6, r4
    uint32_t port = ((extp->config->channels[channel].mode &
                      EXT_MODE_GPIO_MASK) >>
 800e396:	f3c0 1503 	ubfx	r5, r0, #4, #4
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 800e39a:	ea27 0606 	bic.w	r6, r7, r6

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
    uint32_t port = ((extp->config->channels[channel].mode &
 800e39e:	fa05 f404 	lsl.w	r4, r5, r4
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 800e3a2:	4334      	orrs	r4, r6
 800e3a4:	609c      	str	r4, [r3, #8]

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 800e3a6:	07c3      	lsls	r3, r0, #31
 800e3a8:	d4ca      	bmi.n	800e340 <ext_lld_channel_enable+0x10>
      EXTI->RTSR |= (1 << channel);
    else
      EXTI->RTSR &= ~(1 << channel);
 800e3aa:	4e08      	ldr	r6, [pc, #32]	; (800e3cc <ext_lld_channel_enable+0x9c>)
 800e3ac:	2301      	movs	r3, #1
 800e3ae:	68b5      	ldr	r5, [r6, #8]
 800e3b0:	408b      	lsls	r3, r1
 800e3b2:	43dc      	mvns	r4, r3
 800e3b4:	4025      	ands	r5, r4
 800e3b6:	60b5      	str	r5, [r6, #8]
 800e3b8:	e7c9      	b.n	800e34e <ext_lld_channel_enable+0x1e>
    if (extp->config->channels[channel].cb != NULL) {
      EXTI->IMR |= (1 << channel);
      EXTI->EMR &= ~(1 << channel);
    }
    else {
      EXTI->EMR |= (1 << channel);
 800e3ba:	4a04      	ldr	r2, [pc, #16]	; (800e3cc <ext_lld_channel_enable+0x9c>)
 800e3bc:	6851      	ldr	r1, [r2, #4]
 800e3be:	430b      	orrs	r3, r1
 800e3c0:	6053      	str	r3, [r2, #4]
      EXTI->IMR &= ~(1 << channel);
 800e3c2:	6813      	ldr	r3, [r2, #0]
 800e3c4:	4023      	ands	r3, r4
 800e3c6:	6013      	str	r3, [r2, #0]
      EXTI->EMR2 |= (1 << (32 - channel));
      EXTI->IMR2 &= ~(1 << (32 - channel));
    }
  }
#endif
}
 800e3c8:	bcf0      	pop	{r4, r5, r6, r7}
 800e3ca:	4770      	bx	lr
 800e3cc:	40013c00 	.word	0x40013c00

0800e3d0 <ext_lld_channel_disable>:
  (void)extp;

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    EXTI->IMR   &= ~(1 << channel);
 800e3d0:	4b08      	ldr	r3, [pc, #32]	; (800e3f4 <ext_lld_channel_disable+0x24>)
 800e3d2:	2201      	movs	r2, #1
 800e3d4:	6818      	ldr	r0, [r3, #0]
 800e3d6:	408a      	lsls	r2, r1
 800e3d8:	43d1      	mvns	r1, r2
 800e3da:	4008      	ands	r0, r1
 800e3dc:	6018      	str	r0, [r3, #0]
    EXTI->EMR   &= ~(1 << channel);
 800e3de:	6858      	ldr	r0, [r3, #4]
 800e3e0:	4008      	ands	r0, r1
 800e3e2:	6058      	str	r0, [r3, #4]
    EXTI->RTSR  &= ~(1 << channel);
 800e3e4:	6898      	ldr	r0, [r3, #8]
 800e3e6:	4008      	ands	r0, r1
 800e3e8:	6098      	str	r0, [r3, #8]
    EXTI->FTSR  &= ~(1 << channel);
 800e3ea:	68d8      	ldr	r0, [r3, #12]
 800e3ec:	4001      	ands	r1, r0
 800e3ee:	60d9      	str	r1, [r3, #12]
    EXTI->PR     =  (1 << channel);
 800e3f0:	615a      	str	r2, [r3, #20]
 800e3f2:	4770      	bx	lr
 800e3f4:	40013c00 	.word	0x40013c00
	...

0800e400 <ext_lld_start>:
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 800e400:	b538      	push	{r3, r4, r5, lr}
  unsigned i;

  if (extp->state == EXT_STOP)
 800e402:	7803      	ldrb	r3, [r0, #0]
 800e404:	2b01      	cmp	r3, #1
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 800e406:	4605      	mov	r5, r0
  unsigned i;

  if (extp->state == EXT_STOP)
 800e408:	d016      	beq.n	800e438 <ext_lld_start+0x38>
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 800e40a:	2400      	movs	r4, #0
 800e40c:	e004      	b.n	800e418 <ext_lld_start+0x18>

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 800e40e:	3401      	adds	r4, #1
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, i);
 800e410:	f7ff ff8e 	bl	800e330 <ext_lld_channel_enable>

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 800e414:	2c17      	cmp	r4, #23
 800e416:	d00e      	beq.n	800e436 <ext_lld_start+0x36>
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
 800e418:	686b      	ldr	r3, [r5, #4]
 800e41a:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 800e41e:	f013 0f04 	tst.w	r3, #4
      ext_lld_channel_enable(extp, i);
 800e422:	4628      	mov	r0, r5
 800e424:	4621      	mov	r1, r4
  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
 800e426:	d1f2      	bne.n	800e40e <ext_lld_start+0xe>
      ext_lld_channel_enable(extp, i);
    else
      ext_lld_channel_disable(extp, i);
 800e428:	4621      	mov	r1, r4
 800e42a:	4628      	mov	r0, r5

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 800e42c:	3401      	adds	r4, #1
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, i);
    else
      ext_lld_channel_disable(extp, i);
 800e42e:	f7ff ffcf 	bl	800e3d0 <ext_lld_channel_disable>

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 800e432:	2c17      	cmp	r4, #23
 800e434:	d1f0      	bne.n	800e418 <ext_lld_start+0x18>
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, i);
    else
      ext_lld_channel_disable(extp, i);
}
 800e436:	bd38      	pop	{r3, r4, r5, pc}
 */
void ext_lld_start(EXTDriver *extp) {
  unsigned i;

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();
 800e438:	f7ff ff32 	bl	800e2a0 <ext_lld_exti_irq_enable>
 800e43c:	e7e5      	b.n	800e40a <ext_lld_start+0xa>
 800e43e:	bf00      	nop

0800e440 <can_lld_set_filters>:
 *
 * @notapi
 */
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {
 800e440:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 800e442:	4c43      	ldr	r4, [pc, #268]	; (800e550 <can_lld_set_filters+0x110>)

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 800e444:	4d43      	ldr	r5, [pc, #268]	; (800e554 <can_lld_set_filters+0x114>)
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 800e446:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800e448:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800e44c:	6423      	str	r3, [r4, #64]	; 0x40

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 800e44e:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
 800e452:	0c1b      	lsrs	r3, r3, #16
 800e454:	041b      	lsls	r3, r3, #16
 800e456:	f043 0301 	orr.w	r3, r3, #1
 800e45a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800e45e:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
  if (num > 0) {
 800e462:	2900      	cmp	r1, #0
 800e464:	d04e      	beq.n	800e504 <can_lld_set_filters+0xc4>
    uint32_t i, fmask;

    /* All filters cleared.*/
    CAN1->FA1R = 0;
 800e466:	2300      	movs	r3, #0
 800e468:	f8c5 321c 	str.w	r3, [r5, #540]	; 0x21c
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800e46c:	4618      	mov	r0, r3
  if (num > 0) {
    uint32_t i, fmask;

    /* All filters cleared.*/
    CAN1->FA1R = 0;
    CAN1->FM1R = 0;
 800e46e:	f8c5 3204 	str.w	r3, [r5, #516]	; 0x204
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
      CAN1->sFilterRegister[i].FR1 = 0;
 800e472:	461c      	mov	r4, r3
    uint32_t i, fmask;

    /* All filters cleared.*/
    CAN1->FA1R = 0;
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
 800e474:	f8c5 320c 	str.w	r3, [r5, #524]	; 0x20c
    CAN1->FFA1R = 0;
 800e478:	f8c5 3214 	str.w	r3, [r5, #532]	; 0x214
 800e47c:	00c3      	lsls	r3, r0, #3
 800e47e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800e482:	f503 43c8 	add.w	r3, r3, #25600	; 0x6400
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800e486:	3001      	adds	r0, #1
 800e488:	281c      	cmp	r0, #28
      CAN1->sFilterRegister[i].FR1 = 0;
 800e48a:	f8c3 4240 	str.w	r4, [r3, #576]	; 0x240
      CAN1->sFilterRegister[i].FR2 = 0;
 800e48e:	f8c3 4244 	str.w	r4, [r3, #580]	; 0x244
    /* All filters cleared.*/
    CAN1->FA1R = 0;
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800e492:	d1f3      	bne.n	800e47c <can_lld_set_filters+0x3c>

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
      fmask = 1 << cfp->filter;
      if (cfp->mode)
        CAN1->FM1R |= fmask;
 800e494:	482f      	ldr	r0, [pc, #188]	; (800e554 <can_lld_set_filters+0x114>)
    /* All filters cleared.*/
    CAN1->FA1R = 0;
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800e496:	2600      	movs	r6, #0
      CAN1->sFilterRegister[i].FR2 = 0;
    }

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
      fmask = 1 << cfp->filter;
 800e498:	2701      	movs	r7, #1
 800e49a:	6815      	ldr	r5, [r2, #0]
      if (cfp->mode)
 800e49c:	7914      	ldrb	r4, [r2, #4]
 800e49e:	00eb      	lsls	r3, r5, #3
 800e4a0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800e4a4:	f014 0f01 	tst.w	r4, #1
 800e4a8:	f503 43c8 	add.w	r3, r3, #25600	; 0x6400
      CAN1->sFilterRegister[i].FR1 = 0;
      CAN1->sFilterRegister[i].FR2 = 0;
    }

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
 800e4ac:	f106 0601 	add.w	r6, r6, #1
      fmask = 1 << cfp->filter;
 800e4b0:	fa07 f505 	lsl.w	r5, r7, r5
      if (cfp->mode)
 800e4b4:	d005      	beq.n	800e4c2 <can_lld_set_filters+0x82>
        CAN1->FM1R |= fmask;
 800e4b6:	f8d0 e204 	ldr.w	lr, [r0, #516]	; 0x204
 800e4ba:	ea45 0e0e 	orr.w	lr, r5, lr
 800e4be:	f8c0 e204 	str.w	lr, [r0, #516]	; 0x204
      if (cfp->scale)
 800e4c2:	f014 0f02 	tst.w	r4, #2
 800e4c6:	d005      	beq.n	800e4d4 <can_lld_set_filters+0x94>
        CAN1->FS1R |= fmask;
 800e4c8:	f8d0 e20c 	ldr.w	lr, [r0, #524]	; 0x20c
 800e4cc:	ea45 0e0e 	orr.w	lr, r5, lr
 800e4d0:	f8c0 e20c 	str.w	lr, [r0, #524]	; 0x20c
      if (cfp->assignment)
 800e4d4:	0764      	lsls	r4, r4, #29
 800e4d6:	d504      	bpl.n	800e4e2 <can_lld_set_filters+0xa2>
        CAN1->FFA1R |= fmask;
 800e4d8:	f8d0 4214 	ldr.w	r4, [r0, #532]	; 0x214
 800e4dc:	432c      	orrs	r4, r5
 800e4de:	f8c0 4214 	str.w	r4, [r0, #532]	; 0x214
      CAN1->sFilterRegister[cfp->filter].FR1 = cfp->register1;
 800e4e2:	6894      	ldr	r4, [r2, #8]
 800e4e4:	f8c3 4240 	str.w	r4, [r3, #576]	; 0x240
      CAN1->sFilterRegister[cfp->filter].FR2 = cfp->register2;
 800e4e8:	68d4      	ldr	r4, [r2, #12]
 800e4ea:	f8c3 4244 	str.w	r4, [r3, #580]	; 0x244
      CAN1->FA1R |= fmask;
 800e4ee:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
      CAN1->sFilterRegister[i].FR1 = 0;
      CAN1->sFilterRegister[i].FR2 = 0;
    }

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
 800e4f2:	428e      	cmp	r6, r1
        CAN1->FS1R |= fmask;
      if (cfp->assignment)
        CAN1->FFA1R |= fmask;
      CAN1->sFilterRegister[cfp->filter].FR1 = cfp->register1;
      CAN1->sFilterRegister[cfp->filter].FR2 = cfp->register2;
      CAN1->FA1R |= fmask;
 800e4f4:	ea43 0305 	orr.w	r3, r3, r5
      cfp++;
 800e4f8:	f102 0210 	add.w	r2, r2, #16
        CAN1->FS1R |= fmask;
      if (cfp->assignment)
        CAN1->FFA1R |= fmask;
      CAN1->sFilterRegister[cfp->filter].FR1 = cfp->register1;
      CAN1->sFilterRegister[cfp->filter].FR2 = cfp->register2;
      CAN1->FA1R |= fmask;
 800e4fc:	f8c0 321c 	str.w	r3, [r0, #540]	; 0x21c
      CAN1->sFilterRegister[i].FR1 = 0;
      CAN1->sFilterRegister[i].FR2 = 0;
    }

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
 800e500:	d1cb      	bne.n	800e49a <can_lld_set_filters+0x5a>
 800e502:	e018      	b.n	800e536 <can_lld_set_filters+0xf6>
 800e504:	00c2      	lsls	r2, r0, #3
 800e506:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    CAN1->sFilterRegister[can2sb].FR2 = 0;
#endif
    CAN1->FM1R = 0;
    CAN1->FFA1R = 0;
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
 800e50a:	2301      	movs	r3, #1
 800e50c:	f502 42c8 	add.w	r2, r2, #25600	; 0x6400
 800e510:	4083      	lsls	r3, r0
 800e512:	f043 0301 	orr.w	r3, r3, #1
    }
  }
  else {
    /* Setting up a single default filter that enables everything for both
       CANs.*/
    CAN1->sFilterRegister[0].FR1 = 0;
 800e516:	f8c5 1240 	str.w	r1, [r5, #576]	; 0x240
    CAN1->sFilterRegister[0].FR2 = 0;
 800e51a:	f8c5 1244 	str.w	r1, [r5, #580]	; 0x244
#if STM32_HAS_CAN2
    CAN1->sFilterRegister[can2sb].FR1 = 0;
 800e51e:	f8c2 1240 	str.w	r1, [r2, #576]	; 0x240
    CAN1->sFilterRegister[can2sb].FR2 = 0;
 800e522:	f8c2 1244 	str.w	r1, [r2, #580]	; 0x244
#endif
    CAN1->FM1R = 0;
 800e526:	f8c5 1204 	str.w	r1, [r5, #516]	; 0x204
    CAN1->FFA1R = 0;
 800e52a:	f8c5 1214 	str.w	r1, [r5, #532]	; 0x214
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
 800e52e:	f8c5 320c 	str.w	r3, [r5, #524]	; 0x20c
    CAN1->FA1R = 1 | (1 << can2sb);
 800e532:	f8c5 321c 	str.w	r3, [r5, #540]	; 0x21c
#else
    CAN1->FS1R = 1;
    CAN1->FA1R = 1;
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 800e536:	4907      	ldr	r1, [pc, #28]	; (800e554 <can_lld_set_filters+0x114>)

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  rccDisableCAN1(FALSE);
 800e538:	4a05      	ldr	r2, [pc, #20]	; (800e550 <can_lld_set_filters+0x110>)
#else
    CAN1->FS1R = 1;
    CAN1->FA1R = 1;
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 800e53a:	f8d1 3200 	ldr.w	r3, [r1, #512]	; 0x200
 800e53e:	f023 0301 	bic.w	r3, r3, #1
 800e542:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  rccDisableCAN1(FALSE);
 800e546:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800e548:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 800e54c:	6413      	str	r3, [r2, #64]	; 0x40
 800e54e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e550:	40023800 	.word	0x40023800
 800e554:	40006400 	.word	0x40006400
	...

0800e560 <Vector8C>:
/**
 * @brief   CAN1 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 800e560:	b510      	push	{r4, lr}
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {

  /* No more events until a message is transmitted.*/
  canp->can->TSR = CAN_TSR_RQCP0 | CAN_TSR_RQCP1 | CAN_TSR_RQCP2;
 800e562:	4c0a      	ldr	r4, [pc, #40]	; (800e58c <Vector8C+0x2c>)
 800e564:	4a0a      	ldr	r2, [pc, #40]	; (800e590 <Vector8C+0x30>)
 800e566:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800e568:	609a      	str	r2, [r3, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e56a:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800e56c:	2100      	movs	r1, #0
 800e56e:	f104 0008 	add.w	r0, r4, #8
 800e572:	f7fe f9cd 	bl	800c910 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800e576:	f104 001c 	add.w	r0, r4, #28
 800e57a:	2101      	movs	r1, #1
 800e57c:	f7fe faf0 	bl	800cb60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e580:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800e582:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800e586:	f7fe bc63 	b.w	800ce50 <_port_irq_epilogue>
 800e58a:	bf00      	nop
 800e58c:	20000b78 	.word	0x20000b78
 800e590:	00010101 	.word	0x00010101
	...

0800e5a0 <Vector90>:
/*
 * @brief   CAN1 RX0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 800e5a0:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
 800e5a2:	4d12      	ldr	r5, [pc, #72]	; (800e5ec <Vector90+0x4c>)
 800e5a4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e5a6:	68dc      	ldr	r4, [r3, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 800e5a8:	07a2      	lsls	r2, r4, #30
 800e5aa:	d10d      	bne.n	800e5c8 <Vector90+0x28>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(1));
    osalSysUnlockFromISR();
  }
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 800e5ac:	06e3      	lsls	r3, r4, #27
 800e5ae:	d507      	bpl.n	800e5c0 <Vector90+0x20>
    /* Overflow events handling.*/
    canp->can->RF0R = CAN_RF0R_FOVR0;
 800e5b0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e5b2:	2110      	movs	r1, #16
 800e5b4:	60d9      	str	r1, [r3, #12]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e5b6:	b672      	cpsid	i
 800e5b8:	480d      	ldr	r0, [pc, #52]	; (800e5f0 <Vector90+0x50>)
 800e5ba:	f7fe fad1 	bl	800cb60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e5be:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800e5c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800e5c4:	f7fe bc44 	b.w	800ce50 <_port_irq_epilogue>
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE0;
 800e5c8:	695a      	ldr	r2, [r3, #20]
 800e5ca:	f022 0202 	bic.w	r2, r2, #2
 800e5ce:	615a      	str	r2, [r3, #20]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e5d0:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800e5d2:	2100      	movs	r1, #0
 800e5d4:	f105 0010 	add.w	r0, r5, #16
 800e5d8:	f7fe f99a 	bl	800c910 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800e5dc:	f105 0018 	add.w	r0, r5, #24
 800e5e0:	2101      	movs	r1, #1
 800e5e2:	f7fe fabd 	bl	800cb60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e5e6:	b662      	cpsie	i
 800e5e8:	e7e0      	b.n	800e5ac <Vector90+0xc>
 800e5ea:	bf00      	nop
 800e5ec:	20000b78 	.word	0x20000b78
 800e5f0:	20000b98 	.word	0x20000b98
	...

0800e600 <Vector94>:
/**
 * @brief   CAN1 RX1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX1_HANDLER) {
 800e600:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
 800e602:	4d12      	ldr	r5, [pc, #72]	; (800e64c <Vector94+0x4c>)
 800e604:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e606:	691c      	ldr	r4, [r3, #16]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 800e608:	07a2      	lsls	r2, r4, #30
 800e60a:	d10d      	bne.n	800e628 <Vector94+0x28>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(2));
    osalSysUnlockFromISR();
  }
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 800e60c:	06e3      	lsls	r3, r4, #27
 800e60e:	d507      	bpl.n	800e620 <Vector94+0x20>
    /* Overflow events handling.*/
    canp->can->RF1R = CAN_RF1R_FOVR1;
 800e610:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e612:	2110      	movs	r1, #16
 800e614:	6119      	str	r1, [r3, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e616:	b672      	cpsid	i
 800e618:	480d      	ldr	r0, [pc, #52]	; (800e650 <Vector94+0x50>)
 800e61a:	f7fe faa1 	bl	800cb60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e61e:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800e620:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800e624:	f7fe bc14 	b.w	800ce50 <_port_irq_epilogue>
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE1;
 800e628:	695a      	ldr	r2, [r3, #20]
 800e62a:	f022 0210 	bic.w	r2, r2, #16
 800e62e:	615a      	str	r2, [r3, #20]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e630:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800e632:	2100      	movs	r1, #0
 800e634:	f105 0010 	add.w	r0, r5, #16
 800e638:	f7fe f96a 	bl	800c910 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800e63c:	f105 0018 	add.w	r0, r5, #24
 800e640:	2102      	movs	r1, #2
 800e642:	f7fe fa8d 	bl	800cb60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e646:	b662      	cpsie	i
 800e648:	e7e0      	b.n	800e60c <Vector94+0xc>
 800e64a:	bf00      	nop
 800e64c:	20000b78 	.word	0x20000b78
 800e650:	20000b98 	.word	0x20000b98
	...

0800e660 <Vector98>:
/**
 * @brief   CAN1 SCE interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_SCE_HANDLER) {
 800e660:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
static void can_lld_sce_handler(CANDriver *canp) {
  uint32_t msr;

  msr = canp->can->MSR;
 800e662:	4d17      	ldr	r5, [pc, #92]	; (800e6c0 <Vector98+0x60>)
 800e664:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e666:	685c      	ldr	r4, [r3, #4]
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
 800e668:	221c      	movs	r2, #28
 800e66a:	605a      	str	r2, [r3, #4]
  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
 800e66c:	0722      	lsls	r2, r4, #28
 800e66e:	d419      	bmi.n	800e6a4 <Vector98+0x44>
    osalEventBroadcastFlagsI(&canp->wakeup_event, 0);
    osalSysUnlockFromISR();
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 800e670:	0763      	lsls	r3, r4, #29
 800e672:	d513      	bpl.n	800e69c <Vector98+0x3c>
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;
 800e674:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800e676:	6993      	ldr	r3, [r2, #24]

    canp->can->ESR &= ~CAN_ESR_LEC;
 800e678:	6991      	ldr	r1, [r2, #24]
 800e67a:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 800e67e:	6191      	str	r1, [r2, #24]
    flags = (eventflags_t)(esr & 7);
    if ((esr & CAN_ESR_LEC) > 0)
 800e680:	f013 0f70 	tst.w	r3, #112	; 0x70
  if (msr & CAN_MSR_ERRI) {
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;

    canp->can->ESR &= ~CAN_ESR_LEC;
    flags = (eventflags_t)(esr & 7);
 800e684:	f003 0107 	and.w	r1, r3, #7
    if ((esr & CAN_ESR_LEC) > 0)
      flags |= CAN_FRAMING_ERROR;
 800e688:	bf18      	it	ne
 800e68a:	f041 0108 	orrne.w	r1, r1, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e68e:	b672      	cpsid	i
 800e690:	480c      	ldr	r0, [pc, #48]	; (800e6c4 <Vector98+0x64>)
 800e692:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800e696:	f7fe fa63 	bl	800cb60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e69a:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800e69c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800e6a0:	f7fe bbd6 	b.w	800ce50 <_port_irq_epilogue>
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800e6a4:	681a      	ldr	r2, [r3, #0]
  msr = canp->can->MSR;
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
 800e6a6:	4628      	mov	r0, r5
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800e6a8:	f022 0202 	bic.w	r2, r2, #2
  msr = canp->can->MSR;
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
 800e6ac:	2103      	movs	r1, #3
 800e6ae:	f800 1b28 	strb.w	r1, [r0], #40
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800e6b2:	601a      	str	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e6b4:	b672      	cpsid	i
 800e6b6:	2100      	movs	r1, #0
 800e6b8:	f7fe fa52 	bl	800cb60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e6bc:	b662      	cpsie	i
 800e6be:	e7d7      	b.n	800e670 <Vector98+0x10>
 800e6c0:	20000b78 	.word	0x20000b78
 800e6c4:	20000b98 	.word	0x20000b98
	...

0800e6d0 <can_lld_init>:
/**
 * @brief   Low level CAN driver initialization.
 *
 * @notapi
 */
void can_lld_init(void) {
 800e6d0:	b510      	push	{r4, lr}

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
 800e6d2:	4c06      	ldr	r4, [pc, #24]	; (800e6ec <can_lld_init+0x1c>)
 800e6d4:	4620      	mov	r0, r4
 800e6d6:	f7fe fc33 	bl	800cf40 <canObjectInit>
  CAND2.can = CAN2;
#endif

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800e6da:	2100      	movs	r1, #0
void can_lld_init(void) {

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
  CAND1.can = CAN1;
 800e6dc:	4b04      	ldr	r3, [pc, #16]	; (800e6f0 <can_lld_init+0x20>)
 800e6de:	62e3      	str	r3, [r4, #44]	; 0x2c
  CAND2.can = CAN2;
#endif

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800e6e0:	460a      	mov	r2, r1
 800e6e2:	200e      	movs	r0, #14
#else
  can_lld_set_filters(STM32_CAN_MAX_FILTERS, 0, NULL);
#endif
}
 800e6e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CAND2.can = CAN2;
#endif

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800e6e8:	f7ff beaa 	b.w	800e440 <can_lld_set_filters>
 800e6ec:	20000b78 	.word	0x20000b78
 800e6f0:	40006400 	.word	0x40006400
	...

0800e700 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 800e700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800e704:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 800e8bc <_pal_lld_init+0x1bc>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e708:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 800e8c0 <_pal_lld_init+0x1c0>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800e70c:	f8d8 a030 	ldr.w	sl, [r8, #48]	; 0x30
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e710:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 800e8c4 <_pal_lld_init+0x1c4>
 800e714:	4f63      	ldr	r7, [pc, #396]	; (800e8a4 <_pal_lld_init+0x1a4>)
 800e716:	4e64      	ldr	r6, [pc, #400]	; (800e8a8 <_pal_lld_init+0x1a8>)
 800e718:	4d64      	ldr	r5, [pc, #400]	; (800e8ac <_pal_lld_init+0x1ac>)
 800e71a:	4c65      	ldr	r4, [pc, #404]	; (800e8b0 <_pal_lld_init+0x1b0>)
 800e71c:	4965      	ldr	r1, [pc, #404]	; (800e8b4 <_pal_lld_init+0x1b4>)
 800e71e:	4a66      	ldr	r2, [pc, #408]	; (800e8b8 <_pal_lld_init+0x1b8>)
 800e720:	f8df b1a4 	ldr.w	fp, [pc, #420]	; 800e8c8 <_pal_lld_init+0x1c8>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800e724:	f240 19ff 	movw	r9, #511	; 0x1ff
 800e728:	ea4a 0a09 	orr.w	sl, sl, r9
 800e72c:	f8c8 a030 	str.w	sl, [r8, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 800e730:	f8d8 a050 	ldr.w	sl, [r8, #80]	; 0x50
 800e734:	ea4a 0909 	orr.w	r9, sl, r9
 800e738:	f8c8 9050 	str.w	r9, [r8, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e73c:	6843      	ldr	r3, [r0, #4]
 800e73e:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e742:	6883      	ldr	r3, [r0, #8]
 800e744:	f8cc 3008 	str.w	r3, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 800e748:	68c3      	ldr	r3, [r0, #12]
 800e74a:	f8cc 300c 	str.w	r3, [ip, #12]
  gpiop->ODR     = config->odr;
 800e74e:	6903      	ldr	r3, [r0, #16]
 800e750:	f8cc 3014 	str.w	r3, [ip, #20]
  gpiop->AFRL    = config->afrl;
 800e754:	6943      	ldr	r3, [r0, #20]
 800e756:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 800e75a:	6983      	ldr	r3, [r0, #24]
 800e75c:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e760:	6803      	ldr	r3, [r0, #0]
 800e762:	f8cc 3000 	str.w	r3, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e766:	6a03      	ldr	r3, [r0, #32]
 800e768:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e76c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800e76e:	f8ce 3008 	str.w	r3, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 800e772:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800e774:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 800e778:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800e77a:	f8ce 3014 	str.w	r3, [lr, #20]
  gpiop->AFRL    = config->afrl;
 800e77e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800e780:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 800e784:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e786:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e78a:	69c3      	ldr	r3, [r0, #28]
 800e78c:	f8ce 3000 	str.w	r3, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e790:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800e792:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e794:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800e796:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 800e798:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800e79a:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 800e79c:	6c83      	ldr	r3, [r0, #72]	; 0x48
 800e79e:	617b      	str	r3, [r7, #20]
  gpiop->AFRL    = config->afrl;
 800e7a0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800e7a2:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 800e7a4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800e7a6:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e7a8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800e7aa:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e7ac:	6d87      	ldr	r7, [r0, #88]	; 0x58
 800e7ae:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e7b0:	6dc7      	ldr	r7, [r0, #92]	; 0x5c
 800e7b2:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 800e7b4:	6e07      	ldr	r7, [r0, #96]	; 0x60
 800e7b6:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 800e7b8:	6e47      	ldr	r7, [r0, #100]	; 0x64
 800e7ba:	6177      	str	r7, [r6, #20]
  gpiop->AFRL    = config->afrl;
 800e7bc:	6e87      	ldr	r7, [r0, #104]	; 0x68
 800e7be:	6237      	str	r7, [r6, #32]
  gpiop->AFRH    = config->afrh;
 800e7c0:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
 800e7c2:	6277      	str	r7, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e7c4:	6d47      	ldr	r7, [r0, #84]	; 0x54
 800e7c6:	6037      	str	r7, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e7c8:	6f46      	ldr	r6, [r0, #116]	; 0x74
 800e7ca:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e7cc:	6f86      	ldr	r6, [r0, #120]	; 0x78
 800e7ce:	60ae      	str	r6, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 800e7d0:	6fc6      	ldr	r6, [r0, #124]	; 0x7c
 800e7d2:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
 800e7d4:	f8d0 6080 	ldr.w	r6, [r0, #128]	; 0x80
 800e7d8:	616e      	str	r6, [r5, #20]
  gpiop->AFRL    = config->afrl;
 800e7da:	f8d0 6084 	ldr.w	r6, [r0, #132]	; 0x84
 800e7de:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 800e7e0:	f8d0 6088 	ldr.w	r6, [r0, #136]	; 0x88
 800e7e4:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e7e6:	6f06      	ldr	r6, [r0, #112]	; 0x70
 800e7e8:	602e      	str	r6, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e7ea:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
 800e7ee:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e7f0:	f8d0 5094 	ldr.w	r5, [r0, #148]	; 0x94
 800e7f4:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 800e7f6:	f8d0 5098 	ldr.w	r5, [r0, #152]	; 0x98
 800e7fa:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 800e7fc:	f8d0 509c 	ldr.w	r5, [r0, #156]	; 0x9c
 800e800:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 800e802:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 800e806:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 800e808:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4
 800e80c:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e80e:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
 800e812:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e814:	f8d0 40ac 	ldr.w	r4, [r0, #172]	; 0xac
 800e818:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e81a:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 800e81e:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 800e820:	f8d0 40b4 	ldr.w	r4, [r0, #180]	; 0xb4
 800e824:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 800e826:	f8d0 40b8 	ldr.w	r4, [r0, #184]	; 0xb8
 800e82a:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800e82c:	f8d0 40bc 	ldr.w	r4, [r0, #188]	; 0xbc
 800e830:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800e832:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
 800e836:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e838:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 800e83c:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e83e:	f8d0 10c8 	ldr.w	r1, [r0, #200]	; 0xc8
 800e842:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e844:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
 800e848:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800e84a:	f8d0 10d0 	ldr.w	r1, [r0, #208]	; 0xd0
 800e84e:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 800e850:	f8d0 10d4 	ldr.w	r1, [r0, #212]	; 0xd4
 800e854:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800e856:	f8d0 10d8 	ldr.w	r1, [r0, #216]	; 0xd8
 800e85a:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 800e85c:	f8d0 10dc 	ldr.w	r1, [r0, #220]	; 0xdc
 800e860:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e862:	f8d0 10c4 	ldr.w	r1, [r0, #196]	; 0xc4
 800e866:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800e868:	f8d0 20e4 	ldr.w	r2, [r0, #228]	; 0xe4
 800e86c:	f8cb 2004 	str.w	r2, [fp, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e870:	f8d0 20e8 	ldr.w	r2, [r0, #232]	; 0xe8
 800e874:	f8cb 2008 	str.w	r2, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
 800e878:	f8d0 20ec 	ldr.w	r2, [r0, #236]	; 0xec
 800e87c:	f8cb 200c 	str.w	r2, [fp, #12]
  gpiop->ODR     = config->odr;
 800e880:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 800e884:	f8cb 2014 	str.w	r2, [fp, #20]
  gpiop->AFRL    = config->afrl;
 800e888:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 800e88c:	f8cb 2020 	str.w	r2, [fp, #32]
  gpiop->AFRH    = config->afrh;
 800e890:	f8d0 20f8 	ldr.w	r2, [r0, #248]	; 0xf8
 800e894:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800e898:	f8d0 20e0 	ldr.w	r2, [r0, #224]	; 0xe0
 800e89c:	f8cb 2000 	str.w	r2, [fp]
 800e8a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e8a4:	40020800 	.word	0x40020800
 800e8a8:	40020c00 	.word	0x40020c00
 800e8ac:	40021000 	.word	0x40021000
 800e8b0:	40021400 	.word	0x40021400
 800e8b4:	40021800 	.word	0x40021800
 800e8b8:	40021c00 	.word	0x40021c00
 800e8bc:	40023800 	.word	0x40023800
 800e8c0:	40020000 	.word	0x40020000
 800e8c4:	40020400 	.word	0x40020400
 800e8c8:	40022000 	.word	0x40022000
 800e8cc:	00000000 	.word	0x00000000

0800e8d0 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 800e8d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
 800e8d4:	f04f 0c0f 	mov.w	ip, #15
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800e8d8:	f002 0e03 	and.w	lr, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800e8dc:	f3c2 0780 	ubfx	r7, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800e8e0:	f3c2 06c1 	ubfx	r6, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 800e8e4:	f3c2 1541 	ubfx	r5, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 800e8e8:	2400      	movs	r4, #0

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800e8ea:	f3c2 12c3 	ubfx	r2, r2, #7, #4
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 800e8ee:	f04f 0901 	mov.w	r9, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800e8f2:	f04f 0803 	mov.w	r8, #3
 800e8f6:	e02b      	b.n	800e950 <_pal_lld_setgroupmode+0x80>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 800e8f8:	f8d0 b020 	ldr.w	fp, [r0, #32]
 800e8fc:	ea2b 0303 	bic.w	r3, fp, r3
 800e900:	ea43 030a 	orr.w	r3, r3, sl
 800e904:	6203      	str	r3, [r0, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800e906:	6843      	ldr	r3, [r0, #4]
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 800e908:	fa09 fa04 	lsl.w	sl, r9, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800e90c:	ea23 030a 	bic.w	r3, r3, sl
 800e910:	433b      	orrs	r3, r7
 800e912:	6043      	str	r3, [r0, #4]
 800e914:	ea4f 0a44 	mov.w	sl, r4, lsl #1
      m2 = 3 << (bit * 2);
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800e918:	6883      	ldr	r3, [r0, #8]
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800e91a:	fa08 fa0a 	lsl.w	sl, r8, sl
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800e91e:	ea6f 0a0a 	mvn.w	sl, sl
 800e922:	ea0a 0303 	and.w	r3, sl, r3
 800e926:	4333      	orrs	r3, r6
 800e928:	6083      	str	r3, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800e92a:	68c3      	ldr	r3, [r0, #12]
 800e92c:	ea0a 0303 	and.w	r3, sl, r3
 800e930:	432b      	orrs	r3, r5
 800e932:	60c3      	str	r3, [r0, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 800e934:	6803      	ldr	r3, [r0, #0]
 800e936:	ea0a 0303 	and.w	r3, sl, r3
 800e93a:	ea43 030e 	orr.w	r3, r3, lr
 800e93e:	6003      	str	r3, [r0, #0]
    }
    mask >>= 1;
    if (!mask)
 800e940:	0849      	lsrs	r1, r1, #1
 800e942:	d019      	beq.n	800e978 <_pal_lld_setgroupmode+0xa8>
      return;
    otyper <<= 1;
 800e944:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
 800e946:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 800e948:	00ad      	lsls	r5, r5, #2
    moder <<= 2;
 800e94a:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    bit++;
 800e94e:	3401      	adds	r4, #1
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800e950:	f004 0307 	and.w	r3, r4, #7
 800e954:	009b      	lsls	r3, r3, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 800e956:	f011 0f01 	tst.w	r1, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800e95a:	fa02 fa03 	lsl.w	sl, r2, r3
      m4 = 15 << ((bit & 7) * 4);
 800e95e:	fa0c f303 	lsl.w	r3, ip, r3
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 800e962:	d0ed      	beq.n	800e940 <_pal_lld_setgroupmode+0x70>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
 800e964:	2c07      	cmp	r4, #7
 800e966:	d9c7      	bls.n	800e8f8 <_pal_lld_setgroupmode+0x28>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 800e968:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 800e96c:	ea2b 0303 	bic.w	r3, fp, r3
 800e970:	ea43 030a 	orr.w	r3, r3, sl
 800e974:	6243      	str	r3, [r0, #36]	; 0x24
 800e976:	e7c6      	b.n	800e906 <_pal_lld_setgroupmode+0x36>
 800e978:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e97c:	0000      	movs	r0, r0
	...

0800e980 <i2c_lld_serve_event_interrupt>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
 800e980:	b538      	push	{r3, r4, r5, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 800e982:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800e984:	4a38      	ldr	r2, [pc, #224]	; (800ea68 <i2c_lld_serve_event_interrupt+0xe8>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 800e986:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 800e988:	6965      	ldr	r5, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800e98a:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 800e98e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800e992:	4293      	cmp	r3, r2
 800e994:	d04b      	beq.n	800ea2e <i2c_lld_serve_event_interrupt+0xae>
 800e996:	d81b      	bhi.n	800e9d0 <i2c_lld_serve_event_interrupt+0x50>
 800e998:	3a07      	subs	r2, #7
 800e99a:	4293      	cmp	r3, r2
 800e99c:	d03b      	beq.n	800ea16 <i2c_lld_serve_event_interrupt+0x96>
 800e99e:	3201      	adds	r2, #1
 800e9a0:	4293      	cmp	r3, r2
 800e9a2:	d110      	bne.n	800e9c6 <i2c_lld_serve_event_interrupt+0x46>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800e9a4:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 800e9a6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800e9a8:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 800e9ac:	681b      	ldr	r3, [r3, #0]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800e9ae:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 800e9b0:	681a      	ldr	r2, [r3, #0]
 800e9b2:	f042 0201 	orr.w	r2, r2, #1
 800e9b6:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 800e9b8:	6862      	ldr	r2, [r4, #4]
 800e9ba:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800e9be:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 800e9c0:	685b      	ldr	r3, [r3, #4]
 800e9c2:	2b01      	cmp	r3, #1
 800e9c4:	d94a      	bls.n	800ea5c <i2c_lld_serve_event_interrupt+0xdc>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 800e9c6:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 800e9ca:	bf18      	it	ne
 800e9cc:	69a3      	ldrne	r3, [r4, #24]
 800e9ce:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800e9d0:	4a26      	ldr	r2, [pc, #152]	; (800ea6c <i2c_lld_serve_event_interrupt+0xec>)
 800e9d2:	4293      	cmp	r3, r2
 800e9d4:	d010      	beq.n	800e9f8 <i2c_lld_serve_event_interrupt+0x78>
 800e9d6:	3202      	adds	r2, #2
 800e9d8:	4293      	cmp	r3, r2
 800e9da:	d1f4      	bne.n	800e9c6 <i2c_lld_serve_event_interrupt+0x46>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 800e9dc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800e9de:	681b      	ldr	r3, [r3, #0]
 800e9e0:	6859      	ldr	r1, [r3, #4]
 800e9e2:	2900      	cmp	r1, #0
 800e9e4:	d02c      	beq.n	800ea40 <i2c_lld_serve_event_interrupt+0xc0>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800e9e6:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800e9e8:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800e9ea:	f042 0201 	orr.w	r2, r2, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800e9ee:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800e9f2:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800e9f4:	6023      	str	r3, [r4, #0]
      return;
 800e9f6:	bd38      	pop	{r3, r4, r5, pc}
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800e9f8:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800e9fa:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800e9fc:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 800ea00:	6812      	ldr	r2, [r2, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800ea02:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800ea04:	6813      	ldr	r3, [r2, #0]
 800ea06:	f043 0301 	orr.w	r3, r3, #1
 800ea0a:	6013      	str	r3, [r2, #0]
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 800ea0c:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 800ea10:	bf18      	it	ne
 800ea12:	69a3      	ldrne	r3, [r4, #24]
 800ea14:	bd38      	pop	{r3, r4, r5, pc}
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 800ea16:	8c03      	ldrh	r3, [r0, #32]
 800ea18:	0a1a      	lsrs	r2, r3, #8
 800ea1a:	d00b      	beq.n	800ea34 <i2c_lld_serve_event_interrupt+0xb4>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 800ea1c:	f003 0301 	and.w	r3, r3, #1
 800ea20:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 800ea24:	f002 0206 	and.w	r2, r2, #6
 800ea28:	4313      	orrs	r3, r2
 800ea2a:	6123      	str	r3, [r4, #16]
 800ea2c:	e7cb      	b.n	800e9c6 <i2c_lld_serve_event_interrupt+0x46>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 800ea2e:	8c03      	ldrh	r3, [r0, #32]
 800ea30:	f3c3 0347 	ubfx	r3, r3, #1, #8
 800ea34:	6123      	str	r3, [r4, #16]
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 800ea36:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 800ea3a:	bf18      	it	ne
 800ea3c:	69a3      	ldrne	r3, [r4, #24]
 800ea3e:	bd38      	pop	{r3, r4, r5, pc}
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800ea40:	6863      	ldr	r3, [r4, #4]
 800ea42:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800ea46:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 800ea48:	6823      	ldr	r3, [r4, #0]
 800ea4a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800ea4e:	6023      	str	r3, [r4, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ea50:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800ea52:	301c      	adds	r0, #28
 800ea54:	f7fd ff34 	bl	800c8c0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ea58:	b662      	cpsie	i
 800ea5a:	e7b4      	b.n	800e9c6 <i2c_lld_serve_event_interrupt+0x46>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 800ea5c:	6823      	ldr	r3, [r4, #0]
 800ea5e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800ea62:	6023      	str	r3, [r4, #0]
 800ea64:	e7af      	b.n	800e9c6 <i2c_lld_serve_event_interrupt+0x46>
 800ea66:	bf00      	nop
 800ea68:	00030008 	.word	0x00030008
 800ea6c:	00070082 	.word	0x00070082

0800ea70 <i2c_lld_serve_error_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in]  sr       content of the SR1 register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {
 800ea70:	b570      	push	{r4, r5, r6, lr}

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800ea72:	6b05      	ldr	r5, [r0, #48]	; 0x30
 800ea74:	682a      	ldr	r2, [r5, #0]
 800ea76:	6813      	ldr	r3, [r2, #0]
 800ea78:	f023 031f 	bic.w	r3, r3, #31
 800ea7c:	6013      	str	r3, [r2, #0]
 800ea7e:	6813      	ldr	r3, [r2, #0]
 800ea80:	07de      	lsls	r6, r3, #31
 800ea82:	d4fc      	bmi.n	800ea7e <i2c_lld_serve_error_interrupt+0xe>
 800ea84:	7a2e      	ldrb	r6, [r5, #8]
  dmaStreamDisable(i2cp->dmarx);
 800ea86:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800ea88:	686d      	ldr	r5, [r5, #4]
  dmaStreamDisable(i2cp->dmarx);
 800ea8a:	6822      	ldr	r2, [r4, #0]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800ea8c:	233d      	movs	r3, #61	; 0x3d
 800ea8e:	40b3      	lsls	r3, r6
 800ea90:	602b      	str	r3, [r5, #0]
  dmaStreamDisable(i2cp->dmarx);
 800ea92:	6813      	ldr	r3, [r2, #0]
 800ea94:	f023 031f 	bic.w	r3, r3, #31
 800ea98:	6013      	str	r3, [r2, #0]
 800ea9a:	6813      	ldr	r3, [r2, #0]
 800ea9c:	f013 0301 	ands.w	r3, r3, #1
 800eaa0:	d1fb      	bne.n	800ea9a <i2c_lld_serve_error_interrupt+0x2a>
 800eaa2:	7a25      	ldrb	r5, [r4, #8]
 800eaa4:	6864      	ldr	r4, [r4, #4]
 800eaa6:	223d      	movs	r2, #61	; 0x3d
 800eaa8:	40aa      	lsls	r2, r5

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 800eaaa:	05cd      	lsls	r5, r1, #23
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 800eaac:	6022      	str	r2, [r4, #0]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 800eaae:	bf48      	it	mi
 800eab0:	2301      	movmi	r3, #1

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 800eab2:	058c      	lsls	r4, r1, #22
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 800eab4:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;
 800eab6:	bf44      	itt	mi
 800eab8:	f043 0302 	orrmi.w	r3, r3, #2
 800eabc:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 800eabe:	054a      	lsls	r2, r1, #21
 800eac0:	d50b      	bpl.n	800eada <i2c_lld_serve_error_interrupt+0x6a>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800eac2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800eac4:	6854      	ldr	r4, [r2, #4]
 800eac6:	f424 7400 	bic.w	r4, r4, #512	; 0x200
 800eaca:	6054      	str	r4, [r2, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800eacc:	6814      	ldr	r4, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 800eace:	f043 0304 	orr.w	r3, r3, #4
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800ead2:	f444 7400 	orr.w	r4, r4, #512	; 0x200
 800ead6:	6014      	str	r4, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 800ead8:	6083      	str	r3, [r0, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 800eada:	050e      	lsls	r6, r1, #20
    i2cp->errors |= I2C_OVERRUN;
 800eadc:	bf44      	itt	mi
 800eade:	f043 0308 	orrmi.w	r3, r3, #8
 800eae2:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 800eae4:	044d      	lsls	r5, r1, #17
    i2cp->errors |= I2C_TIMEOUT;
 800eae6:	bf44      	itt	mi
 800eae8:	f043 0320 	orrmi.w	r3, r3, #32
 800eaec:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 800eaee:	04cc      	lsls	r4, r1, #19
 800eaf0:	d50c      	bpl.n	800eb0c <i2c_lld_serve_error_interrupt+0x9c>
    i2cp->errors |= I2C_PEC_ERROR;
 800eaf2:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800eaf6:	0409      	lsls	r1, r1, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 800eaf8:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800eafa:	d40c      	bmi.n	800eb16 <i2c_lld_serve_error_interrupt+0xa6>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800eafc:	b672      	cpsid	i
 800eafe:	f06f 0101 	mvn.w	r1, #1
 800eb02:	301c      	adds	r0, #28
 800eb04:	f7fd fedc 	bl	800c8c0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800eb08:	b662      	cpsie	i
 800eb0a:	bd70      	pop	{r4, r5, r6, pc}
 800eb0c:	040a      	lsls	r2, r1, #16
 800eb0e:	d402      	bmi.n	800eb16 <i2c_lld_serve_error_interrupt+0xa6>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 800eb10:	2b00      	cmp	r3, #0
 800eb12:	d1f3      	bne.n	800eafc <i2c_lld_serve_error_interrupt+0x8c>
 800eb14:	bd70      	pop	{r4, r5, r6, pc}

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 800eb16:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800eb1a:	6083      	str	r3, [r0, #8]
 800eb1c:	e7ee      	b.n	800eafc <i2c_lld_serve_error_interrupt+0x8c>
 800eb1e:	bf00      	nop

0800eb20 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 800eb20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);
 800eb22:	4803      	ldr	r0, [pc, #12]	; (800eb30 <VectorBC+0x10>)
 800eb24:	f7ff ff2c 	bl	800e980 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 800eb28:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 800eb2c:	f7fe b990 	b.w	800ce50 <_port_irq_epilogue>
 800eb30:	20000ba8 	.word	0x20000ba8
	...

0800eb40 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 800eb40:	4807      	ldr	r0, [pc, #28]	; (800eb60 <VectorC0+0x20>)
 800eb42:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800eb44:	6951      	ldr	r1, [r2, #20]
}

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 800eb46:	b508      	push	{r3, lr}
 800eb48:	b289      	uxth	r1, r1
  uint16_t sr = I2CD1.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 800eb4a:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 800eb4e:	43db      	mvns	r3, r3
 800eb50:	6153      	str	r3, [r2, #20]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);
 800eb52:	f7ff ff8d 	bl	800ea70 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 800eb56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 800eb5a:	f7fe b979 	b.w	800ce50 <_port_irq_epilogue>
 800eb5e:	bf00      	nop
 800eb60:	20000ba8 	.word	0x20000ba8
	...

0800eb70 <VectorC4>:
/**
 * @brief   I2C2 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {
 800eb70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);
 800eb72:	4803      	ldr	r0, [pc, #12]	; (800eb80 <VectorC4+0x10>)
 800eb74:	f7ff ff04 	bl	800e980 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 800eb78:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 800eb7c:	f7fe b968 	b.w	800ce50 <_port_irq_epilogue>
 800eb80:	20000be0 	.word	0x20000be0
	...

0800eb90 <VectorC8>:
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 800eb90:	4807      	ldr	r0, [pc, #28]	; (800ebb0 <VectorC8+0x20>)
 800eb92:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800eb94:	6951      	ldr	r1, [r2, #20]
/**
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
 800eb96:	b508      	push	{r3, lr}
 800eb98:	b289      	uxth	r1, r1
  uint16_t sr = I2CD2.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 800eb9a:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 800eb9e:	43db      	mvns	r3, r3
 800eba0:	6153      	str	r3, [r2, #20]
  i2c_lld_serve_error_interrupt(&I2CD2, sr);
 800eba2:	f7ff ff65 	bl	800ea70 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 800eba6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 800ebaa:	f7fe b951 	b.w	800ce50 <_port_irq_epilogue>
 800ebae:	bf00      	nop
 800ebb0:	20000be0 	.word	0x20000be0
	...

0800ebc0 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 800ebc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 800ebc2:	4e0d      	ldr	r6, [pc, #52]	; (800ebf8 <i2c_lld_init+0x38>)
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 800ebc4:	4d0d      	ldr	r5, [pc, #52]	; (800ebfc <i2c_lld_init+0x3c>)

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800ebc6:	4c0e      	ldr	r4, [pc, #56]	; (800ec00 <i2c_lld_init+0x40>)
 * @notapi
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 800ebc8:	4630      	mov	r0, r6
 800ebca:	f7fe fa19 	bl	800d000 <i2cObjectInit>
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 800ebce:	4b0d      	ldr	r3, [pc, #52]	; (800ec04 <i2c_lld_init+0x44>)
 800ebd0:	6373      	str	r3, [r6, #52]	; 0x34
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 800ebd2:	2700      	movs	r7, #0
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 800ebd4:	f104 0348 	add.w	r3, r4, #72	; 0x48
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 800ebd8:	4628      	mov	r0, r5

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800ebda:	62f4      	str	r4, [r6, #44]	; 0x2c
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 800ebdc:	6333      	str	r3, [r6, #48]	; 0x30
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 800ebde:	61f7      	str	r7, [r6, #28]
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 800ebe0:	f7fe fa0e 	bl	800d000 <i2cObjectInit>
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 800ebe4:	f104 0318 	add.w	r3, r4, #24
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 800ebe8:	4a07      	ldr	r2, [pc, #28]	; (800ec08 <i2c_lld_init+0x48>)
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 800ebea:	61ef      	str	r7, [r5, #28]
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 800ebec:	3454      	adds	r4, #84	; 0x54
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 800ebee:	636a      	str	r2, [r5, #52]	; 0x34
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 800ebf0:	62eb      	str	r3, [r5, #44]	; 0x2c
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 800ebf2:	632c      	str	r4, [r5, #48]	; 0x30
 800ebf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ebf6:	bf00      	nop
 800ebf8:	20000ba8 	.word	0x20000ba8
 800ebfc:	20000be0 	.word	0x20000be0
 800ec00:	08010b90 	.word	0x08010b90
 800ec04:	40005400 	.word	0x40005400
 800ec08:	40005800 	.word	0x40005800
 800ec0c:	00000000 	.word	0x00000000

0800ec10 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 800ec10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 800ec14:	4ba7      	ldr	r3, [pc, #668]	; (800eeb4 <usb_lld_pump+0x2a4>)
 800ec16:	4aa8      	ldr	r2, [pc, #672]	; (800eeb8 <usb_lld_pump+0x2a8>)
 800ec18:	699b      	ldr	r3, [r3, #24]
  USBDriver *usbp = (USBDriver *)p;
  stm32_otg_t *otgp = usbp->otg;
 800ec1a:	f8d0 a050 	ldr.w	sl, [r0, #80]	; 0x50
 800ec1e:	619a      	str	r2, [r3, #24]
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 800ec20:	b085      	sub	sp, #20
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ec22:	b672      	cpsid	i
 800ec24:	f100 0360 	add.w	r3, r0, #96	; 0x60
 800ec28:	46d3      	mov	fp, sl
 800ec2a:	9303      	str	r3, [sp, #12]
 800ec2c:	4682      	mov	sl, r0
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 800ec2e:	f89a 3000 	ldrb.w	r3, [sl]
 800ec32:	2b01      	cmp	r3, #1
 800ec34:	d006      	beq.n	800ec44 <usb_lld_pump+0x34>
 800ec36:	f8da 305c 	ldr.w	r3, [sl, #92]	; 0x5c
 800ec3a:	b963      	cbnz	r3, 800ec56 <usb_lld_pump+0x46>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 800ec3c:	f8db 3014 	ldr.w	r3, [fp, #20]
 800ec40:	06da      	lsls	r2, r3, #27
 800ec42:	d408      	bmi.n	800ec56 <usb_lld_pump+0x46>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 800ec44:	f8db 3018 	ldr.w	r3, [fp, #24]
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 800ec48:	9803      	ldr	r0, [sp, #12]
 800ec4a:	f043 0310 	orr.w	r3, r3, #16
 800ec4e:	f8cb 3018 	str.w	r3, [fp, #24]
 800ec52:	f7fd fe25 	bl	800c8a0 <chThdSuspendS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ec56:	b662      	cpsie	i
 800ec58:	f04f 0800 	mov.w	r8, #0

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 800ec5c:	f8db 3014 	ldr.w	r3, [fp, #20]
 800ec60:	06db      	lsls	r3, r3, #27
 800ec62:	d523      	bpl.n	800ecac <usb_lld_pump+0x9c>
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 800ec64:	f8da 2050 	ldr.w	r2, [sl, #80]	; 0x50
 800ec68:	6a13      	ldr	r3, [r2, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800ec6a:	f403 11f0 	and.w	r1, r3, #1966080	; 0x1e0000
 800ec6e:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 800ec72:	d02e      	beq.n	800ecd2 <usb_lld_pump+0xc2>
 800ec74:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 800ec78:	d1f0      	bne.n	800ec5c <usb_lld_pump+0x4c>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800ec7a:	f003 010f 	and.w	r1, r3, #15
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800ec7e:	eb0a 0181 	add.w	r1, sl, r1, lsl #2
  sts = usbp->otg->GRXSTSP;
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 800ec82:	f3c3 130a 	ubfx	r3, r3, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800ec86:	68c9      	ldr	r1, [r1, #12]
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 800ec88:	3303      	adds	r3, #3
  max = (max + 3) / 4;
  while (n) {
 800ec8a:	089b      	lsrs	r3, r3, #2
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800ec8c:	6a0c      	ldr	r4, [r1, #32]
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 800ec8e:	d0e5      	beq.n	800ec5c <usb_lld_pump+0x4c>
 800ec90:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 800ec94:	2102      	movs	r1, #2
    uint32_t w = *fifop;
 800ec96:	6810      	ldr	r0, [r2, #0]
    if (max) {
 800ec98:	b111      	cbz	r1, 800eca0 <usb_lld_pump+0x90>
      /* Note, this line relies on the Cortex-M3/M4 ability to perform
         unaligned word accesses and on the LSB-first memory organization.*/
      *((PACKED_VAR uint32_t *)buf) = w;
 800ec9a:	f844 0b04 	str.w	r0, [r4], #4
      buf += 4;
      max--;
 800ec9e:	3901      	subs	r1, #1
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 800eca0:	3b01      	subs	r3, #1
 800eca2:	d1f8      	bne.n	800ec96 <usb_lld_pump+0x86>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 800eca4:	f8db 3014 	ldr.w	r3, [fp, #20]
 800eca8:	06db      	lsls	r3, r3, #27
 800ecaa:	d4db      	bmi.n	800ec64 <usb_lld_pump+0x54>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 800ecac:	2201      	movs	r2, #1
      if (usbp->txpending & epmask) {
 800ecae:	f8da 305c 	ldr.w	r3, [sl, #92]	; 0x5c
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 800ecb2:	fa02 f208 	lsl.w	r2, r2, r8
      if (usbp->txpending & epmask) {
 800ecb6:	421a      	tst	r2, r3
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 800ecb8:	9201      	str	r2, [sp, #4]
      if (usbp->txpending & epmask) {
 800ecba:	d162      	bne.n	800ed82 <usb_lld_pump+0x172>
 800ecbc:	f108 0801 	add.w	r8, r8, #1
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800ecc0:	f8da 3054 	ldr.w	r3, [sl, #84]	; 0x54
 800ecc4:	689b      	ldr	r3, [r3, #8]
 800ecc6:	fa5f f888 	uxtb.w	r8, r8
 800ecca:	4598      	cmp	r8, r3
 800eccc:	d9c6      	bls.n	800ec5c <usb_lld_pump+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ecce:	b672      	cpsid	i
 800ecd0:	e7ad      	b.n	800ec2e <usb_lld_pump+0x1e>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800ecd2:	f003 050f 	and.w	r5, r3, #15
 800ecd6:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 800ecda:	f3c3 140a 	ubfx	r4, r3, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    if (usbp->epc[ep]->out_state->rxqueued) {
 800ecde:	68eb      	ldr	r3, [r5, #12]
 800ece0:	6998      	ldr	r0, [r3, #24]
 800ece2:	7803      	ldrb	r3, [r0, #0]
 800ece4:	b9db      	cbnz	r3, 800ed1e <usb_lld_pump+0x10e>
 800ece6:	6843      	ldr	r3, [r0, #4]
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 800ece8:	6881      	ldr	r1, [r0, #8]
      otg_fifo_read_to_queue(usbp->otg->FIFO[0],
                             usbp->epc[ep]->out_state->mode.queue.rxqueue,
                             cnt);
    }
    else {
      otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800ecea:	68c6      	ldr	r6, [r0, #12]
 800ecec:	3303      	adds	r3, #3
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 800ecee:	1a59      	subs	r1, r3, r1
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 800ecf0:	1ce3      	adds	r3, r4, #3
  max = (max + 3) / 4;
  while (n) {
 800ecf2:	089b      	lsrs	r3, r3, #2
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 800ecf4:	ea4f 0191 	mov.w	r1, r1, lsr #2
  while (n) {
 800ecf8:	d009      	beq.n	800ed0e <usb_lld_pump+0xfe>
 800ecfa:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 800ecfe:	46b6      	mov	lr, r6
    uint32_t w = *fifop;
 800ed00:	6817      	ldr	r7, [r2, #0]
    if (max) {
 800ed02:	b111      	cbz	r1, 800ed0a <usb_lld_pump+0xfa>
      /* Note, this line relies on the Cortex-M3/M4 ability to perform
         unaligned word accesses and on the LSB-first memory organization.*/
      *((PACKED_VAR uint32_t *)buf) = w;
 800ed04:	f84e 7b04 	str.w	r7, [lr], #4
      buf += 4;
      max--;
 800ed08:	3901      	subs	r1, #1
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 800ed0a:	3b01      	subs	r3, #1
 800ed0c:	d1f8      	bne.n	800ed00 <usb_lld_pump+0xf0>
      otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                              usbp->epc[ep]->out_state->mode.linear.rxbuf,
                              cnt,
                              usbp->epc[ep]->out_state->rxsize -
                              usbp->epc[ep]->out_state->rxcnt);
      usbp->epc[ep]->out_state->mode.linear.rxbuf += cnt;
 800ed0e:	4426      	add	r6, r4
 800ed10:	60c6      	str	r6, [r0, #12]
    }
    usbp->epc[ep]->out_state->rxcnt += cnt;
 800ed12:	68eb      	ldr	r3, [r5, #12]
 800ed14:	699a      	ldr	r2, [r3, #24]
 800ed16:	6893      	ldr	r3, [r2, #8]
 800ed18:	4423      	add	r3, r4
 800ed1a:	6093      	str	r3, [r2, #8]
 800ed1c:	e79e      	b.n	800ec5c <usb_lld_pump+0x4c>
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    if (usbp->epc[ep]->out_state->rxqueued) {
      /* Queue associated.*/
      otg_fifo_read_to_queue(usbp->otg->FIFO[0],
 800ed1e:	68c0      	ldr	r0, [r0, #12]
                                   input_queue_t *iqp,
                                   size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 800ed20:	b324      	cbz	r4, 800ed6c <usb_lld_pump+0x15c>
 800ed22:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 800ed26:	4626      	mov	r6, r4
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 800ed28:	2e03      	cmp	r6, #3
      size_t streak;
      uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
 800ed2a:	6941      	ldr	r1, [r0, #20]
  ntogo = n;
  while (ntogo > 0) {
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 800ed2c:	d907      	bls.n	800ed3e <usb_lld_pump+0x12e>
      size_t streak;
      uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
      if (iqp->q_wrptr >= iqp->q_top) {
 800ed2e:	6903      	ldr	r3, [r0, #16]
 800ed30:	4299      	cmp	r1, r3
 800ed32:	d304      	bcc.n	800ed3e <usb_lld_pump+0x12e>
        iqp->q_wrptr = iqp->q_buffer;
 800ed34:	68c3      	ldr	r3, [r0, #12]
 800ed36:	6143      	str	r3, [r0, #20]
  ntogo = n;
  while (ntogo > 0) {
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 800ed38:	2e03      	cmp	r6, #3
      size_t streak;
      uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
 800ed3a:	6941      	ldr	r1, [r0, #20]
  ntogo = n;
  while (ntogo > 0) {
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 800ed3c:	d8f7      	bhi.n	800ed2e <usb_lld_pump+0x11e>
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
      break;

    /* One byte at time.*/
    w = *fifop;
 800ed3e:	f8d2 e000 	ldr.w	lr, [r2]
 800ed42:	2700      	movs	r7, #0
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      *iqp->q_wrptr++ = (uint8_t)(w >> (i * 8));
 800ed44:	f101 0c01 	add.w	ip, r1, #1
 800ed48:	fa2e f307 	lsr.w	r3, lr, r7
 800ed4c:	f8c0 c014 	str.w	ip, [r0, #20]
 800ed50:	700b      	strb	r3, [r1, #0]
      if (iqp->q_wrptr >= iqp->q_top)
 800ed52:	6903      	ldr	r3, [r0, #16]
 800ed54:	6941      	ldr	r1, [r0, #20]
 800ed56:	4299      	cmp	r1, r3
        iqp->q_wrptr = iqp->q_buffer;
 800ed58:	bf24      	itt	cs
 800ed5a:	68c3      	ldrcs	r3, [r0, #12]
 800ed5c:	6143      	strcs	r3, [r0, #20]
      break;

    /* One byte at time.*/
    w = *fifop;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 800ed5e:	3e01      	subs	r6, #1
 800ed60:	d004      	beq.n	800ed6c <usb_lld_pump+0x15c>
 800ed62:	2f18      	cmp	r7, #24
 800ed64:	d0e0      	beq.n	800ed28 <usb_lld_pump+0x118>
 800ed66:	3708      	adds	r7, #8
 800ed68:	6941      	ldr	r1, [r0, #20]
 800ed6a:	e7eb      	b.n	800ed44 <usb_lld_pump+0x134>
 800ed6c:	b672      	cpsid	i
    }
  }

  /* Updating queue.*/
  osalSysLock();
  iqp->q_counter += n;
 800ed6e:	6883      	ldr	r3, [r0, #8]
 800ed70:	4423      	add	r3, r4
 800ed72:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800ed74:	2100      	movs	r1, #0
 800ed76:	f7fd fdcb 	bl	800c910 <chThdDequeueAllI>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 800ed7a:	f7fd fca1 	bl	800c6c0 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ed7e:	b662      	cpsie	i
 800ed80:	e7c7      	b.n	800ed12 <usb_lld_pump+0x102>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ed82:	b672      	cpsid	i
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 800ed84:	f8db 2008 	ldr.w	r2, [fp, #8]
        usbp->txpending &= ~epmask;
 800ed88:	f8da 305c 	ldr.w	r3, [sl, #92]	; 0x5c
 800ed8c:	9901      	ldr	r1, [sp, #4]
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 800ed8e:	f022 0201 	bic.w	r2, r2, #1
        usbp->txpending &= ~epmask;
 800ed92:	ea23 0301 	bic.w	r3, r3, r1
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 800ed96:	f8cb 2008 	str.w	r2, [fp, #8]
        usbp->txpending &= ~epmask;
 800ed9a:	f8ca 305c 	str.w	r3, [sl, #92]	; 0x5c
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ed9e:	b662      	cpsie	i
 800eda0:	eb0a 0988 	add.w	r9, sl, r8, lsl #2
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800eda4:	f8d9 000c 	ldr.w	r0, [r9, #12]
 800eda8:	6941      	ldr	r1, [r0, #20]
 800edaa:	688a      	ldr	r2, [r1, #8]
 800edac:	684b      	ldr	r3, [r1, #4]
 800edae:	429a      	cmp	r2, r3
 800edb0:	f080 80a9 	bcs.w	800ef06 <usb_lld_pump+0x2f6>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800edb4:	f8da 6050 	ldr.w	r6, [sl, #80]	; 0x50
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 800edb8:	8a07      	ldrh	r7, [r0, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800edba:	ea4f 1048 	mov.w	r0, r8, lsl #5
 800edbe:	4604      	mov	r4, r0
 800edc0:	1830      	adds	r0, r6, r0
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 800edc2:	1a9b      	subs	r3, r3, r2
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800edc4:	f8d0 2918 	ldr.w	r2, [r0, #2328]	; 0x918
 800edc8:	429f      	cmp	r7, r3
 800edca:	bf28      	it	cs
 800edcc:	461f      	movcs	r7, r3
 800edce:	b293      	uxth	r3, r2
 800edd0:	ebb7 0f83 	cmp.w	r7, r3, lsl #2
 800edd4:	f108 0801 	add.w	r8, r8, #1
 800edd8:	d82e      	bhi.n	800ee38 <usb_lld_pump+0x228>
 800edda:	f8cd b008 	str.w	fp, [sp, #8]
 800edde:	46a3      	mov	fp, r4

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    /* Handles the two cases: linear buffer or queue.*/
    if (usbp->epc[ep]->in_state->txqueued) {
 800ede0:	780b      	ldrb	r3, [r1, #0]
 800ede2:	2b00      	cmp	r3, #0
 800ede4:	d139      	bne.n	800ee5a <usb_lld_pump+0x24a>
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {

  otg_do_push(fifop, (uint8_t *)buf, (n + 3) / 4);
 800ede6:	1cfb      	adds	r3, r7, #3
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800ede8:	68cc      	ldr	r4, [r1, #12]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 800edea:	089b      	lsrs	r3, r3, #2
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800edec:	eb06 3608 	add.w	r6, r6, r8, lsl #12
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 800edf0:	bf18      	it	ne
 800edf2:	4622      	movne	r2, r4
 800edf4:	d004      	beq.n	800ee00 <usb_lld_pump+0x1f0>
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses and on the LSB-first memory organization.*/
    *fifop = *((PACKED_VAR uint32_t *)buf);
 800edf6:	f852 0b04 	ldr.w	r0, [r2], #4
 800edfa:	6030      	str	r0, [r6, #0]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 800edfc:	3b01      	subs	r3, #1
 800edfe:	d1fa      	bne.n	800edf6 <usb_lld_pump+0x1e6>
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
                                 usbp->epc[ep]->in_state->mode.linear.txbuf,
                                 n);
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
 800ee00:	443c      	add	r4, r7
 800ee02:	60cc      	str	r4, [r1, #12]
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 800ee04:	f8d9 000c 	ldr.w	r0, [r9, #12]
 800ee08:	6941      	ldr	r1, [r0, #20]
 800ee0a:	688b      	ldr	r3, [r1, #8]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800ee0c:	684a      	ldr	r2, [r1, #4]
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 800ee0e:	443b      	add	r3, r7
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800ee10:	429a      	cmp	r2, r3
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 800ee12:	608b      	str	r3, [r1, #8]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800ee14:	d973      	bls.n	800eefe <usb_lld_pump+0x2ee>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800ee16:	f8da 6050 	ldr.w	r6, [sl, #80]	; 0x50
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 800ee1a:	8a00      	ldrh	r0, [r0, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800ee1c:	eb06 040b 	add.w	r4, r6, fp
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 800ee20:	1ad7      	subs	r7, r2, r3
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800ee22:	f8d4 3918 	ldr.w	r3, [r4, #2328]	; 0x918
 800ee26:	4287      	cmp	r7, r0
 800ee28:	bf28      	it	cs
 800ee2a:	4607      	movcs	r7, r0
 800ee2c:	b29b      	uxth	r3, r3
 800ee2e:	ebb7 0f83 	cmp.w	r7, r3, lsl #2
 800ee32:	d9d5      	bls.n	800ede0 <usb_lld_pump+0x1d0>
 800ee34:	f8dd b008 	ldr.w	fp, [sp, #8]
      return FALSE;
 800ee38:	2200      	movs	r2, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ee3a:	b672      	cpsid	i
        osalSysUnlock();

        done = otg_txfifo_handler(usbp, ep);

        osalSysLock();
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800ee3c:	f8db 3008 	ldr.w	r3, [fp, #8]
 800ee40:	f043 0301 	orr.w	r3, r3, #1
 800ee44:	f8cb 3008 	str.w	r3, [fp, #8]
        if (!done)
 800ee48:	b92a      	cbnz	r2, 800ee56 <usb_lld_pump+0x246>
          otgp->DIEPEMPMSK |= epmask;
 800ee4a:	f8db 3834 	ldr.w	r3, [fp, #2100]	; 0x834
 800ee4e:	9a01      	ldr	r2, [sp, #4]
 800ee50:	431a      	orrs	r2, r3
 800ee52:	f8cb 2834 	str.w	r2, [fp, #2100]	; 0x834
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ee56:	b662      	cpsie	i
 800ee58:	e732      	b.n	800ecc0 <usb_lld_pump+0xb0>
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    /* Handles the two cases: linear buffer or queue.*/
    if (usbp->epc[ep]->in_state->txqueued) {
      /* Queue associated.*/
      otg_fifo_write_from_queue(usbp->otg->FIFO[ep],
 800ee5a:	eb06 3608 	add.w	r6, r6, r8, lsl #12
 800ee5e:	68c8      	ldr	r0, [r1, #12]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 800ee60:	b1e7      	cbz	r7, 800ee9c <usb_lld_pump+0x28c>
 800ee62:	f8d0 e010 	ldr.w	lr, [r0, #16]
 800ee66:	463a      	mov	r2, r7
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 800ee68:	0893      	lsrs	r3, r2, #2
 800ee6a:	d127      	bne.n	800eebc <usb_lld_pump+0x2ac>
 800ee6c:	6983      	ldr	r3, [r0, #24]
      }
    }

    /* If this condition is not satisfied then there is a word lying across
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
 800ee6e:	2100      	movs	r1, #0
 800ee70:	460c      	mov	r4, r1

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 800ee72:	1c5d      	adds	r5, r3, #1
 800ee74:	6185      	str	r5, [r0, #24]
 800ee76:	781b      	ldrb	r3, [r3, #0]
      if (oqp->q_rdptr >= oqp->q_top)
 800ee78:	4575      	cmp	r5, lr

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 800ee7a:	fa03 f301 	lsl.w	r3, r3, r1
 800ee7e:	ea44 0403 	orr.w	r4, r4, r3
      if (oqp->q_rdptr >= oqp->q_top)
        oqp->q_rdptr = oqp->q_buffer;
 800ee82:	bf24      	itt	cs
 800ee84:	68c3      	ldrcs	r3, [r0, #12]
 800ee86:	6183      	strcs	r3, [r0, #24]
      break;

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 800ee88:	3a01      	subs	r2, #1
 800ee8a:	d004      	beq.n	800ee96 <usb_lld_pump+0x286>
 800ee8c:	2918      	cmp	r1, #24
 800ee8e:	d002      	beq.n	800ee96 <usb_lld_pump+0x286>
 800ee90:	3108      	adds	r1, #8
 800ee92:	6983      	ldr	r3, [r0, #24]
 800ee94:	e7ed      	b.n	800ee72 <usb_lld_pump+0x262>
      if (oqp->q_rdptr >= oqp->q_top)
        oqp->q_rdptr = oqp->q_buffer;
      ntogo--;
      i++;
    }
    *fifop = w;
 800ee96:	6034      	str	r4, [r6, #0]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 800ee98:	2a00      	cmp	r2, #0
 800ee9a:	d1e5      	bne.n	800ee68 <usb_lld_pump+0x258>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ee9c:	b672      	cpsid	i
    *fifop = w;
  }

  /* Updating queue.*/
  osalSysLock();
  oqp->q_counter += n;
 800ee9e:	6883      	ldr	r3, [r0, #8]
 800eea0:	443b      	add	r3, r7
 800eea2:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800eea4:	2100      	movs	r1, #0
 800eea6:	f7fd fd33 	bl	800c910 <chThdDequeueAllI>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 800eeaa:	f7fd fc09 	bl	800c6c0 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800eeae:	b662      	cpsie	i
 800eeb0:	e7a8      	b.n	800ee04 <usb_lld_pump+0x1f4>
 800eeb2:	bf00      	nop
 800eeb4:	20000838 	.word	0x20000838
 800eeb8:	08010c60 	.word	0x08010c60
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;
 800eebc:	6984      	ldr	r4, [r0, #24]
 800eebe:	ebbe 0104 	subs.w	r1, lr, r4
 800eec2:	bf48      	it	mi
 800eec4:	3103      	addmi	r1, #3
 800eec6:	1089      	asrs	r1, r1, #2

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
 800eec8:	428b      	cmp	r3, r1
 800eeca:	bf28      	it	cs
 800eecc:	460b      	movcs	r3, r1
 800eece:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 800eed2:	ebcc 0202 	rsb	r2, ip, r2
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 800eed6:	b133      	cbz	r3, 800eee6 <usb_lld_pump+0x2d6>
 800eed8:	4621      	mov	r1, r4
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses and on the LSB-first memory organization.*/
    *fifop = *((PACKED_VAR uint32_t *)buf);
 800eeda:	f851 5b04 	ldr.w	r5, [r1], #4
 800eede:	6035      	str	r5, [r6, #0]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 800eee0:	3b01      	subs	r3, #1
 800eee2:	d1fa      	bne.n	800eeda <usb_lld_pump+0x2ca>
 800eee4:	4464      	add	r4, ip
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
      if (oqp->q_rdptr >= oqp->q_top) {
 800eee6:	45a6      	cmp	lr, r4
    if (nw > 0) {
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
 800eee8:	6184      	str	r4, [r0, #24]
      if (oqp->q_rdptr >= oqp->q_top) {
 800eeea:	d804      	bhi.n	800eef6 <usb_lld_pump+0x2e6>
        oqp->q_rdptr = oqp->q_buffer;
 800eeec:	68c3      	ldr	r3, [r0, #12]
 800eeee:	6183      	str	r3, [r0, #24]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 800eef0:	2a00      	cmp	r2, #0
 800eef2:	d1b9      	bne.n	800ee68 <usb_lld_pump+0x258>
 800eef4:	e7d2      	b.n	800ee9c <usb_lld_pump+0x28c>
      }
    }

    /* If this condition is not satisfied then there is a word lying across
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
 800eef6:	2a00      	cmp	r2, #0
 800eef8:	d0d0      	beq.n	800ee9c <usb_lld_pump+0x28c>
 800eefa:	4623      	mov	r3, r4
 800eefc:	e7b7      	b.n	800ee6e <usb_lld_pump+0x25e>
 800eefe:	f8dd b008 	ldr.w	fp, [sp, #8]
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;
 800ef02:	2201      	movs	r2, #1
 800ef04:	e799      	b.n	800ee3a <usb_lld_pump+0x22a>
 800ef06:	f108 0801 	add.w	r8, r8, #1
 800ef0a:	e7fa      	b.n	800ef02 <usb_lld_pump+0x2f2>
 800ef0c:	0000      	movs	r0, r0
	...

0800ef10 <otg_disable_ep.isra.0>:
  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
    ;
}

static void otg_disable_ep(USBDriver *usbp) {
 800ef10:	b5f0      	push	{r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800ef12:	2400      	movs	r4, #0
 800ef14:	f8d1 e008 	ldr.w	lr, [r1, #8]
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
 800ef18:	4625      	mov	r5, r4
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".*/
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0) {
      otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
 800ef1a:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
    otgp->ie[i].DIEPTSIZ = 0;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800ef1e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 800ef22:	e014      	b.n	800ef4e <otg_disable_ep.isra.0+0x3e>
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
 800ef24:	f8c1 5900 	str.w	r5, [r1, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
 800ef28:	18c2      	adds	r2, r0, r3
 800ef2a:	f8c2 5910 	str.w	r5, [r2, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800ef2e:	f8c2 7908 	str.w	r7, [r2, #2312]	; 0x908
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".
       Note that the attempt to disable the OUT EP0 is ignored by the
       hardware but the code is simpler this way.*/
    if ((otgp->oe[i].DOEPCTL & DOEPCTL_EPENA) != 0) {
 800ef32:	f8d1 6b00 	ldr.w	r6, [r1, #2816]	; 0xb00
 800ef36:	2e00      	cmp	r6, #0
 800ef38:	db17      	blt.n	800ef6a <otg_disable_ep.isra.0+0x5a>
      /* Wait for endpoint disable.*/
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
        ;
    }
    else
      otgp->oe[i].DOEPCTL = 0;
 800ef3a:	f8c1 5b00 	str.w	r5, [r1, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 800ef3e:	4403      	add	r3, r0

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800ef40:	3401      	adds	r4, #1
 800ef42:	45a6      	cmp	lr, r4
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
        ;
    }
    else
      otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
 800ef44:	f8c3 5b10 	str.w	r5, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800ef48:	f8c3 7b08 	str.w	r7, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800ef4c:	d314      	bcc.n	800ef78 <otg_disable_ep.isra.0+0x68>
 800ef4e:	0163      	lsls	r3, r4, #5
 800ef50:	18c1      	adds	r1, r0, r3
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".*/
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0) {
 800ef52:	f8d1 2900 	ldr.w	r2, [r1, #2304]	; 0x900
 800ef56:	2a00      	cmp	r2, #0
 800ef58:	dae4      	bge.n	800ef24 <otg_disable_ep.isra.0+0x14>
      otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
 800ef5a:	f8c1 c900 	str.w	ip, [r1, #2304]	; 0x900
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
 800ef5e:	460e      	mov	r6, r1
 800ef60:	f8d6 2908 	ldr.w	r2, [r6, #2312]	; 0x908
 800ef64:	0792      	lsls	r2, r2, #30
 800ef66:	d5fb      	bpl.n	800ef60 <otg_disable_ep.isra.0+0x50>
 800ef68:	e7de      	b.n	800ef28 <otg_disable_ep.isra.0+0x18>
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".
       Note that the attempt to disable the OUT EP0 is ignored by the
       hardware but the code is simpler this way.*/
    if ((otgp->oe[i].DOEPCTL & DOEPCTL_EPENA) != 0) {
      otgp->oe[i].DOEPCTL = DOEPCTL_EPDIS;
 800ef6a:	f8c1 cb00 	str.w	ip, [r1, #2816]	; 0xb00
      /* Wait for endpoint disable.*/
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
 800ef6e:	f8d2 1b08 	ldr.w	r1, [r2, #2824]	; 0xb08
 800ef72:	06c9      	lsls	r1, r1, #27
 800ef74:	d5fb      	bpl.n	800ef6e <otg_disable_ep.isra.0+0x5e>
 800ef76:	e7e2      	b.n	800ef3e <otg_disable_ep.isra.0+0x2e>
    else
      otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800ef78:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 800ef7c:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
 800ef80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ef82:	bf00      	nop
	...

0800ef90 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 800ef90:	b510      	push	{r4, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 800ef92:	4c06      	ldr	r4, [pc, #24]	; (800efac <usb_lld_init+0x1c>)
 800ef94:	4620      	mov	r0, r4
 800ef96:	f7fe fa03 	bl	800d3a0 <usbObjectInit>
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 800ef9a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
  USBD1.otgparams = &fsparams;
 800ef9e:	4a04      	ldr	r2, [pc, #16]	; (800efb0 <usb_lld_init+0x20>)

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 800efa0:	6523      	str	r3, [r4, #80]	; 0x50
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 800efa2:	2300      	movs	r3, #0
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 800efa4:	6562      	str	r2, [r4, #84]	; 0x54
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 800efa6:	6623      	str	r3, [r4, #96]	; 0x60
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 800efa8:	6663      	str	r3, [r4, #100]	; 0x64
 800efaa:	bd10      	pop	{r4, pc}
 800efac:	20000c18 	.word	0x20000c18
 800efb0:	08010c50 	.word	0x08010c50
	...

0800efc0 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 800efc0:	b570      	push	{r4, r5, r6, lr}
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 800efc2:	7803      	ldrb	r3, [r0, #0]
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 800efc4:	6d06      	ldr	r6, [r0, #80]	; 0x50

  if (usbp->state == USB_STOP) {
 800efc6:	2b01      	cmp	r3, #1
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 800efc8:	b082      	sub	sp, #8
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 800efca:	d001      	beq.n	800efd0 <usb_lld_start+0x10>
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
  }
}
 800efcc:	b002      	add	sp, #8
 800efce:	bd70      	pop	{r4, r5, r6, pc}
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 800efd0:	4b30      	ldr	r3, [pc, #192]	; (800f094 <usb_lld_start+0xd4>)
 800efd2:	4298      	cmp	r0, r3
 800efd4:	4605      	mov	r5, r0
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 800efd6:	bf18      	it	ne
 800efd8:	4634      	movne	r4, r6

  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 800efda:	d03a      	beq.n	800f052 <usb_lld_start+0x92>
      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
    }
#endif

    usbp->txpending = 0;
 800efdc:	2300      	movs	r3, #0

    /* - Forced device mode.
       - USB turn-around time = TRDT_VALUE.
       - Full Speed 1.1 PHY.*/
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 800efde:	482e      	ldr	r0, [pc, #184]	; (800f098 <usb_lld_start+0xd8>)

    /* 48MHz 1.1 PHY.*/
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800efe0:	492e      	ldr	r1, [pc, #184]	; (800f09c <usb_lld_start+0xdc>)
      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
    }
#endif

    usbp->txpending = 0;
 800efe2:	65eb      	str	r3, [r5, #92]	; 0x5c
    /* PHY enabled.*/
    otgp->PCGCCTL = 0;

    /* Internal FS PHY activation.*/
#if defined(BOARD_OTG_NOVBUSSENS)
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
 800efe4:	f44f 1234 	mov.w	r2, #2949120	; 0x2d0000
    usbp->txpending = 0;

    /* - Forced device mode.
       - USB turn-around time = TRDT_VALUE.
       - Full Speed 1.1 PHY.*/
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 800efe8:	60f0      	str	r0, [r6, #12]

    /* 48MHz 1.1 PHY.*/
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800efea:	f8c6 1800 	str.w	r1, [r6, #2048]	; 0x800
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 800efee:	2020      	movs	r0, #32

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 800eff0:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00

    /* Internal FS PHY activation.*/
#if defined(BOARD_OTG_NOVBUSSENS)
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
 800eff4:	63b2      	str	r2, [r6, #56]	; 0x38
 800eff6:	f7fd f9eb 	bl	800c3d0 <chSysPolledDelayX>
  stm32_otg_t *otgp = usbp->otg;

  osalSysPolledDelayX(32);

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 800effa:	2301      	movs	r3, #1
 800effc:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 800effe:	6923      	ldr	r3, [r4, #16]
 800f000:	07db      	lsls	r3, r3, #31
 800f002:	d4fc      	bmi.n	800effe <usb_lld_start+0x3e>
 800f004:	200c      	movs	r0, #12
 800f006:	f7fd f9e3 	bl	800c3d0 <chSysPolledDelayX>
    ;

  osalSysPolledDelayX(12);

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800f00a:	6923      	ldr	r3, [r4, #16]
 800f00c:	2b00      	cmp	r3, #0
 800f00e:	dafc      	bge.n	800f00a <usb_lld_start+0x4a>

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 800f010:	2400      	movs	r4, #0
 800f012:	60b4      	str	r4, [r6, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 800f014:	6d28      	ldr	r0, [r5, #80]	; 0x50
 800f016:	6d69      	ldr	r1, [r5, #84]	; 0x54
 800f018:	f7ff ff7a 	bl	800ef10 <otg_disable_ep.isra.0>
    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 800f01c:	686b      	ldr	r3, [r5, #4]
    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 800f01e:	f8c6 4810 	str.w	r4, [r6, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 800f022:	68db      	ldr	r3, [r3, #12]
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
 800f024:	f8c6 4814 	str.w	r4, [r6, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 800f028:	f8c6 481c 	str.w	r4, [r6, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 800f02c:	b16b      	cbz	r3, 800f04a <usb_lld_start+0x8a>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM  |*/;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 800f02e:	f243 0308 	movw	r3, #12296	; 0x3008
 800f032:	61b3      	str	r3, [r6, #24]
                       GINTMSK_ESUSPM */ | GINTMSK_SOFM;
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 800f034:	6e6b      	ldr	r3, [r5, #100]	; 0x64
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM  |*/;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM */ | GINTMSK_SOFM;
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */
 800f036:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800f03a:	6172      	str	r2, [r6, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 800f03c:	b1d3      	cbz	r3, 800f074 <usb_lld_start+0xb4>
      chSchRescheduleS();
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800f03e:	68b3      	ldr	r3, [r6, #8]
 800f040:	f043 0301 	orr.w	r3, r3, #1
 800f044:	60b3      	str	r3, [r6, #8]
  }
}
 800f046:	b002      	add	sp, #8
 800f048:	bd70      	pop	{r4, r5, r6, pc}
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 800f04a:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 800f04e:	61b3      	str	r3, [r6, #24]
 800f050:	e7f0      	b.n	800f034 <usb_lld_start+0x74>
  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
 800f052:	4b13      	ldr	r3, [pc, #76]	; (800f0a0 <usb_lld_start+0xe0>)
 800f054:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800f056:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800f05a:	635a      	str	r2, [r3, #52]	; 0x34
      rccResetOTG_FS();
 800f05c:	695a      	ldr	r2, [r3, #20]
 800f05e:	2100      	movs	r1, #0
 800f060:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800f064:	615a      	str	r2, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 800f066:	2043      	movs	r0, #67	; 0x43
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
      rccResetOTG_FS();
 800f068:	6159      	str	r1, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 800f06a:	210e      	movs	r1, #14
 800f06c:	f7fe fc80 	bl	800d970 <nvicEnableVector>
 800f070:	6d2c      	ldr	r4, [r5, #80]	; 0x50
 800f072:	e7b3      	b.n	800efdc <usb_lld_start+0x1c>
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 800f074:	f44f 7106 	mov.w	r1, #536	; 0x218
 800f078:	2202      	movs	r2, #2
 800f07a:	4b0a      	ldr	r3, [pc, #40]	; (800f0a4 <usb_lld_start+0xe4>)
 800f07c:	9500      	str	r5, [sp, #0]
 800f07e:	f105 0068 	add.w	r0, r5, #104	; 0x68
 800f082:	f7fd fb65 	bl	800c750 <chThdCreateI>
 800f086:	6668      	str	r0, [r5, #100]	; 0x64
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 800f088:	f7fd fa3a 	bl	800c500 <chSchReadyI>
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
      chSchRescheduleS();
 800f08c:	f7fd fb18 	bl	800c6c0 <chSchRescheduleS>
 800f090:	e7d5      	b.n	800f03e <usb_lld_start+0x7e>
 800f092:	bf00      	nop
 800f094:	20000c18 	.word	0x20000c18
 800f098:	40001440 	.word	0x40001440
 800f09c:	02200003 	.word	0x02200003
 800f0a0:	40023800 	.word	0x40023800
 800f0a4:	0800ec11 	.word	0x0800ec11
	...

0800f0b0 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 800f0b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 800f0b2:	6d05      	ldr	r5, [r0, #80]	; 0x50
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800f0b4:	2320      	movs	r3, #32
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 800f0b6:	4607      	mov	r7, r0
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800f0b8:	612b      	str	r3, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800f0ba:	692b      	ldr	r3, [r5, #16]
 800f0bc:	f013 0420 	ands.w	r4, r3, #32
 800f0c0:	d1fb      	bne.n	800f0ba <usb_lld_reset+0xa>
 800f0c2:	200c      	movs	r0, #12
 800f0c4:	f7fd f984 	bl	800c3d0 <chSysPolledDelayX>
 800f0c8:	f8d7 e054 	ldr.w	lr, [r7, #84]	; 0x54
 800f0cc:	f8de 6008 	ldr.w	r6, [lr, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800f0d0:	4623      	mov	r3, r4
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800f0d2:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFF;
 800f0d6:	21ff      	movs	r1, #255	; 0xff
 800f0d8:	eb05 1243 	add.w	r2, r5, r3, lsl #5

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800f0dc:	3301      	adds	r3, #1
 800f0de:	42b3      	cmp	r3, r6
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800f0e0:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800f0e4:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFF;
 800f0e8:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFF;
 800f0ec:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800f0f0:	d9f2      	bls.n	800f0d8 <usb_lld_reset+0x28>
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800f0f2:	f8de 3000 	ldr.w	r3, [lr]
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 800f0f6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800f0fa:	f04f 1101 	mov.w	r1, #65537	; 0x10001
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 800f0fe:	f8c5 2818 	str.w	r2, [r5, #2072]	; 0x818
 800f102:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800f104:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800f108:	65bb      	str	r3, [r7, #88]	; 0x58

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 800f10a:	f8de 3000 	ldr.w	r3, [lr]
 800f10e:	626b      	str	r3, [r5, #36]	; 0x24
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 800f110:	2310      	movs	r3, #16
 800f112:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 800f114:	6913      	ldr	r3, [r2, #16]
 800f116:	f013 0410 	ands.w	r4, r3, #16
 800f11a:	d1fb      	bne.n	800f114 <usb_lld_reset+0x64>
 800f11c:	200c      	movs	r0, #12
 800f11e:	f7fd f957 	bl	800c3d0 <chSysPolledDelayX>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 800f122:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800f126:	4a11      	ldr	r2, [pc, #68]	; (800f16c <usb_lld_reset+0xbc>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 800f128:	4811      	ldr	r0, [pc, #68]	; (800f170 <usb_lld_reset+0xc0>)
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 800f12a:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800f12e:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 800f132:	69ab      	ldr	r3, [r5, #24]
 800f134:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 800f138:	f043 0310 	orr.w	r3, r3, #16
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 800f13c:	2109      	movs	r1, #9

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 800f13e:	61ab      	str	r3, [r5, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 800f140:	f8c5 1810 	str.w	r1, [r5, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 800f144:	f8c5 1814 	str.w	r1, [r5, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 800f148:	60f8      	str	r0, [r7, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 800f14a:	f8c5 4b10 	str.w	r4, [r5, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800f14e:	f8c5 2b00 	str.w	r2, [r5, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 800f152:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800f156:	f8c5 2900 	str.w	r2, [r5, #2304]	; 0x900
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 800f15a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  usbp->pmnext += size;
 800f15c:	f103 0210 	add.w	r2, r3, #16
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800f160:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 800f164:	65ba      	str	r2, [r7, #88]	; 0x58
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800f166:	62ab      	str	r3, [r5, #40]	; 0x28
 800f168:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f16a:	bf00      	nop
 800f16c:	10008040 	.word	0x10008040
 800f170:	08010c70 	.word	0x08010c70
	...

0800f180 <usb_lld_set_address>:
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 800f180:	6d02      	ldr	r2, [r0, #80]	; 0x50

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800f182:	f890 104e 	ldrb.w	r1, [r0, #78]	; 0x4e
 800f186:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 800f18a:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800f18e:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800f192:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 800f196:	4770      	bx	lr
	...

0800f1a0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 800f1a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f1a4:	fa0f f881 	sxth.w	r8, r1
 800f1a8:	eb00 0788 	add.w	r7, r0, r8, lsl #2
 800f1ac:	460d      	mov	r5, r1
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 800f1ae:	68fb      	ldr	r3, [r7, #12]
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 800f1b0:	6d04      	ldr	r4, [r0, #80]	; 0x50

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 800f1b2:	681a      	ldr	r2, [r3, #0]
 800f1b4:	f002 0203 	and.w	r2, r2, #3
 800f1b8:	2a02      	cmp	r2, #2
 800f1ba:	d05c      	beq.n	800f276 <usb_lld_init_endpoint+0xd6>
 800f1bc:	2a03      	cmp	r2, #3
 800f1be:	d05c      	beq.n	800f27a <usb_lld_init_endpoint+0xda>
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 800f1c0:	4e4a      	ldr	r6, [pc, #296]	; (800f2ec <usb_lld_init_endpoint+0x14c>)
 800f1c2:	494b      	ldr	r1, [pc, #300]	; (800f2f0 <usb_lld_init_endpoint+0x150>)
 800f1c4:	2a01      	cmp	r2, #1
 800f1c6:	bf18      	it	ne
 800f1c8:	460e      	movne	r6, r1
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 800f1ca:	016a      	lsls	r2, r5, #5
  if (usbp->epc[ep]->out_cb != NULL) {
 800f1cc:	68d9      	ldr	r1, [r3, #12]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 800f1ce:	eb04 0e02 	add.w	lr, r4, r2
 800f1d2:	f04f 0c00 	mov.w	ip, #0
 800f1d6:	f8ce cb10 	str.w	ip, [lr, #2832]	; 0xb10
  if (usbp->epc[ep]->out_cb != NULL) {
 800f1da:	2900      	cmp	r1, #0
 800f1dc:	d071      	beq.n	800f2c2 <usb_lld_init_endpoint+0x122>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 800f1de:	f8b3 e012 	ldrh.w	lr, [r3, #18]
 800f1e2:	f105 0158 	add.w	r1, r5, #88	; 0x58
 800f1e6:	0149      	lsls	r1, r1, #5
 800f1e8:	ea46 0e0e 	orr.w	lr, r6, lr
 800f1ec:	f844 e001 	str.w	lr, [r4, r1]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 800f1f0:	f105 0c10 	add.w	ip, r5, #16
 800f1f4:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
 800f1f8:	f04f 0e01 	mov.w	lr, #1
 800f1fc:	fa0e fe0c 	lsl.w	lr, lr, ip
 800f200:	ea4e 0101 	orr.w	r1, lr, r1
 800f204:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 800f208:	4422      	add	r2, r4
  if (usbp->epc[ep]->in_cb != NULL) {
 800f20a:	6899      	ldr	r1, [r3, #8]
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 800f20c:	f04f 0e00 	mov.w	lr, #0
 800f210:	f8c2 e910 	str.w	lr, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_cb != NULL) {
 800f214:	b399      	cbz	r1, 800f27e <usb_lld_init_endpoint+0xde>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 800f216:	8b99      	ldrh	r1, [r3, #28]

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800f218:	8a1a      	ldrh	r2, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 800f21a:	2901      	cmp	r1, #1

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800f21c:	ea4f 0392 	mov.w	r3, r2, lsr #2
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
 800f220:	bf88      	it	hi
 800f222:	434b      	mulhi	r3, r1
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800f224:	f105 0e3f 	add.w	lr, r5, #63	; 0x3f
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 800f228:	6d81      	ldr	r1, [r0, #88]	; 0x58
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800f22a:	eb04 0e8e 	add.w	lr, r4, lr, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800f22e:	01aa      	lsls	r2, r5, #6
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 800f230:	eb03 0c01 	add.w	ip, r3, r1
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800f234:	f042 0220 	orr.w	r2, r2, #32
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800f238:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 800f23c:	f8c0 c058 	str.w	ip, [r0, #88]	; 0x58
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800f240:	f8ce 3004 	str.w	r3, [lr, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800f244:	6122      	str	r2, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800f246:	6923      	ldr	r3, [r4, #16]
 800f248:	069a      	lsls	r2, r3, #26
 800f24a:	d4fc      	bmi.n	800f246 <usb_lld_init_endpoint+0xa6>
 800f24c:	200c      	movs	r0, #12
 800f24e:	f7fd f8bf 	bl	800c3d0 <chSysPolledDelayX>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 800f252:	68fb      	ldr	r3, [r7, #12]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 800f254:	8a1a      	ldrh	r2, [r3, #16]
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 800f256:	f105 0348 	add.w	r3, r5, #72	; 0x48
 800f25a:	015b      	lsls	r3, r3, #5
 800f25c:	ea42 5285 	orr.w	r2, r2, r5, lsl #22
                           DIEPCTL_TXFNUM(ep) |
 800f260:	4332      	orrs	r2, r6
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 800f262:	50e2      	str	r2, [r4, r3]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 800f264:	2301      	movs	r3, #1
 800f266:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 800f26a:	40ab      	lsls	r3, r5
 800f26c:	4313      	orrs	r3, r2
 800f26e:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
 800f272:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 800f276:	4e1f      	ldr	r6, [pc, #124]	; (800f2f4 <usb_lld_init_endpoint+0x154>)
    break;
 800f278:	e7a7      	b.n	800f1ca <usb_lld_init_endpoint+0x2a>
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 800f27a:	4e1f      	ldr	r6, [pc, #124]	; (800f2f8 <usb_lld_init_endpoint+0x158>)
    break;
 800f27c:	e7a5      	b.n	800f1ca <usb_lld_init_endpoint+0x2a>
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800f27e:	f105 023f 	add.w	r2, r5, #63	; 0x3f
 800f282:	eb04 0282 	add.w	r2, r4, r2, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800f286:	01ab      	lsls	r3, r5, #6
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800f288:	491c      	ldr	r1, [pc, #112]	; (800f2fc <usb_lld_init_endpoint+0x15c>)
 800f28a:	6051      	str	r1, [r2, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800f28c:	f043 0320 	orr.w	r3, r3, #32
 800f290:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800f292:	6923      	ldr	r3, [r4, #16]
 800f294:	069b      	lsls	r3, r3, #26
 800f296:	d4fc      	bmi.n	800f292 <usb_lld_init_endpoint+0xf2>
 800f298:	eb04 1848 	add.w	r8, r4, r8, lsl #5
 800f29c:	200c      	movs	r0, #12
 800f29e:	f7fd f897 	bl	800c3d0 <chSysPolledDelayX>
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 800f2a2:	f8d8 2900 	ldr.w	r2, [r8, #2304]	; 0x900
 800f2a6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800f2aa:	f8c8 2900 	str.w	r2, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 800f2ae:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 800f2b2:	2301      	movs	r3, #1
 800f2b4:	40ab      	lsls	r3, r5
 800f2b6:	ea22 0303 	bic.w	r3, r2, r3
 800f2ba:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
 800f2be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f2c2:	eb04 1148 	add.w	r1, r4, r8, lsl #5
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 800f2c6:	f105 0c10 	add.w	ip, r5, #16
  if (usbp->epc[ep]->out_cb != NULL) {
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 800f2ca:	f8d1 eb00 	ldr.w	lr, [r1, #2816]	; 0xb00
 800f2ce:	f42e 4e00 	bic.w	lr, lr, #32768	; 0x8000
 800f2d2:	f8c1 eb00 	str.w	lr, [r1, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 800f2d6:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
 800f2da:	f04f 0e01 	mov.w	lr, #1
 800f2de:	fa0e fe0c 	lsl.w	lr, lr, ip
 800f2e2:	ea21 010e 	bic.w	r1, r1, lr
 800f2e6:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
 800f2ea:	e78d      	b.n	800f208 <usb_lld_init_endpoint+0x68>
 800f2ec:	10048000 	.word	0x10048000
 800f2f0:	10008000 	.word	0x10008000
 800f2f4:	10088000 	.word	0x10088000
 800f2f8:	100c8000 	.word	0x100c8000
 800f2fc:	02000400 	.word	0x02000400

0800f300 <usb_lld_get_status_out>:
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800f300:	3158      	adds	r1, #88	; 0x58
 800f302:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800f304:	0149      	lsls	r1, r1, #5
 800f306:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 800f308:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 800f30c:	d004      	beq.n	800f318 <usb_lld_get_status_out+0x18>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
 800f30e:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
    return EP_STATUS_STALLED;
  return EP_STATUS_ACTIVE;
 800f312:	bf14      	ite	ne
 800f314:	2001      	movne	r0, #1
 800f316:	2002      	moveq	r0, #2
}
 800f318:	4770      	bx	lr
 800f31a:	bf00      	nop
 800f31c:	0000      	movs	r0, r0
	...

0800f320 <usb_lld_get_status_in>:
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 800f320:	3148      	adds	r1, #72	; 0x48
 800f322:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800f324:	0149      	lsls	r1, r1, #5
 800f326:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 800f328:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 800f32c:	d004      	beq.n	800f338 <usb_lld_get_status_in+0x18>
    return EP_STATUS_DISABLED;
  if (ctl & DIEPCTL_STALL)
 800f32e:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
    return EP_STATUS_STALLED;
  return EP_STATUS_ACTIVE;
 800f332:	bf14      	ite	ne
 800f334:	2001      	movne	r0, #1
 800f336:	2002      	moveq	r0, #2
}
 800f338:	4770      	bx	lr
 800f33a:	bf00      	nop
 800f33c:	0000      	movs	r0, r0
	...

0800f340 <usb_lld_read_setup>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 800f340:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800f344:	68cb      	ldr	r3, [r1, #12]
 800f346:	6a1b      	ldr	r3, [r3, #32]
 800f348:	6819      	ldr	r1, [r3, #0]
 800f34a:	685b      	ldr	r3, [r3, #4]
 800f34c:	6053      	str	r3, [r2, #4]
 800f34e:	6011      	str	r1, [r2, #0]
 800f350:	4770      	bx	lr
 800f352:	bf00      	nop
	...

0800f360 <usb_lld_prepare_receive>:
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800f360:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
 800f364:	b430      	push	{r4, r5}
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800f366:	68dd      	ldr	r5, [r3, #12]
 800f368:	69ac      	ldr	r4, [r5, #24]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800f36a:	6863      	ldr	r3, [r4, #4]
 800f36c:	6123      	str	r3, [r4, #16]
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
 800f36e:	b931      	cbnz	r1, 800f37e <usb_lld_prepare_receive+0x1e>
 800f370:	2b40      	cmp	r3, #64	; 0x40
 800f372:	d904      	bls.n	800f37e <usb_lld_prepare_receive+0x1e>
      osp->rxsize = EP0_MAX_OUTSIZE;
 800f374:	2340      	movs	r3, #64	; 0x40
 800f376:	6063      	str	r3, [r4, #4]
 800f378:	4a09      	ldr	r2, [pc, #36]	; (800f3a0 <usb_lld_prepare_receive+0x40>)
 800f37a:	243f      	movs	r4, #63	; 0x3f
 800f37c:	e002      	b.n	800f384 <usb_lld_prepare_receive+0x24>
 800f37e:	1e5c      	subs	r4, r3, #1
 800f380:	f043 42c0 	orr.w	r2, r3, #1610612736	; 0x60000000

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800f384:	6d00      	ldr	r0, [r0, #80]	; 0x50
  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 800f386:	8a6d      	ldrh	r5, [r5, #18]
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800f388:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 800f38c:	1963      	adds	r3, r4, r5
 800f38e:	fbb3 f3f5 	udiv	r3, r3, r5
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800f392:	ea42 43c3 	orr.w	r3, r2, r3, lsl #19
 800f396:	f8c1 3b10 	str.w	r3, [r1, #2832]	; 0xb10
                               DOEPTSIZ_XFRSIZ(osp->rxsize);

}
 800f39a:	bc30      	pop	{r4, r5}
 800f39c:	4770      	bx	lr
 800f39e:	bf00      	nop
 800f3a0:	60000040 	.word	0x60000040
	...

0800f3b0 <otg_epout_handler.constprop.7>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800f3b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 800f3b4:	4e24      	ldr	r6, [pc, #144]	; (800f448 <otg_epout_handler.constprop.7+0x98>)
 800f3b6:	6d37      	ldr	r7, [r6, #80]	; 0x50
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800f3b8:	eb07 1340 	add.w	r3, r7, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800f3bc:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800f3be:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 800f3c2:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 800f3c6:	0720      	lsls	r0, r4, #28
 800f3c8:	d503      	bpl.n	800f3d2 <otg_epout_handler.constprop.7+0x22>
 800f3ca:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800f3ce:	0719      	lsls	r1, r3, #28
 800f3d0:	d41d      	bmi.n	800f40e <otg_epout_handler.constprop.7+0x5e>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);

  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 800f3d2:	07e2      	lsls	r2, r4, #31
 800f3d4:	d519      	bpl.n	800f40a <otg_epout_handler.constprop.7+0x5a>
 800f3d6:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800f3da:	07db      	lsls	r3, r3, #31
 800f3dc:	d515      	bpl.n	800f40a <otg_epout_handler.constprop.7+0x5a>
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800f3de:	eb06 0685 	add.w	r6, r6, r5, lsl #2
 800f3e2:	4c19      	ldr	r4, [pc, #100]	; (800f448 <otg_epout_handler.constprop.7+0x98>)
 800f3e4:	68f1      	ldr	r1, [r6, #12]
 800f3e6:	698b      	ldr	r3, [r1, #24]

    if (osp->rxsize < osp->totsize) {
 800f3e8:	6858      	ldr	r0, [r3, #4]
 800f3ea:	691a      	ldr	r2, [r3, #16]
 800f3ec:	4290      	cmp	r0, r2
 800f3ee:	d316      	bcc.n	800f41e <otg_epout_handler.constprop.7+0x6e>
      usb_lld_start_out(usbp, ep);
      chSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 800f3f0:	8962      	ldrh	r2, [r4, #10]
 800f3f2:	68ce      	ldr	r6, [r1, #12]
 800f3f4:	2301      	movs	r3, #1
 800f3f6:	40ab      	lsls	r3, r5
 800f3f8:	ea22 0303 	bic.w	r3, r2, r3
 800f3fc:	8163      	strh	r3, [r4, #10]
 800f3fe:	4629      	mov	r1, r5
 800f400:	4620      	mov	r0, r4
 800f402:	4633      	mov	r3, r6
    }
  }
}
 800f404:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      usb_lld_start_out(usbp, ep);
      chSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 800f408:	4718      	bx	r3
 800f40a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 800f40e:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 800f412:	4630      	mov	r0, r6
 800f414:	68db      	ldr	r3, [r3, #12]
 800f416:	4629      	mov	r1, r5
 800f418:	685b      	ldr	r3, [r3, #4]
 800f41a:	4798      	blx	r3
 800f41c:	e7d9      	b.n	800f3d2 <otg_epout_handler.constprop.7+0x22>

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 800f41e:	1a12      	subs	r2, r2, r0
      osp->rxcnt  = 0;
 800f420:	2100      	movs	r1, #0
 800f422:	6099      	str	r1, [r3, #8]

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 800f424:	605a      	str	r2, [r3, #4]
      osp->rxcnt  = 0;
      usb_lld_prepare_receive(usbp, ep);
 800f426:	4620      	mov	r0, r4
 800f428:	4629      	mov	r1, r5
 800f42a:	f7ff ff99 	bl	800f360 <usb_lld_prepare_receive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f42e:	b672      	cpsid	i
 800f430:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800f432:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 800f436:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
 800f43a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800f43e:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f442:	b662      	cpsie	i
 800f444:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f448:	20000c18 	.word	0x20000c18
 800f44c:	00000000 	.word	0x00000000

0800f450 <usb_lld_prepare_transmit>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800f450:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
 800f454:	b410      	push	{r4}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800f456:	68dc      	ldr	r4, [r3, #12]
 800f458:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800f45a:	6853      	ldr	r3, [r2, #4]
 800f45c:	6113      	str	r3, [r2, #16]
  if (isp->txsize == 0) {
 800f45e:	b1ab      	cbz	r3, 800f48c <usb_lld_prepare_transmit+0x3c>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 800f460:	b171      	cbz	r1, 800f480 <usb_lld_prepare_transmit+0x30>
 800f462:	1e5a      	subs	r2, r3, #1
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 800f464:	6d00      	ldr	r0, [r0, #80]	; 0x50
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800f466:	8a24      	ldrh	r4, [r4, #16]
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 800f468:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800f46c:	4422      	add	r2, r4
 800f46e:	fbb2 f2f4 	udiv	r2, r2, r4
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 800f472:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 800f476:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 800f47a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800f47e:	4770      	bx	lr
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 800f480:	2b40      	cmp	r3, #64	; 0x40
 800f482:	d9ee      	bls.n	800f462 <usb_lld_prepare_transmit+0x12>
      isp->txsize = EP0_MAX_INSIZE;
 800f484:	2340      	movs	r3, #64	; 0x40
 800f486:	6053      	str	r3, [r2, #4]
 800f488:	223f      	movs	r2, #63	; 0x3f
 800f48a:	e7eb      	b.n	800f464 <usb_lld_prepare_transmit+0x14>

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800f48c:	6d03      	ldr	r3, [r0, #80]	; 0x50
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 800f48e:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800f492:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 800f496:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800f49a:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 800f49e:	4770      	bx	lr

0800f4a0 <otg_epin_handler.constprop.8>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800f4a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
 800f4a2:	4f2b      	ldr	r7, [pc, #172]	; (800f550 <otg_epin_handler.constprop.8+0xb0>)
 800f4a4:	6d3d      	ldr	r5, [r7, #80]	; 0x50
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800f4a6:	eb05 1340 	add.w	r3, r5, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800f4aa:	4606      	mov	r6, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800f4ac:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908

  otgp->ie[ep].DIEPINT = epint;
 800f4b0:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 800f4b4:	07e1      	lsls	r1, r4, #31
 800f4b6:	d503      	bpl.n	800f4c0 <otg_epin_handler.constprop.8+0x20>
 800f4b8:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 800f4bc:	07da      	lsls	r2, r3, #31
 800f4be:	d408      	bmi.n	800f4d2 <otg_epin_handler.constprop.8+0x32>
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 800f4c0:	0623      	lsls	r3, r4, #24
 800f4c2:	d505      	bpl.n	800f4d0 <otg_epin_handler.constprop.8+0x30>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800f4c4:	2301      	movs	r3, #1
 800f4c6:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
 800f4ca:	40b3      	lsls	r3, r6
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 800f4cc:	4213      	tst	r3, r2
 800f4ce:	d123      	bne.n	800f518 <otg_epin_handler.constprop.8+0x78>
 800f4d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800f4d2:	eb07 0380 	add.w	r3, r7, r0, lsl #2
 800f4d6:	68d9      	ldr	r1, [r3, #12]
 800f4d8:	694b      	ldr	r3, [r1, #20]

    if (isp->txsize < isp->totsize) {
 800f4da:	6858      	ldr	r0, [r3, #4]
 800f4dc:	691a      	ldr	r2, [r3, #16]
 800f4de:	4290      	cmp	r0, r2
 800f4e0:	d22a      	bcs.n	800f538 <otg_epin_handler.constprop.8+0x98>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800f4e2:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 800f4e4:	2100      	movs	r1, #0
 800f4e6:	6099      	str	r1, [r3, #8]

    if (isp->txsize < isp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800f4e8:	605a      	str	r2, [r3, #4]
      isp->txcnt  = 0;
      usb_lld_prepare_transmit(usbp, ep);
 800f4ea:	4638      	mov	r0, r7
 800f4ec:	4631      	mov	r1, r6
 800f4ee:	f7ff ffaf 	bl	800f450 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f4f2:	b672      	cpsid	i
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800f4f4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f4f6:	eb03 1046 	add.w	r0, r3, r6, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800f4fa:	2201      	movs	r2, #1
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800f4fc:	f8d0 1900 	ldr.w	r1, [r0, #2304]	; 0x900
 800f500:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 800f504:	f8c0 1900 	str.w	r1, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800f508:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 800f50c:	40b2      	lsls	r2, r6
 800f50e:	430a      	orrs	r2, r1
 800f510:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f514:	b662      	cpsie	i
 800f516:	e7d3      	b.n	800f4c0 <otg_epin_handler.constprop.8+0x20>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f518:	b672      	cpsid	i
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800f51a:	f8d5 1834 	ldr.w	r1, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 800f51e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800f520:	480c      	ldr	r0, [pc, #48]	; (800f554 <otg_epin_handler.constprop.8+0xb4>)
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800f522:	ea21 0103 	bic.w	r1, r1, r3
 800f526:	f8c5 1834 	str.w	r1, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 800f52a:	4313      	orrs	r3, r2
 800f52c:	2100      	movs	r1, #0
 800f52e:	65fb      	str	r3, [r7, #92]	; 0x5c
 800f530:	f7fd f9c6 	bl	800c8c0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f534:	b662      	cpsie	i
 800f536:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      usb_lld_start_in(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 800f538:	893a      	ldrh	r2, [r7, #8]
 800f53a:	f8d1 c008 	ldr.w	ip, [r1, #8]
 800f53e:	2301      	movs	r3, #1
 800f540:	40b3      	lsls	r3, r6
 800f542:	ea22 0303 	bic.w	r3, r2, r3
 800f546:	813b      	strh	r3, [r7, #8]
 800f548:	4638      	mov	r0, r7
 800f54a:	4631      	mov	r1, r6
 800f54c:	47e0      	blx	ip
 800f54e:	e7b7      	b.n	800f4c0 <otg_epin_handler.constprop.8+0x20>
 800f550:	20000c18 	.word	0x20000c18
 800f554:	20000c78 	.word	0x20000c78
	...

0800f560 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 800f560:	b570      	push	{r4, r5, r6, lr}
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 800f562:	4e38      	ldr	r6, [pc, #224]	; (800f644 <Vector14C+0xe4>)
 800f564:	6d35      	ldr	r5, [r6, #80]	; 0x50
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 800f566:	696b      	ldr	r3, [r5, #20]
  sts &= otgp->GINTMSK;
 800f568:	69ac      	ldr	r4, [r5, #24]
 800f56a:	401c      	ands	r4, r3
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 800f56c:	04e1      	lsls	r1, r4, #19
  stm32_otg_t *otgp = usbp->otg;
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;
 800f56e:	616c      	str	r4, [r5, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 800f570:	d42d      	bmi.n	800f5ce <Vector14C+0x6e>
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 800f572:	04a2      	lsls	r2, r4, #18
    (void)otgp->DSTS;
 800f574:	bf48      	it	mi
 800f576:	f8d5 3808 	ldrmi.w	r3, [r5, #2056]	; 0x808
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 800f57a:	0723      	lsls	r3, r4, #28
 800f57c:	d504      	bpl.n	800f588 <Vector14C+0x28>
    _usb_isr_invoke_sof_cb(usbp);
 800f57e:	6873      	ldr	r3, [r6, #4]
 800f580:	68db      	ldr	r3, [r3, #12]
 800f582:	b10b      	cbz	r3, 800f588 <Vector14C+0x28>
 800f584:	482f      	ldr	r0, [pc, #188]	; (800f644 <Vector14C+0xe4>)
 800f586:	4798      	blx	r3
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 800f588:	06e6      	lsls	r6, r4, #27
 800f58a:	d42b      	bmi.n	800f5e4 <Vector14C+0x84>
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
 800f58c:	0360      	lsls	r0, r4, #13
    osalThreadResumeI(&usbp->wait, MSG_OK);
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 800f58e:	f8d5 5818 	ldr.w	r5, [r5, #2072]	; 0x818
  if (sts & GINTSTS_IEPINT) {
 800f592:	d507      	bpl.n	800f5a4 <Vector14C+0x44>
    if (src & (1 << 0))
 800f594:	07e9      	lsls	r1, r5, #31
 800f596:	d441      	bmi.n	800f61c <Vector14C+0xbc>
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
 800f598:	07aa      	lsls	r2, r5, #30
 800f59a:	d444      	bmi.n	800f626 <Vector14C+0xc6>
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
 800f59c:	076b      	lsls	r3, r5, #29
 800f59e:	d447      	bmi.n	800f630 <Vector14C+0xd0>
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
 800f5a0:	072e      	lsls	r6, r5, #28
 800f5a2:	d44a      	bmi.n	800f63a <Vector14C+0xda>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 800f5a4:	0324      	lsls	r4, r4, #12
 800f5a6:	d507      	bpl.n	800f5b8 <Vector14C+0x58>
    if (src & (1 << 16))
 800f5a8:	03e8      	lsls	r0, r5, #15
 800f5aa:	d42c      	bmi.n	800f606 <Vector14C+0xa6>
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
 800f5ac:	03a9      	lsls	r1, r5, #14
 800f5ae:	d42f      	bmi.n	800f610 <Vector14C+0xb0>
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
 800f5b0:	036a      	lsls	r2, r5, #13
 800f5b2:	d422      	bmi.n	800f5fa <Vector14C+0x9a>
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
 800f5b4:	032b      	lsls	r3, r5, #12
 800f5b6:	d403      	bmi.n	800f5c0 <Vector14C+0x60>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 800f5b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 800f5bc:	f7fd bc48 	b.w	800ce50 <_port_irq_epilogue>
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
      otg_epout_handler(usbp, 3);
 800f5c0:	2003      	movs	r0, #3
 800f5c2:	f7ff fef5 	bl	800f3b0 <otg_epout_handler.constprop.7>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 800f5c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 800f5ca:	f7fd bc41 	b.w	800ce50 <_port_irq_epilogue>
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
    _usb_reset(usbp);
 800f5ce:	4630      	mov	r0, r6
 800f5d0:	f7fd ff76 	bl	800d4c0 <_usb_reset>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800f5d4:	6873      	ldr	r3, [r6, #4]
 800f5d6:	681b      	ldr	r3, [r3, #0]
 800f5d8:	2b00      	cmp	r3, #0
 800f5da:	d0ca      	beq.n	800f572 <Vector14C+0x12>
 800f5dc:	4630      	mov	r0, r6
 800f5de:	2100      	movs	r1, #0
 800f5e0:	4798      	blx	r3
 800f5e2:	e7c6      	b.n	800f572 <Vector14C+0x12>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f5e4:	b672      	cpsid	i
  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 800f5e6:	69ab      	ldr	r3, [r5, #24]
 800f5e8:	4817      	ldr	r0, [pc, #92]	; (800f648 <Vector14C+0xe8>)
 800f5ea:	f023 0310 	bic.w	r3, r3, #16
 800f5ee:	61ab      	str	r3, [r5, #24]
 800f5f0:	2100      	movs	r1, #0
 800f5f2:	f7fd f965 	bl	800c8c0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f5f6:	b662      	cpsie	i
 800f5f8:	e7c8      	b.n	800f58c <Vector14C+0x2c>
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
 800f5fa:	2002      	movs	r0, #2
 800f5fc:	f7ff fed8 	bl	800f3b0 <otg_epout_handler.constprop.7>
    if (src & (1 << 19))
 800f600:	032b      	lsls	r3, r5, #12
 800f602:	d5d9      	bpl.n	800f5b8 <Vector14C+0x58>
 800f604:	e7dc      	b.n	800f5c0 <Vector14C+0x60>
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
 800f606:	2000      	movs	r0, #0
 800f608:	f7ff fed2 	bl	800f3b0 <otg_epout_handler.constprop.7>
    if (src & (1 << 17))
 800f60c:	03a9      	lsls	r1, r5, #14
 800f60e:	d5cf      	bpl.n	800f5b0 <Vector14C+0x50>
      otg_epout_handler(usbp, 1);
 800f610:	2001      	movs	r0, #1
 800f612:	f7ff fecd 	bl	800f3b0 <otg_epout_handler.constprop.7>
    if (src & (1 << 18))
 800f616:	036a      	lsls	r2, r5, #13
 800f618:	d5cc      	bpl.n	800f5b4 <Vector14C+0x54>
 800f61a:	e7ee      	b.n	800f5fa <Vector14C+0x9a>

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
 800f61c:	2000      	movs	r0, #0
 800f61e:	f7ff ff3f 	bl	800f4a0 <otg_epin_handler.constprop.8>
    if (src & (1 << 1))
 800f622:	07aa      	lsls	r2, r5, #30
 800f624:	d5ba      	bpl.n	800f59c <Vector14C+0x3c>
      otg_epin_handler(usbp, 1);
 800f626:	2001      	movs	r0, #1
 800f628:	f7ff ff3a 	bl	800f4a0 <otg_epin_handler.constprop.8>
    if (src & (1 << 2))
 800f62c:	076b      	lsls	r3, r5, #29
 800f62e:	d5b7      	bpl.n	800f5a0 <Vector14C+0x40>
      otg_epin_handler(usbp, 2);
 800f630:	2002      	movs	r0, #2
 800f632:	f7ff ff35 	bl	800f4a0 <otg_epin_handler.constprop.8>
    if (src & (1 << 3))
 800f636:	072e      	lsls	r6, r5, #28
 800f638:	d5b4      	bpl.n	800f5a4 <Vector14C+0x44>
      otg_epin_handler(usbp, 3);
 800f63a:	2003      	movs	r0, #3
 800f63c:	f7ff ff30 	bl	800f4a0 <otg_epin_handler.constprop.8>
 800f640:	e7b0      	b.n	800f5a4 <Vector14C+0x44>
 800f642:	bf00      	nop
 800f644:	20000c18 	.word	0x20000c18
 800f648:	20000c78 	.word	0x20000c78
 800f64c:	00000000 	.word	0x00000000

0800f650 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 800f650:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800f652:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 800f656:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 800f65a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800f65e:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 800f662:	4770      	bx	lr
	...

0800f670 <usb_lld_start_in>:
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800f670:	6d03      	ldr	r3, [r0, #80]	; 0x50
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 800f672:	b410      	push	{r4}
 800f674:	eb03 1441 	add.w	r4, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800f678:	2201      	movs	r2, #1
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800f67a:	f8d4 0900 	ldr.w	r0, [r4, #2304]	; 0x900
 800f67e:	f040 4004 	orr.w	r0, r0, #2214592512	; 0x84000000
 800f682:	f8c4 0900 	str.w	r0, [r4, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800f686:	f8d3 0834 	ldr.w	r0, [r3, #2100]	; 0x834
}
 800f68a:	f85d 4b04 	ldr.w	r4, [sp], #4
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800f68e:	408a      	lsls	r2, r1
 800f690:	4302      	orrs	r2, r0
 800f692:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 800f696:	4770      	bx	lr
	...

0800f6a0 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 800f6a0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800f6a2:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800f6a6:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 800f6aa:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800f6ae:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 800f6b2:	4770      	bx	lr
	...

0800f6c0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 800f6c0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800f6c2:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800f6c6:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 800f6ca:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800f6ce:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 800f6d2:	4770      	bx	lr
	...

0800f6e0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 800f6e0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800f6e2:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800f6e6:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 800f6ea:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800f6ee:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 800f6f2:	4770      	bx	lr
	...

0800f700 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 800f700:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800f702:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800f706:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 800f70a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800f70e:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 800f712:	4770      	bx	lr
	...

0800f720 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 800f720:	b510      	push	{r4, lr}
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800f722:	4c0a      	ldr	r4, [pc, #40]	; (800f74c <spi_lld_init+0x2c>)
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 800f724:	4b0a      	ldr	r3, [pc, #40]	; (800f750 <spi_lld_init+0x30>)
 800f726:	f64f 72ff 	movw	r2, #65535	; 0xffff
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800f72a:	4620      	mov	r0, r4
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 800f72c:	801a      	strh	r2, [r3, #0]
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800f72e:	f7fd fe27 	bl	800d380 <spiObjectInit>
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 800f732:	4b08      	ldr	r3, [pc, #32]	; (800f754 <spi_lld_init+0x34>)
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 800f734:	4808      	ldr	r0, [pc, #32]	; (800f758 <spi_lld_init+0x38>)
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 800f736:	4909      	ldr	r1, [pc, #36]	; (800f75c <spi_lld_init+0x3c>)
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 800f738:	4a09      	ldr	r2, [pc, #36]	; (800f760 <spi_lld_init+0x40>)
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 800f73a:	61e0      	str	r0, [r4, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 800f73c:	f103 000c 	add.w	r0, r3, #12
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 800f740:	6223      	str	r3, [r4, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 800f742:	6260      	str	r0, [r4, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 800f744:	62a1      	str	r1, [r4, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 800f746:	62e2      	str	r2, [r4, #44]	; 0x2c
 800f748:	bd10      	pop	{r4, pc}
 800f74a:	bf00      	nop
 800f74c:	20000eb8 	.word	0x20000eb8
 800f750:	20000eb4 	.word	0x20000eb4
 800f754:	08010bb4 	.word	0x08010bb4
 800f758:	40003800 	.word	0x40003800
 800f75c:	00010016 	.word	0x00010016
 800f760:	00010046 	.word	0x00010046
	...

0800f770 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 800f770:	b538      	push	{r3, r4, r5, lr}
 * @param[in] pwmp      pointer to a @p PWMDriver object
 */
static void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 800f772:	4d17      	ldr	r5, [pc, #92]	; (800f7d0 <VectorB4+0x60>)
 800f774:	69ab      	ldr	r3, [r5, #24]
 800f776:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800f778:	68dc      	ldr	r4, [r3, #12]
 800f77a:	4014      	ands	r4, r2
 800f77c:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 800f77e:	43d2      	mvns	r2, r2
 800f780:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800f782:	07a3      	lsls	r3, r4, #30
 800f784:	d504      	bpl.n	800f790 <VectorB4+0x20>
      (pwmp->config->channels[0].callback != NULL))
 800f786:	686b      	ldr	r3, [r5, #4]
 800f788:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800f78a:	b10b      	cbz	r3, 800f790 <VectorB4+0x20>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 800f78c:	4628      	mov	r0, r5
 800f78e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800f790:	0760      	lsls	r0, r4, #29
 800f792:	d504      	bpl.n	800f79e <VectorB4+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 800f794:	686b      	ldr	r3, [r5, #4]
 800f796:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800f798:	b10b      	cbz	r3, 800f79e <VectorB4+0x2e>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 800f79a:	480d      	ldr	r0, [pc, #52]	; (800f7d0 <VectorB4+0x60>)
 800f79c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800f79e:	0721      	lsls	r1, r4, #28
 800f7a0:	d504      	bpl.n	800f7ac <VectorB4+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 800f7a2:	686b      	ldr	r3, [r5, #4]
 800f7a4:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800f7a6:	b10b      	cbz	r3, 800f7ac <VectorB4+0x3c>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 800f7a8:	4809      	ldr	r0, [pc, #36]	; (800f7d0 <VectorB4+0x60>)
 800f7aa:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800f7ac:	06e2      	lsls	r2, r4, #27
 800f7ae:	d504      	bpl.n	800f7ba <VectorB4+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 800f7b0:	686b      	ldr	r3, [r5, #4]
 800f7b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800f7b4:	b10b      	cbz	r3, 800f7ba <VectorB4+0x4a>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 800f7b6:	4806      	ldr	r0, [pc, #24]	; (800f7d0 <VectorB4+0x60>)
 800f7b8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 800f7ba:	07e3      	lsls	r3, r4, #31
 800f7bc:	d504      	bpl.n	800f7c8 <VectorB4+0x58>
 800f7be:	686b      	ldr	r3, [r5, #4]
 800f7c0:	689b      	ldr	r3, [r3, #8]
 800f7c2:	b10b      	cbz	r3, 800f7c8 <VectorB4+0x58>
    pwmp->config->callback(pwmp);
 800f7c4:	4802      	ldr	r0, [pc, #8]	; (800f7d0 <VectorB4+0x60>)
 800f7c6:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
}
 800f7c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
 800f7cc:	f7fd bb40 	b.w	800ce50 <_port_irq_epilogue>
 800f7d0:	20000ee8 	.word	0x20000ee8
	...

0800f7e0 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 800f7e0:	b510      	push	{r4, lr}
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 800f7e2:	4c04      	ldr	r4, [pc, #16]	; (800f7f4 <pwm_lld_init+0x14>)
 800f7e4:	4620      	mov	r0, r4
 800f7e6:	f7fd fc1b 	bl	800d020 <pwmObjectInit>
  PWMD3.channels = STM32_TIM3_CHANNELS;
 800f7ea:	2204      	movs	r2, #4
  PWMD3.tim = STM32_TIM3;
 800f7ec:	4b02      	ldr	r3, [pc, #8]	; (800f7f8 <pwm_lld_init+0x18>)
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
 800f7ee:	7422      	strb	r2, [r4, #16]
  PWMD3.tim = STM32_TIM3;
 800f7f0:	61a3      	str	r3, [r4, #24]
 800f7f2:	bd10      	pop	{r4, pc}
 800f7f4:	20000ee8 	.word	0x20000ee8
 800f7f8:	40000400 	.word	0x40000400
 800f7fc:	00000000 	.word	0x00000000

0800f800 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 800f800:	f7fe babe 	b.w	800dd80 <stm32_clock_init>
	...

0800f810 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 800f810:	4770      	bx	lr
 800f812:	bf00      	nop
	...

0800f820 <halAssyInit>:
 * @param   none
 *
 * @return  none
 */
void halAssyInit(void)
{
 800f820:	b538      	push	{r3, r4, r5, lr}
	CC2520_GPIO0_DIR_OUT();
	CC2520_GPIO1_DIR_OUT();
 800f822:	4d24      	ldr	r5, [pc, #144]	; (800f8b4 <halAssyInit+0x94>)
 *
 * @return  none
 */
void halAssyInit(void)
{
	CC2520_GPIO0_DIR_OUT();
 800f824:	4824      	ldr	r0, [pc, #144]	; (800f8b8 <halAssyInit+0x98>)
	CC2520_GPIO1_DIR_OUT();
	CC2520_GPIO2_DIR_OUT();
	CC2520_GPIO3_DIR_OUT();
 800f826:	4c25      	ldr	r4, [pc, #148]	; (800f8bc <halAssyInit+0x9c>)
 *
 * @return  none
 */
void halAssyInit(void)
{
	CC2520_GPIO0_DIR_OUT();
 800f828:	2180      	movs	r1, #128	; 0x80
 800f82a:	2200      	movs	r2, #0
 800f82c:	f7ff f850 	bl	800e8d0 <_pal_lld_setgroupmode>
	CC2520_GPIO1_DIR_OUT();
 800f830:	4628      	mov	r0, r5
 800f832:	2110      	movs	r1, #16
 800f834:	2200      	movs	r2, #0
 800f836:	f7ff f84b 	bl	800e8d0 <_pal_lld_setgroupmode>
	CC2520_GPIO2_DIR_OUT();
 800f83a:	4628      	mov	r0, r5
 800f83c:	2120      	movs	r1, #32
 800f83e:	2200      	movs	r2, #0
 800f840:	f7ff f846 	bl	800e8d0 <_pal_lld_setgroupmode>
	CC2520_GPIO3_DIR_OUT();
 800f844:	4620      	mov	r0, r4
 800f846:	2101      	movs	r1, #1
 800f848:	2200      	movs	r2, #0
 800f84a:	f7ff f841 	bl	800e8d0 <_pal_lld_setgroupmode>
	CC2520_GPIO4_DIR_OUT();
 800f84e:	4620      	mov	r0, r4
 800f850:	2102      	movs	r1, #2
 800f852:	2200      	movs	r2, #0
 800f854:	f7ff f83c 	bl	800e8d0 <_pal_lld_setgroupmode>
	CC2520_GPIO5_DIR_OUT();
 800f858:	4620      	mov	r0, r4
 800f85a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800f85e:	2200      	movs	r2, #0
 800f860:	f7ff f836 	bl	800e8d0 <_pal_lld_setgroupmode>
 *
 * @return      none
 */
static void halRadioSpiInit(void)
{
	palSetPad(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN);
 800f864:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800f868:	8321      	strh	r1, [r4, #24]
	palSetPadMode(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 800f86a:	4620      	mov	r0, r4
 800f86c:	2219      	movs	r2, #25
 800f86e:	f7ff f82f 	bl	800e8d0 <_pal_lld_setgroupmode>
	CC2520_ENABLE_SPI_FUNC();
 800f872:	4620      	mov	r0, r4
 800f874:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800f878:	2200      	movs	r2, #0
 800f87a:	f7ff f829 	bl	800e8d0 <_pal_lld_setgroupmode>
 800f87e:	4620      	mov	r0, r4
 800f880:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800f884:	2201      	movs	r2, #1
 800f886:	f7ff f823 	bl	800e8d0 <_pal_lld_setgroupmode>
 800f88a:	4620      	mov	r0, r4
 800f88c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800f890:	2201      	movs	r2, #1
 800f892:	f7ff f81d 	bl	800e8d0 <_pal_lld_setgroupmode>
 800f896:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 * @return  none
 */
static void halMcuRfInterfaceInit(void)
{
	// Initialize the CC2520 interface
	CC2520_RESET_OPIN(0);
 800f89a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 */
static void halRadioSpiInit(void)
{
	palSetPad(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN);
	palSetPadMode(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
	CC2520_ENABLE_SPI_FUNC();
 800f89e:	8362      	strh	r2, [r4, #26]
 * @return  none
 */
static void halMcuRfInterfaceInit(void)
{
	// Initialize the CC2520 interface
	CC2520_RESET_OPIN(0);
 800f8a0:	61a3      	str	r3, [r4, #24]
	CC2520_BASIC_IO_DIR_INIT();
 800f8a2:	4620      	mov	r0, r4
 800f8a4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800f8a8:	2219      	movs	r2, #25
	halRadioSpiInit();
	halMcuRfInterfaceInit();
#ifndef MRFI_CC2520
	//halDigioConfig(&pinRadio_GPIO0);
#endif
}
 800f8aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 */
static void halMcuRfInterfaceInit(void)
{
	// Initialize the CC2520 interface
	CC2520_RESET_OPIN(0);
	CC2520_BASIC_IO_DIR_INIT();
 800f8ae:	f7ff b80f 	b.w	800e8d0 <_pal_lld_setgroupmode>
 800f8b2:	bf00      	nop
 800f8b4:	40020800 	.word	0x40020800
 800f8b8:	40020000 	.word	0x40020000
 800f8bc:	40020400 	.word	0x40020400

0800f8c0 <halSpiExc>:
#ifndef MRFI_CC2520
	//halDigioConfig(&pinRadio_GPIO0);
#endif
}

unsigned char halSpiExc(unsigned char x) {
 800f8c0:	b500      	push	{lr}
 800f8c2:	b085      	sub	sp, #20
	unsigned char rx;
#if SPI_USE_SW
	spi_sw_transfer((char*)&rx, (char*)&x, 1);
 800f8c4:	f10d 0107 	add.w	r1, sp, #7
#ifndef MRFI_CC2520
	//halDigioConfig(&pinRadio_GPIO0);
#endif
}

unsigned char halSpiExc(unsigned char x) {
 800f8c8:	f88d 0007 	strb.w	r0, [sp, #7]
	unsigned char rx;
#if SPI_USE_SW
	spi_sw_transfer((char*)&rx, (char*)&x, 1);
 800f8cc:	2201      	movs	r2, #1
 800f8ce:	f10d 000f 	add.w	r0, sp, #15
 800f8d2:	f000 fa5d 	bl	800fd90 <spi_sw_transfer>
#else
	spiExchange(&CC2520_SPI, 1, &x, &rx);
#endif
	return rx;
}
 800f8d6:	f89d 000f 	ldrb.w	r0, [sp, #15]
 800f8da:	b005      	add	sp, #20
 800f8dc:	f85d fb04 	ldr.w	pc, [sp], #4

0800f8e0 <CC2520_INS_STROBE>:
 * @param   uint8 strobe - strobe command
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_INS_STROBE(uint8 strobe)
{
 800f8e0:	b510      	push	{r4, lr}
 800f8e2:	4604      	mov	r4, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 800f8e4:	f000 fa94 	bl	800fe10 <spi_sw_begin>
	s = CC2520_SPI_TXRX(strobe);
 800f8e8:	4620      	mov	r0, r4
 800f8ea:	f7ff ffe9 	bl	800f8c0 <halSpiExc>
 800f8ee:	4604      	mov	r4, r0
	CC2520_SPI_END();
 800f8f0:	f000 fa96 	bl	800fe20 <spi_sw_end>
	return s;
}
 800f8f4:	4620      	mov	r0, r4
 800f8f6:	bd10      	pop	{r4, pc}
	...

0800f900 <CC2520_MEMRD8>:
 * @param   uint16 addr
 *
 * @return  uint8 - result
 */
uint8 CC2520_MEMRD8(uint16 addr)
{
 800f900:	b510      	push	{r4, lr}
 800f902:	4604      	mov	r4, r0
	uint8 value;
	CC2520_SPI_BEGIN();
 800f904:	f000 fa84 	bl	800fe10 <spi_sw_begin>
	CC2520_SPI_TXRX(CC2520_INS_MEMRD | HI_UINT16(addr));
 800f908:	0a20      	lsrs	r0, r4, #8
 800f90a:	f040 0010 	orr.w	r0, r0, #16
 800f90e:	f7ff ffd7 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_TXRX(LO_UINT16(addr));
 800f912:	b2e0      	uxtb	r0, r4
 800f914:	f7ff ffd4 	bl	800f8c0 <halSpiExc>
	value = CC2520_SPI_TXRX(0x00);
 800f918:	2000      	movs	r0, #0
 800f91a:	f7ff ffd1 	bl	800f8c0 <halSpiExc>
 800f91e:	4604      	mov	r4, r0
	CC2520_SPI_END();
 800f920:	f000 fa7e 	bl	800fe20 <spi_sw_end>
	return value;
}
 800f924:	4620      	mov	r0, r4
 800f926:	bd10      	pop	{r4, pc}
	...

0800f930 <CC2520_MEMWR8>:
 *          uint8 value
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_MEMWR8(uint16 addr, uint8 value)
{
 800f930:	b570      	push	{r4, r5, r6, lr}
 800f932:	4604      	mov	r4, r0
 800f934:	460e      	mov	r6, r1
	uint8 s;
	CC2520_SPI_BEGIN();
 800f936:	f000 fa6b 	bl	800fe10 <spi_sw_begin>
	s = CC2520_SPI_TXRX(CC2520_INS_MEMWR | HI_UINT16(addr));
 800f93a:	0a20      	lsrs	r0, r4, #8
 800f93c:	f040 0020 	orr.w	r0, r0, #32
 800f940:	f7ff ffbe 	bl	800f8c0 <halSpiExc>
 800f944:	4605      	mov	r5, r0
	CC2520_SPI_TXRX(LO_UINT16(addr));
 800f946:	b2e0      	uxtb	r0, r4
 800f948:	f7ff ffba 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_TXRX(value);
 800f94c:	4630      	mov	r0, r6
 800f94e:	f7ff ffb7 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_END();
 800f952:	f000 fa65 	bl	800fe20 <spi_sw_end>
	return s;
}
 800f956:	4628      	mov	r0, r5
 800f958:	bd70      	pop	{r4, r5, r6, pc}
 800f95a:	bf00      	nop
 800f95c:	0000      	movs	r0, r0
	...

0800f960 <CC2520_MEMWR16>:
 *          uint16 value
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_MEMWR16(uint16 addr, uint16 value)
{
 800f960:	b570      	push	{r4, r5, r6, lr}
 800f962:	4605      	mov	r5, r0
 800f964:	460c      	mov	r4, r1
	uint8 s;
	CC2520_SPI_BEGIN();
 800f966:	f000 fa53 	bl	800fe10 <spi_sw_begin>
	s = CC2520_SPI_TXRX(CC2520_INS_MEMWR | HI_UINT16(addr));
 800f96a:	0a28      	lsrs	r0, r5, #8
 800f96c:	f040 0020 	orr.w	r0, r0, #32
 800f970:	f7ff ffa6 	bl	800f8c0 <halSpiExc>
 800f974:	4606      	mov	r6, r0
	CC2520_SPI_TXRX(LO_UINT16(addr));
 800f976:	b2e8      	uxtb	r0, r5
 800f978:	f7ff ffa2 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_TXRX(LO_UINT16(value));
 800f97c:	b2e0      	uxtb	r0, r4
 800f97e:	f7ff ff9f 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_TXRX(HI_UINT16(value));
 800f982:	0a20      	lsrs	r0, r4, #8
 800f984:	f7ff ff9c 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_END();
 800f988:	f000 fa4a 	bl	800fe20 <spi_sw_end>
	return s;
}
 800f98c:	4630      	mov	r0, r6
 800f98e:	bd70      	pop	{r4, r5, r6, pc}

0800f990 <CC2520_RXBUF>:
 *          uint8  *pData
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_RXBUF(uint8 count, uint8  *pData)
{
 800f990:	b570      	push	{r4, r5, r6, lr}
 800f992:	460e      	mov	r6, r1
 800f994:	4605      	mov	r5, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 800f996:	f000 fa3b 	bl	800fe10 <spi_sw_begin>
	s = CC2520_SPI_TXRX(CC2520_INS_RXBUF);
 800f99a:	2030      	movs	r0, #48	; 0x30
 800f99c:	f7ff ff90 	bl	800f8c0 <halSpiExc>
	CC2520_INS_RD_ARRAY(count, pData);
 800f9a0:	462a      	mov	r2, r5
 */
uint8 CC2520_RXBUF(uint8 count, uint8  *pData)
{
	uint8 s;
	CC2520_SPI_BEGIN();
	s = CC2520_SPI_TXRX(CC2520_INS_RXBUF);
 800f9a2:	4604      	mov	r4, r0
	CC2520_INS_RD_ARRAY(count, pData);
 800f9a4:	2100      	movs	r1, #0
 800f9a6:	4630      	mov	r0, r6
 800f9a8:	f000 f9f2 	bl	800fd90 <spi_sw_transfer>
	CC2520_SPI_END();
 800f9ac:	f000 fa38 	bl	800fe20 <spi_sw_end>
	return s;
}
 800f9b0:	4620      	mov	r0, r4
 800f9b2:	bd70      	pop	{r4, r5, r6, pc}
	...

0800f9c0 <CC2520_RXBUF8>:
 * @param   none
 *
 * @return  uint8 - result
 */
uint8 CC2520_RXBUF8(void)
{
 800f9c0:	b510      	push	{r4, lr}
	uint8 value;
	CC2520_SPI_BEGIN();
 800f9c2:	f000 fa25 	bl	800fe10 <spi_sw_begin>
	CC2520_SPI_TXRX(CC2520_INS_RXBUF);
 800f9c6:	2030      	movs	r0, #48	; 0x30
 800f9c8:	f7ff ff7a 	bl	800f8c0 <halSpiExc>
	value = CC2520_SPI_TXRX(0x00);
 800f9cc:	2000      	movs	r0, #0
 800f9ce:	f7ff ff77 	bl	800f8c0 <halSpiExc>
 800f9d2:	4604      	mov	r4, r0
	CC2520_SPI_END();
 800f9d4:	f000 fa24 	bl	800fe20 <spi_sw_end>
	return value;
}
 800f9d8:	4620      	mov	r0, r4
 800f9da:	bd10      	pop	{r4, pc}
 800f9dc:	0000      	movs	r0, r0
	...

0800f9e0 <CC2520_TXBUF>:
 *          uint8  *pData - pointer to data buffer
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_TXBUF(uint8 count, uint8  *pData)
{
 800f9e0:	b570      	push	{r4, r5, r6, lr}
 800f9e2:	4605      	mov	r5, r0
 800f9e4:	460e      	mov	r6, r1
	uint8 s;
	CC2520_SPI_BEGIN();
 800f9e6:	f000 fa13 	bl	800fe10 <spi_sw_begin>
	s = CC2520_SPI_TXRX(CC2520_INS_TXBUF);
 800f9ea:	203a      	movs	r0, #58	; 0x3a
 800f9ec:	f7ff ff68 	bl	800f8c0 <halSpiExc>
	CC2520_INS_WR_ARRAY(count, pData);
 800f9f0:	4631      	mov	r1, r6
 */
uint8 CC2520_TXBUF(uint8 count, uint8  *pData)
{
	uint8 s;
	CC2520_SPI_BEGIN();
	s = CC2520_SPI_TXRX(CC2520_INS_TXBUF);
 800f9f2:	4604      	mov	r4, r0
	CC2520_INS_WR_ARRAY(count, pData);
 800f9f4:	462a      	mov	r2, r5
 800f9f6:	2000      	movs	r0, #0
 800f9f8:	f000 f9ca 	bl	800fd90 <spi_sw_transfer>
	CC2520_SPI_END();
 800f9fc:	f000 fa10 	bl	800fe20 <spi_sw_end>
	return s;
}
 800fa00:	4620      	mov	r0, r4
 800fa02:	bd70      	pop	{r4, r5, r6, pc}
	...

0800fa10 <CC2520_BCLR>:
 * @param  uint8 bitAddr - address
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_BCLR(uint8 bitAddr)
{
 800fa10:	b538      	push	{r3, r4, r5, lr}
 800fa12:	4605      	mov	r5, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 800fa14:	f000 f9fc 	bl	800fe10 <spi_sw_begin>
	s = CC2520_SPI_TXRX(CC2520_INS_BCLR);
 800fa18:	2058      	movs	r0, #88	; 0x58
 800fa1a:	f7ff ff51 	bl	800f8c0 <halSpiExc>
 800fa1e:	4604      	mov	r4, r0
	CC2520_SPI_TXRX(bitAddr);
 800fa20:	4628      	mov	r0, r5
 800fa22:	f7ff ff4d 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_END();
 800fa26:	f000 f9fb 	bl	800fe20 <spi_sw_end>
	return s;
}
 800fa2a:	4620      	mov	r0, r4
 800fa2c:	bd38      	pop	{r3, r4, r5, pc}
 800fa2e:	bf00      	nop

0800fa30 <CC2520_REGRD8>:
 * @param  uint8 addr - address
 *
 * @return  uint8 - result
 */
uint8 CC2520_REGRD8(uint8 addr)
{
 800fa30:	b510      	push	{r4, lr}
 800fa32:	4604      	mov	r4, r0
	uint8 value;
	CC2520_SPI_BEGIN();
 800fa34:	f000 f9ec 	bl	800fe10 <spi_sw_begin>
	CC2520_SPI_TXRX(CC2520_INS_REGRD | addr);
 800fa38:	f044 0080 	orr.w	r0, r4, #128	; 0x80
 800fa3c:	f7ff ff40 	bl	800f8c0 <halSpiExc>
	value = CC2520_SPI_TXRX(0x00);
 800fa40:	2000      	movs	r0, #0
 800fa42:	f7ff ff3d 	bl	800f8c0 <halSpiExc>
 800fa46:	4604      	mov	r4, r0
	CC2520_SPI_END();
 800fa48:	f000 f9ea 	bl	800fe20 <spi_sw_end>
	return value;
}
 800fa4c:	4620      	mov	r0, r4
 800fa4e:	bd10      	pop	{r4, pc}

0800fa50 <CC2520_REGWR8>:
 *         uint8 value
 *
 * @return  none
 */
void CC2520_REGWR8(uint8 addr, uint8 value)
{
 800fa50:	b538      	push	{r3, r4, r5, lr}
 800fa52:	4605      	mov	r5, r0
 800fa54:	460c      	mov	r4, r1
	CC2520_SPI_BEGIN();
 800fa56:	f000 f9db 	bl	800fe10 <spi_sw_begin>
	CC2520_SPI_TXRX(CC2520_INS_REGWR | addr);
 800fa5a:	f045 00c0 	orr.w	r0, r5, #192	; 0xc0
 800fa5e:	f7ff ff2f 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_TXRX(value);
 800fa62:	4620      	mov	r0, r4
 800fa64:	f7ff ff2c 	bl	800f8c0 <halSpiExc>
	CC2520_SPI_END();
	return;
}
 800fa68:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void CC2520_REGWR8(uint8 addr, uint8 value)
{
	CC2520_SPI_BEGIN();
	CC2520_SPI_TXRX(CC2520_INS_REGWR | addr);
	CC2520_SPI_TXRX(value);
	CC2520_SPI_END();
 800fa6c:	f000 b9d8 	b.w	800fe20 <spi_sw_end>

0800fa70 <isrThread>:
	chSysLockFromISR();
	chEvtSignalI(isr_tp, (eventmask_t) 1);
	chSysUnlockFromISR();
}

static THD_FUNCTION(isrThread, arg) {
 800fa70:	b508      	push	{r3, lr}
 800fa72:	4b07      	ldr	r3, [pc, #28]	; (800fa90 <isrThread+0x20>)
	(void) arg;
	chRegSetThreadName("CC2520 EXTI");

	isr_tp = chThdGetSelfX();
 800fa74:	4a07      	ldr	r2, [pc, #28]	; (800fa94 <isrThread+0x24>)
 800fa76:	699b      	ldr	r3, [r3, #24]
 800fa78:	4907      	ldr	r1, [pc, #28]	; (800fa98 <isrThread+0x28>)
 800fa7a:	4c08      	ldr	r4, [pc, #32]	; (800fa9c <isrThread+0x2c>)
 800fa7c:	6199      	str	r1, [r3, #24]
 800fa7e:	6013      	str	r3, [r2, #0]

	for (;;) {
		chEvtWaitAny((eventmask_t) 1);
 800fa80:	2001      	movs	r0, #1
 800fa82:	f7fd f88d 	bl	800cba0 <chEvtWaitAny>

		if (gpio0_func) {
 800fa86:	6823      	ldr	r3, [r4, #0]
 800fa88:	2b00      	cmp	r3, #0
 800fa8a:	d0f9      	beq.n	800fa80 <isrThread+0x10>
			gpio0_func();
 800fa8c:	4798      	blx	r3
 800fa8e:	e7f7      	b.n	800fa80 <isrThread+0x10>
 800fa90:	20000838 	.word	0x20000838
 800fa94:	200014a0 	.word	0x200014a0
 800fa98:	08010da0 	.word	0x08010da0
 800fa9c:	200014a4 	.word	0x200014a4

0800faa0 <halRfGetRssiOffset>:
 * @param   none
 *
 * @return  uint8 - RSSI offset
 */
uint8 halRfGetRssiOffset(void) {
	return rssiOffset;
 800faa0:	4b01      	ldr	r3, [pc, #4]	; (800faa8 <halRfGetRssiOffset+0x8>)
}
 800faa2:	7818      	ldrb	r0, [r3, #0]
 800faa4:	4770      	bx	lr
 800faa6:	bf00      	nop
 800faa8:	20000836 	.word	0x20000836
 800faac:	00000000 	.word	0x00000000

0800fab0 <halRfSetChannel>:
 * @param   channel - logical channel number
 *
 * @return  none
 */
void halRfSetChannel(uint8 channel) {
	CC2520_REGWR8(CC2520_FREQCTRL,
 800fab0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800fab4:	f1a0 012c 	sub.w	r1, r0, #44	; 0x2c
 800fab8:	b2c9      	uxtb	r1, r1
 800faba:	202e      	movs	r0, #46	; 0x2e
 800fabc:	f7ff bfc8 	b.w	800fa50 <CC2520_REGWR8>

0800fac0 <halRfSetShortAddr>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfSetShortAddr(uint16 shortAddr) {
 800fac0:	4601      	mov	r1, r0
	CC2520_MEMWR16(CC2520_RAM_SHORTADDR, shortAddr);
 800fac2:	f44f 707d 	mov.w	r0, #1012	; 0x3f4
 800fac6:	f7ff bf4b 	b.w	800f960 <CC2520_MEMWR16>
 800faca:	bf00      	nop
 800facc:	0000      	movs	r0, r0
	...

0800fad0 <halRfSetPanId>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfSetPanId(uint16 panId) {
 800fad0:	4601      	mov	r1, r0
	CC2520_MEMWR16(CC2520_RAM_PANID, panId);
 800fad2:	f240 30f2 	movw	r0, #1010	; 0x3f2
 800fad6:	f7ff bf43 	b.w	800f960 <CC2520_MEMWR16>
 800fada:	bf00      	nop
 800fadc:	0000      	movs	r0, r0
	...

0800fae0 <halRfWriteTxBuf>:
 * @param   uint8* data - buffer to write
 *          uint8 length - number of bytes
 *
 * @return  none
 */
void halRfWriteTxBuf(uint8* data, uint8 length) {
 800fae0:	4603      	mov	r3, r0
	// Copy packet to TX FIFO
	CC2520_TXBUF(length, data);
 800fae2:	4608      	mov	r0, r1
 800fae4:	4619      	mov	r1, r3
 800fae6:	f7ff bf7b 	b.w	800f9e0 <CC2520_TXBUF>
 800faea:	bf00      	nop
 800faec:	0000      	movs	r0, r0
	...

0800faf0 <halRfReadRxBuf>:
 * @param   uint8* pData - data buffer. This must be allocated by caller.
 *          uint8 length - number of bytes
 *
 * @return  none
 */
void halRfReadRxBuf(uint8* pData, uint8 length) {
 800faf0:	4603      	mov	r3, r0
	CC2520_RXBUF(length, pData);
 800faf2:	4608      	mov	r0, r1
 800faf4:	4619      	mov	r1, r3
 800faf6:	f7ff bf4b 	b.w	800f990 <CC2520_RXBUF>
 800fafa:	bf00      	nop
 800fafc:	0000      	movs	r0, r0
	...

0800fb00 <halRfTransmit>:
 *
 * @param   none
 *
 * @return  uint8 - SUCCESS or FAILED
 */
uint8 halRfTransmit(void) {
 800fb00:	b538      	push	{r3, r4, r5, lr}
	uint8 status = 0;

	PA_RX();

	// Wait for RSSI to become valid
	while(!CC2520_RSSI_VALID_PIN){}
 800fb02:	4a1a      	ldr	r2, [pc, #104]	; (800fb6c <halRfTransmit+0x6c>)
 800fb04:	6913      	ldr	r3, [r2, #16]
 800fb06:	0699      	lsls	r1, r3, #26
 800fb08:	d5fc      	bpl.n	800fb04 <halRfTransmit+0x4>

	// Reuse GPIO2 for TX_FRM_DONE exception
	CC2520_CFG_GPIO_OUT(2, 1 + CC2520_EXC_TX_FRM_DONE);
 800fb0a:	2022      	movs	r0, #34	; 0x22
 800fb0c:	2102      	movs	r1, #2
 800fb0e:	f7ff ff9f 	bl	800fa50 <CC2520_REGWR8>
 800fb12:	4816      	ldr	r0, [pc, #88]	; (800fb6c <halRfTransmit+0x6c>)
 800fb14:	2120      	movs	r1, #32
 800fb16:	2200      	movs	r2, #0

	// Wait for the transmission to begin before exiting (makes sure that this function cannot be called
	// a second time, and thereby canceling the first transmission.
	while (--timeout > 0) {
		CC2520_INS_STROBE(CC2520_INS_STXONCCA);
		if (CC2520_SAMPLED_CCA_PIN) {
 800fb18:	4605      	mov	r5, r0

	// Wait for RSSI to become valid
	while(!CC2520_RSSI_VALID_PIN){}

	// Reuse GPIO2 for TX_FRM_DONE exception
	CC2520_CFG_GPIO_OUT(2, 1 + CC2520_EXC_TX_FRM_DONE);
 800fb1a:	f240 14f3 	movw	r4, #499	; 0x1f3
 800fb1e:	f7fe fed7 	bl	800e8d0 <_pal_lld_setgroupmode>
 800fb22:	e004      	b.n	800fb2e <halRfTransmit+0x2e>

	// Wait for the transmission to begin before exiting (makes sure that this function cannot be called
	// a second time, and thereby canceling the first transmission.
	while (--timeout > 0) {
 800fb24:	3c01      	subs	r4, #1
 800fb26:	b2a4      	uxth	r4, r4
		if (CC2520_SAMPLED_CCA_PIN) {
			PA_TX();
			break;
		}

		chThdSleepMicroseconds(100);
 800fb28:	f7fc fe8a 	bl	800c840 <chThdSleep>
	// Reuse GPIO2 for TX_FRM_DONE exception
	CC2520_CFG_GPIO_OUT(2, 1 + CC2520_EXC_TX_FRM_DONE);

	// Wait for the transmission to begin before exiting (makes sure that this function cannot be called
	// a second time, and thereby canceling the first transmission.
	while (--timeout > 0) {
 800fb2c:	b1c4      	cbz	r4, 800fb60 <halRfTransmit+0x60>
		CC2520_INS_STROBE(CC2520_INS_STXONCCA);
 800fb2e:	2044      	movs	r0, #68	; 0x44
 800fb30:	f7ff fed6 	bl	800f8e0 <CC2520_INS_STROBE>
		if (CC2520_SAMPLED_CCA_PIN) {
 800fb34:	692b      	ldr	r3, [r5, #16]
 800fb36:	06da      	lsls	r2, r3, #27
			PA_TX();
			break;
		}

		chThdSleepMicroseconds(100);
 800fb38:	f04f 0001 	mov.w	r0, #1

	// Wait for the transmission to begin before exiting (makes sure that this function cannot be called
	// a second time, and thereby canceling the first transmission.
	while (--timeout > 0) {
		CC2520_INS_STROBE(CC2520_INS_STXONCCA);
		if (CC2520_SAMPLED_CCA_PIN) {
 800fb3c:	d5f2      	bpl.n	800fb24 <halRfTransmit+0x24>
		}

		chThdSleepMicroseconds(100);
	}

	if (timeout == 0) {
 800fb3e:	b17c      	cbz	r4, 800fb60 <halRfTransmit+0x60>
		status = FAILED;
		CC2520_INS_STROBE(CC2520_INS_SFLUSHTX);
	} else {
		status = SUCCESS;
		// Wait for TX_FRM_DONE exception
		while(!CC2520_TX_FRM_DONE_PIN){};
 800fb40:	4a0a      	ldr	r2, [pc, #40]	; (800fb6c <halRfTransmit+0x6c>)
 800fb42:	6913      	ldr	r3, [r2, #16]
 800fb44:	069b      	lsls	r3, r3, #26
 800fb46:	d5fc      	bpl.n	800fb42 <halRfTransmit+0x42>

	if (timeout == 0) {
		status = FAILED;
		CC2520_INS_STROBE(CC2520_INS_SFLUSHTX);
	} else {
		status = SUCCESS;
 800fb48:	2400      	movs	r4, #0
	}

	PA_RX();

	// Reconfigure GPIO2
	CC2520_CFG_GPIO_OUT(2, CC2520_GPIO_RSSI_VALID);
 800fb4a:	2022      	movs	r0, #34	; 0x22
 800fb4c:	212c      	movs	r1, #44	; 0x2c
 800fb4e:	f7ff ff7f 	bl	800fa50 <CC2520_REGWR8>
 800fb52:	4806      	ldr	r0, [pc, #24]	; (800fb6c <halRfTransmit+0x6c>)
 800fb54:	2120      	movs	r1, #32
 800fb56:	2200      	movs	r2, #0
 800fb58:	f7fe feba 	bl	800e8d0 <_pal_lld_setgroupmode>

	return status;
}
 800fb5c:	4620      	mov	r0, r4
 800fb5e:	bd38      	pop	{r3, r4, r5, pc}
		chThdSleepMicroseconds(100);
	}

	if (timeout == 0) {
		status = FAILED;
		CC2520_INS_STROBE(CC2520_INS_SFLUSHTX);
 800fb60:	2048      	movs	r0, #72	; 0x48
 800fb62:	f7ff febd 	bl	800f8e0 <CC2520_INS_STROBE>

		chThdSleepMicroseconds(100);
	}

	if (timeout == 0) {
		status = FAILED;
 800fb66:	2401      	movs	r4, #1
 800fb68:	e7ef      	b.n	800fb4a <halRfTransmit+0x4a>
 800fb6a:	bf00      	nop
 800fb6c:	40020800 	.word	0x40020800

0800fb70 <halRfRxInterruptConfig>:
	HAL_INT_OFF();
}

void halRfRxInterruptConfig(void (*func)(void)) {
	// Set function pointer
	gpio0_func = func;
 800fb70:	4b02      	ldr	r3, [pc, #8]	; (800fb7c <halRfRxInterruptConfig+0xc>)
 800fb72:	6018      	str	r0, [r3, #0]

	CLEAR_EXC_RX_FRM_DONE();
 800fb74:	2088      	movs	r0, #136	; 0x88
 800fb76:	f7ff bf4b 	b.w	800fa10 <CC2520_BCLR>
 800fb7a:	bf00      	nop
 800fb7c:	200014a4 	.word	0x200014a4

0800fb80 <halRfDisableRxInterrupt>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfDisableRxInterrupt(void) {
 800fb80:	b508      	push	{r3, lr}
	CLEAR_EXC_RX_FRM_DONE();
 800fb82:	2088      	movs	r0, #136	; 0x88
 800fb84:	f7ff ff44 	bl	800fa10 <CC2520_BCLR>
	extChannelDisable(&EXTD1, 9);
 800fb88:	4802      	ldr	r0, [pc, #8]	; (800fb94 <halRfDisableRxInterrupt+0x14>)
 800fb8a:	2109      	movs	r1, #9
}
 800fb8c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 *
 * @return  none
 */
void halRfDisableRxInterrupt(void) {
	CLEAR_EXC_RX_FRM_DONE();
	extChannelDisable(&EXTD1, 9);
 800fb90:	f7fd ba26 	b.w	800cfe0 <extChannelDisable>
 800fb94:	20000b70 	.word	0x20000b70
	...

0800fba0 <halRfInit>:
 *
 * @param   none
 *
 * @return  SUCCESS if the radio has started, FAILURE otherwise
 */
uint8 halRfInit(void) {
 800fba0:	b570      	push	{r4, r5, r6, lr}
	regVal_t* p;
	uint8 val;

#ifdef INCLUDE_PA
	PA_HGM_OUT();
 800fba2:	4d29      	ldr	r5, [pc, #164]	; (800fc48 <halRfInit+0xa8>)

	// Avoid GPIO0 interrupts during reset
	halRfDisableRxInterrupt();

	// Make sure to pull the CC2520 RESETn pin low
	CC2520_RESET_OPIN(0);
 800fba4:	4c29      	ldr	r4, [pc, #164]	; (800fc4c <halRfInit+0xac>)
 *
 * @param   none
 *
 * @return  SUCCESS if the radio has started, FAILURE otherwise
 */
uint8 halRfInit(void) {
 800fba6:	b082      	sub	sp, #8
	regVal_t* p;
	uint8 val;

#ifdef INCLUDE_PA
	PA_HGM_OUT();
 800fba8:	2110      	movs	r1, #16
 800fbaa:	2219      	movs	r2, #25
 800fbac:	4628      	mov	r0, r5
 800fbae:	f7fe fe8f 	bl	800e8d0 <_pal_lld_setgroupmode>
	PA_OFF();
#endif
#endif

	// High gain mode by default
	HAL_PA_LNA_RX_HGM();
 800fbb2:	2310      	movs	r3, #16
 800fbb4:	61ab      	str	r3, [r5, #24]

	// Avoid GPIO0 interrupts during reset
	halRfDisableRxInterrupt();
 800fbb6:	f7ff ffe3 	bl	800fb80 <halRfDisableRxInterrupt>

	// Make sure to pull the CC2520 RESETn pin low
	CC2520_RESET_OPIN(0);
 800fbba:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800fbbe:	61a3      	str	r3, [r4, #24]
	CC2520_SPI_END();
 800fbc0:	f000 f92e 	bl	800fe20 <spi_sw_end>
	chThdSleepMilliseconds(2);
 800fbc4:	2014      	movs	r0, #20
 800fbc6:	f7fc fe3b 	bl	800c840 <chThdSleep>

	// Make sure MISO is configured as output.
	CC2520_MISO_DIR_OUT();
 800fbca:	4620      	mov	r0, r4
 800fbcc:	2200      	movs	r2, #0
 800fbce:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800fbd2:	f7fe fe7d 	bl	800e8d0 <_pal_lld_setgroupmode>

	// Release reset
	CC2520_RESET_OPIN(1);
 800fbd6:	f44f 6200 	mov.w	r2, #2048	; 0x800
static uint8 halRfWaitRadioReady(void) {
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
 800fbda:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000

	// Make sure MISO is configured as output.
	CC2520_MISO_DIR_OUT();

	// Release reset
	CC2520_RESET_OPIN(1);
 800fbde:	61a2      	str	r2, [r4, #24]
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
 800fbe0:	4626      	mov	r6, r4
static uint8 halRfWaitRadioReady(void) {
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
 800fbe2:	61a3      	str	r3, [r4, #24]
 800fbe4:	2432      	movs	r4, #50	; 0x32
 800fbe6:	e005      	b.n	800fbf4 <halRfInit+0x54>
	while (i > 0 && !CC2520_MISO_IPIN) {
		chThdSleepMicroseconds(100);
 800fbe8:	f7fc fe2a 	bl	800c840 <chThdSleep>
 800fbec:	1e63      	subs	r3, r4, #1
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
 800fbee:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 800fbf2:	d023      	beq.n	800fc3c <halRfInit+0x9c>
 800fbf4:	6933      	ldr	r3, [r6, #16]
 800fbf6:	4d15      	ldr	r5, [pc, #84]	; (800fc4c <halRfInit+0xac>)
 800fbf8:	041b      	lsls	r3, r3, #16
		chThdSleepMicroseconds(100);
 800fbfa:	f04f 0001 	mov.w	r0, #1
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
 800fbfe:	d5f3      	bpl.n	800fbe8 <halRfInit+0x48>
		chThdSleepMicroseconds(100);
		--i;
	}
	CC2520_CSN_OPIN(1);
 800fc00:	f44f 5380 	mov.w	r3, #4096	; 0x1000
		return FAILED;
	}

	// Write non-default register values
	p = regval;
	while (p->reg != 0) {
 800fc04:	4c12      	ldr	r4, [pc, #72]	; (800fc50 <halRfInit+0xb0>)
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
		chThdSleepMicroseconds(100);
		--i;
	}
	CC2520_CSN_OPIN(1);
 800fc06:	61ab      	str	r3, [r5, #24]
		return FAILED;
	}

	// Write non-default register values
	p = regval;
	while (p->reg != 0) {
 800fc08:	7820      	ldrb	r0, [r4, #0]
 800fc0a:	b130      	cbz	r0, 800fc1a <halRfInit+0x7a>
		CC2520_MEMWR8(p->reg, p->val);
 800fc0c:	7861      	ldrb	r1, [r4, #1]
 800fc0e:	f7ff fe8f 	bl	800f930 <CC2520_MEMWR8>
		return FAILED;
	}

	// Write non-default register values
	p = regval;
	while (p->reg != 0) {
 800fc12:	f814 0f02 	ldrb.w	r0, [r4, #2]!
 800fc16:	2800      	cmp	r0, #0
 800fc18:	d1f8      	bne.n	800fc0c <halRfInit+0x6c>
		CC2520_MEMWR8(p->reg, p->val);
		p++;
	}

	// ISR Thread
	chThdCreateStatic(waIsrTx, sizeof(waIsrTx), NORMALPRIO + 2, isrThread, NULL);
 800fc1a:	2300      	movs	r3, #0
 800fc1c:	9300      	str	r3, [sp, #0]
 800fc1e:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 800fc22:	4b0c      	ldr	r3, [pc, #48]	; (800fc54 <halRfInit+0xb4>)
 800fc24:	480c      	ldr	r0, [pc, #48]	; (800fc58 <halRfInit+0xb8>)
 800fc26:	2242      	movs	r2, #66	; 0x42
 800fc28:	f7fc fdca 	bl	800c7c0 <chThdCreateStatic>

	// Verify a register
	val = CC2520_MEMRD8(CC2520_MDMCTRL0);
 800fc2c:	2046      	movs	r0, #70	; 0x46
 800fc2e:	f7ff fe67 	bl	800f900 <CC2520_MEMRD8>
	return val == 0x85 ? SUCCESS : FAILED;
 800fc32:	3885      	subs	r0, #133	; 0x85
 800fc34:	bf18      	it	ne
 800fc36:	2001      	movne	r0, #1
}
 800fc38:	b002      	add	sp, #8
 800fc3a:	bd70      	pop	{r4, r5, r6, pc}
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
		chThdSleepMicroseconds(100);
		--i;
	}
	CC2520_CSN_OPIN(1);
 800fc3c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
	// Release reset
	CC2520_RESET_OPIN(1);

	// Wait for XOSC stable to be announced on the MISO pin
	if (halRfWaitRadioReady() == FAILED) {
		return FAILED;
 800fc40:	2001      	movs	r0, #1
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
		chThdSleepMicroseconds(100);
		--i;
	}
	CC2520_CSN_OPIN(1);
 800fc42:	61ab      	str	r3, [r5, #24]
	chThdCreateStatic(waIsrTx, sizeof(waIsrTx), NORMALPRIO + 2, isrThread, NULL);

	// Verify a register
	val = CC2520_MEMRD8(CC2520_MDMCTRL0);
	return val == 0x85 ? SUCCESS : FAILED;
}
 800fc44:	b002      	add	sp, #8
 800fc46:	bd70      	pop	{r4, r5, r6, pc}
 800fc48:	40020000 	.word	0x40020000
 800fc4c:	40020400 	.word	0x40020400
 800fc50:	20000808 	.word	0x20000808
 800fc54:	0800fa71 	.word	0x0800fa71
 800fc58:	20000f08 	.word	0x20000f08
 800fc5c:	00000000 	.word	0x00000000

0800fc60 <halRfReceiveOn>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfReceiveOn(void) {
 800fc60:	b510      	push	{r4, lr}
	PA_RX();

	/* Flush RX FIFO if needed.
	 * See bug #1 in http://www.ti.com/lit/er/swrz024/swrz024.pdf */
	halRfDisableRxInterrupt();
 800fc62:	f7ff ff8d 	bl	800fb80 <halRfDisableRxInterrupt>
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 800fc66:	2047      	movs	r0, #71	; 0x47
 800fc68:	f7ff fe3a 	bl	800f8e0 <CC2520_INS_STROBE>
	uint8_t rx_fifo_cnt = CC2520_REGRD8(CC2520_RXFIFOCNT);
 800fc6c:	203e      	movs	r0, #62	; 0x3e
 800fc6e:	f7ff fedf 	bl	800fa30 <CC2520_REGRD8>
 800fc72:	4604      	mov	r4, r0

	CC2520_INS_STROBE(CC2520_INS_SRXON);
 800fc74:	2042      	movs	r0, #66	; 0x42
 800fc76:	f7ff fe33 	bl	800f8e0 <CC2520_INS_STROBE>

	if (rx_fifo_cnt != CC2520_REGRD8(CC2520_RXFIFOCNT)) {
 800fc7a:	203e      	movs	r0, #62	; 0x3e
 800fc7c:	f7ff fed8 	bl	800fa30 <CC2520_REGRD8>
 800fc80:	42a0      	cmp	r0, r4
 800fc82:	d002      	beq.n	800fc8a <halRfReceiveOn+0x2a>
		CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 800fc84:	2047      	movs	r0, #71	; 0x47
 800fc86:	f7ff fe2b 	bl	800f8e0 <CC2520_INS_STROBE>
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 7);
 800fc8a:	4803      	ldr	r0, [pc, #12]	; (800fc98 <halRfReceiveOn+0x38>)
 800fc8c:	2107      	movs	r1, #7

	if (rx_fifo_cnt != CC2520_REGRD8(CC2520_RXFIFOCNT)) {
		CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
	}
	halRfEnableRxInterrupt();
}
 800fc8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 7);
 800fc92:	f7fd b99d 	b.w	800cfd0 <extChannelEnable>
 800fc96:	bf00      	nop
 800fc98:	20000b70 	.word	0x20000b70
 800fc9c:	00000000 	.word	0x00000000

0800fca0 <halRfReceiveOff>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfReceiveOff(void) {
 800fca0:	b510      	push	{r4, lr}
	PA_OFF();

	/* Flush RX FIFO if needed.
	 * See bug #1 in http://www.ti.com/lit/er/swrz024/swrz024.pdf */
	halRfDisableRxInterrupt();
 800fca2:	f7ff ff6d 	bl	800fb80 <halRfDisableRxInterrupt>
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 800fca6:	2047      	movs	r0, #71	; 0x47
 800fca8:	f7ff fe1a 	bl	800f8e0 <CC2520_INS_STROBE>
	uint8_t rx_fifo_cnt = CC2520_REGRD8(CC2520_RXFIFOCNT);
 800fcac:	203e      	movs	r0, #62	; 0x3e
 800fcae:	f7ff febf 	bl	800fa30 <CC2520_REGRD8>
 800fcb2:	4604      	mov	r4, r0

	CC2520_INS_STROBE(CC2520_INS_SRFOFF);
 800fcb4:	2045      	movs	r0, #69	; 0x45
 800fcb6:	f7ff fe13 	bl	800f8e0 <CC2520_INS_STROBE>

	if (rx_fifo_cnt != CC2520_REGRD8(CC2520_RXFIFOCNT)) {
 800fcba:	203e      	movs	r0, #62	; 0x3e
 800fcbc:	f7ff feb8 	bl	800fa30 <CC2520_REGRD8>
 800fcc0:	42a0      	cmp	r0, r4
 800fcc2:	d002      	beq.n	800fcca <halRfReceiveOff+0x2a>
		CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 800fcc4:	2047      	movs	r0, #71	; 0x47
 800fcc6:	f7ff fe0b 	bl	800f8e0 <CC2520_INS_STROBE>
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 7);
 800fcca:	4803      	ldr	r0, [pc, #12]	; (800fcd8 <halRfReceiveOff+0x38>)
 800fccc:	2107      	movs	r1, #7
		CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
		// Software clean-up
		// Reset software for frame reception...
	}
	halRfEnableRxInterrupt();
}
 800fcce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 7);
 800fcd2:	f7fd b97d 	b.w	800cfd0 <extChannelEnable>
 800fcd6:	bf00      	nop
 800fcd8:	20000b70 	.word	0x20000b70
 800fcdc:	00000000 	.word	0x00000000

0800fce0 <halRfFlushRx>:
		// Reset software for frame reception...
	}
	halRfEnableRxInterrupt();
}

void halRfFlushRx(void) {
 800fce0:	b508      	push	{r3, lr}
	/* Flush RX FIFO twice instead of once. See bug #1 in
	 * http://www.ti.com/lit/er/swrz024/swrz024.pdf */
	halRfDisableRxInterrupt();
 800fce2:	f7ff ff4d 	bl	800fb80 <halRfDisableRxInterrupt>
	CC2520_RXBUF8();
 800fce6:	f7ff fe6b 	bl	800f9c0 <CC2520_RXBUF8>
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 800fcea:	2047      	movs	r0, #71	; 0x47
 800fcec:	f7ff fdf8 	bl	800f8e0 <CC2520_INS_STROBE>
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 800fcf0:	2047      	movs	r0, #71	; 0x47
 800fcf2:	f7ff fdf5 	bl	800f8e0 <CC2520_INS_STROBE>
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 7);
 800fcf6:	4803      	ldr	r0, [pc, #12]	; (800fd04 <halRfFlushRx+0x24>)
 800fcf8:	2107      	movs	r1, #7
	halRfDisableRxInterrupt();
	CC2520_RXBUF8();
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
	halRfEnableRxInterrupt();
}
 800fcfa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 7);
 800fcfe:	f7fd b967 	b.w	800cfd0 <extChannelEnable>
 800fd02:	bf00      	nop
 800fd04:	20000b70 	.word	0x20000b70
	...

0800fd10 <halRfExtCb>:

/**
 * External interrupt handler for lines 9 to 5
 */

void halRfExtCb(EXTDriver *extp, expchannel_t channel) {
 800fd10:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800fd12:	b672      	cpsid	i
	(void)extp;
	(void)channel;

	chSysLockFromISR();
	chEvtSignalI(isr_tp, (eventmask_t) 1);
 800fd14:	4b03      	ldr	r3, [pc, #12]	; (800fd24 <halRfExtCb+0x14>)
 800fd16:	2101      	movs	r1, #1
 800fd18:	6818      	ldr	r0, [r3, #0]
 800fd1a:	f7fc ff09 	bl	800cb30 <chEvtSignalI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fd1e:	b662      	cpsie	i
 800fd20:	bd08      	pop	{r3, pc}
 800fd22:	bf00      	nop
 800fd24:	200014a0 	.word	0x200014a0
	...

0800fd30 <halRfWaitTransceiverReady>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfWaitTransceiverReady(void) {
 800fd30:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800fd32:	b672      	cpsid	i
#if defined(INCLUDE_PA) && !defined(PA_CTRL_FROM_MCU)
	// GPIO3 is not conncted to combo board; use SFD at GPIO2 instead
	HAL_INT_OFF();
	// GPIO2 = SFD
	CC2520_CFG_GPIO_OUT(2,CC2520_GPIO_SFD);
 800fd34:	4c0e      	ldr	r4, [pc, #56]	; (800fd70 <halRfWaitTransceiverReady+0x40>)
 800fd36:	2022      	movs	r0, #34	; 0x22
 800fd38:	212a      	movs	r1, #42	; 0x2a
 800fd3a:	f7ff fe89 	bl	800fa50 <CC2520_REGWR8>
 800fd3e:	2200      	movs	r2, #0
 800fd40:	4620      	mov	r0, r4
 800fd42:	2120      	movs	r1, #32
 800fd44:	f7fe fdc4 	bl	800e8d0 <_pal_lld_setgroupmode>
	while (CC2520_GPIO2_IPIN) {
 800fd48:	6923      	ldr	r3, [r4, #16]
 800fd4a:	069a      	lsls	r2, r3, #26
 800fd4c:	d505      	bpl.n	800fd5a <halRfWaitTransceiverReady+0x2a>
		chThdSleep(1);
 800fd4e:	2001      	movs	r0, #1
 800fd50:	f7fc fd76 	bl	800c840 <chThdSleep>
#if defined(INCLUDE_PA) && !defined(PA_CTRL_FROM_MCU)
	// GPIO3 is not conncted to combo board; use SFD at GPIO2 instead
	HAL_INT_OFF();
	// GPIO2 = SFD
	CC2520_CFG_GPIO_OUT(2,CC2520_GPIO_SFD);
	while (CC2520_GPIO2_IPIN) {
 800fd54:	6923      	ldr	r3, [r4, #16]
 800fd56:	069b      	lsls	r3, r3, #26
 800fd58:	d4f9      	bmi.n	800fd4e <halRfWaitTransceiverReady+0x1e>
		chThdSleep(1);
	};
	// GPIO2 = default (RSSI_VALID)
	CC2520_CFG_GPIO_OUT(2,CC2520_GPIO_RSSI_VALID);
 800fd5a:	2022      	movs	r0, #34	; 0x22
 800fd5c:	212c      	movs	r1, #44	; 0x2c
 800fd5e:	f7ff fe77 	bl	800fa50 <CC2520_REGWR8>
 800fd62:	4803      	ldr	r0, [pc, #12]	; (800fd70 <halRfWaitTransceiverReady+0x40>)
 800fd64:	2120      	movs	r1, #32
 800fd66:	2200      	movs	r2, #0
 800fd68:	f7fe fdb2 	bl	800e8d0 <_pal_lld_setgroupmode>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fd6c:	b662      	cpsie	i
 800fd6e:	bd10      	pop	{r4, pc}
 800fd70:	40020800 	.word	0x40020800
	...

0800fd80 <min>:
uint8 min(uint8 v1, uint8 v2)
{
	if(v1 < v2)
		return v1;
	else return v2;
}
 800fd80:	4288      	cmp	r0, r1
 800fd82:	bf28      	it	cs
 800fd84:	4608      	movcs	r0, r1
 800fd86:	4770      	bx	lr
	...

0800fd90 <spi_sw_transfer>:
		palClearPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
		init_done = true;
	}
}

void spi_sw_transfer(char *in_buf, const char *out_buf, int length) {
 800fd90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	palClearPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
 800fd94:	4d1b      	ldr	r5, [pc, #108]	; (800fe04 <spi_sw_transfer+0x74>)
 800fd96:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800fd9a:	836b      	strh	r3, [r5, #26]

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 800fd9c:	bf00      	nop
	spi_sw_delay();

	for (int i = 0;i < length;i++) {
 800fd9e:	2a00      	cmp	r2, #0
 800fda0:	dd2c      	ble.n	800fdfc <spi_sw_transfer+0x6c>
 800fda2:	f04f 0800 	mov.w	r8, #0
		unsigned char send = out_buf ? out_buf[i] : 0;
 800fda6:	b359      	cbz	r1, 800fe00 <spi_sw_transfer+0x70>
 800fda8:	f811 4008 	ldrb.w	r4, [r1, r8]
 800fdac:	2708      	movs	r7, #8
 800fdae:	2300      	movs	r3, #0
			recieve <<= 1;
			if (palReadPad(CC2520_SPI_MISO_PORT, CC2520_SPI_MISO_PIN)) {
				recieve |= 0x1;
			}

			palSetPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
 800fdb0:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
	for (int i = 0;i < length;i++) {
		unsigned char send = out_buf ? out_buf[i] : 0;
		unsigned char recieve = 0;

		for (int bit=0;bit < 8;bit++) {
			palWritePad(CC2520_SPI_MOSI_PORT, CC2520_SPI_MOSI_PIN, send >> 7);
 800fdb4:	f3c4 1ec7 	ubfx	lr, r4, #7, #8
 800fdb8:	f1be 0f00 	cmp.w	lr, #0
 800fdbc:	bf0c      	ite	eq
 800fdbe:	f04f 4680 	moveq.w	r6, #1073741824	; 0x40000000
 800fdc2:	2600      	movne	r6, #0
 800fdc4:	ea46 368e 	orr.w	r6, r6, lr, lsl #14
			send <<= 1;
 800fdc8:	0064      	lsls	r4, r4, #1
 800fdca:	b2e4      	uxtb	r4, r4
	for (int i = 0;i < length;i++) {
		unsigned char send = out_buf ? out_buf[i] : 0;
		unsigned char recieve = 0;

		for (int bit=0;bit < 8;bit++) {
			palWritePad(CC2520_SPI_MOSI_PORT, CC2520_SPI_MOSI_PIN, send >> 7);
 800fdcc:	61ae      	str	r6, [r5, #24]
 800fdce:	bf00      	nop
			send <<= 1;

			spi_sw_delay();

			recieve <<= 1;
			if (palReadPad(CC2520_SPI_MISO_PORT, CC2520_SPI_MISO_PIN)) {
 800fdd0:	692e      	ldr	r6, [r5, #16]
				recieve |= 0x1;
			}

			palSetPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
 800fdd2:	f8a5 c018 	strh.w	ip, [r5, #24]
			palWritePad(CC2520_SPI_MOSI_PORT, CC2520_SPI_MOSI_PIN, send >> 7);
			send <<= 1;

			spi_sw_delay();

			recieve <<= 1;
 800fdd6:	005b      	lsls	r3, r3, #1
 800fdd8:	b2db      	uxtb	r3, r3
			if (palReadPad(CC2520_SPI_MISO_PORT, CC2520_SPI_MISO_PIN)) {
 800fdda:	f416 4f00 	tst.w	r6, #32768	; 0x8000
				recieve |= 0x1;
 800fdde:	bf18      	it	ne
 800fde0:	f043 0301 	orrne.w	r3, r3, #1
 800fde4:	bf00      	nop

	for (int i = 0;i < length;i++) {
		unsigned char send = out_buf ? out_buf[i] : 0;
		unsigned char recieve = 0;

		for (int bit=0;bit < 8;bit++) {
 800fde6:	3f01      	subs	r7, #1
				recieve |= 0x1;
			}

			palSetPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
			spi_sw_delay();
			palClearPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
 800fde8:	f8a5 c01a 	strh.w	ip, [r5, #26]

	for (int i = 0;i < length;i++) {
		unsigned char send = out_buf ? out_buf[i] : 0;
		unsigned char recieve = 0;

		for (int bit=0;bit < 8;bit++) {
 800fdec:	d1e2      	bne.n	800fdb4 <spi_sw_transfer+0x24>
			palSetPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
			spi_sw_delay();
			palClearPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
		}

		if (in_buf) {
 800fdee:	b108      	cbz	r0, 800fdf4 <spi_sw_transfer+0x64>
			in_buf[i] = recieve;
 800fdf0:	f800 3008 	strb.w	r3, [r0, r8]

void spi_sw_transfer(char *in_buf, const char *out_buf, int length) {
	palClearPad(CC2520_SPI_SCK_PORT, CC2520_SPI_SCK_PIN);
	spi_sw_delay();

	for (int i = 0;i < length;i++) {
 800fdf4:	f108 0801 	add.w	r8, r8, #1
 800fdf8:	4590      	cmp	r8, r2
 800fdfa:	d1d4      	bne.n	800fda6 <spi_sw_transfer+0x16>
 800fdfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		unsigned char send = out_buf ? out_buf[i] : 0;
 800fe00:	460c      	mov	r4, r1
 800fe02:	e7d3      	b.n	800fdac <spi_sw_transfer+0x1c>
 800fe04:	40020400 	.word	0x40020400
	...

0800fe10 <spi_sw_begin>:
		}
	}
}

void spi_sw_begin(void) {
	palClearPad(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN);
 800fe10:	4b02      	ldr	r3, [pc, #8]	; (800fe1c <spi_sw_begin+0xc>)
 800fe12:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800fe16:	835a      	strh	r2, [r3, #26]
 800fe18:	bf00      	nop
 800fe1a:	4770      	bx	lr
 800fe1c:	40020400 	.word	0x40020400

0800fe20 <spi_sw_end>:
 800fe20:	bf00      	nop
	spi_sw_delay();
}

void spi_sw_end(void) {
	spi_sw_delay();
	palSetPad(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN);
 800fe22:	4b02      	ldr	r3, [pc, #8]	; (800fe2c <spi_sw_end+0xc>)
 800fe24:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800fe28:	831a      	strh	r2, [r3, #24]
 800fe2a:	4770      	bx	lr
 800fe2c:	40020400 	.word	0x40020400

0800fe30 <basicRf_thread>:
/**
 * This thread only checks if the CC2520 has gotten the RX_OVERFLOW exception and
 * flushes the rx buffer in that case. This is because it will stop receiving
 * packets otherwise.
 */
static THD_FUNCTION(basicRf_thread, arg) {
 800fe30:	b508      	push	{r3, lr}
 800fe32:	4b0c      	ldr	r3, [pc, #48]	; (800fe64 <basicRf_thread+0x34>)
 800fe34:	4a0c      	ldr	r2, [pc, #48]	; (800fe68 <basicRf_thread+0x38>)
 800fe36:	699b      	ldr	r3, [r3, #24]
	(void)arg;

	chRegSetThreadName("CC2520 EXC");

	for(;;) {
		if (CC2520_RX_OVERFLOW_PIN) {
 800fe38:	4c0c      	ldr	r4, [pc, #48]	; (800fe6c <basicRf_thread+0x3c>)
 800fe3a:	619a      	str	r2, [r3, #24]
 800fe3c:	e002      	b.n	800fe44 <basicRf_thread+0x14>
			halRfFlushRx();
			CC2520_CLEAR_EXC(CC2520_EXC_RX_OVERFLOW);
			chMtxUnlock(&rf_mutex);
		}

		chThdSleepMilliseconds(1);
 800fe3e:	200a      	movs	r0, #10
 800fe40:	f7fc fcfe 	bl	800c840 <chThdSleep>
	(void)arg;

	chRegSetThreadName("CC2520 EXC");

	for(;;) {
		if (CC2520_RX_OVERFLOW_PIN) {
 800fe44:	6923      	ldr	r3, [r4, #16]
 800fe46:	07db      	lsls	r3, r3, #31
 800fe48:	d5f9      	bpl.n	800fe3e <basicRf_thread+0xe>
			chMtxLock(&rf_mutex);
 800fe4a:	4809      	ldr	r0, [pc, #36]	; (800fe70 <basicRf_thread+0x40>)
 800fe4c:	f7fc fe38 	bl	800cac0 <chMtxLock>
			halRfFlushRx();
 800fe50:	f7ff ff46 	bl	800fce0 <halRfFlushRx>
			CC2520_CLEAR_EXC(CC2520_EXC_RX_OVERFLOW);
 800fe54:	2086      	movs	r0, #134	; 0x86
 800fe56:	f7ff fddb 	bl	800fa10 <CC2520_BCLR>
			chMtxUnlock(&rf_mutex);
 800fe5a:	4805      	ldr	r0, [pc, #20]	; (800fe70 <basicRf_thread+0x40>)
 800fe5c:	f7fc fe38 	bl	800cad0 <chMtxUnlock>
 800fe60:	e7ed      	b.n	800fe3e <basicRf_thread+0xe>
 800fe62:	bf00      	nop
 800fe64:	20000838 	.word	0x20000838
 800fe68:	08010de0 	.word	0x08010de0
 800fe6c:	40020400 	.word	0x40020400
 800fe70:	200017e8 	.word	0x200017e8
	...

0800fe80 <basicRfRxFrmDoneIsr>:
 *                    frame
 *              txState - file scope variable that keeps tx state info
 *
 * @return      none
 */
static void basicRfRxFrmDoneIsr(void) {
 800fe80:	b538      	push	{r3, r4, r5, lr}
	uint8 *pStatusWord;
#ifdef SECURITY_CCM
	uint8 authStatus=0;
#endif

	chMtxLock(&rf_mutex);
 800fe82:	4828      	ldr	r0, [pc, #160]	; (800ff24 <basicRfRxFrmDoneIsr+0xa4>)

	// Clear interrupt
	CLEAR_EXC_RX_FRM_DONE();

	// Read payload length.
	halRfReadRxBuf(&pHdr->packetLength,1);
 800fe84:	4c28      	ldr	r4, [pc, #160]	; (800ff28 <basicRfRxFrmDoneIsr+0xa8>)
	uint8 *pStatusWord;
#ifdef SECURITY_CCM
	uint8 authStatus=0;
#endif

	chMtxLock(&rf_mutex);
 800fe86:	f7fc fe1b 	bl	800cac0 <chMtxLock>

	// Map header to packet buffer
	pHdr= (basicRfPktHdr_t*)rxMpdu;

	// Clear interrupt
	CLEAR_EXC_RX_FRM_DONE();
 800fe8a:	2088      	movs	r0, #136	; 0x88
 800fe8c:	f7ff fdc0 	bl	800fa10 <CC2520_BCLR>

	// Read payload length.
	halRfReadRxBuf(&pHdr->packetLength,1);
 800fe90:	2101      	movs	r1, #1
 800fe92:	4620      	mov	r0, r4
 800fe94:	f7ff fe2c 	bl	800faf0 <halRfReadRxBuf>
	pHdr->packetLength &= BASIC_RF_PLD_LEN_MASK; // Ignore MSB
 800fe98:	7821      	ldrb	r1, [r4, #0]
 800fe9a:	f001 017f 	and.w	r1, r1, #127	; 0x7f

	// Is this an acknowledgment packet?
	// Only ack packets may be 5 bytes in total.
	if (pHdr->packetLength == BASIC_RF_ACK_PACKET_SIZE) {
 800fe9e:	2905      	cmp	r1, #5
	// Clear interrupt
	CLEAR_EXC_RX_FRM_DONE();

	// Read payload length.
	halRfReadRxBuf(&pHdr->packetLength,1);
	pHdr->packetLength &= BASIC_RF_PLD_LEN_MASK; // Ignore MSB
 800fea0:	7021      	strb	r1, [r4, #0]

	// Is this an acknowledgment packet?
	// Only ack packets may be 5 bytes in total.
	if (pHdr->packetLength == BASIC_RF_ACK_PACKET_SIZE) {
 800fea2:	d021      	beq.n	800fee8 <basicRfRxFrmDoneIsr+0x68>
	} else {

		// It is assumed that the radio rejects packets with invalid length.
		// Subtract the number of bytes in the frame overhead to get actual payload.

		rxi.length = pHdr->packetLength - BASIC_RF_PACKET_OVERHEAD_SIZE;
 800fea4:	4d21      	ldr	r5, [pc, #132]	; (800ff2c <basicRfRxFrmDoneIsr+0xac>)
 800fea6:	f1a1 030b 	sub.w	r3, r1, #11
 800feaa:	b2db      	uxtb	r3, r3
#ifdef SECURITY_CCM
		rxi.length -= (BASIC_RF_AUX_HDR_LENGTH + BASIC_RF_LEN_MIC);
		authStatus = halRfReadRxBufSecure(&rxMpdu[1], pHdr->packetLength, rxi.length,
				BASIC_RF_LEN_AUTH, BASIC_RF_SECURITY_M);
#else
		halRfReadRxBuf(&rxMpdu[1], pHdr->packetLength);
 800feac:	1c60      	adds	r0, r4, #1
	} else {

		// It is assumed that the radio rejects packets with invalid length.
		// Subtract the number of bytes in the frame overhead to get actual payload.

		rxi.length = pHdr->packetLength - BASIC_RF_PACKET_OVERHEAD_SIZE;
 800feae:	71ab      	strb	r3, [r5, #6]
#ifdef SECURITY_CCM
		rxi.length -= (BASIC_RF_AUX_HDR_LENGTH + BASIC_RF_LEN_MIC);
		authStatus = halRfReadRxBufSecure(&rxMpdu[1], pHdr->packetLength, rxi.length,
				BASIC_RF_LEN_AUTH, BASIC_RF_SECURITY_M);
#else
		halRfReadRxBuf(&rxMpdu[1], pHdr->packetLength);
 800feb0:	f7ff fe1e 	bl	800faf0 <halRfReadRxBuf>
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 800feb4:	7861      	ldrb	r1, [r4, #1]

		// Read the source address
		rxi.srcAddr= pHdr->srcAddr;
 800feb6:	8922      	ldrh	r2, [r4, #8]
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 800feb8:	f3c1 1040 	ubfx	r0, r1, #5, #1

		// Read the source address
		rxi.srcAddr= pHdr->srcAddr;

		// Read the packet payload
		rxi.pPayload = rxMpdu + BASIC_RF_HDR_SIZE;
 800febc:	f104 030a 	add.w	r3, r4, #10
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 800fec0:	7328      	strb	r0, [r5, #12]

		// Read the source address
		rxi.srcAddr= pHdr->srcAddr;
 800fec2:	806a      	strh	r2, [r5, #2]

		// Read the packet payload
		rxi.pPayload = rxMpdu + BASIC_RF_HDR_SIZE;
 800fec4:	60ab      	str	r3, [r5, #8]

		// Read the FCS to get the RSSI and CRC
		pStatusWord= rxi.pPayload+rxi.length;
 800fec6:	68aa      	ldr	r2, [r5, #8]
 800fec8:	79ab      	ldrb	r3, [r5, #6]
 800feca:	b25b      	sxtb	r3, r3
 800fecc:	18d0      	adds	r0, r2, r3
#ifdef SECURITY_CCM
		pStatusWord+= BASIC_RF_LEN_MIC;
#endif
		rxi.rssi = pStatusWord[0];
 800fece:	5cd3      	ldrb	r3, [r2, r3]
 800fed0:	736b      	strb	r3, [r5, #13]

		// Notify the application about the received data packet if the CRC is OK
		// Throw packet if the previous packet had the same sequence number
		if( (pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (rxi.seqNumber != pHdr->seqNumber) ) {
 800fed2:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800fed6:	2b00      	cmp	r3, #0
 800fed8:	78e3      	ldrb	r3, [r4, #3]
 800feda:	db19      	blt.n	800ff10 <basicRfRxFrmDoneIsr+0x90>
			if ( ((pHdr->fcf0 & (BASIC_RF_FCF_BM_L)) == BASIC_RF_FCF_NOACK_L) ) {
				rxi.isReady = TRUE;
			}
#endif
		}
		rxi.seqNumber = pHdr->seqNumber;
 800fedc:	702b      	strb	r3, [r5, #0]
	}

	chMtxUnlock(&rf_mutex);
 800fede:	4811      	ldr	r0, [pc, #68]	; (800ff24 <basicRfRxFrmDoneIsr+0xa4>)
}
 800fee0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
		}
		rxi.seqNumber = pHdr->seqNumber;
	}

	chMtxUnlock(&rf_mutex);
 800fee4:	f7fc bdf4 	b.w	800cad0 <chMtxUnlock>
	// Is this an acknowledgment packet?
	// Only ack packets may be 5 bytes in total.
	if (pHdr->packetLength == BASIC_RF_ACK_PACKET_SIZE) {

		// Read the packet
		halRfReadRxBuf(&rxMpdu[1], pHdr->packetLength);
 800fee8:	1c60      	adds	r0, r4, #1
 800feea:	f7ff fe01 	bl	800faf0 <halRfReadRxBuf>
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 800feee:	7863      	ldrb	r3, [r4, #1]

		// Read the status word and check for CRC OK
		pStatusWord= rxMpdu + 4;

		// Indicate the successful ACK reception if CRC and sequence number OK
		if ((pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (pHdr->seqNumber == txState.txSeqNumber)) {
 800fef0:	f994 2005 	ldrsb.w	r2, [r4, #5]
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 800fef4:	490d      	ldr	r1, [pc, #52]	; (800ff2c <basicRfRxFrmDoneIsr+0xac>)
 800fef6:	f3c3 1340 	ubfx	r3, r3, #5, #1

		// Read the status word and check for CRC OK
		pStatusWord= rxMpdu + 4;

		// Indicate the successful ACK reception if CRC and sequence number OK
		if ((pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (pHdr->seqNumber == txState.txSeqNumber)) {
 800fefa:	2a00      	cmp	r2, #0
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 800fefc:	730b      	strb	r3, [r1, #12]

		// Read the status word and check for CRC OK
		pStatusWord= rxMpdu + 4;

		// Indicate the successful ACK reception if CRC and sequence number OK
		if ((pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (pHdr->seqNumber == txState.txSeqNumber)) {
 800fefe:	daee      	bge.n	800fede <basicRfRxFrmDoneIsr+0x5e>
 800ff00:	4b0b      	ldr	r3, [pc, #44]	; (800ff30 <basicRfRxFrmDoneIsr+0xb0>)
 800ff02:	78e1      	ldrb	r1, [r4, #3]
 800ff04:	781a      	ldrb	r2, [r3, #0]
 800ff06:	4291      	cmp	r1, r2
 800ff08:	d1e9      	bne.n	800fede <basicRfRxFrmDoneIsr+0x5e>
			txState.ackReceived = TRUE;
 800ff0a:	2201      	movs	r2, #1
 800ff0c:	705a      	strb	r2, [r3, #1]
 800ff0e:	e7e6      	b.n	800fede <basicRfRxFrmDoneIsr+0x5e>
#endif
		rxi.rssi = pStatusWord[0];

		// Notify the application about the received data packet if the CRC is OK
		// Throw packet if the previous packet had the same sequence number
		if( (pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (rxi.seqNumber != pHdr->seqNumber) ) {
 800ff10:	782a      	ldrb	r2, [r5, #0]
 800ff12:	429a      	cmp	r2, r3
 800ff14:	d0e2      	beq.n	800fedc <basicRfRxFrmDoneIsr+0x5c>
						(BASIC_RF_FCF_NOACK_L | BASIC_RF_SEC_ENABLED_FCF_BM_L)) {
					rxi.isReady = TRUE;
				}
			}
#else
			if ( ((pHdr->fcf0 & (BASIC_RF_FCF_BM_L)) == BASIC_RF_FCF_NOACK_L) ) {
 800ff16:	f001 01df 	and.w	r1, r1, #223	; 0xdf
 800ff1a:	2941      	cmp	r1, #65	; 0x41
				rxi.isReady = TRUE;
 800ff1c:	bf04      	itt	eq
 800ff1e:	2201      	moveq	r2, #1
 800ff20:	73aa      	strbeq	r2, [r5, #14]
 800ff22:	e7db      	b.n	800fedc <basicRfRxFrmDoneIsr+0x5c>
 800ff24:	200017e8 	.word	0x200017e8
 800ff28:	200014b8 	.word	0x200014b8
 800ff2c:	200014a8 	.word	0x200014a8
 800ff30:	200017e0 	.word	0x200017e0
	...

0800ff40 <basicRfInit>:
 *              rxi - file scope variable info extracted from the last incoming
 *                    frame
 *
 * @return      none
 */
uint8 basicRfInit(basicRfCfg_t* pRfConfig) {
 800ff40:	b570      	push	{r4, r5, r6, lr}
 800ff42:	b082      	sub	sp, #8
 800ff44:	4606      	mov	r6, r0
	if (halRfInit() == FAILED) {
 800ff46:	f7ff fe2b 	bl	800fba0 <halRfInit>
 800ff4a:	2801      	cmp	r0, #1
 800ff4c:	d027      	beq.n	800ff9e <basicRfInit+0x5e>
		return FAILED;
	}

	chMtxObjectInit(&rf_mutex);
 800ff4e:	4815      	ldr	r0, [pc, #84]	; (800ffa4 <basicRfInit+0x64>)
	chMtxObjectInit(&rf_send_mutex);

	// Set the protocol configuration
	pConfig = pRfConfig;
 800ff50:	4d15      	ldr	r5, [pc, #84]	; (800ffa8 <basicRfInit+0x68>)
uint8 basicRfInit(basicRfCfg_t* pRfConfig) {
	if (halRfInit() == FAILED) {
		return FAILED;
	}

	chMtxObjectInit(&rf_mutex);
 800ff52:	f7fc fd45 	bl	800c9e0 <chMtxObjectInit>
	chMtxObjectInit(&rf_send_mutex);
 800ff56:	4815      	ldr	r0, [pc, #84]	; (800ffac <basicRfInit+0x6c>)
 800ff58:	f7fc fd42 	bl	800c9e0 <chMtxObjectInit>

	// Set the protocol configuration
	pConfig = pRfConfig;
	rxi.pPayload   = NULL;
 800ff5c:	4914      	ldr	r1, [pc, #80]	; (800ffb0 <basicRfInit+0x70>)

	txState.receiveOn = TRUE;
 800ff5e:	4b15      	ldr	r3, [pc, #84]	; (800ffb4 <basicRfInit+0x74>)

	chMtxObjectInit(&rf_mutex);
	chMtxObjectInit(&rf_send_mutex);

	// Set the protocol configuration
	pConfig = pRfConfig;
 800ff60:	602e      	str	r6, [r5, #0]
	rxi.pPayload   = NULL;

	txState.receiveOn = TRUE;
 800ff62:	2201      	movs	r2, #1
	chMtxObjectInit(&rf_mutex);
	chMtxObjectInit(&rf_send_mutex);

	// Set the protocol configuration
	pConfig = pRfConfig;
	rxi.pPayload   = NULL;
 800ff64:	2400      	movs	r4, #0
 800ff66:	608c      	str	r4, [r1, #8]

	txState.receiveOn = TRUE;
 800ff68:	709a      	strb	r2, [r3, #2]
	txState.frameCounter = 0;
 800ff6a:	605c      	str	r4, [r3, #4]

	// Set channel
	halRfSetChannel(pConfig->channel);
 800ff6c:	7930      	ldrb	r0, [r6, #4]
 800ff6e:	f7ff fd9f 	bl	800fab0 <halRfSetChannel>

	// Write the short address and the PAN ID to the CC2520 RAM
	halRfSetShortAddr(pConfig->myAddr);
 800ff72:	682b      	ldr	r3, [r5, #0]
 800ff74:	8818      	ldrh	r0, [r3, #0]
 800ff76:	b280      	uxth	r0, r0
 800ff78:	f7ff fda2 	bl	800fac0 <halRfSetShortAddr>
	halRfSetPanId(pConfig->panId);
 800ff7c:	682b      	ldr	r3, [r5, #0]
 800ff7e:	8858      	ldrh	r0, [r3, #2]
 800ff80:	b280      	uxth	r0, r0
 800ff82:	f7ff fda5 	bl	800fad0 <halRfSetPanId>
#ifdef SECURITY_CCM
	basicRfSecurityInit((basicRfCfg_t*)pConfig);
#endif

	// Set up receive interrupt (received data or acknowlegment)
	halRfRxInterruptConfig(basicRfRxFrmDoneIsr);
 800ff86:	480c      	ldr	r0, [pc, #48]	; (800ffb8 <basicRfInit+0x78>)
 800ff88:	f7ff fdf2 	bl	800fb70 <halRfRxInterruptConfig>

	chThdCreateStatic(basicRf_thread_wa, sizeof(basicRf_thread_wa), NORMALPRIO, basicRf_thread, NULL);
 800ff8c:	9400      	str	r4, [sp, #0]
 800ff8e:	480b      	ldr	r0, [pc, #44]	; (800ffbc <basicRfInit+0x7c>)
 800ff90:	4b0b      	ldr	r3, [pc, #44]	; (800ffc0 <basicRfInit+0x80>)
 800ff92:	f44f 7126 	mov.w	r1, #664	; 0x298
 800ff96:	2240      	movs	r2, #64	; 0x40
 800ff98:	f7fc fc12 	bl	800c7c0 <chThdCreateStatic>

	return SUCCESS;
 800ff9c:	4620      	mov	r0, r4
}
 800ff9e:	b002      	add	sp, #8
 800ffa0:	bd70      	pop	{r4, r5, r6, pc}
 800ffa2:	bf00      	nop
 800ffa4:	200017e8 	.word	0x200017e8
 800ffa8:	200017f8 	.word	0x200017f8
 800ffac:	200017d0 	.word	0x200017d0
 800ffb0:	200014a8 	.word	0x200014a8
 800ffb4:	200017e0 	.word	0x200017e0
 800ffb8:	0800fe81 	.word	0x0800fe81
 800ffbc:	20001538 	.word	0x20001538
 800ffc0:	0800fe31 	.word	0x0800fe31
	...

0800ffd0 <basicRfPacketIsReady>:
 * @param       none
 *
 * @return      uint8 - TRUE if a packet is ready to be read by higher layer
 */
uint8 basicRfPacketIsReady(void) {
	return rxi.isReady;
 800ffd0:	4b01      	ldr	r3, [pc, #4]	; (800ffd8 <basicRfPacketIsReady+0x8>)
 800ffd2:	7b98      	ldrb	r0, [r3, #14]
}
 800ffd4:	4770      	bx	lr
 800ffd6:	bf00      	nop
 800ffd8:	200014a8 	.word	0x200014a8
 800ffdc:	00000000 	.word	0x00000000

0800ffe0 <basicRfReceive>:
 *                    incoming packet
 *
 * @return      uint8 - number of bytes actually copied into buffer
 */
uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)
{
 800ffe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// Accessing shared variables -> this is a critical region
	// Critical region start
	chMtxLock(&rf_mutex);

	memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
 800ffe4:	4d11      	ldr	r5, [pc, #68]	; (801002c <basicRfReceive+0x4c>)
 *                    incoming packet
 *
 * @return      uint8 - number of bytes actually copied into buffer
 */
uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)
{
 800ffe6:	4680      	mov	r8, r0
 800ffe8:	460e      	mov	r6, r1
	// Accessing shared variables -> this is a critical region
	// Critical region start
	chMtxLock(&rf_mutex);
 800ffea:	4811      	ldr	r0, [pc, #68]	; (8010030 <basicRfReceive+0x50>)
 *                    incoming packet
 *
 * @return      uint8 - number of bytes actually copied into buffer
 */
uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)
{
 800ffec:	4617      	mov	r7, r2
	// Accessing shared variables -> this is a critical region
	// Critical region start
	chMtxLock(&rf_mutex);
 800ffee:	f7fc fd67 	bl	800cac0 <chMtxLock>

	memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
 800fff2:	68ac      	ldr	r4, [r5, #8]
 800fff4:	79a8      	ldrb	r0, [r5, #6]
 800fff6:	4631      	mov	r1, r6
 800fff8:	f7ff fec2 	bl	800fd80 <min>
 800fffc:	4621      	mov	r1, r4
 800fffe:	4602      	mov	r2, r0
 8010000:	4640      	mov	r0, r8
 8010002:	f7fc f8a5 	bl	800c150 <memcpy>
	if(pRssi != NULL) {
 8010006:	b137      	cbz	r7, 8010016 <basicRfReceive+0x36>
 * @param       none

 * @return      int8 - RSSI value
 */
int8 basicRfGetRssi(void) {
	return rxi.rssi - halRfGetRssiOffset();
 8010008:	7b6c      	ldrb	r4, [r5, #13]
 801000a:	f7ff fd49 	bl	800faa0 <halRfGetRssiOffset>
 801000e:	b2e4      	uxtb	r4, r4
 8010010:	1a20      	subs	r0, r4, r0
	// Critical region start
	chMtxLock(&rf_mutex);

	memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
	if(pRssi != NULL) {
		*pRssi = basicRfGetRssi();
 8010012:	b240      	sxtb	r0, r0
 8010014:	8038      	strh	r0, [r7, #0]
	}
	rxi.isReady = FALSE;
 8010016:	2300      	movs	r3, #0

	// Critical region end
	chMtxUnlock(&rf_mutex);
 8010018:	4805      	ldr	r0, [pc, #20]	; (8010030 <basicRfReceive+0x50>)

	memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
	if(pRssi != NULL) {
		*pRssi = basicRfGetRssi();
	}
	rxi.isReady = FALSE;
 801001a:	73ab      	strb	r3, [r5, #14]

	// Critical region end
	chMtxUnlock(&rf_mutex);
 801001c:	f7fc fd58 	bl	800cad0 <chMtxUnlock>

	return min(rxi.length, len);
 8010020:	79a8      	ldrb	r0, [r5, #6]
 8010022:	4631      	mov	r1, r6
}
 8010024:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	rxi.isReady = FALSE;

	// Critical region end
	chMtxUnlock(&rf_mutex);

	return min(rxi.length, len);
 8010028:	f7ff beaa 	b.w	800fd80 <min>
 801002c:	200014a8 	.word	0x200014a8
 8010030:	200017e8 	.word	0x200017e8
	...

08010040 <basicRfReceiveOn>:
 *
 * @param       txState - file scope variable
 *
 * @return      none
 */
void basicRfReceiveOn(void) {
 8010040:	b510      	push	{r4, lr}
	chMtxLock(&rf_mutex);
 8010042:	4c07      	ldr	r4, [pc, #28]	; (8010060 <basicRfReceiveOn+0x20>)
 8010044:	4620      	mov	r0, r4
 8010046:	f7fc fd3b 	bl	800cac0 <chMtxLock>
	txState.receiveOn = TRUE;
 801004a:	4b06      	ldr	r3, [pc, #24]	; (8010064 <basicRfReceiveOn+0x24>)
 801004c:	2201      	movs	r2, #1
 801004e:	709a      	strb	r2, [r3, #2]
	halRfReceiveOn();
 8010050:	f7ff fe06 	bl	800fc60 <halRfReceiveOn>
	chMtxUnlock(&rf_mutex);
 8010054:	4620      	mov	r0, r4
}
 8010056:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 */
void basicRfReceiveOn(void) {
	chMtxLock(&rf_mutex);
	txState.receiveOn = TRUE;
	halRfReceiveOn();
	chMtxUnlock(&rf_mutex);
 801005a:	f7fc bd39 	b.w	800cad0 <chMtxUnlock>
 801005e:	bf00      	nop
 8010060:	200017e8 	.word	0x200017e8
 8010064:	200017e0 	.word	0x200017e0
	...

08010070 <basicRfReceiveOff>:
 *
 * @param       txState - file scope variable
 *
 * @return      none
 */
void basicRfReceiveOff(void) {
 8010070:	b510      	push	{r4, lr}
	chMtxLock(&rf_mutex);
 8010072:	4c07      	ldr	r4, [pc, #28]	; (8010090 <basicRfReceiveOff+0x20>)
 8010074:	4620      	mov	r0, r4
 8010076:	f7fc fd23 	bl	800cac0 <chMtxLock>
	txState.receiveOn = FALSE;
 801007a:	4b06      	ldr	r3, [pc, #24]	; (8010094 <basicRfReceiveOff+0x24>)
 801007c:	2200      	movs	r2, #0
 801007e:	709a      	strb	r2, [r3, #2]
	halRfReceiveOff();
 8010080:	f7ff fe0e 	bl	800fca0 <halRfReceiveOff>
	chMtxUnlock(&rf_mutex);
 8010084:	4620      	mov	r0, r4
}
 8010086:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 */
void basicRfReceiveOff(void) {
	chMtxLock(&rf_mutex);
	txState.receiveOn = FALSE;
	halRfReceiveOff();
	chMtxUnlock(&rf_mutex);
 801008a:	f7fc bd21 	b.w	800cad0 <chMtxUnlock>
 801008e:	bf00      	nop
 8010090:	200017e8 	.word	0x200017e8
 8010094:	200017e0 	.word	0x200017e0
	...

080100a0 <basicRfSendPacket>:
 *              txState - file scope variable that keeps tx state info
 *              mpdu - file scope variable. Buffer for the frame to send
 *
 * @return      basicRFStatus_t - SUCCESS or FAILED
 */
uint8 basicRfSendPacket(uint16 destAddr, uint8* pPayload, uint8 length) {
 80100a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8 status = SUCCESS;

	chMtxLock(&rf_send_mutex);

	// Turn on receiver if its not on
	if(!txState.receiveOn) {
 80100a4:	4d36      	ldr	r5, [pc, #216]	; (8010180 <basicRfSendPacket+0xe0>)
 *              txState - file scope variable that keeps tx state info
 *              mpdu - file scope variable. Buffer for the frame to send
 *
 * @return      basicRFStatus_t - SUCCESS or FAILED
 */
uint8 basicRfSendPacket(uint16 destAddr, uint8* pPayload, uint8 length) {
 80100a6:	4680      	mov	r8, r0
	uint8 mpduLength;
	uint8 status = SUCCESS;

	chMtxLock(&rf_send_mutex);
 80100a8:	4836      	ldr	r0, [pc, #216]	; (8010184 <basicRfSendPacket+0xe4>)
 *              txState - file scope variable that keeps tx state info
 *              mpdu - file scope variable. Buffer for the frame to send
 *
 * @return      basicRFStatus_t - SUCCESS or FAILED
 */
uint8 basicRfSendPacket(uint16 destAddr, uint8* pPayload, uint8 length) {
 80100aa:	460c      	mov	r4, r1
 80100ac:	4617      	mov	r7, r2
	uint8 mpduLength;
	uint8 status = SUCCESS;

	chMtxLock(&rf_send_mutex);
 80100ae:	f7fc fd07 	bl	800cac0 <chMtxLock>

	// Turn on receiver if its not on
	if(!txState.receiveOn) {
 80100b2:	78ab      	ldrb	r3, [r5, #2]
 80100b4:	2b00      	cmp	r3, #0
 80100b6:	d05f      	beq.n	8010178 <basicRfSendPacket+0xd8>
		basicRfReceiveOn();
	}

	// Check packet length
	length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
 80100b8:	4638      	mov	r0, r7
 80100ba:	2167      	movs	r1, #103	; 0x67
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 80100bc:	4e32      	ldr	r6, [pc, #200]	; (8010188 <basicRfSendPacket+0xe8>)
	if(!txState.receiveOn) {
		basicRfReceiveOn();
	}

	// Check packet length
	length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
 80100be:	f7ff fe5f 	bl	800fd80 <min>
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 80100c2:	6832      	ldr	r2, [r6, #0]
	uint16 fcf;

	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
 80100c4:	4b31      	ldr	r3, [pc, #196]	; (801018c <basicRfSendPacket+0xec>)
	if(!txState.receiveOn) {
		basicRfReceiveOn();
	}

	// Check packet length
	length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
 80100c6:	4607      	mov	r7, r0
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 80100c8:	7950      	ldrb	r0, [r2, #5]
	pHdr->fcf0 = LO_UINT16(fcf);
	pHdr->fcf1 = HI_UINT16(fcf);
	pHdr->seqNumber= txState.txSeqNumber;
 80100ca:	7829      	ldrb	r1, [r5, #0]
 80100cc:	70d9      	strb	r1, [r3, #3]
	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	pHdr->fcf0 = LO_UINT16(fcf);
	pHdr->fcf1 = HI_UINT16(fcf);
 80100ce:	2188      	movs	r1, #136	; 0x88
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 80100d0:	2800      	cmp	r0, #0
	pHdr->fcf0 = LO_UINT16(fcf);
	pHdr->fcf1 = HI_UINT16(fcf);
 80100d2:	7099      	strb	r1, [r3, #2]
	pHdr->seqNumber= txState.txSeqNumber;
	pHdr->panId= pConfig->panId;
 80100d4:	8851      	ldrh	r1, [r2, #2]
 80100d6:	8099      	strh	r1, [r3, #4]
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 80100d8:	bf14      	ite	ne
 80100da:	f04f 0e61 	movne.w	lr, #97	; 0x61
 80100de:	f04f 0e41 	moveq.w	lr, #65	; 0x41
	uint16 fcf;

	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
 80100e2:	f107 000b 	add.w	r0, r7, #11
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	pHdr->fcf0 = LO_UINT16(fcf);
 80100e6:	f883 e001 	strb.w	lr, [r3, #1]
	uint16 fcf;

	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
 80100ea:	7018      	strb	r0, [r3, #0]
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	pHdr->fcf0 = LO_UINT16(fcf);
	pHdr->fcf1 = HI_UINT16(fcf);
	pHdr->seqNumber= txState.txSeqNumber;
	pHdr->panId= pConfig->panId;
	pHdr->destAddr= destAddr;
 80100ec:	f8a3 8006 	strh.w	r8, [r3, #6]
	pHdr->srcAddr= pConfig->myAddr;
 80100f0:	8812      	ldrh	r2, [r2, #0]
 80100f2:	811a      	strh	r2, [r3, #8]
static uint8 basicRfBuildMpdu(uint16 destAddr, uint8* pPayload, uint8 payloadLength) {
	uint8 hdrLength, n;

	hdrLength = basicRfBuildHeader(txMpdu, destAddr, payloadLength);

	for(n=0;n<payloadLength;n++) {
 80100f4:	b15f      	cbz	r7, 801010e <basicRfSendPacket+0x6e>
 80100f6:	1e78      	subs	r0, r7, #1
 80100f8:	b2c0      	uxtb	r0, r0
 80100fa:	300a      	adds	r0, #10
 80100fc:	4418      	add	r0, r3
 80100fe:	1e62      	subs	r2, r4, #1
 8010100:	3309      	adds	r3, #9
		txMpdu[hdrLength+n] = pPayload[n];
 8010102:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8010106:	f803 1f01 	strb.w	r1, [r3, #1]!
static uint8 basicRfBuildMpdu(uint16 destAddr, uint8* pPayload, uint8 payloadLength) {
	uint8 hdrLength, n;

	hdrLength = basicRfBuildHeader(txMpdu, destAddr, payloadLength);

	for(n=0;n<payloadLength;n++) {
 801010a:	4283      	cmp	r3, r0
 801010c:	d1f9      	bne.n	8010102 <basicRfSendPacket+0x62>
	// Check packet length
	length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
	mpduLength = basicRfBuildMpdu(destAddr, pPayload, length);

	// Wait until the transceiver is idle
	chMtxLock(&rf_mutex);
 801010e:	4820      	ldr	r0, [pc, #128]	; (8010190 <basicRfSendPacket+0xf0>)
 8010110:	f7fc fcd6 	bl	800cac0 <chMtxLock>
	halRfWaitTransceiverReady();
 8010114:	f7ff fe0c 	bl	800fd30 <halRfWaitTransceiverReady>

	for(n=0;n<payloadLength;n++) {
		txMpdu[hdrLength+n] = pPayload[n];
	}

	return hdrLength + payloadLength; // total mpdu length
 8010118:	f107 010a 	add.w	r1, r7, #10

#ifdef SECURITY_CCM
	halRfWriteTxBufSecure(txMpdu, mpduLength, length, BASIC_RF_LEN_AUTH, BASIC_RF_SECURITY_M);
	txState.frameCounter++;     // Increment frame counter field
#else
	halRfWriteTxBuf(txMpdu, mpduLength);
 801011c:	b2c9      	uxtb	r1, r1
 801011e:	481b      	ldr	r0, [pc, #108]	; (801018c <basicRfSendPacket+0xec>)
 8010120:	f7ff fcde 	bl	800fae0 <halRfWriteTxBuf>
#endif

	// Send frame with CCA. return FAILED if not successful
	if(halRfTransmit() != SUCCESS) {
 8010124:	f7ff fcec 	bl	800fb00 <halRfTransmit>
 8010128:	4607      	mov	r7, r0
 801012a:	b198      	cbz	r0, 8010154 <basicRfSendPacket+0xb4>
		status = FAILED;
	}

	chMtxUnlock(&rf_mutex);
 801012c:	4818      	ldr	r0, [pc, #96]	; (8010190 <basicRfSendPacket+0xf0>)
 801012e:	f7fc fccf 	bl	800cad0 <chMtxUnlock>

	// Wait for the acknowledge to be received, if any
	if (pConfig->ackRequest && status == SUCCESS) {
 8010132:	6833      	ldr	r3, [r6, #0]
 8010134:	795b      	ldrb	r3, [r3, #5]
	halRfWriteTxBuf(txMpdu, mpduLength);
#endif

	// Send frame with CCA. return FAILED if not successful
	if(halRfTransmit() != SUCCESS) {
		status = FAILED;
 8010136:	2401      	movs	r4, #1
		// If an acknowledgment has been received (by RxFrmDoneIsr), the ackReceived flag should be set
		status = txState.ackReceived ? SUCCESS : FAILED;
	}

	// Turn off the receiver if it should not continue to be enabled
	if (!txState.receiveOn) {
 8010138:	78ab      	ldrb	r3, [r5, #2]
 801013a:	b90b      	cbnz	r3, 8010140 <basicRfSendPacket+0xa0>
		basicRfReceiveOff();
 801013c:	f7ff ff98 	bl	8010070 <basicRfReceiveOff>
	}

	txState.txSeqNumber++;
 8010140:	782b      	ldrb	r3, [r5, #0]
	chMtxLock(&rf_mutex);
	halRfIncNonceTx();          // Increment nonce value
	chMtxUnlock();
#endif

	chMtxUnlock(&rf_send_mutex);
 8010142:	4810      	ldr	r0, [pc, #64]	; (8010184 <basicRfSendPacket+0xe4>)
	// Turn off the receiver if it should not continue to be enabled
	if (!txState.receiveOn) {
		basicRfReceiveOff();
	}

	txState.txSeqNumber++;
 8010144:	3301      	adds	r3, #1
 8010146:	b2db      	uxtb	r3, r3
 8010148:	702b      	strb	r3, [r5, #0]
	chMtxLock(&rf_mutex);
	halRfIncNonceTx();          // Increment nonce value
	chMtxUnlock();
#endif

	chMtxUnlock(&rf_send_mutex);
 801014a:	f7fc fcc1 	bl	800cad0 <chMtxUnlock>

	return status;
}
 801014e:	4620      	mov	r0, r4
 8010150:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	// Send frame with CCA. return FAILED if not successful
	if(halRfTransmit() != SUCCESS) {
		status = FAILED;
	}

	chMtxUnlock(&rf_mutex);
 8010154:	480e      	ldr	r0, [pc, #56]	; (8010190 <basicRfSendPacket+0xf0>)
 8010156:	f7fc fcbb 	bl	800cad0 <chMtxUnlock>

	// Wait for the acknowledge to be received, if any
	if (pConfig->ackRequest && status == SUCCESS) {
 801015a:	6833      	ldr	r3, [r6, #0]
 801015c:	795b      	ldrb	r3, [r3, #5]
 801015e:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 8010162:	2b00      	cmp	r3, #0
 8010164:	d0e8      	beq.n	8010138 <basicRfSendPacket+0x98>

		// We'll enter RX automatically, so just wait until we can be sure that the ack reception should have finished
		// The timeout consists of a 12-symbol turnaround time, the ack packet duration, and a small margin
		// TODO: Sleep may be to un-accurate?
		//		halMcuWaitUs((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
		chThdSleepMicroseconds((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
 8010166:	2006      	movs	r0, #6

	chMtxUnlock(&rf_mutex);

	// Wait for the acknowledge to be received, if any
	if (pConfig->ackRequest && status == SUCCESS) {
		txState.ackReceived = FALSE;
 8010168:	706f      	strb	r7, [r5, #1]

		// We'll enter RX automatically, so just wait until we can be sure that the ack reception should have finished
		// The timeout consists of a 12-symbol turnaround time, the ack packet duration, and a small margin
		// TODO: Sleep may be to un-accurate?
		//		halMcuWaitUs((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
		chThdSleepMicroseconds((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
 801016a:	f7fc fb69 	bl	800c840 <chThdSleep>

		// If an acknowledgment has been received (by RxFrmDoneIsr), the ackReceived flag should be set
		status = txState.ackReceived ? SUCCESS : FAILED;
 801016e:	786c      	ldrb	r4, [r5, #1]
 8010170:	fab4 f484 	clz	r4, r4
 8010174:	0964      	lsrs	r4, r4, #5
 8010176:	e7df      	b.n	8010138 <basicRfSendPacket+0x98>

	chMtxLock(&rf_send_mutex);

	// Turn on receiver if its not on
	if(!txState.receiveOn) {
		basicRfReceiveOn();
 8010178:	f7ff ff62 	bl	8010040 <basicRfReceiveOn>
 801017c:	e79c      	b.n	80100b8 <basicRfSendPacket+0x18>
 801017e:	bf00      	nop
 8010180:	200017e0 	.word	0x200017e0
 8010184:	200017d0 	.word	0x200017d0
 8010188:	200017f8 	.word	0x200017f8
 801018c:	200017fc 	.word	0x200017fc
 8010190:	200017e8 	.word	0x200017e8
	...

080101a0 <main>:
#include "ext_cb.h"
#include "led.h"
#include "comm_usb.h"
#include "packet.h"

int main(void) {
 80101a0:	b508      	push	{r3, lr}
	halInit();
 80101a2:	f7fc fe85 	bl	800ceb0 <halInit>
	chSysInit();
 80101a6:	f7fc f89b 	bl	800c2e0 <chSysInit>

	led_init();
 80101aa:	f000 fa31 	bl	8010610 <led_init>
	ext_cb_init();
 80101ae:	f000 fa5f 	bl	8010670 <ext_cb_init>
	comm_cc2520_init();
 80101b2:	f000 f925 	bl	8010400 <comm_cc2520_init>
	comm_usb_init();
 80101b6:	f000 fb03 	bl	80107c0 <comm_usb_init>

	for(;;) {
		chThdSleepMilliseconds(2);
 80101ba:	2014      	movs	r0, #20
 80101bc:	f7fc fb40 	bl	800c840 <chThdSleep>
		packet_timerfunc();
 80101c0:	f000 fb9e 	bl	8010900 <packet_timerfunc>
	}
 80101c4:	e7f9      	b.n	80101ba <main+0x1a>
 80101c6:	bf00      	nop
	...

080101d0 <get_descriptor>:
		uint8_t dindex,
		uint16_t lang) {

	(void)usbp;
	(void)lang;
	switch (dtype) {
 80101d0:	2902      	cmp	r1, #2
 80101d2:	d006      	beq.n	80101e2 <get_descriptor+0x12>
 80101d4:	2903      	cmp	r1, #3
 80101d6:	d006      	beq.n	80101e6 <get_descriptor+0x16>
 80101d8:	2901      	cmp	r1, #1
		return &vcom_configuration_descriptor;
	case USB_DESCRIPTOR_STRING:
		if (dindex < 4)
			return &vcom_strings[dindex];
	}
	return NULL;
 80101da:	4806      	ldr	r0, [pc, #24]	; (80101f4 <get_descriptor+0x24>)
 80101dc:	bf18      	it	ne
 80101de:	2000      	movne	r0, #0
 80101e0:	4770      	bx	lr
	(void)lang;
	switch (dtype) {
	case USB_DESCRIPTOR_DEVICE:
		return &vcom_device_descriptor;
	case USB_DESCRIPTOR_CONFIGURATION:
		return &vcom_configuration_descriptor;
 80101e2:	4805      	ldr	r0, [pc, #20]	; (80101f8 <get_descriptor+0x28>)
 80101e4:	4770      	bx	lr
	case USB_DESCRIPTOR_STRING:
		if (dindex < 4)
 80101e6:	2a03      	cmp	r2, #3
			return &vcom_strings[dindex];
 80101e8:	bf9a      	itte	ls
 80101ea:	4b04      	ldrls	r3, [pc, #16]	; (80101fc <get_descriptor+0x2c>)
 80101ec:	eb03 00c2 	addls.w	r0, r3, r2, lsl #3
	}
	return NULL;
 80101f0:	2000      	movhi	r0, #0
}
 80101f2:	4770      	bx	lr
 80101f4:	08010fa0 	.word	0x08010fa0
 80101f8:	08010e20 	.word	0x08010e20
 80101fc:	08010f70 	.word	0x08010f70

08010200 <usb_event>:
/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {

	switch (event) {
 8010200:	2902      	cmp	r1, #2
 8010202:	d111      	bne.n	8010228 <usb_event+0x28>
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8010204:	b538      	push	{r3, r4, r5, lr}
 8010206:	4605      	mov	r5, r0
 8010208:	460c      	mov	r4, r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 801020a:	b672      	cpsid	i
		chSysLockFromISR();

		/* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
		usbInitEndpointI(usbp, USBD2_DATA_REQUEST_EP, &ep1config);
 801020c:	2101      	movs	r1, #1
 801020e:	4a07      	ldr	r2, [pc, #28]	; (801022c <usb_event+0x2c>)
 8010210:	f7fd f8e6 	bl	800d3e0 <usbInitEndpointI>
		usbInitEndpointI(usbp, USBD2_INTERRUPT_REQUEST_EP, &ep2config);
 8010214:	4628      	mov	r0, r5
 8010216:	4621      	mov	r1, r4
 8010218:	4a05      	ldr	r2, [pc, #20]	; (8010230 <usb_event+0x30>)
 801021a:	f7fd f8e1 	bl	800d3e0 <usbInitEndpointI>

		/* Resetting the state of the CDC subsystem.*/
		sduConfigureHookI(&SDU1);
 801021e:	4805      	ldr	r0, [pc, #20]	; (8010234 <usb_event+0x34>)
 8010220:	f7fc fff6 	bl	800d210 <sduConfigureHookI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8010224:	b662      	cpsie	i
 8010226:	bd38      	pop	{r3, r4, r5, pc}
 8010228:	4770      	bx	lr
 801022a:	bf00      	nop
 801022c:	08010df0 	.word	0x08010df0
 8010230:	08010e30 	.word	0x08010e30
 8010234:	20001884 	.word	0x20001884
	...

08010240 <comm_usb_serial_init>:
		USBD2_DATA_REQUEST_EP,
		USBD2_DATA_AVAILABLE_EP,
		USBD2_INTERRUPT_REQUEST_EP
};

void comm_usb_serial_init(void) {
 8010240:	b538      	push	{r3, r4, r5, lr}
	sduObjectInit(&SDU1);
 8010242:	4d0e      	ldr	r5, [pc, #56]	; (801027c <comm_usb_serial_init+0x3c>)
	/*
	 * Activates the USB driver and then the USB bus pull-up on D+.
	 * Note, a delay is inserted in order to not have to disconnect the cable
	 * after a reset.
	 */
	usbDisconnectBus(serusbcfg.usbp);
 8010244:	4c0e      	ldr	r4, [pc, #56]	; (8010280 <comm_usb_serial_init+0x40>)
		USBD2_DATA_AVAILABLE_EP,
		USBD2_INTERRUPT_REQUEST_EP
};

void comm_usb_serial_init(void) {
	sduObjectInit(&SDU1);
 8010246:	4628      	mov	r0, r5
 8010248:	f7fc ffa2 	bl	800d190 <sduObjectInit>
	sduStart(&SDU1, &serusbcfg);
 801024c:	490d      	ldr	r1, [pc, #52]	; (8010284 <comm_usb_serial_init+0x44>)
 801024e:	4628      	mov	r0, r5
 8010250:	f7fc ffc6 	bl	800d1e0 <sduStart>
	/*
	 * Activates the USB driver and then the USB bus pull-up on D+.
	 * Note, a delay is inserted in order to not have to disconnect the cable
	 * after a reset.
	 */
	usbDisconnectBus(serusbcfg.usbp);
 8010254:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8010256:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8010258:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 801025c:	6393      	str	r3, [r2, #56]	; 0x38
	chThdSleepMilliseconds(1500);
 801025e:	f643 2098 	movw	r0, #15000	; 0x3a98
 8010262:	f7fc faed 	bl	800c840 <chThdSleep>
	usbStart(serusbcfg.usbp, &usbcfg);
 8010266:	4620      	mov	r0, r4
 8010268:	4907      	ldr	r1, [pc, #28]	; (8010288 <comm_usb_serial_init+0x48>)
 801026a:	f7fd f8a9 	bl	800d3c0 <usbStart>
	usbConnectBus(serusbcfg.usbp);
 801026e:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8010270:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8010272:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8010276:	6393      	str	r3, [r2, #56]	; 0x38
 8010278:	bd38      	pop	{r3, r4, r5, pc}
 801027a:	bf00      	nop
 801027c:	20001884 	.word	0x20001884
 8010280:	20000c18 	.word	0x20000c18
 8010284:	08010f90 	.word	0x08010f90
 8010288:	08010e60 	.word	0x08010e60
 801028c:	00000000 	.word	0x00000000

08010290 <tx_thread>:
 8010290:	4b14      	ldr	r3, [pc, #80]	; (80102e4 <tx_thread+0x54>)
static THD_FUNCTION(tx_thread, arg) {
	(void)arg;

	chRegSetThreadName("CC2520 Tx");

	tx_tp = chThdGetSelfX();
 8010292:	4a15      	ldr	r2, [pc, #84]	; (80102e8 <tx_thread+0x58>)
 8010294:	699b      	ldr	r3, [r3, #24]
 8010296:	4c15      	ldr	r4, [pc, #84]	; (80102ec <tx_thread+0x5c>)
 8010298:	4915      	ldr	r1, [pc, #84]	; (80102f0 <tx_thread+0x60>)
 801029a:	4d16      	ldr	r5, [pc, #88]	; (80102f4 <tx_thread+0x64>)
 801029c:	4e16      	ldr	r6, [pc, #88]	; (80102f8 <tx_thread+0x68>)
 801029e:	f8df 805c 	ldr.w	r8, [pc, #92]	; 80102fc <tx_thread+0x6c>

		chThdSleepMicroseconds(100);
	}
}

static THD_FUNCTION(tx_thread, arg) {
 80102a2:	b580      	push	{r7, lr}
 80102a4:	6199      	str	r1, [r3, #24]
	(void)arg;

	chRegSetThreadName("CC2520 Tx");

	tx_tp = chThdGetSelfX();
 80102a6:	6013      	str	r3, [r2, #0]

		while(tx_slot_read != tx_slot_write) {
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
			led_toggle(LED_GREEN);

			tx_slot_read++;
 80102a8:	4627      	mov	r7, r4
	chRegSetThreadName("CC2520 Tx");

	tx_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);
 80102aa:	2001      	movs	r0, #1
 80102ac:	f7fc fc78 	bl	800cba0 <chEvtWaitAny>
 80102b0:	6823      	ldr	r3, [r4, #0]

		while(tx_slot_read != tx_slot_write) {
 80102b2:	f8d8 2000 	ldr.w	r2, [r8]
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
 80102b6:	eb03 1183 	add.w	r1, r3, r3, lsl #6
	tx_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while(tx_slot_read != tx_slot_write) {
 80102ba:	429a      	cmp	r2, r3
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
 80102bc:	eb05 0141 	add.w	r1, r5, r1, lsl #1
 80102c0:	f64f 70ff 	movw	r0, #65535	; 0xffff
	tx_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while(tx_slot_read != tx_slot_write) {
 80102c4:	d0f1      	beq.n	80102aa <tx_thread+0x1a>
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
 80102c6:	5cf2      	ldrb	r2, [r6, r3]
 80102c8:	f7ff feea 	bl	80100a0 <basicRfSendPacket>
			led_toggle(LED_GREEN);
 80102cc:	2001      	movs	r0, #1
 80102ce:	f000 f9b7 	bl	8010640 <led_toggle>

			tx_slot_read++;
 80102d2:	6823      	ldr	r3, [r4, #0]
 80102d4:	3301      	adds	r3, #1
			if (tx_slot_read >= TX_BUFFER_SLOTS) {
 80102d6:	2b09      	cmp	r3, #9

		while(tx_slot_read != tx_slot_write) {
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
			led_toggle(LED_GREEN);

			tx_slot_read++;
 80102d8:	6023      	str	r3, [r4, #0]
			if (tx_slot_read >= TX_BUFFER_SLOTS) {
 80102da:	ddea      	ble.n	80102b2 <tx_thread+0x22>
				tx_slot_read = 0;
 80102dc:	2300      	movs	r3, #0
 80102de:	603b      	str	r3, [r7, #0]
 80102e0:	e7e6      	b.n	80102b0 <tx_thread+0x20>
 80102e2:	bf00      	nop
 80102e4:	20000838 	.word	0x20000838
 80102e8:	2000249c 	.word	0x2000249c
 80102ec:	20002e68 	.word	0x20002e68
 80102f0:	08010fb0 	.word	0x08010fb0
 80102f4:	20001b88 	.word	0x20001b88
 80102f8:	200024a4 	.word	0x200024a4
 80102fc:	200024a0 	.word	0x200024a0

08010300 <rx_thread>:
		chVTSetI(&vt, US2ST(TX_DELAY_US), wakeup_tx, NULL);
	}
	chSysUnlock();
}

static THD_FUNCTION(rx_thread, arg) {
 8010300:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010304:	4b2b      	ldr	r3, [pc, #172]	; (80103b4 <rx_thread+0xb4>)
 8010306:	4d2c      	ldr	r5, [pc, #176]	; (80103b8 <rx_thread+0xb8>)
 8010308:	699b      	ldr	r3, [r3, #24]
 801030a:	4a2c      	ldr	r2, [pc, #176]	; (80103bc <rx_thread+0xbc>)
 801030c:	4f2c      	ldr	r7, [pc, #176]	; (80103c0 <rx_thread+0xc0>)
 801030e:	619a      	str	r2, [r3, #24]
		if (basicRfPacketIsReady()) {
			static uint8_t buf[130];
			unsigned int len = 0;
			unsigned int ind = 0;

			len = basicRfReceive(buf, 130, NULL);
 8010310:	46a8      	mov	r8, r5
 8010312:	e002      	b.n	801031a <rx_thread+0x1a>
			default:
				break;
			}
		}

		chThdSleepMicroseconds(100);
 8010314:	2001      	movs	r0, #1
 8010316:	f7fc fa93 	bl	800c840 <chThdSleep>
	(void)arg;

	chRegSetThreadName("CC2520 RX");

	for(;;) {
		if (basicRfPacketIsReady()) {
 801031a:	f7ff fe59 	bl	800ffd0 <basicRfPacketIsReady>
 801031e:	2800      	cmp	r0, #0
 8010320:	d0f8      	beq.n	8010314 <rx_thread+0x14>
			static uint8_t buf[130];
			unsigned int len = 0;
			unsigned int ind = 0;

			len = basicRfReceive(buf, 130, NULL);
 8010322:	4825      	ldr	r0, [pc, #148]	; (80103b8 <rx_thread+0xb8>)
 8010324:	2182      	movs	r1, #130	; 0x82
 8010326:	2200      	movs	r2, #0
 8010328:	f7ff fe5a 	bl	800ffe0 <basicRfReceive>
			MOTE_PACKET packet = buf[0];
 801032c:	782c      	ldrb	r4, [r5, #0]
		if (basicRfPacketIsReady()) {
			static uint8_t buf[130];
			unsigned int len = 0;
			unsigned int ind = 0;

			len = basicRfReceive(buf, 130, NULL);
 801032e:	4606      	mov	r6, r0
			MOTE_PACKET packet = buf[0];

			led_toggle(LED_RED);
 8010330:	2000      	movs	r0, #0
 8010332:	f000 f985 	bl	8010640 <led_toggle>

			switch (packet) {
 8010336:	2c03      	cmp	r4, #3
 8010338:	d8ec      	bhi.n	8010314 <rx_thread+0x14>
 801033a:	e8df f004 	tbb	[pc, r4]
 801033e:	2633      	.short	0x2633
 8010340:	0207      	.short	0x0207
				}
			}
			break;

			case MOTE_PACKET_PROCESS_SHORT_BUFFER:
				comm_usb_send_packet(buf + 1, len - 1);
 8010342:	1e71      	subs	r1, r6, #1
 8010344:	481f      	ldr	r0, [pc, #124]	; (80103c4 <rx_thread+0xc4>)
 8010346:	f000 fa6b 	bl	8010820 <comm_usb_send_packet>
				break;
 801034a:	e7e3      	b.n	8010314 <rx_thread+0x14>
			}
			break;

			case MOTE_PACKET_PROCESS_RX_BUFFER: {
				ind = 1;
				int rxbuf_len = (unsigned int)buf[ind++] << 8;
 801034c:	786c      	ldrb	r4, [r5, #1]
				rxbuf_len |= (unsigned int)buf[ind++];
 801034e:	78ab      	ldrb	r3, [r5, #2]
 8010350:	ea43 2404 	orr.w	r4, r3, r4, lsl #8

				if (rxbuf_len > RX_BUFFER_SIZE) {
 8010354:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 8010358:	d8dc      	bhi.n	8010314 <rx_thread+0x14>
 801035a:	1d60      	adds	r0, r4, #5
				}

				uint8_t crc_high = buf[ind++];
				uint8_t crc_low = buf[ind++];

				memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);
 801035c:	1b80      	subs	r0, r0, r6
 801035e:	1f72      	subs	r2, r6, #5
 8010360:	4919      	ldr	r1, [pc, #100]	; (80103c8 <rx_thread+0xc8>)

				if (rxbuf_len > RX_BUFFER_SIZE) {
					break;
				}

				uint8_t crc_high = buf[ind++];
 8010362:	f898 9003 	ldrb.w	r9, [r8, #3]
				uint8_t crc_low = buf[ind++];
 8010366:	f898 6004 	ldrb.w	r6, [r8, #4]

				memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);
 801036a:	4438      	add	r0, r7
 801036c:	f7fb fef0 	bl	800c150 <memcpy>

				if (crc16(rx_buffer, rxbuf_len)
 8010370:	4813      	ldr	r0, [pc, #76]	; (80103c0 <rx_thread+0xc0>)
 8010372:	4621      	mov	r1, r4
 8010374:	f000 f984 	bl	8010680 <crc16>
						== ((unsigned short) crc_high << 8
								| (unsigned short) crc_low)) {
 8010378:	ea46 2609 	orr.w	r6, r6, r9, lsl #8
				uint8_t crc_high = buf[ind++];
				uint8_t crc_low = buf[ind++];

				memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);

				if (crc16(rx_buffer, rxbuf_len)
 801037c:	42b0      	cmp	r0, r6
 801037e:	d1c9      	bne.n	8010314 <rx_thread+0x14>
						== ((unsigned short) crc_high << 8
								| (unsigned short) crc_low)) {

					comm_usb_send_packet(rx_buffer, rxbuf_len);
 8010380:	4621      	mov	r1, r4
 8010382:	480f      	ldr	r0, [pc, #60]	; (80103c0 <rx_thread+0xc0>)
 8010384:	f000 fa4c 	bl	8010820 <comm_usb_send_packet>
 8010388:	e7c4      	b.n	8010314 <rx_thread+0x14>
			case MOTE_PACKET_FILL_RX_BUFFER:
				memcpy(rx_buffer + buf[1], buf + 2, len - 2);
				break;

			case MOTE_PACKET_FILL_RX_BUFFER_LONG: {
				int rxbuf_ind = (unsigned int)buf[1] << 8;
 801038a:	7868      	ldrb	r0, [r5, #1]
				rxbuf_ind |= buf[2];
 801038c:	78ab      	ldrb	r3, [r5, #2]
 801038e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
				if (rxbuf_ind < RX_BUFFER_SIZE) {
 8010392:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8010396:	dabd      	bge.n	8010314 <rx_thread+0x14>
					memcpy(rx_buffer + rxbuf_ind, buf + 3, len - 3);
 8010398:	4438      	add	r0, r7
 801039a:	1ef2      	subs	r2, r6, #3
 801039c:	490b      	ldr	r1, [pc, #44]	; (80103cc <rx_thread+0xcc>)
 801039e:	f7fb fed7 	bl	800c150 <memcpy>
 80103a2:	e7b7      	b.n	8010314 <rx_thread+0x14>

			led_toggle(LED_RED);

			switch (packet) {
			case MOTE_PACKET_FILL_RX_BUFFER:
				memcpy(rx_buffer + buf[1], buf + 2, len - 2);
 80103a4:	7868      	ldrb	r0, [r5, #1]
 80103a6:	490a      	ldr	r1, [pc, #40]	; (80103d0 <rx_thread+0xd0>)
 80103a8:	1eb2      	subs	r2, r6, #2
 80103aa:	4438      	add	r0, r7
 80103ac:	f7fb fed0 	bl	800c150 <memcpy>
				break;
 80103b0:	e7b0      	b.n	8010314 <rx_thread+0x14>
 80103b2:	bf00      	nop
 80103b4:	20000838 	.word	0x20000838
 80103b8:	20001b04 	.word	0x20001b04
 80103bc:	08010fbc 	.word	0x08010fbc
 80103c0:	2000209c 	.word	0x2000209c
 80103c4:	20001b05 	.word	0x20001b05
 80103c8:	20001b09 	.word	0x20001b09
 80103cc:	20001b07 	.word	0x20001b07
 80103d0:	20001b06 	.word	0x20001b06
	...

080103e0 <wakeup_tx>:
			}
		}
	}
}

static void wakeup_tx(void *p) {
 80103e0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80103e2:	b672      	cpsid	i
	(void)p;

	chSysLockFromISR();
	chEvtSignalI(tx_tp, (eventmask_t) 1);
 80103e4:	4b03      	ldr	r3, [pc, #12]	; (80103f4 <wakeup_tx+0x14>)
 80103e6:	2101      	movs	r1, #1
 80103e8:	6818      	ldr	r0, [r3, #0]
 80103ea:	f7fc fba1 	bl	800cb30 <chEvtSignalI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80103ee:	b662      	cpsie	i
 80103f0:	bd08      	pop	{r3, pc}
 80103f2:	bf00      	nop
 80103f4:	2000249c 	.word	0x2000249c
	...

08010400 <comm_cc2520_init>:
static THD_FUNCTION(tx_thread, arg);
static void wakeup_tx(void *p);

#include "led.h"

void comm_cc2520_init(void) {
 8010400:	b530      	push	{r4, r5, lr}
	tx_slot_read = 0;
 8010402:	4a15      	ldr	r2, [pc, #84]	; (8010458 <comm_cc2520_init+0x58>)
	tx_slot_write = 0;
 8010404:	4b15      	ldr	r3, [pc, #84]	; (801045c <comm_cc2520_init+0x5c>)
static void wakeup_tx(void *p);

#include "led.h"

void comm_cc2520_init(void) {
	tx_slot_read = 0;
 8010406:	2400      	movs	r4, #0
static THD_FUNCTION(tx_thread, arg);
static void wakeup_tx(void *p);

#include "led.h"

void comm_cc2520_init(void) {
 8010408:	b083      	sub	sp, #12
	tx_slot_read = 0;
 801040a:	6014      	str	r4, [r2, #0]
	tx_slot_write = 0;
 801040c:	601c      	str	r4, [r3, #0]

	// rf
	halAssyInit();
 801040e:	f7ff fa07 	bl	800f820 <halAssyInit>
	basicRfConfig.panId = CC2520_PAN_ID;
 8010412:	4b13      	ldr	r3, [pc, #76]	; (8010460 <comm_cc2520_init+0x60>)
	basicRfConfig.channel = CC2520_RF_CHANNEL;
 8010414:	210c      	movs	r1, #12
	basicRfConfig.ackRequest = FALSE;
	basicRfConfig.myAddr = CC2520_NODE_ADDRESS;
 8010416:	2201      	movs	r2, #1
	tx_slot_read = 0;
	tx_slot_write = 0;

	// rf
	halAssyInit();
	basicRfConfig.panId = CC2520_PAN_ID;
 8010418:	f64f 2511 	movw	r5, #64017	; 0xfa11
	basicRfConfig.myAddr = CC2520_NODE_ADDRESS;
#ifdef SECURITY_CCM
	basicRfConfig.securityKey = rf_security_key;
#endif

	if(basicRfInit(&basicRfConfig) == FAILED) {
 801041c:	4618      	mov	r0, r3

	// rf
	halAssyInit();
	basicRfConfig.panId = CC2520_PAN_ID;
	basicRfConfig.channel = CC2520_RF_CHANNEL;
	basicRfConfig.ackRequest = FALSE;
 801041e:	715c      	strb	r4, [r3, #5]
	tx_slot_read = 0;
	tx_slot_write = 0;

	// rf
	halAssyInit();
	basicRfConfig.panId = CC2520_PAN_ID;
 8010420:	805d      	strh	r5, [r3, #2]
	basicRfConfig.channel = CC2520_RF_CHANNEL;
 8010422:	7119      	strb	r1, [r3, #4]
	basicRfConfig.ackRequest = FALSE;
	basicRfConfig.myAddr = CC2520_NODE_ADDRESS;
 8010424:	801a      	strh	r2, [r3, #0]
#ifdef SECURITY_CCM
	basicRfConfig.securityKey = rf_security_key;
#endif

	if(basicRfInit(&basicRfConfig) == FAILED) {
 8010426:	f7ff fd8b 	bl	800ff40 <basicRfInit>
 801042a:	2801      	cmp	r0, #1
 801042c:	d100      	bne.n	8010430 <comm_cc2520_init+0x30>
		for(;;) {}
 801042e:	e7fe      	b.n	801042e <comm_cc2520_init+0x2e>
	}

	basicRfReceiveOn();
 8010430:	f7ff fe06 	bl	8010040 <basicRfReceiveOn>

	chThdCreateStatic(rx_thread_wa, sizeof(rx_thread_wa),
 8010434:	9400      	str	r4, [sp, #0]
 8010436:	4b0b      	ldr	r3, [pc, #44]	; (8010464 <comm_cc2520_init+0x64>)
 8010438:	480b      	ldr	r0, [pc, #44]	; (8010468 <comm_cc2520_init+0x68>)
 801043a:	f640 1198 	movw	r1, #2456	; 0x998
 801043e:	2240      	movs	r2, #64	; 0x40
 8010440:	f7fc f9be 	bl	800c7c0 <chThdCreateStatic>
			NORMALPRIO, rx_thread, NULL);
	chThdCreateStatic(tx_thread_wa, sizeof(tx_thread_wa),
 8010444:	9400      	str	r4, [sp, #0]
 8010446:	4b09      	ldr	r3, [pc, #36]	; (801046c <comm_cc2520_init+0x6c>)
 8010448:	4809      	ldr	r0, [pc, #36]	; (8010470 <comm_cc2520_init+0x70>)
 801044a:	f44f 7166 	mov.w	r1, #920	; 0x398
 801044e:	2240      	movs	r2, #64	; 0x40
 8010450:	f7fc f9b6 	bl	800c7c0 <chThdCreateStatic>
			NORMALPRIO, tx_thread, NULL);
}
 8010454:	b003      	add	sp, #12
 8010456:	bd30      	pop	{r4, r5, pc}
 8010458:	20002e68 	.word	0x20002e68
 801045c:	200024a0 	.word	0x200024a0
 8010460:	20002e60 	.word	0x20002e60
 8010464:	08010301 	.word	0x08010301
 8010468:	200024c8 	.word	0x200024c8
 801046c:	08010291 	.word	0x08010291
 8010470:	20002e70 	.word	0x20002e70
	...

08010480 <comm_cc2520_send_packet>:
 * Note that this packet is stored and sent in another thread after a delay. The delay is done
 * in case that this packet is a request from the (Qt) client, which means that more requests
 * can come within a short time. We want to give the additional requests a chance to arrive
 * before blocking the RF channel by sending the response.
 */
void comm_cc2520_send_packet(uint8_t *data, uint8_t len) {
 8010480:	b570      	push	{r4, r5, r6, lr}
	memcpy(tx_buffer[tx_slot_write], data, len);
 8010482:	4d0f      	ldr	r5, [pc, #60]	; (80104c0 <comm_cc2520_send_packet+0x40>)
 8010484:	4b0f      	ldr	r3, [pc, #60]	; (80104c4 <comm_cc2520_send_packet+0x44>)
 8010486:	682c      	ldr	r4, [r5, #0]
 * Note that this packet is stored and sent in another thread after a delay. The delay is done
 * in case that this packet is a request from the (Qt) client, which means that more requests
 * can come within a short time. We want to give the additional requests a chance to arrive
 * before blocking the RF channel by sending the response.
 */
void comm_cc2520_send_packet(uint8_t *data, uint8_t len) {
 8010488:	460e      	mov	r6, r1
	memcpy(tx_buffer[tx_slot_write], data, len);
 801048a:	eb04 1284 	add.w	r2, r4, r4, lsl #6
 801048e:	4601      	mov	r1, r0
 8010490:	eb03 0042 	add.w	r0, r3, r2, lsl #1
 8010494:	4632      	mov	r2, r6
 8010496:	f7fb fe5b 	bl	800c150 <memcpy>
	tx_slot_len[tx_slot_write] = len;

	tx_slot_write++;
 801049a:	1c63      	adds	r3, r4, #1
 * can come within a short time. We want to give the additional requests a chance to arrive
 * before blocking the RF channel by sending the response.
 */
void comm_cc2520_send_packet(uint8_t *data, uint8_t len) {
	memcpy(tx_buffer[tx_slot_write], data, len);
	tx_slot_len[tx_slot_write] = len;
 801049c:	4a0a      	ldr	r2, [pc, #40]	; (80104c8 <comm_cc2520_send_packet+0x48>)

	tx_slot_write++;
	if (tx_slot_write >= TX_BUFFER_SLOTS) {
 801049e:	2b09      	cmp	r3, #9
		tx_slot_write = 0;
 80104a0:	bfc8      	it	gt
 80104a2:	2300      	movgt	r3, #0
 * can come within a short time. We want to give the additional requests a chance to arrive
 * before blocking the RF channel by sending the response.
 */
void comm_cc2520_send_packet(uint8_t *data, uint8_t len) {
	memcpy(tx_buffer[tx_slot_write], data, len);
	tx_slot_len[tx_slot_write] = len;
 80104a4:	5516      	strb	r6, [r2, r4]

	tx_slot_write++;
	if (tx_slot_write >= TX_BUFFER_SLOTS) {
		tx_slot_write = 0;
 80104a6:	602b      	str	r3, [r5, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80104a8:	b672      	cpsid	i
 80104aa:	4808      	ldr	r0, [pc, #32]	; (80104cc <comm_cc2520_send_packet+0x4c>)
	}

	chSysLock();
	if (!chVTIsArmedI(&vt)) {
 80104ac:	68c3      	ldr	r3, [r0, #12]
 80104ae:	b10b      	cbz	r3, 80104b4 <comm_cc2520_send_packet+0x34>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80104b0:	b662      	cpsie	i
 80104b2:	bd70      	pop	{r4, r5, r6, pc}
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 80104b4:	2132      	movs	r1, #50	; 0x32
 80104b6:	4a06      	ldr	r2, [pc, #24]	; (80104d0 <comm_cc2520_send_packet+0x50>)
 80104b8:	f7fb ffaa 	bl	800c410 <chVTDoSetI>
 80104bc:	b662      	cpsie	i
 80104be:	bd70      	pop	{r4, r5, r6, pc}
 80104c0:	200024a0 	.word	0x200024a0
 80104c4:	20001b88 	.word	0x20001b88
 80104c8:	200024a4 	.word	0x200024a4
 80104cc:	200024b0 	.word	0x200024b0
 80104d0:	080103e1 	.word	0x080103e1
	...

080104e0 <comm_cc2520_send_buffer>:
			NORMALPRIO, rx_thread, NULL);
	chThdCreateStatic(tx_thread_wa, sizeof(tx_thread_wa),
			NORMALPRIO, tx_thread, NULL);
}

void comm_cc2520_send_buffer(uint8_t *data, unsigned int len) {
 80104e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t send_buffer[MAX_PL_LEN];

	if (len <= (MAX_PL_LEN - 1)) {
 80104e4:	296d      	cmp	r1, #109	; 0x6d
			NORMALPRIO, rx_thread, NULL);
	chThdCreateStatic(tx_thread_wa, sizeof(tx_thread_wa),
			NORMALPRIO, tx_thread, NULL);
}

void comm_cc2520_send_buffer(uint8_t *data, unsigned int len) {
 80104e6:	b09d      	sub	sp, #116	; 0x74
 80104e8:	4689      	mov	r9, r1
 80104ea:	4682      	mov	sl, r0
	uint8_t send_buffer[MAX_PL_LEN];

	if (len <= (MAX_PL_LEN - 1)) {
 80104ec:	d970      	bls.n	80105d0 <comm_cc2520_send_buffer+0xf0>
		memcpy(send_buffer + ind, data, len);
		ind += len;
		comm_cc2520_send_packet(send_buffer, ind);
	} else {
		unsigned int end_a = 0;
		unsigned int len2 = len - (MAX_PL_LEN - 5);
 80104ee:	f1a1 0769 	sub.w	r7, r1, #105	; 0x69
 80104f2:	b2fd      	uxtb	r5, r7
 80104f4:	1cae      	adds	r6, r5, #2
		send_buffer[ind++] = MOTE_PACKET_PROCESS_SHORT_BUFFER;
		memcpy(send_buffer + ind, data, len);
		ind += len;
		comm_cc2520_send_packet(send_buffer, ind);
	} else {
		unsigned int end_a = 0;
 80104f6:	2400      	movs	r4, #0
 80104f8:	b2f6      	uxtb	r6, r6
			}

			end_a = i + (MAX_PL_LEN - 2);

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
 80104fa:	46a3      	mov	fp, r4
 80104fc:	4680      	mov	r8, r0
		for (unsigned int i = 0;i < len2;i += (MAX_PL_LEN - 2)) {
			if (i > 255) {
				break;
			}

			end_a = i + (MAX_PL_LEN - 2);
 80104fe:	346c      	adds	r4, #108	; 0x6c
 8010500:	f1a4 036c 	sub.w	r3, r4, #108	; 0x6c

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
			send_buffer[1] = i;

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
 8010504:	42a7      	cmp	r7, r4
			}

			end_a = i + (MAX_PL_LEN - 2);

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
 8010506:	f88d b000 	strb.w	fp, [sp]
			send_buffer[1] = i;
 801050a:	f88d 3001 	strb.w	r3, [sp, #1]

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
				memcpy(send_buffer + 2, data + i, send_len);
 801050e:	f10d 0002 	add.w	r0, sp, #2
 8010512:	4641      	mov	r1, r8
 8010514:	f04f 026c 	mov.w	r2, #108	; 0x6c

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
			send_buffer[1] = i;

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
 8010518:	d36d      	bcc.n	80105f6 <comm_cc2520_send_buffer+0x116>
				memcpy(send_buffer + 2, data + i, send_len);
 801051a:	f7fb fe19 	bl	800c150 <memcpy>
 801051e:	216e      	movs	r1, #110	; 0x6e
			} else {
				send_len = len2 - i;
				memcpy(send_buffer + 2, data + i, send_len);
			}

			comm_cc2520_send_packet(send_buffer, send_len + 2);
 8010520:	4668      	mov	r0, sp
 8010522:	f7ff ffad 	bl	8010480 <comm_cc2520_send_packet>
 8010526:	3e6c      	subs	r6, #108	; 0x6c
		comm_cc2520_send_packet(send_buffer, ind);
	} else {
		unsigned int end_a = 0;
		unsigned int len2 = len - (MAX_PL_LEN - 5);

		for (unsigned int i = 0;i < len2;i += (MAX_PL_LEN - 2)) {
 8010528:	42a7      	cmp	r7, r4
 801052a:	b2f6      	uxtb	r6, r6
 801052c:	f108 086c 	add.w	r8, r8, #108	; 0x6c
 8010530:	d92d      	bls.n	801058e <comm_cc2520_send_buffer+0xae>
			if (i > 255) {
 8010532:	f5b4 7fa2 	cmp.w	r4, #324	; 0x144
 8010536:	d1e2      	bne.n	80104fe <comm_cc2520_send_buffer+0x1e>
 8010538:	3d41      	subs	r5, #65	; 0x41
 801053a:	b2ed      	uxtb	r5, r5
 801053c:	f50a 76a2 	add.w	r6, sl, #324	; 0x144
			comm_cc2520_send_packet(send_buffer, send_len + 2);
		}

		for (unsigned int i = end_a;i < len2;i += (MAX_PL_LEN - 3)) {
			uint8_t send_len = (MAX_PL_LEN - 3);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
 8010540:	f04f 0801 	mov.w	r8, #1
 8010544:	e00b      	b.n	801055e <comm_cc2520_send_buffer+0x7e>
			send_buffer[1] = i >> 8;
			send_buffer[2] = i & 0xFF;

			if ((i + (MAX_PL_LEN - 3)) <= len2) {
				memcpy(send_buffer + 3, data + i, send_len);
 8010546:	f7fb fe03 	bl	800c150 <memcpy>
 801054a:	216e      	movs	r1, #110	; 0x6e
			} else {
				send_len = len2 - i;
				memcpy(send_buffer + 3, data + i, send_len);
			}

			comm_cc2520_send_packet(send_buffer, send_len + 3);
 801054c:	4668      	mov	r0, sp
 801054e:	f7ff ff97 	bl	8010480 <comm_cc2520_send_packet>
 8010552:	3d6b      	subs	r5, #107	; 0x6b
			}

			comm_cc2520_send_packet(send_buffer, send_len + 2);
		}

		for (unsigned int i = end_a;i < len2;i += (MAX_PL_LEN - 3)) {
 8010554:	42a7      	cmp	r7, r4
 8010556:	f106 066b 	add.w	r6, r6, #107	; 0x6b
 801055a:	b2ed      	uxtb	r5, r5
 801055c:	d917      	bls.n	801058e <comm_cc2520_send_buffer+0xae>
			uint8_t send_len = (MAX_PL_LEN - 3);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
			send_buffer[1] = i >> 8;
 801055e:	0a23      	lsrs	r3, r4, #8
			send_buffer[2] = i & 0xFF;
 8010560:	f88d 4002 	strb.w	r4, [sp, #2]

			if ((i + (MAX_PL_LEN - 3)) <= len2) {
 8010564:	346b      	adds	r4, #107	; 0x6b
 8010566:	42a7      	cmp	r7, r4
			comm_cc2520_send_packet(send_buffer, send_len + 2);
		}

		for (unsigned int i = end_a;i < len2;i += (MAX_PL_LEN - 3)) {
			uint8_t send_len = (MAX_PL_LEN - 3);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
 8010568:	f88d 8000 	strb.w	r8, [sp]
			send_buffer[1] = i >> 8;
 801056c:	f88d 3001 	strb.w	r3, [sp, #1]
			send_buffer[2] = i & 0xFF;

			if ((i + (MAX_PL_LEN - 3)) <= len2) {
				memcpy(send_buffer + 3, data + i, send_len);
 8010570:	f10d 0003 	add.w	r0, sp, #3
 8010574:	4631      	mov	r1, r6
 8010576:	f04f 026b 	mov.w	r2, #107	; 0x6b
			uint8_t send_len = (MAX_PL_LEN - 3);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
			send_buffer[1] = i >> 8;
			send_buffer[2] = i & 0xFF;

			if ((i + (MAX_PL_LEN - 3)) <= len2) {
 801057a:	d2e4      	bcs.n	8010546 <comm_cc2520_send_buffer+0x66>
 801057c:	1eea      	subs	r2, r5, #3
				memcpy(send_buffer + 3, data + i, send_len);
			} else {
				send_len = len2 - i;
				memcpy(send_buffer + 3, data + i, send_len);
 801057e:	4631      	mov	r1, r6
 8010580:	b2d2      	uxtb	r2, r2
 8010582:	f10d 0003 	add.w	r0, sp, #3
 8010586:	f7fb fde3 	bl	800c150 <memcpy>
 801058a:	4629      	mov	r1, r5
 801058c:	e7de      	b.n	801054c <comm_cc2520_send_buffer+0x6c>
			comm_cc2520_send_packet(send_buffer, send_len + 3);
		}

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
		send_buffer[ind++] = len >> 8;
 801058e:	ea4f 2319 	mov.w	r3, r9, lsr #8

			comm_cc2520_send_packet(send_buffer, send_len + 3);
		}

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
 8010592:	2202      	movs	r2, #2
		send_buffer[ind++] = len >> 8;
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
 8010594:	4649      	mov	r1, r9
 8010596:	4650      	mov	r0, sl

			comm_cc2520_send_packet(send_buffer, send_len + 3);
		}

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
 8010598:	f88d 2000 	strb.w	r2, [sp]
		send_buffer[ind++] = len >> 8;
 801059c:	f88d 3001 	strb.w	r3, [sp, #1]
		send_buffer[ind++] = len & 0xFF;
 80105a0:	f88d 9002 	strb.w	r9, [sp, #2]
		unsigned short crc = crc16(data, len);
 80105a4:	f000 f86c 	bl	8010680 <crc16>
		send_buffer[ind++] = (uint8_t)(crc >> 8);
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
		memcpy(send_buffer + 5, data + len2, len - len2);
 80105a8:	eb0a 0107 	add.w	r1, sl, r7

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
		send_buffer[ind++] = len >> 8;
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
 80105ac:	4603      	mov	r3, r0
		send_buffer[ind++] = (uint8_t)(crc >> 8);
 80105ae:	0a04      	lsrs	r4, r0, #8
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
		memcpy(send_buffer + 5, data + len2, len - len2);
 80105b0:	2269      	movs	r2, #105	; 0x69
 80105b2:	f10d 0005 	add.w	r0, sp, #5
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
		send_buffer[ind++] = len >> 8;
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
		send_buffer[ind++] = (uint8_t)(crc >> 8);
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
 80105b6:	f88d 3004 	strb.w	r3, [sp, #4]
		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
		send_buffer[ind++] = len >> 8;
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
		send_buffer[ind++] = (uint8_t)(crc >> 8);
 80105ba:	f88d 4003 	strb.w	r4, [sp, #3]
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
		memcpy(send_buffer + 5, data + len2, len - len2);
 80105be:	f7fb fdc7 	bl	800c150 <memcpy>
		ind += len - len2;

		comm_cc2520_send_packet(send_buffer, ind);
 80105c2:	4668      	mov	r0, sp
 80105c4:	216e      	movs	r1, #110	; 0x6e
 80105c6:	f7ff ff5b 	bl	8010480 <comm_cc2520_send_packet>
	}
}
 80105ca:	b01d      	add	sp, #116	; 0x74
 80105cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
void comm_cc2520_send_buffer(uint8_t *data, unsigned int len) {
	uint8_t send_buffer[MAX_PL_LEN];

	if (len <= (MAX_PL_LEN - 1)) {
		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_SHORT_BUFFER;
 80105d0:	ac1c      	add	r4, sp, #112	; 0x70
 80105d2:	2303      	movs	r3, #3
 80105d4:	f804 3d70 	strb.w	r3, [r4, #-112]!
		memcpy(send_buffer + ind, data, len);
 80105d8:	4601      	mov	r1, r0
 80105da:	464a      	mov	r2, r9
 80105dc:	f10d 0001 	add.w	r0, sp, #1
 80105e0:	f7fb fdb6 	bl	800c150 <memcpy>
		ind += len;
 80105e4:	f109 0101 	add.w	r1, r9, #1
		comm_cc2520_send_packet(send_buffer, ind);
 80105e8:	4620      	mov	r0, r4
 80105ea:	b2c9      	uxtb	r1, r1
 80105ec:	f7ff ff48 	bl	8010480 <comm_cc2520_send_packet>
		memcpy(send_buffer + 5, data + len2, len - len2);
		ind += len - len2;

		comm_cc2520_send_packet(send_buffer, ind);
	}
}
 80105f0:	b01d      	add	sp, #116	; 0x74
 80105f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80105f6:	1eb2      	subs	r2, r6, #2

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
				memcpy(send_buffer + 2, data + i, send_len);
			} else {
				send_len = len2 - i;
				memcpy(send_buffer + 2, data + i, send_len);
 80105f8:	4641      	mov	r1, r8
 80105fa:	b2d2      	uxtb	r2, r2
 80105fc:	f10d 0002 	add.w	r0, sp, #2
 8010600:	f7fb fda6 	bl	800c150 <memcpy>
 8010604:	4631      	mov	r1, r6
 8010606:	e78b      	b.n	8010520 <comm_cc2520_send_buffer+0x40>
	...

08010610 <led_init>:

#include "led.h"
#include "ch.h"
#include "hal.h"

void led_init(void) {
 8010610:	b510      	push	{r4, lr}
	palSetPadMode(GPIOA, 1,
 8010612:	4c09      	ldr	r4, [pc, #36]	; (8010638 <led_init+0x28>)
 8010614:	2102      	movs	r1, #2
 8010616:	4620      	mov	r0, r4
 8010618:	2219      	movs	r2, #25
 801061a:	f7fe f959 	bl	800e8d0 <_pal_lld_setgroupmode>
			PAL_MODE_OUTPUT_PUSHPULL |
			PAL_STM32_OSPEED_HIGHEST);
	palSetPadMode(GPIOA, 2,
 801061e:	2219      	movs	r2, #25
 8010620:	4620      	mov	r0, r4
 8010622:	2104      	movs	r1, #4
 8010624:	f7fe f954 	bl	800e8d0 <_pal_lld_setgroupmode>
}

void led_write(int num, int state) {
	switch (num) {
	case LED_RED:
		palWritePad(GPIOA, 2, state);
 8010628:	f44f 2280 	mov.w	r2, #262144	; 0x40000
		break;

	case LED_GREEN:
		palWritePad(GPIOA, 1, state);
 801062c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
}

void led_write(int num, int state) {
	switch (num) {
	case LED_RED:
		palWritePad(GPIOA, 2, state);
 8010630:	61a2      	str	r2, [r4, #24]
		break;

	case LED_GREEN:
		palWritePad(GPIOA, 1, state);
 8010632:	61a3      	str	r3, [r4, #24]
 8010634:	bd10      	pop	{r4, pc}
 8010636:	bf00      	nop
 8010638:	40020000 	.word	0x40020000
 801063c:	00000000 	.word	0x00000000

08010640 <led_toggle>:
		break;
	}
}

void led_toggle(int num) {
	switch (num) {
 8010640:	b140      	cbz	r0, 8010654 <led_toggle+0x14>
 8010642:	2801      	cmp	r0, #1
 8010644:	d105      	bne.n	8010652 <led_toggle+0x12>
	case LED_RED:
		palTogglePad(GPIOA, 2);
		break;

	case LED_GREEN:
		palTogglePad(GPIOA, 1);
 8010646:	4a06      	ldr	r2, [pc, #24]	; (8010660 <led_toggle+0x20>)
 8010648:	6953      	ldr	r3, [r2, #20]
 801064a:	f083 0302 	eor.w	r3, r3, #2
 801064e:	6153      	str	r3, [r2, #20]
 8010650:	4770      	bx	lr
 8010652:	4770      	bx	lr
}

void led_toggle(int num) {
	switch (num) {
	case LED_RED:
		palTogglePad(GPIOA, 2);
 8010654:	4a02      	ldr	r2, [pc, #8]	; (8010660 <led_toggle+0x20>)
 8010656:	6953      	ldr	r3, [r2, #20]
 8010658:	f083 0304 	eor.w	r3, r3, #4
 801065c:	6153      	str	r3, [r2, #20]
		break;
 801065e:	4770      	bx	lr
 8010660:	40020000 	.word	0x40020000
	...

08010670 <ext_cb_init>:
				{EXT_CH_MODE_DISABLED, NULL}
		}
};

void ext_cb_init(void) {
	extStart(&EXTD1, &extcfg);
 8010670:	4801      	ldr	r0, [pc, #4]	; (8010678 <ext_cb_init+0x8>)
 8010672:	4902      	ldr	r1, [pc, #8]	; (801067c <ext_cb_init+0xc>)
 8010674:	f7fc bc9c 	b.w	800cfb0 <extStart>
 8010678:	20000b70 	.word	0x20000b70
 801067c:	08010fd0 	.word	0x08010fd0

08010680 <crc16>:
		0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16(unsigned char *buf, unsigned int len) {
	unsigned int i;
	unsigned short cksum = 0;
	for (i = 0; i < len; i++) {
 8010680:	b191      	cbz	r1, 80106a8 <crc16+0x28>
		0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b,
		0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0,
		0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
		0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16(unsigned char *buf, unsigned int len) {
 8010682:	b470      	push	{r4, r5, r6}
 8010684:	4e09      	ldr	r6, [pc, #36]	; (80106ac <crc16+0x2c>)
 8010686:	1845      	adds	r5, r0, r1
	unsigned int i;
	unsigned short cksum = 0;
	for (i = 0; i < len; i++) {
 8010688:	2300      	movs	r3, #0
		cksum = crc16_tab[(((cksum >> 8) ^ *buf++) & 0xFF)] ^ (cksum << 8);
 801068a:	f810 2b01 	ldrb.w	r2, [r0], #1
 801068e:	f3c3 240f 	ubfx	r4, r3, #8, #16
 8010692:	4062      	eors	r2, r4
		0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16(unsigned char *buf, unsigned int len) {
	unsigned int i;
	unsigned short cksum = 0;
	for (i = 0; i < len; i++) {
 8010694:	42a8      	cmp	r0, r5
		cksum = crc16_tab[(((cksum >> 8) ^ *buf++) & 0xFF)] ^ (cksum << 8);
 8010696:	f836 1012 	ldrh.w	r1, [r6, r2, lsl #1]
 801069a:	ea81 2303 	eor.w	r3, r1, r3, lsl #8
 801069e:	b29b      	uxth	r3, r3
		0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16(unsigned char *buf, unsigned int len) {
	unsigned int i;
	unsigned short cksum = 0;
	for (i = 0; i < len; i++) {
 80106a0:	d1f3      	bne.n	801068a <crc16+0xa>
		cksum = crc16_tab[(((cksum >> 8) ^ *buf++) & 0xFF)] ^ (cksum << 8);
	}
	return cksum;
}
 80106a2:	4618      	mov	r0, r3
 80106a4:	bc70      	pop	{r4, r5, r6}
 80106a6:	4770      	bx	lr
 80106a8:	4608      	mov	r0, r1
 80106aa:	4770      	bx	lr
 80106ac:	08011090 	.word	0x08011090

080106b0 <send_packet>:
static void process_packet(unsigned char *data, unsigned int len) {
	comm_cc2520_send_buffer(data, len);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
	chSequentialStreamWrite(&SDU1, buffer, len);
 80106b0:	4b05      	ldr	r3, [pc, #20]	; (80106c8 <send_packet+0x18>)

static void process_packet(unsigned char *data, unsigned int len) {
	comm_cc2520_send_buffer(data, len);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
 80106b2:	b410      	push	{r4}
	chSequentialStreamWrite(&SDU1, buffer, len);
 80106b4:	681c      	ldr	r4, [r3, #0]
 80106b6:	6824      	ldr	r4, [r4, #0]

static void process_packet(unsigned char *data, unsigned int len) {
	comm_cc2520_send_buffer(data, len);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
 80106b8:	460a      	mov	r2, r1
	chSequentialStreamWrite(&SDU1, buffer, len);
 80106ba:	4601      	mov	r1, r0
 80106bc:	4618      	mov	r0, r3
 80106be:	4623      	mov	r3, r4
}
 80106c0:	f85d 4b04 	ldr.w	r4, [sp], #4
static void process_packet(unsigned char *data, unsigned int len) {
	comm_cc2520_send_buffer(data, len);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
	chSequentialStreamWrite(&SDU1, buffer, len);
 80106c4:	4718      	bx	r3
 80106c6:	bf00      	nop
 80106c8:	20001884 	.word	0x20001884
 80106cc:	00000000 	.word	0x00000000

080106d0 <serial_process_thread>:
 80106d0:	4b11      	ldr	r3, [pc, #68]	; (8010718 <serial_process_thread+0x48>)
static THD_FUNCTION(serial_process_thread, arg) {
	(void)arg;

	chRegSetThreadName("USB-Serial process");

	process_tp = chThdGetSelfX();
 80106d2:	4a12      	ldr	r2, [pc, #72]	; (801071c <serial_process_thread+0x4c>)
 80106d4:	699b      	ldr	r3, [r3, #24]
 80106d6:	4c12      	ldr	r4, [pc, #72]	; (8010720 <serial_process_thread+0x50>)
 80106d8:	4912      	ldr	r1, [pc, #72]	; (8010724 <serial_process_thread+0x54>)
 80106da:	4e13      	ldr	r6, [pc, #76]	; (8010728 <serial_process_thread+0x58>)
			had_data = 0;
		}
	}
}

static THD_FUNCTION(serial_process_thread, arg) {
 80106dc:	b580      	push	{r7, lr}
 80106de:	4f13      	ldr	r7, [pc, #76]	; (801072c <serial_process_thread+0x5c>)
 80106e0:	6199      	str	r1, [r3, #24]
	(void)arg;

	chRegSetThreadName("USB-Serial process");

	process_tp = chThdGetSelfX();
 80106e2:	6013      	str	r3, [r2, #0]

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while (serial_rx_read_pos != serial_rx_write_pos) {
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 80106e4:	46a1      	mov	r9, r4
	chRegSetThreadName("USB-Serial process");

	process_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);
 80106e6:	2001      	movs	r0, #1
 80106e8:	f7fc fa5a 	bl	800cba0 <chEvtWaitAny>

		while (serial_rx_read_pos != serial_rx_write_pos) {
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 80106ec:	f04f 0800 	mov.w	r8, #0
 80106f0:	6823      	ldr	r3, [r4, #0]
	process_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while (serial_rx_read_pos != serial_rx_write_pos) {
 80106f2:	6832      	ldr	r2, [r6, #0]
 80106f4:	429a      	cmp	r2, r3
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 80106f6:	f103 0501 	add.w	r5, r3, #1
 80106fa:	f04f 0100 	mov.w	r1, #0
	process_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while (serial_rx_read_pos != serial_rx_write_pos) {
 80106fe:	d0f2      	beq.n	80106e6 <serial_process_thread+0x16>
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8010700:	5cf8      	ldrb	r0, [r7, r3]
 8010702:	6025      	str	r5, [r4, #0]
 8010704:	f000 f90c 	bl	8010920 <packet_process_byte>

			if (serial_rx_read_pos == SERIAL_RX_BUFFER_SIZE) {
 8010708:	6823      	ldr	r3, [r4, #0]
 801070a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 801070e:	d1f0      	bne.n	80106f2 <serial_process_thread+0x22>
				serial_rx_read_pos = 0;
 8010710:	f8c9 8000 	str.w	r8, [r9]
 8010714:	e7ec      	b.n	80106f0 <serial_process_thread+0x20>
 8010716:	bf00      	nop
 8010718:	20000838 	.word	0x20000838
 801071c:	20004f54 	.word	0x20004f54
 8010720:	20004f50 	.word	0x20004f50
 8010724:	08011290 	.word	0x08011290
 8010728:	20003208 	.word	0x20003208
 801072c:	200043b8 	.word	0x200043b8

08010730 <serial_read_thread>:
	chMtxLock(&send_mutex);
	packet_send_packet(data, len, PACKET_HANDLER);
	chMtxUnlock(&send_mutex);
}

static THD_FUNCTION(serial_read_thread, arg) {
 8010730:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010734:	4b15      	ldr	r3, [pc, #84]	; (801078c <serial_read_thread+0x5c>)
 8010736:	4a16      	ldr	r2, [pc, #88]	; (8010790 <serial_read_thread+0x60>)
 8010738:	699b      	ldr	r3, [r3, #24]
 801073a:	4f16      	ldr	r7, [pc, #88]	; (8010794 <serial_read_thread+0x64>)
 801073c:	4e16      	ldr	r6, [pc, #88]	; (8010798 <serial_read_thread+0x68>)
 801073e:	f8df 905c 	ldr.w	r9, [pc, #92]	; 801079c <serial_read_thread+0x6c>
 8010742:	f8df 805c 	ldr.w	r8, [pc, #92]	; 80107a0 <serial_read_thread+0x70>
 8010746:	619a      	str	r2, [r3, #24]
 8010748:	b0a1      	sub	sp, #132	; 0x84
	int i;
	int len;
	int had_data = 0;

	for(;;) {
		len = chSequentialStreamRead(&SDU1, (uint8_t*) buffer, 1);
 801074a:	683b      	ldr	r3, [r7, #0]
 801074c:	4811      	ldr	r0, [pc, #68]	; (8010794 <serial_read_thread+0x64>)
 801074e:	685b      	ldr	r3, [r3, #4]
 8010750:	4669      	mov	r1, sp
 8010752:	2201      	movs	r2, #1
 8010754:	4798      	blx	r3

		for (i = 0;i < len;i++) {
 8010756:	2800      	cmp	r0, #0
 8010758:	ddf7      	ble.n	801074a <serial_read_thread+0x1a>
 801075a:	6833      	ldr	r3, [r6, #0]
 801075c:	f10d 34ff 	add.w	r4, sp, #4294967295	; 0xffffffff
 8010760:	2200      	movs	r2, #0
			serial_rx_buffer[serial_rx_write_pos++] = buffer[i];
 8010762:	1c59      	adds	r1, r3, #1

			if (serial_rx_write_pos == SERIAL_RX_BUFFER_SIZE) {
				serial_rx_write_pos = 0;
 8010764:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
	int had_data = 0;

	for(;;) {
		len = chSequentialStreamRead(&SDU1, (uint8_t*) buffer, 1);

		for (i = 0;i < len;i++) {
 8010768:	f102 0201 	add.w	r2, r2, #1
			serial_rx_buffer[serial_rx_write_pos++] = buffer[i];
 801076c:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8010770:	f809 5003 	strb.w	r5, [r9, r3]

			if (serial_rx_write_pos == SERIAL_RX_BUFFER_SIZE) {
				serial_rx_write_pos = 0;
 8010774:	bf14      	ite	ne
 8010776:	460b      	movne	r3, r1
 8010778:	2300      	moveq	r3, #0
	int had_data = 0;

	for(;;) {
		len = chSequentialStreamRead(&SDU1, (uint8_t*) buffer, 1);

		for (i = 0;i < len;i++) {
 801077a:	4282      	cmp	r2, r0
 801077c:	dbf1      	blt.n	8010762 <serial_read_thread+0x32>

			had_data = 1;
		}

		if (had_data) {
			chEvtSignal(process_tp, (eventmask_t) 1);
 801077e:	f8d8 0000 	ldr.w	r0, [r8]
 8010782:	6033      	str	r3, [r6, #0]
 8010784:	2101      	movs	r1, #1
 8010786:	f7fc fa03 	bl	800cb90 <chEvtSignal>
 801078a:	e7de      	b.n	801074a <serial_read_thread+0x1a>
 801078c:	20000838 	.word	0x20000838
 8010790:	080112a4 	.word	0x080112a4
 8010794:	20001884 	.word	0x20001884
 8010798:	20003208 	.word	0x20003208
 801079c:	200043b8 	.word	0x200043b8
 80107a0:	20004f54 	.word	0x20004f54
	...

080107b0 <process_packet>:
		}
	}
}

static void process_packet(unsigned char *data, unsigned int len) {
	comm_cc2520_send_buffer(data, len);
 80107b0:	f7ff be96 	b.w	80104e0 <comm_cc2520_send_buffer>
	...

080107c0 <comm_usb_init>:
static void process_packet(unsigned char *data, unsigned int len);
static void send_packet(unsigned char *buffer, unsigned int len);
static THD_FUNCTION(serial_read_thread, arg);
static THD_FUNCTION(serial_process_thread, arg);

void comm_usb_init(void) {
 80107c0:	b510      	push	{r4, lr}
 80107c2:	b082      	sub	sp, #8
	comm_usb_serial_init();
 80107c4:	f7ff fd3c 	bl	8010240 <comm_usb_serial_init>
	packet_init(send_packet, process_packet, PACKET_HANDLER);
 80107c8:	490d      	ldr	r1, [pc, #52]	; (8010800 <comm_usb_init+0x40>)
 80107ca:	480e      	ldr	r0, [pc, #56]	; (8010804 <comm_usb_init+0x44>)
 80107cc:	2200      	movs	r2, #0
 80107ce:	f000 f83f 	bl	8010850 <packet_init>

	chMtxObjectInit(&send_mutex);

	// Threads
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
 80107d2:	2400      	movs	r4, #0

void comm_usb_init(void) {
	comm_usb_serial_init();
	packet_init(send_packet, process_packet, PACKET_HANDLER);

	chMtxObjectInit(&send_mutex);
 80107d4:	480c      	ldr	r0, [pc, #48]	; (8010808 <comm_usb_init+0x48>)
 80107d6:	f7fc f903 	bl	800c9e0 <chMtxObjectInit>

	// Threads
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
 80107da:	9400      	str	r4, [sp, #0]
 80107dc:	4b0b      	ldr	r3, [pc, #44]	; (801080c <comm_usb_init+0x4c>)
 80107de:	480c      	ldr	r0, [pc, #48]	; (8010810 <comm_usb_init+0x50>)
 80107e0:	f44f 7166 	mov.w	r1, #920	; 0x398
 80107e4:	2240      	movs	r2, #64	; 0x40
 80107e6:	f7fb ffeb 	bl	800c7c0 <chThdCreateStatic>
	chThdCreateStatic(serial_process_thread_wa, sizeof(serial_process_thread_wa), NORMALPRIO, serial_process_thread, NULL);
 80107ea:	9400      	str	r4, [sp, #0]
 80107ec:	4b09      	ldr	r3, [pc, #36]	; (8010814 <comm_usb_init+0x54>)
 80107ee:	480a      	ldr	r0, [pc, #40]	; (8010818 <comm_usb_init+0x58>)
 80107f0:	f241 1198 	movw	r1, #4504	; 0x1198
 80107f4:	2240      	movs	r2, #64	; 0x40
 80107f6:	f7fb ffe3 	bl	800c7c0 <chThdCreateStatic>
}
 80107fa:	b002      	add	sp, #8
 80107fc:	bd10      	pop	{r4, pc}
 80107fe:	bf00      	nop
 8010800:	080107b1 	.word	0x080107b1
 8010804:	080106b1 	.word	0x080106b1
 8010808:	2000320c 	.word	0x2000320c
 801080c:	08010731 	.word	0x08010731
 8010810:	20004bb8 	.word	0x20004bb8
 8010814:	080106d1 	.word	0x080106d1
 8010818:	20003220 	.word	0x20003220
 801081c:	00000000 	.word	0x00000000

08010820 <comm_usb_send_packet>:

void comm_usb_send_packet(unsigned char *data, unsigned int len) {
 8010820:	b570      	push	{r4, r5, r6, lr}
	chMtxLock(&send_mutex);
 8010822:	4c08      	ldr	r4, [pc, #32]	; (8010844 <comm_usb_send_packet+0x24>)
	// Threads
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
	chThdCreateStatic(serial_process_thread_wa, sizeof(serial_process_thread_wa), NORMALPRIO, serial_process_thread, NULL);
}

void comm_usb_send_packet(unsigned char *data, unsigned int len) {
 8010824:	4606      	mov	r6, r0
 8010826:	460d      	mov	r5, r1
	chMtxLock(&send_mutex);
 8010828:	4620      	mov	r0, r4
 801082a:	f7fc f949 	bl	800cac0 <chMtxLock>
	packet_send_packet(data, len, PACKET_HANDLER);
 801082e:	4630      	mov	r0, r6
 8010830:	4629      	mov	r1, r5
 8010832:	2200      	movs	r2, #0
 8010834:	f000 f81c 	bl	8010870 <packet_send_packet>
	chMtxUnlock(&send_mutex);
 8010838:	4620      	mov	r0, r4
}
 801083a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
}

void comm_usb_send_packet(unsigned char *data, unsigned int len) {
	chMtxLock(&send_mutex);
	packet_send_packet(data, len, PACKET_HANDLER);
	chMtxUnlock(&send_mutex);
 801083e:	f7fc b947 	b.w	800cad0 <chMtxUnlock>
 8010842:	bf00      	nop
 8010844:	2000320c 	.word	0x2000320c
	...

08010850 <packet_init>:

static PACKET_STATE_t handler_states[PACKET_HANDLERS];

void packet_init(void (*s_func)(unsigned char *data, unsigned int len),
		void (*p_func)(unsigned char *data, unsigned int len), int handler_num) {
	handler_states[handler_num].send_func = s_func;
 8010850:	4b03      	ldr	r3, [pc, #12]	; (8010860 <packet_init+0x10>)
 8010852:	eb02 1282 	add.w	r2, r2, r2, lsl #6
 8010856:	eb03 1242 	add.w	r2, r3, r2, lsl #5
 801085a:	6050      	str	r0, [r2, #4]
	handler_states[handler_num].process_func = p_func;
 801085c:	6091      	str	r1, [r2, #8]
 801085e:	4770      	bx	lr
 8010860:	20004f58 	.word	0x20004f58
	...

08010870 <packet_send_packet>:
}

void packet_send_packet(unsigned char *data, unsigned int len, int handler_num) {
	if (len > PACKET_MAX_PL_LEN) {
 8010870:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
		void (*p_func)(unsigned char *data, unsigned int len), int handler_num) {
	handler_states[handler_num].send_func = s_func;
	handler_states[handler_num].process_func = p_func;
}

void packet_send_packet(unsigned char *data, unsigned int len, int handler_num) {
 8010874:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8010878:	460c      	mov	r4, r1
	if (len > PACKET_MAX_PL_LEN) {
 801087a:	d831      	bhi.n	80108e0 <packet_send_packet+0x70>
	}

	int b_ind = 0;

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
 801087c:	0195      	lsls	r5, r2, #6
 801087e:	f8df 8070 	ldr.w	r8, [pc, #112]	; 80108f0 <packet_send_packet+0x80>
 8010882:	18ab      	adds	r3, r5, r2
		return;
	}

	int b_ind = 0;

	if (len <= 256) {
 8010884:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8010888:	4681      	mov	r9, r0
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
 801088a:	eb08 1343 	add.w	r3, r8, r3, lsl #5
		return;
	}

	int b_ind = 0;

	if (len <= 256) {
 801088e:	d929      	bls.n	80108e4 <packet_send_packet+0x74>
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
		handler_states[handler_num].tx_buffer[b_ind++] = len;
	} else {
		handler_states[handler_num].tx_buffer[b_ind++] = 3;
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
 8010890:	0a08      	lsrs	r0, r1, #8

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
		handler_states[handler_num].tx_buffer[b_ind++] = len;
	} else {
		handler_states[handler_num].tx_buffer[b_ind++] = 3;
 8010892:	2603      	movs	r6, #3
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
		handler_states[handler_num].tx_buffer[b_ind++] = len & 0xFF;
 8010894:	f883 1412 	strb.w	r1, [r3, #1042]	; 0x412
	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
		handler_states[handler_num].tx_buffer[b_ind++] = len;
	} else {
		handler_states[handler_num].tx_buffer[b_ind++] = 3;
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
 8010898:	f883 0411 	strb.w	r0, [r3, #1041]	; 0x411

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
		handler_states[handler_num].tx_buffer[b_ind++] = len;
	} else {
		handler_states[handler_num].tx_buffer[b_ind++] = 3;
 801089c:	f883 6410 	strb.w	r6, [r3, #1040]	; 0x410
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
		handler_states[handler_num].tx_buffer[b_ind++] = len & 0xFF;
	}

	memcpy(handler_states[handler_num].tx_buffer + b_ind, data, len);
 80108a0:	442a      	add	r2, r5
 80108a2:	0155      	lsls	r5, r2, #5
 80108a4:	f505 6782 	add.w	r7, r5, #1040	; 0x410
 80108a8:	4447      	add	r7, r8
 80108aa:	4622      	mov	r2, r4
 80108ac:	4649      	mov	r1, r9
 80108ae:	19b8      	adds	r0, r7, r6
 80108b0:	f7fb fc4e 	bl	800c150 <memcpy>
	b_ind += len;

	unsigned short crc = crc16(data, len);
 80108b4:	4621      	mov	r1, r4
 80108b6:	4648      	mov	r0, r9
 80108b8:	f7ff fee2 	bl	8010680 <crc16>
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
 80108bc:	4445      	add	r5, r8
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
		handler_states[handler_num].tx_buffer[b_ind++] = len & 0xFF;
	}

	memcpy(handler_states[handler_num].tx_buffer + b_ind, data, len);
	b_ind += len;
 80108be:	4434      	add	r4, r6

	unsigned short crc = crc16(data, len);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
 80108c0:	192b      	adds	r3, r5, r4
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc & 0xFF);
	handler_states[handler_num].tx_buffer[b_ind++] = 3;

	if (handler_states[handler_num].send_func) {
 80108c2:	686a      	ldr	r2, [r5, #4]
	memcpy(handler_states[handler_num].tx_buffer + b_ind, data, len);
	b_ind += len;

	unsigned short crc = crc16(data, len);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc & 0xFF);
 80108c4:	f883 0411 	strb.w	r0, [r3, #1041]	; 0x411
	handler_states[handler_num].tx_buffer[b_ind++] = 3;
 80108c8:	2503      	movs	r5, #3

	memcpy(handler_states[handler_num].tx_buffer + b_ind, data, len);
	b_ind += len;

	unsigned short crc = crc16(data, len);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
 80108ca:	0a00      	lsrs	r0, r0, #8
 80108cc:	f883 0410 	strb.w	r0, [r3, #1040]	; 0x410
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc & 0xFF);
	handler_states[handler_num].tx_buffer[b_ind++] = 3;
 80108d0:	1961      	adds	r1, r4, r5
 80108d2:	f883 5412 	strb.w	r5, [r3, #1042]	; 0x412

	if (handler_states[handler_num].send_func) {
 80108d6:	b11a      	cbz	r2, 80108e0 <packet_send_packet+0x70>
		handler_states[handler_num].send_func(handler_states[handler_num].tx_buffer, b_ind);
 80108d8:	4638      	mov	r0, r7
	}
}
 80108da:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc & 0xFF);
	handler_states[handler_num].tx_buffer[b_ind++] = 3;

	if (handler_states[handler_num].send_func) {
		handler_states[handler_num].send_func(handler_states[handler_num].tx_buffer, b_ind);
 80108de:	4710      	bx	r2
 80108e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}

	int b_ind = 0;

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
 80108e4:	2602      	movs	r6, #2
		handler_states[handler_num].tx_buffer[b_ind++] = len;
 80108e6:	f883 1411 	strb.w	r1, [r3, #1041]	; 0x411
	}

	int b_ind = 0;

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
 80108ea:	f883 6410 	strb.w	r6, [r3, #1040]	; 0x410
 80108ee:	e7d7      	b.n	80108a0 <packet_send_packet+0x30>
 80108f0:	20004f58 	.word	0x20004f58
	...

08010900 <packet_timerfunc>:
/**
 * Call this function every millisecond.
 */
void packet_timerfunc(void) {
	for (int i = 0;i < PACKET_HANDLERS;i++) {
		if (handler_states[i].rx_timeout) {
 8010900:	4b05      	ldr	r3, [pc, #20]	; (8010918 <packet_timerfunc+0x18>)
 8010902:	785a      	ldrb	r2, [r3, #1]
 8010904:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 8010908:	b90a      	cbnz	r2, 801090e <packet_timerfunc+0xe>
			handler_states[i].rx_timeout--;
		} else {
			handler_states[i].rx_state = 0;
 801090a:	7019      	strb	r1, [r3, #0]
 801090c:	4770      	bx	lr
 * Call this function every millisecond.
 */
void packet_timerfunc(void) {
	for (int i = 0;i < PACKET_HANDLERS;i++) {
		if (handler_states[i].rx_timeout) {
			handler_states[i].rx_timeout--;
 801090e:	785a      	ldrb	r2, [r3, #1]
 8010910:	3a01      	subs	r2, #1
 8010912:	b2d2      	uxtb	r2, r2
 8010914:	705a      	strb	r2, [r3, #1]
 8010916:	4770      	bx	lr
 8010918:	20004f58 	.word	0x20004f58
 801091c:	00000000 	.word	0x00000000

08010920 <packet_process_byte>:
			handler_states[i].rx_state = 0;
		}
	}
}

void packet_process_byte(uint8_t rx_data, int handler_num) {
 8010920:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	switch (handler_states[handler_num].rx_state) {
 8010924:	018e      	lsls	r6, r1, #6
 8010926:	1873      	adds	r3, r6, r1
 8010928:	015b      	lsls	r3, r3, #5
 801092a:	4d4e      	ldr	r5, [pc, #312]	; (8010a64 <packet_process_byte+0x144>)
 801092c:	5ceb      	ldrb	r3, [r5, r3]
			handler_states[i].rx_state = 0;
		}
	}
}

void packet_process_byte(uint8_t rx_data, int handler_num) {
 801092e:	460c      	mov	r4, r1
	switch (handler_states[handler_num].rx_state) {
 8010930:	2b06      	cmp	r3, #6
 8010932:	d821      	bhi.n	8010978 <packet_process_byte+0x58>
 8010934:	e8df f003 	tbb	[pc, r3]
 8010938:	5a473a26 	.word	0x5a473a26
 801093c:	8578      	.short	0x8578
 801093e:	04          	.byte	0x04
 801093f:	00          	.byte	0x00
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 6:
		if (rx_data == 3) {
 8010940:	2803      	cmp	r0, #3
 8010942:	d119      	bne.n	8010978 <packet_process_byte+0x58>
			if (crc16(handler_states[handler_num].rx_buffer, handler_states[handler_num].payload_length)
 8010944:	1873      	adds	r3, r6, r1
 8010946:	015b      	lsls	r3, r3, #5
 8010948:	eb05 0803 	add.w	r8, r5, r3
 801094c:	3310      	adds	r3, #16
 801094e:	18ef      	adds	r7, r5, r3
 8010950:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8010954:	4638      	mov	r0, r7
 8010956:	f7ff fe93 	bl	8010680 <crc16>
					== ((unsigned short)handler_states[handler_num].crc_high << 8
 801095a:	f898 181d 	ldrb.w	r1, [r8, #2077]	; 0x81d
							| (unsigned short)handler_states[handler_num].crc_low)) {
 801095e:	f898 381c 	ldrb.w	r3, [r8, #2076]	; 0x81c
 8010962:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 6:
		if (rx_data == 3) {
			if (crc16(handler_states[handler_num].rx_buffer, handler_states[handler_num].payload_length)
 8010966:	4298      	cmp	r0, r3
 8010968:	d106      	bne.n	8010978 <packet_process_byte+0x58>
					== ((unsigned short)handler_states[handler_num].crc_high << 8
							| (unsigned short)handler_states[handler_num].crc_low)) {
				// Packet received!
				if (handler_states[handler_num].process_func) {
 801096a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801096e:	b11b      	cbz	r3, 8010978 <packet_process_byte+0x58>
					handler_states[handler_num].process_func(handler_states[handler_num].rx_buffer,
 8010970:	4638      	mov	r0, r7
 8010972:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8010976:	4798      	blx	r3
		}
		handler_states[handler_num].rx_state = 0;
		break;

	default:
		handler_states[handler_num].rx_state = 0;
 8010978:	4434      	add	r4, r6
 801097a:	0164      	lsls	r4, r4, #5
 801097c:	2300      	movs	r3, #0
 801097e:	552b      	strb	r3, [r5, r4]
 8010980:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
void packet_process_byte(uint8_t rx_data, int handler_num) {
	switch (handler_states[handler_num].rx_state) {
	case 0:
		if (rx_data == 2) {
			// 1 byte PL len
			handler_states[handler_num].rx_state += 2;
 8010984:	4434      	add	r4, r6
}

void packet_process_byte(uint8_t rx_data, int handler_num) {
	switch (handler_states[handler_num].rx_state) {
	case 0:
		if (rx_data == 2) {
 8010986:	2802      	cmp	r0, #2
			// 1 byte PL len
			handler_states[handler_num].rx_state += 2;
 8010988:	ea4f 1444 	mov.w	r4, r4, lsl #5
}

void packet_process_byte(uint8_t rx_data, int handler_num) {
	switch (handler_states[handler_num].rx_state) {
	case 0:
		if (rx_data == 2) {
 801098c:	d064      	beq.n	8010a58 <packet_process_byte+0x138>
			// 1 byte PL len
			handler_states[handler_num].rx_state += 2;
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
			handler_states[handler_num].rx_data_ptr = 0;
			handler_states[handler_num].payload_length = 0;
		} else if (rx_data == 3) {
 801098e:	2803      	cmp	r0, #3
 8010990:	d1f4      	bne.n	801097c <packet_process_byte+0x5c>
			// 2 byte PL len
			handler_states[handler_num].rx_state++;
 8010992:	5d2b      	ldrb	r3, [r5, r4]
 8010994:	3301      	adds	r3, #1
 8010996:	192a      	adds	r2, r5, r4
 8010998:	b2db      	uxtb	r3, r3
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 801099a:	2002      	movs	r0, #2
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
			handler_states[handler_num].rx_data_ptr = 0;
			handler_states[handler_num].payload_length = 0;
		} else if (rx_data == 3) {
			// 2 byte PL len
			handler_states[handler_num].rx_state++;
 801099c:	552b      	strb	r3, [r5, r4]
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
			handler_states[handler_num].rx_data_ptr = 0;
 801099e:	2100      	movs	r1, #0
			handler_states[handler_num].rx_data_ptr = 0;
			handler_states[handler_num].payload_length = 0;
		} else if (rx_data == 3) {
			// 2 byte PL len
			handler_states[handler_num].rx_state++;
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80109a0:	7050      	strb	r0, [r2, #1]
			handler_states[handler_num].rx_data_ptr = 0;
			handler_states[handler_num].payload_length = 0;
 80109a2:	60d1      	str	r1, [r2, #12]
			handler_states[handler_num].payload_length = 0;
		} else if (rx_data == 3) {
			// 2 byte PL len
			handler_states[handler_num].rx_state++;
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
			handler_states[handler_num].rx_data_ptr = 0;
 80109a4:	f8c2 1818 	str.w	r1, [r2, #2072]	; 0x818
 80109a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 1:
		handler_states[handler_num].payload_length = (unsigned int)rx_data << 8;
 80109ac:	4434      	add	r4, r6
 80109ae:	0164      	lsls	r4, r4, #5
 80109b0:	192a      	adds	r2, r5, r4
		handler_states[handler_num].rx_state++;
 80109b2:	5d2b      	ldrb	r3, [r5, r4]
 80109b4:	3301      	adds	r3, #1
 80109b6:	b2db      	uxtb	r3, r3
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80109b8:	2102      	movs	r1, #2
		}
		break;

	case 1:
		handler_states[handler_num].payload_length = (unsigned int)rx_data << 8;
		handler_states[handler_num].rx_state++;
 80109ba:	552b      	strb	r3, [r5, r4]
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 1:
		handler_states[handler_num].payload_length = (unsigned int)rx_data << 8;
 80109bc:	0200      	lsls	r0, r0, #8
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80109be:	7051      	strb	r1, [r2, #1]
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 1:
		handler_states[handler_num].payload_length = (unsigned int)rx_data << 8;
 80109c0:	60d0      	str	r0, [r2, #12]
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;
 80109c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	case 2:
		handler_states[handler_num].payload_length |= (unsigned int)rx_data;
 80109c6:	4434      	add	r4, r6
 80109c8:	0164      	lsls	r4, r4, #5
 80109ca:	4425      	add	r5, r4
 80109cc:	4925      	ldr	r1, [pc, #148]	; (8010a64 <packet_process_byte+0x144>)
 80109ce:	68eb      	ldr	r3, [r5, #12]
 80109d0:	4318      	orrs	r0, r3
		if (handler_states[handler_num].payload_length > 0 &&
 80109d2:	1e43      	subs	r3, r0, #1
 80109d4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 2:
		handler_states[handler_num].payload_length |= (unsigned int)rx_data;
 80109d8:	60e8      	str	r0, [r5, #12]
		if (handler_states[handler_num].payload_length > 0 &&
 80109da:	d239      	bcs.n	8010a50 <packet_process_byte+0x130>
				handler_states[handler_num].payload_length <= PACKET_MAX_PL_LEN) {
			handler_states[handler_num].rx_state++;
 80109dc:	5d0b      	ldrb	r3, [r1, r4]
 80109de:	3301      	adds	r3, #1
 80109e0:	b2db      	uxtb	r3, r3
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80109e2:	2202      	movs	r2, #2

	case 2:
		handler_states[handler_num].payload_length |= (unsigned int)rx_data;
		if (handler_states[handler_num].payload_length > 0 &&
				handler_states[handler_num].payload_length <= PACKET_MAX_PL_LEN) {
			handler_states[handler_num].rx_state++;
 80109e4:	550b      	strb	r3, [r1, r4]
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80109e6:	706a      	strb	r2, [r5, #1]
 80109e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 3:
		handler_states[handler_num].rx_buffer[handler_states[handler_num].rx_data_ptr++] = rx_data;
 80109ec:	1871      	adds	r1, r6, r1
 80109ee:	0149      	lsls	r1, r1, #5
 80109f0:	186a      	adds	r2, r5, r1
 80109f2:	f8df c070 	ldr.w	ip, [pc, #112]	; 8010a64 <packet_process_byte+0x144>
 80109f6:	f8d2 3818 	ldr.w	r3, [r2, #2072]	; 0x818
		if (handler_states[handler_num].rx_data_ptr == handler_states[handler_num].payload_length) {
 80109fa:	68d7      	ldr	r7, [r2, #12]
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 3:
		handler_states[handler_num].rx_buffer[handler_states[handler_num].rx_data_ptr++] = rx_data;
 80109fc:	eb02 0e03 	add.w	lr, r2, r3
 8010a00:	3301      	adds	r3, #1
		if (handler_states[handler_num].rx_data_ptr == handler_states[handler_num].payload_length) {
 8010a02:	42bb      	cmp	r3, r7
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 3:
		handler_states[handler_num].rx_buffer[handler_states[handler_num].rx_data_ptr++] = rx_data;
 8010a04:	f88e 0010 	strb.w	r0, [lr, #16]
 8010a08:	f8c2 3818 	str.w	r3, [r2, #2072]	; 0x818
		if (handler_states[handler_num].rx_data_ptr == handler_states[handler_num].payload_length) {
 8010a0c:	d105      	bne.n	8010a1a <packet_process_byte+0xfa>
			handler_states[handler_num].rx_state++;
 8010a0e:	f81c 3001 	ldrb.w	r3, [ip, r1]
 8010a12:	3301      	adds	r3, #1
 8010a14:	b2db      	uxtb	r3, r3
 8010a16:	f80c 3001 	strb.w	r3, [ip, r1]
		}
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 8010a1a:	4434      	add	r4, r6
 8010a1c:	eb05 1444 	add.w	r4, r5, r4, lsl #5
 8010a20:	2302      	movs	r3, #2
 8010a22:	7063      	strb	r3, [r4, #1]
		break;
 8010a24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	case 4:
		handler_states[handler_num].crc_high = rx_data;
 8010a28:	4434      	add	r4, r6
 8010a2a:	0164      	lsls	r4, r4, #5
 8010a2c:	192a      	adds	r2, r5, r4
		handler_states[handler_num].rx_state++;
 8010a2e:	5d2b      	ldrb	r3, [r5, r4]
		}
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 4:
		handler_states[handler_num].crc_high = rx_data;
 8010a30:	f882 081d 	strb.w	r0, [r2, #2077]	; 0x81d
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 5:
		handler_states[handler_num].crc_low = rx_data;
		handler_states[handler_num].rx_state++;
 8010a34:	3301      	adds	r3, #1
 8010a36:	b2db      	uxtb	r3, r3
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 8010a38:	2102      	movs	r1, #2
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 5:
		handler_states[handler_num].crc_low = rx_data;
		handler_states[handler_num].rx_state++;
 8010a3a:	552b      	strb	r3, [r5, r4]
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 8010a3c:	7051      	strb	r1, [r2, #1]
		break;
 8010a3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 5:
		handler_states[handler_num].crc_low = rx_data;
 8010a42:	4434      	add	r4, r6
 8010a44:	0164      	lsls	r4, r4, #5
 8010a46:	192a      	adds	r2, r5, r4
		handler_states[handler_num].rx_state++;
 8010a48:	5d2b      	ldrb	r3, [r5, r4]
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 5:
		handler_states[handler_num].crc_low = rx_data;
 8010a4a:	f882 081c 	strb.w	r0, [r2, #2076]	; 0x81c
 8010a4e:	e7f1      	b.n	8010a34 <packet_process_byte+0x114>
		if (handler_states[handler_num].payload_length > 0 &&
				handler_states[handler_num].payload_length <= PACKET_MAX_PL_LEN) {
			handler_states[handler_num].rx_state++;
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		} else {
			handler_states[handler_num].rx_state = 0;
 8010a50:	2300      	movs	r3, #0
 8010a52:	550b      	strb	r3, [r1, r4]
 8010a54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
void packet_process_byte(uint8_t rx_data, int handler_num) {
	switch (handler_states[handler_num].rx_state) {
	case 0:
		if (rx_data == 2) {
			// 1 byte PL len
			handler_states[handler_num].rx_state += 2;
 8010a58:	5d2b      	ldrb	r3, [r5, r4]
 8010a5a:	3302      	adds	r3, #2
 8010a5c:	192a      	adds	r2, r5, r4
 8010a5e:	b2db      	uxtb	r3, r3
 8010a60:	e79c      	b.n	801099c <packet_process_byte+0x7c>
 8010a62:	bf00      	nop
 8010a64:	20004f58 	.word	0x20004f58
	...

08010a70 <memset>:
 8010a70:	b470      	push	{r4, r5, r6}
 8010a72:	0784      	lsls	r4, r0, #30
 8010a74:	d046      	beq.n	8010b04 <memset+0x94>
 8010a76:	1e54      	subs	r4, r2, #1
 8010a78:	2a00      	cmp	r2, #0
 8010a7a:	d041      	beq.n	8010b00 <memset+0x90>
 8010a7c:	b2cd      	uxtb	r5, r1
 8010a7e:	4603      	mov	r3, r0
 8010a80:	e002      	b.n	8010a88 <memset+0x18>
 8010a82:	1e62      	subs	r2, r4, #1
 8010a84:	b3e4      	cbz	r4, 8010b00 <memset+0x90>
 8010a86:	4614      	mov	r4, r2
 8010a88:	f803 5b01 	strb.w	r5, [r3], #1
 8010a8c:	079a      	lsls	r2, r3, #30
 8010a8e:	d1f8      	bne.n	8010a82 <memset+0x12>
 8010a90:	2c03      	cmp	r4, #3
 8010a92:	d92e      	bls.n	8010af2 <memset+0x82>
 8010a94:	b2cd      	uxtb	r5, r1
 8010a96:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8010a9a:	2c0f      	cmp	r4, #15
 8010a9c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8010aa0:	d919      	bls.n	8010ad6 <memset+0x66>
 8010aa2:	f103 0210 	add.w	r2, r3, #16
 8010aa6:	4626      	mov	r6, r4
 8010aa8:	3e10      	subs	r6, #16
 8010aaa:	2e0f      	cmp	r6, #15
 8010aac:	f842 5c10 	str.w	r5, [r2, #-16]
 8010ab0:	f842 5c0c 	str.w	r5, [r2, #-12]
 8010ab4:	f842 5c08 	str.w	r5, [r2, #-8]
 8010ab8:	f842 5c04 	str.w	r5, [r2, #-4]
 8010abc:	f102 0210 	add.w	r2, r2, #16
 8010ac0:	d8f2      	bhi.n	8010aa8 <memset+0x38>
 8010ac2:	f1a4 0210 	sub.w	r2, r4, #16
 8010ac6:	f022 020f 	bic.w	r2, r2, #15
 8010aca:	f004 040f 	and.w	r4, r4, #15
 8010ace:	3210      	adds	r2, #16
 8010ad0:	2c03      	cmp	r4, #3
 8010ad2:	4413      	add	r3, r2
 8010ad4:	d90d      	bls.n	8010af2 <memset+0x82>
 8010ad6:	461e      	mov	r6, r3
 8010ad8:	4622      	mov	r2, r4
 8010ada:	3a04      	subs	r2, #4
 8010adc:	2a03      	cmp	r2, #3
 8010ade:	f846 5b04 	str.w	r5, [r6], #4
 8010ae2:	d8fa      	bhi.n	8010ada <memset+0x6a>
 8010ae4:	1f22      	subs	r2, r4, #4
 8010ae6:	f022 0203 	bic.w	r2, r2, #3
 8010aea:	3204      	adds	r2, #4
 8010aec:	4413      	add	r3, r2
 8010aee:	f004 0403 	and.w	r4, r4, #3
 8010af2:	b12c      	cbz	r4, 8010b00 <memset+0x90>
 8010af4:	b2c9      	uxtb	r1, r1
 8010af6:	441c      	add	r4, r3
 8010af8:	f803 1b01 	strb.w	r1, [r3], #1
 8010afc:	42a3      	cmp	r3, r4
 8010afe:	d1fb      	bne.n	8010af8 <memset+0x88>
 8010b00:	bc70      	pop	{r4, r5, r6}
 8010b02:	4770      	bx	lr
 8010b04:	4614      	mov	r4, r2
 8010b06:	4603      	mov	r3, r0
 8010b08:	e7c2      	b.n	8010a90 <memset+0x20>
 8010b0a:	bf00      	nop
 8010b0c:	0000      	movs	r0, r0
 8010b0e:	0000      	movs	r0, r0
 8010b10:	656c6469 	.word	0x656c6469
	...

08010b20 <ch_debug>:
 8010b20:	6e69616d 18011600 08480404 1814100c     main......H.....
 8010b30:	1e1d1c00 0000201f 00000000 00000000     ..... ..........

08010b40 <vmt>:
 8010b40:	0800d131 0800d111 0800d171 0800d151     1.......q...Q...
 8010b50:	0800d161 0800d141 0800d121 0800d101     a...A...!.......

08010b60 <zero_status>:
	...

08010b70 <active_status>:
	...

08010b80 <halted_status>:
 8010b80:	00000001 00000000 00000000 00000000     ................

08010b90 <_stm32_dma_streams>:
 8010b90:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 8010ba0:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 8010bb0:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 8010bc0:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 8010bd0:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 8010be0:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 8010bf0:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 8010c00:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 8010c10:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 8010c20:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 8010c30:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 8010c40:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

08010c50 <fsparams>:
 8010c50:	00000080 00000140 00000003 00000000     ....@...........
 8010c60:	5f627375 5f646c6c 706d7570 00000000     usb_lld_pump....

08010c70 <ep0config>:
 8010c70:	00000000 0800d4f1 0800d821 0800d8e1     ........!.......
 8010c80:	00400040 20000e98 20000e98 00000001     @.@.... ... ....
 8010c90:	20000eac 00000000 00000000 00000000     ... ............

08010ca0 <pal_default_config>:
 8010ca0:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
 8010cb0:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
 8010cc0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 8010cd0:	04000000 00000040 02208001 00000000     ....@..... .....
 8010ce0:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
 8010cf0:	00060600 55000100 00000000 ffffffff     .......U........
 8010d00:	00555055 00000fff 00000000 00000000     UPU.............
 8010d10:	00000040 00000000 ffffffff 00000000     @...............
 8010d20:	0000ffff 00000000 00000000 00000000     ................
 8010d30:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8010d50:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8010d6c:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8010d88:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8010da0:	35324343 45203032 00495458 4264312d     CC2520 EXTI.-1dB
 8010db0:	0000006d 42643131 0000006d 42643431     m...11dBm...14dB
 8010dc0:	0000006d 42643631 0000006d 42643731     m...16dBm...17dB
 8010dd0:	0000006d 00000000 00000000 00000000     m...............
 8010de0:	35324343 45203032 00004358 00000000     CC2520 EXC......

08010df0 <ep1config>:
 8010df0:	00000002 00000000 0800d2a1 0800d301     ................
 8010e00:	00400040 20001adc 20001af0 00000002     @.@.... ... ....
	...

08010e20 <vcom_configuration_descriptor>:
 8010e20:	00000043 08010e70 00000000 00000000     C...p...........

08010e30 <ep2config>:
 8010e30:	00000003 00000000 0800d361 00000000     ........a.......
 8010e40:	00000010 20001870 00000000 00000001     ....p.. ........
	...

08010e60 <usbcfg>:
 8010e60:	08010201 080101d1 0800d261 00000000     ........a.......

08010e70 <vcom_configuration_descriptor_data>:
 8010e70:	00430209 c0000102 00040932 02020100     ..C.....2.......
 8010e80:	24050001 05011000 01000124 02022404     ...$....$....$..
 8010e90:	00062405 82050701 ff000803 00010409     .$..............
 8010ea0:	00000a02 01050700 00004002 02810507     .........@......
 8010eb0:	00000040 00000000 00000000 00000000     @...............

08010ec0 <vcom_device_descriptor_data>:
 8010ec0:	01100112 40000002 57400483 02010200     .......@..@W....
 8010ed0:	00000103 00000000 00000000 00000000     ................

08010ee0 <vcom_string0>:
 8010ee0:	04090304 00000000 00000000 00000000     ................

08010ef0 <vcom_string1>:
 8010ef0:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 8010f00:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 8010f10:	00630069 00000073 00000000 00000000     i.c.s...........

08010f20 <vcom_string2>:
 8010f20:	00430338 00690068 00690062 0053004f     8.C.h.i.b.i.O.S.
 8010f30:	0052002f 00200054 00690056 00740072     /.R.T. .V.i.r.t.
 8010f40:	00610075 0020006c 004f0043 0020004d     u.a.l. .C.O.M. .
 8010f50:	006f0050 00740072 00000000 00000000     P.o.r.t.........

08010f60 <vcom_string3>:
 8010f60:	00330308 00310030 00000000 00000000     ..3.0.1.........

08010f70 <vcom_strings>:
 8010f70:	00000004 08010ee0 00000026 08010ef0     ........&.......
 8010f80:	00000038 08010f20 00000008 08010f60     8... .......`...

08010f90 <serusbcfg>:
 8010f90:	20000c18 00020101 00000000 00000000     ... ............

08010fa0 <vcom_device_descriptor>:
 8010fa0:	00000012 08010ec0 00000000 00000000     ................
 8010fb0:	35324343 54203032 00000078 35324343     CC2520 Tx...CC25
 8010fc0:	52203032 00000058 00000000 00000000     20 RX...........

08010fd0 <extcfg>:
	...
 8011008:	00000001 0800fd11 00000000 00000000     ................
	...

08011090 <crc16_tab>:
 8011090:	10210000 30632042 50a54084 70e760c6     ..!.B c0.@.P.`.p
 80110a0:	91298108 b16ba14a d1adc18c f1efe1ce     ..).J.k.........
 80110b0:	02101231 22523273 429452b5 62d672f7     1...s2R".R.B.r.b
 80110c0:	83189339 a35ab37b c39cd3bd e3def3ff     9...{.Z.........
 80110d0:	34432462 14010420 74c764e6 548544a4     b$C4 ....d.t.D.T
 80110e0:	b54ba56a 95098528 f5cfe5ee d58dc5ac     j.K.(...........
 80110f0:	26723653 06301611 66f676d7 46b45695     S6r&..0..v.f.V.F
 8011100:	a77ab75b 87389719 e7fef7df c7bcd79d     [.z...8.........
 8011110:	58e548c4 78a76886 18610840 38232802     .H.X.h.x@.a..(#8
 8011120:	d9edc9cc f9afe98e 99698948 b92ba90a     ........H.i...+.
 8011130:	4ad45af5 6a967ab7 0a501a71 2a123a33     .Z.J.z.jq.P.3:.*
 8011140:	cbdcdbfd eb9efbbf 8b589b79 ab1abb3b     ........y.X.;...
 8011150:	7c876ca6 5cc54ce4 3c032c22 1c410c60     .l.|.L.\",.<`.A.
 8011160:	fd8fedae ddcdcdec bd0bad2a 9d498d68     ........*...h.I.
 8011170:	6eb67e97 4ef45ed5 2e323e13 0e701e51     .~.n.^.N.>2.Q.p.
 8011180:	efbeff9f cffcdfdd af3abf1b 8f789f59     ..........:.Y.x.
 8011190:	81a99188 a1ebb1ca c12dd10c e16ff14e     ..........-.N.o.
 80111a0:	00a11080 20e330c2 40255004 60677046     .....0. .P%@Fpg`
 80111b0:	939883b9 b3daa3fb d31cc33d f35ee37f     ........=.....^.
 80111c0:	129002b1 32d222f3 52144235 72566277     .....".25B.RwbVr
 80111d0:	a5cbb5ea 858995a8 e54ff56e c50dd52c     ........n.O.,...
 80111e0:	24c334e2 048114a0 64477466 44055424     .4.$....ftGd$T.D
 80111f0:	b7faa7db 97b88799 f77ee75f d73cc71d     ........_.~...<.
 8011200:	36f226d3 16b00691 76766657 56344615     .&.6....Wfvv.F4V
 8011210:	c96dd94c e92ff90e 89e999c8 a9abb98a     L.m.../.........
 8011220:	48655844 68277806 08e118c0 28a33882     DXeH.x'h.....8.(
 8011230:	db5ccb7d fb1eeb3f 9bd88bf9 bb9aabbb     }.\.?...........
 8011240:	5a544a75 7a166a37 1ad00af1 3a922ab3     uJTZ7j.z.....*.:
 8011250:	ed0ffd2e cd4ddd6c ad8bbdaa 8dc99de8     ....l.M.........
 8011260:	6c077c26 4c455c64 2c833ca2 0cc11ce0     &|.ld\EL.<.,....
 8011270:	ff3eef1f df7ccf5d bfbaaf9b 9ff88fd9     ..>.].|.........
 8011280:	7e366e17 5e744e55 3eb22e93 1ef00ed1     .n6~UNt^...>....
 8011290:	2d425355 69726553 70206c61 65636f72     USB-Serial proce
 80112a0:	00007373 2d425355 69726553 72206c61     ss..USB-Serial r
 80112b0:	00646165                                ead.
