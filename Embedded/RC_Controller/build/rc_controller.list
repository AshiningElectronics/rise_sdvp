
build/rc_controller.elf:     file format elf32-littlearm


Disassembly of section .text:

0800c000 <Reset_Handler>:
 800c000:	b672      	cpsid	i
 800c002:	4833      	ldr	r0, [pc, #204]	; (800c0d0 <endfiniloop+0x6>)
 800c004:	f380 8809 	msr	PSP, r0
 800c008:	f240 0000 	movw	r0, #0
 800c00c:	f2cc 0000 	movt	r0, #49152	; 0xc000
 800c010:	f64e 7134 	movw	r1, #61236	; 0xef34
 800c014:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c018:	6008      	str	r0, [r1, #0]
 800c01a:	f3bf 8f4f 	dsb	sy
 800c01e:	f3bf 8f6f 	isb	sy
 800c022:	f240 0000 	movw	r0, #0
 800c026:	f2c0 00f0 	movt	r0, #240	; 0xf0
 800c02a:	f64e 5188 	movw	r1, #60808	; 0xed88
 800c02e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c032:	6008      	str	r0, [r1, #0]
 800c034:	f3bf 8f4f 	dsb	sy
 800c038:	f3bf 8f6f 	isb	sy
 800c03c:	f04f 0000 	mov.w	r0, #0
 800c040:	eee1 0a10 	vmsr	fpscr, r0
 800c044:	f64e 713c 	movw	r1, #61244	; 0xef3c
 800c048:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c04c:	6008      	str	r0, [r1, #0]
 800c04e:	2006      	movs	r0, #6
 800c050:	f380 8814 	msr	CONTROL, r0
 800c054:	f3bf 8f6f 	isb	sy
 800c058:	f001 f872 	bl	800d140 <__core_init>
 800c05c:	f004 ffd0 	bl	8011000 <__early_init>
 800c060:	481c      	ldr	r0, [pc, #112]	; (800c0d4 <endfiniloop+0xa>)
 800c062:	491d      	ldr	r1, [pc, #116]	; (800c0d8 <endfiniloop+0xe>)
 800c064:	4a1d      	ldr	r2, [pc, #116]	; (800c0dc <endfiniloop+0x12>)

0800c066 <msloop>:
 800c066:	4291      	cmp	r1, r2
 800c068:	bf3c      	itt	cc
 800c06a:	f841 0b04 	strcc.w	r0, [r1], #4
 800c06e:	e7fa      	bcc.n	800c066 <msloop>
 800c070:	491b      	ldr	r1, [pc, #108]	; (800c0e0 <endfiniloop+0x16>)
 800c072:	4a17      	ldr	r2, [pc, #92]	; (800c0d0 <endfiniloop+0x6>)

0800c074 <psloop>:
 800c074:	4291      	cmp	r1, r2
 800c076:	bf3c      	itt	cc
 800c078:	f841 0b04 	strcc.w	r0, [r1], #4
 800c07c:	e7fa      	bcc.n	800c074 <psloop>
 800c07e:	4919      	ldr	r1, [pc, #100]	; (800c0e4 <endfiniloop+0x1a>)
 800c080:	4a19      	ldr	r2, [pc, #100]	; (800c0e8 <endfiniloop+0x1e>)
 800c082:	4b1a      	ldr	r3, [pc, #104]	; (800c0ec <endfiniloop+0x22>)

0800c084 <dloop>:
 800c084:	429a      	cmp	r2, r3
 800c086:	bf3e      	ittt	cc
 800c088:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800c08c:	f842 0b04 	strcc.w	r0, [r2], #4
 800c090:	e7f8      	bcc.n	800c084 <dloop>
 800c092:	2000      	movs	r0, #0
 800c094:	4916      	ldr	r1, [pc, #88]	; (800c0f0 <endfiniloop+0x26>)
 800c096:	4a17      	ldr	r2, [pc, #92]	; (800c0f4 <endfiniloop+0x2a>)

0800c098 <bloop>:
 800c098:	4291      	cmp	r1, r2
 800c09a:	bf3c      	itt	cc
 800c09c:	f841 0b04 	strcc.w	r0, [r1], #4
 800c0a0:	e7fa      	bcc.n	800c098 <bloop>
 800c0a2:	f001 f855 	bl	800d150 <__late_init>
 800c0a6:	4c14      	ldr	r4, [pc, #80]	; (800c0f8 <endfiniloop+0x2e>)
 800c0a8:	4d14      	ldr	r5, [pc, #80]	; (800c0fc <endfiniloop+0x32>)

0800c0aa <initloop>:
 800c0aa:	42ac      	cmp	r4, r5
 800c0ac:	da03      	bge.n	800c0b6 <endinitloop>
 800c0ae:	f854 1b04 	ldr.w	r1, [r4], #4
 800c0b2:	4788      	blx	r1
 800c0b4:	e7f9      	b.n	800c0aa <initloop>

0800c0b6 <endinitloop>:
 800c0b6:	f005 fc9b 	bl	80119f0 <main>
 800c0ba:	4c11      	ldr	r4, [pc, #68]	; (800c100 <endfiniloop+0x36>)
 800c0bc:	4d11      	ldr	r5, [pc, #68]	; (800c104 <endfiniloop+0x3a>)

0800c0be <finiloop>:
 800c0be:	42ac      	cmp	r4, r5
 800c0c0:	da03      	bge.n	800c0ca <endfiniloop>
 800c0c2:	f854 1b04 	ldr.w	r1, [r4], #4
 800c0c6:	4788      	blx	r1
 800c0c8:	e7f9      	b.n	800c0be <finiloop>

0800c0ca <endfiniloop>:
 800c0ca:	f001 b849 	b.w	800d160 <__default_exit>
 800c0ce:	0000      	.short	0x0000
 800c0d0:	20000800 	.word	0x20000800
 800c0d4:	55555555 	.word	0x55555555
 800c0d8:	20000000 	.word	0x20000000
 800c0dc:	20000400 	.word	0x20000400
 800c0e0:	20000400 	.word	0x20000400
 800c0e4:	08017140 	.word	0x08017140
 800c0e8:	20000800 	.word	0x20000800
 800c0ec:	200010b4 	.word	0x200010b4
 800c0f0:	200010b8 	.word	0x200010b8
 800c0f4:	20006c0c 	.word	0x20006c0c
 800c0f8:	0800c000 	.word	0x0800c000
 800c0fc:	0800c000 	.word	0x0800c000
 800c100:	0800c000 	.word	0x0800c000
 800c104:	0800c000 	.word	0x0800c000
	...

0800c110 <_port_switch>:
 800c110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c114:	ed2d 8a10 	vpush	{s16-s31}
 800c118:	f8c1 d00c 	str.w	sp, [r1, #12]
 800c11c:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800c120:	ecbd 8a10 	vpop	{s16-s31}
 800c124:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c128 <_port_thread_start>:
 800c128:	b662      	cpsie	i
 800c12a:	4628      	mov	r0, r5
 800c12c:	47a0      	blx	r4
 800c12e:	2000      	movs	r0, #0
 800c130:	f001 fb0e 	bl	800d750 <chThdExit>

0800c134 <_port_switch_from_isr>:
 800c134:	f001 fa34 	bl	800d5a0 <chSchDoReschedule>

0800c138 <_port_exit_from_isr>:
 800c138:	f64e 5304 	movw	r3, #60676	; 0xed04
 800c13c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800c140:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c144:	601a      	str	r2, [r3, #0]
 800c146:	b662      	cpsie	i
 800c148:	e7fe      	b.n	800c148 <_port_exit_from_isr+0x10>
 800c14a:	0000      	movs	r0, r0
 800c14c:	0000      	movs	r0, r0
	...

0800c150 <__aeabi_drsub>:
 800c150:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800c154:	e002      	b.n	800c15c <__adddf3>
 800c156:	bf00      	nop

0800c158 <__aeabi_dsub>:
 800c158:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800c15c <__adddf3>:
 800c15c:	b530      	push	{r4, r5, lr}
 800c15e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800c162:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800c166:	ea94 0f05 	teq	r4, r5
 800c16a:	bf08      	it	eq
 800c16c:	ea90 0f02 	teqeq	r0, r2
 800c170:	bf1f      	itttt	ne
 800c172:	ea54 0c00 	orrsne.w	ip, r4, r0
 800c176:	ea55 0c02 	orrsne.w	ip, r5, r2
 800c17a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800c17e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800c182:	f000 80e2 	beq.w	800c34a <__adddf3+0x1ee>
 800c186:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800c18a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800c18e:	bfb8      	it	lt
 800c190:	426d      	neglt	r5, r5
 800c192:	dd0c      	ble.n	800c1ae <__adddf3+0x52>
 800c194:	442c      	add	r4, r5
 800c196:	ea80 0202 	eor.w	r2, r0, r2
 800c19a:	ea81 0303 	eor.w	r3, r1, r3
 800c19e:	ea82 0000 	eor.w	r0, r2, r0
 800c1a2:	ea83 0101 	eor.w	r1, r3, r1
 800c1a6:	ea80 0202 	eor.w	r2, r0, r2
 800c1aa:	ea81 0303 	eor.w	r3, r1, r3
 800c1ae:	2d36      	cmp	r5, #54	; 0x36
 800c1b0:	bf88      	it	hi
 800c1b2:	bd30      	pophi	{r4, r5, pc}
 800c1b4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800c1b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800c1bc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800c1c0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800c1c4:	d002      	beq.n	800c1cc <__adddf3+0x70>
 800c1c6:	4240      	negs	r0, r0
 800c1c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c1cc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800c1d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c1d4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800c1d8:	d002      	beq.n	800c1e0 <__adddf3+0x84>
 800c1da:	4252      	negs	r2, r2
 800c1dc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c1e0:	ea94 0f05 	teq	r4, r5
 800c1e4:	f000 80a7 	beq.w	800c336 <__adddf3+0x1da>
 800c1e8:	f1a4 0401 	sub.w	r4, r4, #1
 800c1ec:	f1d5 0e20 	rsbs	lr, r5, #32
 800c1f0:	db0d      	blt.n	800c20e <__adddf3+0xb2>
 800c1f2:	fa02 fc0e 	lsl.w	ip, r2, lr
 800c1f6:	fa22 f205 	lsr.w	r2, r2, r5
 800c1fa:	1880      	adds	r0, r0, r2
 800c1fc:	f141 0100 	adc.w	r1, r1, #0
 800c200:	fa03 f20e 	lsl.w	r2, r3, lr
 800c204:	1880      	adds	r0, r0, r2
 800c206:	fa43 f305 	asr.w	r3, r3, r5
 800c20a:	4159      	adcs	r1, r3
 800c20c:	e00e      	b.n	800c22c <__adddf3+0xd0>
 800c20e:	f1a5 0520 	sub.w	r5, r5, #32
 800c212:	f10e 0e20 	add.w	lr, lr, #32
 800c216:	2a01      	cmp	r2, #1
 800c218:	fa03 fc0e 	lsl.w	ip, r3, lr
 800c21c:	bf28      	it	cs
 800c21e:	f04c 0c02 	orrcs.w	ip, ip, #2
 800c222:	fa43 f305 	asr.w	r3, r3, r5
 800c226:	18c0      	adds	r0, r0, r3
 800c228:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800c22c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800c230:	d507      	bpl.n	800c242 <__adddf3+0xe6>
 800c232:	f04f 0e00 	mov.w	lr, #0
 800c236:	f1dc 0c00 	rsbs	ip, ip, #0
 800c23a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800c23e:	eb6e 0101 	sbc.w	r1, lr, r1
 800c242:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800c246:	d31b      	bcc.n	800c280 <__adddf3+0x124>
 800c248:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800c24c:	d30c      	bcc.n	800c268 <__adddf3+0x10c>
 800c24e:	0849      	lsrs	r1, r1, #1
 800c250:	ea5f 0030 	movs.w	r0, r0, rrx
 800c254:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800c258:	f104 0401 	add.w	r4, r4, #1
 800c25c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800c260:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800c264:	f080 809a 	bcs.w	800c39c <__adddf3+0x240>
 800c268:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800c26c:	bf08      	it	eq
 800c26e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800c272:	f150 0000 	adcs.w	r0, r0, #0
 800c276:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c27a:	ea41 0105 	orr.w	r1, r1, r5
 800c27e:	bd30      	pop	{r4, r5, pc}
 800c280:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800c284:	4140      	adcs	r0, r0
 800c286:	eb41 0101 	adc.w	r1, r1, r1
 800c28a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c28e:	f1a4 0401 	sub.w	r4, r4, #1
 800c292:	d1e9      	bne.n	800c268 <__adddf3+0x10c>
 800c294:	f091 0f00 	teq	r1, #0
 800c298:	bf04      	itt	eq
 800c29a:	4601      	moveq	r1, r0
 800c29c:	2000      	moveq	r0, #0
 800c29e:	fab1 f381 	clz	r3, r1
 800c2a2:	bf08      	it	eq
 800c2a4:	3320      	addeq	r3, #32
 800c2a6:	f1a3 030b 	sub.w	r3, r3, #11
 800c2aa:	f1b3 0220 	subs.w	r2, r3, #32
 800c2ae:	da0c      	bge.n	800c2ca <__adddf3+0x16e>
 800c2b0:	320c      	adds	r2, #12
 800c2b2:	dd08      	ble.n	800c2c6 <__adddf3+0x16a>
 800c2b4:	f102 0c14 	add.w	ip, r2, #20
 800c2b8:	f1c2 020c 	rsb	r2, r2, #12
 800c2bc:	fa01 f00c 	lsl.w	r0, r1, ip
 800c2c0:	fa21 f102 	lsr.w	r1, r1, r2
 800c2c4:	e00c      	b.n	800c2e0 <__adddf3+0x184>
 800c2c6:	f102 0214 	add.w	r2, r2, #20
 800c2ca:	bfd8      	it	le
 800c2cc:	f1c2 0c20 	rsble	ip, r2, #32
 800c2d0:	fa01 f102 	lsl.w	r1, r1, r2
 800c2d4:	fa20 fc0c 	lsr.w	ip, r0, ip
 800c2d8:	bfdc      	itt	le
 800c2da:	ea41 010c 	orrle.w	r1, r1, ip
 800c2de:	4090      	lslle	r0, r2
 800c2e0:	1ae4      	subs	r4, r4, r3
 800c2e2:	bfa2      	ittt	ge
 800c2e4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800c2e8:	4329      	orrge	r1, r5
 800c2ea:	bd30      	popge	{r4, r5, pc}
 800c2ec:	ea6f 0404 	mvn.w	r4, r4
 800c2f0:	3c1f      	subs	r4, #31
 800c2f2:	da1c      	bge.n	800c32e <__adddf3+0x1d2>
 800c2f4:	340c      	adds	r4, #12
 800c2f6:	dc0e      	bgt.n	800c316 <__adddf3+0x1ba>
 800c2f8:	f104 0414 	add.w	r4, r4, #20
 800c2fc:	f1c4 0220 	rsb	r2, r4, #32
 800c300:	fa20 f004 	lsr.w	r0, r0, r4
 800c304:	fa01 f302 	lsl.w	r3, r1, r2
 800c308:	ea40 0003 	orr.w	r0, r0, r3
 800c30c:	fa21 f304 	lsr.w	r3, r1, r4
 800c310:	ea45 0103 	orr.w	r1, r5, r3
 800c314:	bd30      	pop	{r4, r5, pc}
 800c316:	f1c4 040c 	rsb	r4, r4, #12
 800c31a:	f1c4 0220 	rsb	r2, r4, #32
 800c31e:	fa20 f002 	lsr.w	r0, r0, r2
 800c322:	fa01 f304 	lsl.w	r3, r1, r4
 800c326:	ea40 0003 	orr.w	r0, r0, r3
 800c32a:	4629      	mov	r1, r5
 800c32c:	bd30      	pop	{r4, r5, pc}
 800c32e:	fa21 f004 	lsr.w	r0, r1, r4
 800c332:	4629      	mov	r1, r5
 800c334:	bd30      	pop	{r4, r5, pc}
 800c336:	f094 0f00 	teq	r4, #0
 800c33a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800c33e:	bf06      	itte	eq
 800c340:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800c344:	3401      	addeq	r4, #1
 800c346:	3d01      	subne	r5, #1
 800c348:	e74e      	b.n	800c1e8 <__adddf3+0x8c>
 800c34a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800c34e:	bf18      	it	ne
 800c350:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800c354:	d029      	beq.n	800c3aa <__adddf3+0x24e>
 800c356:	ea94 0f05 	teq	r4, r5
 800c35a:	bf08      	it	eq
 800c35c:	ea90 0f02 	teqeq	r0, r2
 800c360:	d005      	beq.n	800c36e <__adddf3+0x212>
 800c362:	ea54 0c00 	orrs.w	ip, r4, r0
 800c366:	bf04      	itt	eq
 800c368:	4619      	moveq	r1, r3
 800c36a:	4610      	moveq	r0, r2
 800c36c:	bd30      	pop	{r4, r5, pc}
 800c36e:	ea91 0f03 	teq	r1, r3
 800c372:	bf1e      	ittt	ne
 800c374:	2100      	movne	r1, #0
 800c376:	2000      	movne	r0, #0
 800c378:	bd30      	popne	{r4, r5, pc}
 800c37a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800c37e:	d105      	bne.n	800c38c <__adddf3+0x230>
 800c380:	0040      	lsls	r0, r0, #1
 800c382:	4149      	adcs	r1, r1
 800c384:	bf28      	it	cs
 800c386:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800c38a:	bd30      	pop	{r4, r5, pc}
 800c38c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800c390:	bf3c      	itt	cc
 800c392:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800c396:	bd30      	popcc	{r4, r5, pc}
 800c398:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800c39c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800c3a0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800c3a4:	f04f 0000 	mov.w	r0, #0
 800c3a8:	bd30      	pop	{r4, r5, pc}
 800c3aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800c3ae:	bf1a      	itte	ne
 800c3b0:	4619      	movne	r1, r3
 800c3b2:	4610      	movne	r0, r2
 800c3b4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800c3b8:	bf1c      	itt	ne
 800c3ba:	460b      	movne	r3, r1
 800c3bc:	4602      	movne	r2, r0
 800c3be:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800c3c2:	bf06      	itte	eq
 800c3c4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800c3c8:	ea91 0f03 	teqeq	r1, r3
 800c3cc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800c3d0:	bd30      	pop	{r4, r5, pc}
 800c3d2:	bf00      	nop

0800c3d4 <__aeabi_ui2d>:
 800c3d4:	f090 0f00 	teq	r0, #0
 800c3d8:	bf04      	itt	eq
 800c3da:	2100      	moveq	r1, #0
 800c3dc:	4770      	bxeq	lr
 800c3de:	b530      	push	{r4, r5, lr}
 800c3e0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800c3e4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800c3e8:	f04f 0500 	mov.w	r5, #0
 800c3ec:	f04f 0100 	mov.w	r1, #0
 800c3f0:	e750      	b.n	800c294 <__adddf3+0x138>
 800c3f2:	bf00      	nop

0800c3f4 <__aeabi_i2d>:
 800c3f4:	f090 0f00 	teq	r0, #0
 800c3f8:	bf04      	itt	eq
 800c3fa:	2100      	moveq	r1, #0
 800c3fc:	4770      	bxeq	lr
 800c3fe:	b530      	push	{r4, r5, lr}
 800c400:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800c404:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800c408:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800c40c:	bf48      	it	mi
 800c40e:	4240      	negmi	r0, r0
 800c410:	f04f 0100 	mov.w	r1, #0
 800c414:	e73e      	b.n	800c294 <__adddf3+0x138>
 800c416:	bf00      	nop

0800c418 <__aeabi_f2d>:
 800c418:	0042      	lsls	r2, r0, #1
 800c41a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800c41e:	ea4f 0131 	mov.w	r1, r1, rrx
 800c422:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800c426:	bf1f      	itttt	ne
 800c428:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800c42c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800c430:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800c434:	4770      	bxne	lr
 800c436:	f092 0f00 	teq	r2, #0
 800c43a:	bf14      	ite	ne
 800c43c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800c440:	4770      	bxeq	lr
 800c442:	b530      	push	{r4, r5, lr}
 800c444:	f44f 7460 	mov.w	r4, #896	; 0x380
 800c448:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800c44c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800c450:	e720      	b.n	800c294 <__adddf3+0x138>
 800c452:	bf00      	nop

0800c454 <__aeabi_ul2d>:
 800c454:	ea50 0201 	orrs.w	r2, r0, r1
 800c458:	bf08      	it	eq
 800c45a:	4770      	bxeq	lr
 800c45c:	b530      	push	{r4, r5, lr}
 800c45e:	f04f 0500 	mov.w	r5, #0
 800c462:	e00a      	b.n	800c47a <__aeabi_l2d+0x16>

0800c464 <__aeabi_l2d>:
 800c464:	ea50 0201 	orrs.w	r2, r0, r1
 800c468:	bf08      	it	eq
 800c46a:	4770      	bxeq	lr
 800c46c:	b530      	push	{r4, r5, lr}
 800c46e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800c472:	d502      	bpl.n	800c47a <__aeabi_l2d+0x16>
 800c474:	4240      	negs	r0, r0
 800c476:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c47a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800c47e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800c482:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800c486:	f43f aedc 	beq.w	800c242 <__adddf3+0xe6>
 800c48a:	f04f 0203 	mov.w	r2, #3
 800c48e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800c492:	bf18      	it	ne
 800c494:	3203      	addne	r2, #3
 800c496:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800c49a:	bf18      	it	ne
 800c49c:	3203      	addne	r2, #3
 800c49e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800c4a2:	f1c2 0320 	rsb	r3, r2, #32
 800c4a6:	fa00 fc03 	lsl.w	ip, r0, r3
 800c4aa:	fa20 f002 	lsr.w	r0, r0, r2
 800c4ae:	fa01 fe03 	lsl.w	lr, r1, r3
 800c4b2:	ea40 000e 	orr.w	r0, r0, lr
 800c4b6:	fa21 f102 	lsr.w	r1, r1, r2
 800c4ba:	4414      	add	r4, r2
 800c4bc:	e6c1      	b.n	800c242 <__adddf3+0xe6>
 800c4be:	bf00      	nop

0800c4c0 <__aeabi_dmul>:
 800c4c0:	b570      	push	{r4, r5, r6, lr}
 800c4c2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800c4c6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800c4ca:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800c4ce:	bf1d      	ittte	ne
 800c4d0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800c4d4:	ea94 0f0c 	teqne	r4, ip
 800c4d8:	ea95 0f0c 	teqne	r5, ip
 800c4dc:	f000 f8de 	bleq	800c69c <__aeabi_dmul+0x1dc>
 800c4e0:	442c      	add	r4, r5
 800c4e2:	ea81 0603 	eor.w	r6, r1, r3
 800c4e6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800c4ea:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800c4ee:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800c4f2:	bf18      	it	ne
 800c4f4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800c4f8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c4fc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c500:	d038      	beq.n	800c574 <__aeabi_dmul+0xb4>
 800c502:	fba0 ce02 	umull	ip, lr, r0, r2
 800c506:	f04f 0500 	mov.w	r5, #0
 800c50a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800c50e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800c512:	fbe0 e503 	umlal	lr, r5, r0, r3
 800c516:	f04f 0600 	mov.w	r6, #0
 800c51a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800c51e:	f09c 0f00 	teq	ip, #0
 800c522:	bf18      	it	ne
 800c524:	f04e 0e01 	orrne.w	lr, lr, #1
 800c528:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800c52c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800c530:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800c534:	d204      	bcs.n	800c540 <__aeabi_dmul+0x80>
 800c536:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800c53a:	416d      	adcs	r5, r5
 800c53c:	eb46 0606 	adc.w	r6, r6, r6
 800c540:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800c544:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800c548:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800c54c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800c550:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800c554:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c558:	bf88      	it	hi
 800c55a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c55e:	d81e      	bhi.n	800c59e <__aeabi_dmul+0xde>
 800c560:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800c564:	bf08      	it	eq
 800c566:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800c56a:	f150 0000 	adcs.w	r0, r0, #0
 800c56e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c572:	bd70      	pop	{r4, r5, r6, pc}
 800c574:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800c578:	ea46 0101 	orr.w	r1, r6, r1
 800c57c:	ea40 0002 	orr.w	r0, r0, r2
 800c580:	ea81 0103 	eor.w	r1, r1, r3
 800c584:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800c588:	bfc2      	ittt	gt
 800c58a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c58e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c592:	bd70      	popgt	{r4, r5, r6, pc}
 800c594:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c598:	f04f 0e00 	mov.w	lr, #0
 800c59c:	3c01      	subs	r4, #1
 800c59e:	f300 80ab 	bgt.w	800c6f8 <__aeabi_dmul+0x238>
 800c5a2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800c5a6:	bfde      	ittt	le
 800c5a8:	2000      	movle	r0, #0
 800c5aa:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800c5ae:	bd70      	pople	{r4, r5, r6, pc}
 800c5b0:	f1c4 0400 	rsb	r4, r4, #0
 800c5b4:	3c20      	subs	r4, #32
 800c5b6:	da35      	bge.n	800c624 <__aeabi_dmul+0x164>
 800c5b8:	340c      	adds	r4, #12
 800c5ba:	dc1b      	bgt.n	800c5f4 <__aeabi_dmul+0x134>
 800c5bc:	f104 0414 	add.w	r4, r4, #20
 800c5c0:	f1c4 0520 	rsb	r5, r4, #32
 800c5c4:	fa00 f305 	lsl.w	r3, r0, r5
 800c5c8:	fa20 f004 	lsr.w	r0, r0, r4
 800c5cc:	fa01 f205 	lsl.w	r2, r1, r5
 800c5d0:	ea40 0002 	orr.w	r0, r0, r2
 800c5d4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800c5d8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800c5dc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c5e0:	fa21 f604 	lsr.w	r6, r1, r4
 800c5e4:	eb42 0106 	adc.w	r1, r2, r6
 800c5e8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c5ec:	bf08      	it	eq
 800c5ee:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c5f2:	bd70      	pop	{r4, r5, r6, pc}
 800c5f4:	f1c4 040c 	rsb	r4, r4, #12
 800c5f8:	f1c4 0520 	rsb	r5, r4, #32
 800c5fc:	fa00 f304 	lsl.w	r3, r0, r4
 800c600:	fa20 f005 	lsr.w	r0, r0, r5
 800c604:	fa01 f204 	lsl.w	r2, r1, r4
 800c608:	ea40 0002 	orr.w	r0, r0, r2
 800c60c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c610:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c614:	f141 0100 	adc.w	r1, r1, #0
 800c618:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c61c:	bf08      	it	eq
 800c61e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c622:	bd70      	pop	{r4, r5, r6, pc}
 800c624:	f1c4 0520 	rsb	r5, r4, #32
 800c628:	fa00 f205 	lsl.w	r2, r0, r5
 800c62c:	ea4e 0e02 	orr.w	lr, lr, r2
 800c630:	fa20 f304 	lsr.w	r3, r0, r4
 800c634:	fa01 f205 	lsl.w	r2, r1, r5
 800c638:	ea43 0302 	orr.w	r3, r3, r2
 800c63c:	fa21 f004 	lsr.w	r0, r1, r4
 800c640:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c644:	fa21 f204 	lsr.w	r2, r1, r4
 800c648:	ea20 0002 	bic.w	r0, r0, r2
 800c64c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800c650:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c654:	bf08      	it	eq
 800c656:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c65a:	bd70      	pop	{r4, r5, r6, pc}
 800c65c:	f094 0f00 	teq	r4, #0
 800c660:	d10f      	bne.n	800c682 <__aeabi_dmul+0x1c2>
 800c662:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800c666:	0040      	lsls	r0, r0, #1
 800c668:	eb41 0101 	adc.w	r1, r1, r1
 800c66c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c670:	bf08      	it	eq
 800c672:	3c01      	subeq	r4, #1
 800c674:	d0f7      	beq.n	800c666 <__aeabi_dmul+0x1a6>
 800c676:	ea41 0106 	orr.w	r1, r1, r6
 800c67a:	f095 0f00 	teq	r5, #0
 800c67e:	bf18      	it	ne
 800c680:	4770      	bxne	lr
 800c682:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800c686:	0052      	lsls	r2, r2, #1
 800c688:	eb43 0303 	adc.w	r3, r3, r3
 800c68c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800c690:	bf08      	it	eq
 800c692:	3d01      	subeq	r5, #1
 800c694:	d0f7      	beq.n	800c686 <__aeabi_dmul+0x1c6>
 800c696:	ea43 0306 	orr.w	r3, r3, r6
 800c69a:	4770      	bx	lr
 800c69c:	ea94 0f0c 	teq	r4, ip
 800c6a0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c6a4:	bf18      	it	ne
 800c6a6:	ea95 0f0c 	teqne	r5, ip
 800c6aa:	d00c      	beq.n	800c6c6 <__aeabi_dmul+0x206>
 800c6ac:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c6b0:	bf18      	it	ne
 800c6b2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c6b6:	d1d1      	bne.n	800c65c <__aeabi_dmul+0x19c>
 800c6b8:	ea81 0103 	eor.w	r1, r1, r3
 800c6bc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c6c0:	f04f 0000 	mov.w	r0, #0
 800c6c4:	bd70      	pop	{r4, r5, r6, pc}
 800c6c6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c6ca:	bf06      	itte	eq
 800c6cc:	4610      	moveq	r0, r2
 800c6ce:	4619      	moveq	r1, r3
 800c6d0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c6d4:	d019      	beq.n	800c70a <__aeabi_dmul+0x24a>
 800c6d6:	ea94 0f0c 	teq	r4, ip
 800c6da:	d102      	bne.n	800c6e2 <__aeabi_dmul+0x222>
 800c6dc:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800c6e0:	d113      	bne.n	800c70a <__aeabi_dmul+0x24a>
 800c6e2:	ea95 0f0c 	teq	r5, ip
 800c6e6:	d105      	bne.n	800c6f4 <__aeabi_dmul+0x234>
 800c6e8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800c6ec:	bf1c      	itt	ne
 800c6ee:	4610      	movne	r0, r2
 800c6f0:	4619      	movne	r1, r3
 800c6f2:	d10a      	bne.n	800c70a <__aeabi_dmul+0x24a>
 800c6f4:	ea81 0103 	eor.w	r1, r1, r3
 800c6f8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c6fc:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c700:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800c704:	f04f 0000 	mov.w	r0, #0
 800c708:	bd70      	pop	{r4, r5, r6, pc}
 800c70a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c70e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800c712:	bd70      	pop	{r4, r5, r6, pc}

0800c714 <__aeabi_ddiv>:
 800c714:	b570      	push	{r4, r5, r6, lr}
 800c716:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800c71a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800c71e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800c722:	bf1d      	ittte	ne
 800c724:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800c728:	ea94 0f0c 	teqne	r4, ip
 800c72c:	ea95 0f0c 	teqne	r5, ip
 800c730:	f000 f8a7 	bleq	800c882 <__aeabi_ddiv+0x16e>
 800c734:	eba4 0405 	sub.w	r4, r4, r5
 800c738:	ea81 0e03 	eor.w	lr, r1, r3
 800c73c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c740:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800c744:	f000 8088 	beq.w	800c858 <__aeabi_ddiv+0x144>
 800c748:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c74c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800c750:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800c754:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c758:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800c75c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800c760:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800c764:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800c768:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800c76c:	429d      	cmp	r5, r3
 800c76e:	bf08      	it	eq
 800c770:	4296      	cmpeq	r6, r2
 800c772:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800c776:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800c77a:	d202      	bcs.n	800c782 <__aeabi_ddiv+0x6e>
 800c77c:	085b      	lsrs	r3, r3, #1
 800c77e:	ea4f 0232 	mov.w	r2, r2, rrx
 800c782:	1ab6      	subs	r6, r6, r2
 800c784:	eb65 0503 	sbc.w	r5, r5, r3
 800c788:	085b      	lsrs	r3, r3, #1
 800c78a:	ea4f 0232 	mov.w	r2, r2, rrx
 800c78e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800c792:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800c796:	ebb6 0e02 	subs.w	lr, r6, r2
 800c79a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c79e:	bf22      	ittt	cs
 800c7a0:	1ab6      	subcs	r6, r6, r2
 800c7a2:	4675      	movcs	r5, lr
 800c7a4:	ea40 000c 	orrcs.w	r0, r0, ip
 800c7a8:	085b      	lsrs	r3, r3, #1
 800c7aa:	ea4f 0232 	mov.w	r2, r2, rrx
 800c7ae:	ebb6 0e02 	subs.w	lr, r6, r2
 800c7b2:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c7b6:	bf22      	ittt	cs
 800c7b8:	1ab6      	subcs	r6, r6, r2
 800c7ba:	4675      	movcs	r5, lr
 800c7bc:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800c7c0:	085b      	lsrs	r3, r3, #1
 800c7c2:	ea4f 0232 	mov.w	r2, r2, rrx
 800c7c6:	ebb6 0e02 	subs.w	lr, r6, r2
 800c7ca:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c7ce:	bf22      	ittt	cs
 800c7d0:	1ab6      	subcs	r6, r6, r2
 800c7d2:	4675      	movcs	r5, lr
 800c7d4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800c7d8:	085b      	lsrs	r3, r3, #1
 800c7da:	ea4f 0232 	mov.w	r2, r2, rrx
 800c7de:	ebb6 0e02 	subs.w	lr, r6, r2
 800c7e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c7e6:	bf22      	ittt	cs
 800c7e8:	1ab6      	subcs	r6, r6, r2
 800c7ea:	4675      	movcs	r5, lr
 800c7ec:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800c7f0:	ea55 0e06 	orrs.w	lr, r5, r6
 800c7f4:	d018      	beq.n	800c828 <__aeabi_ddiv+0x114>
 800c7f6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800c7fa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800c7fe:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800c802:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800c806:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800c80a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800c80e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800c812:	d1c0      	bne.n	800c796 <__aeabi_ddiv+0x82>
 800c814:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c818:	d10b      	bne.n	800c832 <__aeabi_ddiv+0x11e>
 800c81a:	ea41 0100 	orr.w	r1, r1, r0
 800c81e:	f04f 0000 	mov.w	r0, #0
 800c822:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800c826:	e7b6      	b.n	800c796 <__aeabi_ddiv+0x82>
 800c828:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c82c:	bf04      	itt	eq
 800c82e:	4301      	orreq	r1, r0
 800c830:	2000      	moveq	r0, #0
 800c832:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c836:	bf88      	it	hi
 800c838:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c83c:	f63f aeaf 	bhi.w	800c59e <__aeabi_dmul+0xde>
 800c840:	ebb5 0c03 	subs.w	ip, r5, r3
 800c844:	bf04      	itt	eq
 800c846:	ebb6 0c02 	subseq.w	ip, r6, r2
 800c84a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800c84e:	f150 0000 	adcs.w	r0, r0, #0
 800c852:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c856:	bd70      	pop	{r4, r5, r6, pc}
 800c858:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800c85c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800c860:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800c864:	bfc2      	ittt	gt
 800c866:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c86a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c86e:	bd70      	popgt	{r4, r5, r6, pc}
 800c870:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c874:	f04f 0e00 	mov.w	lr, #0
 800c878:	3c01      	subs	r4, #1
 800c87a:	e690      	b.n	800c59e <__aeabi_dmul+0xde>
 800c87c:	ea45 0e06 	orr.w	lr, r5, r6
 800c880:	e68d      	b.n	800c59e <__aeabi_dmul+0xde>
 800c882:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c886:	ea94 0f0c 	teq	r4, ip
 800c88a:	bf08      	it	eq
 800c88c:	ea95 0f0c 	teqeq	r5, ip
 800c890:	f43f af3b 	beq.w	800c70a <__aeabi_dmul+0x24a>
 800c894:	ea94 0f0c 	teq	r4, ip
 800c898:	d10a      	bne.n	800c8b0 <__aeabi_ddiv+0x19c>
 800c89a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800c89e:	f47f af34 	bne.w	800c70a <__aeabi_dmul+0x24a>
 800c8a2:	ea95 0f0c 	teq	r5, ip
 800c8a6:	f47f af25 	bne.w	800c6f4 <__aeabi_dmul+0x234>
 800c8aa:	4610      	mov	r0, r2
 800c8ac:	4619      	mov	r1, r3
 800c8ae:	e72c      	b.n	800c70a <__aeabi_dmul+0x24a>
 800c8b0:	ea95 0f0c 	teq	r5, ip
 800c8b4:	d106      	bne.n	800c8c4 <__aeabi_ddiv+0x1b0>
 800c8b6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c8ba:	f43f aefd 	beq.w	800c6b8 <__aeabi_dmul+0x1f8>
 800c8be:	4610      	mov	r0, r2
 800c8c0:	4619      	mov	r1, r3
 800c8c2:	e722      	b.n	800c70a <__aeabi_dmul+0x24a>
 800c8c4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c8c8:	bf18      	it	ne
 800c8ca:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c8ce:	f47f aec5 	bne.w	800c65c <__aeabi_dmul+0x19c>
 800c8d2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800c8d6:	f47f af0d 	bne.w	800c6f4 <__aeabi_dmul+0x234>
 800c8da:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800c8de:	f47f aeeb 	bne.w	800c6b8 <__aeabi_dmul+0x1f8>
 800c8e2:	e712      	b.n	800c70a <__aeabi_dmul+0x24a>
	...

0800c8f0 <__aeabi_d2iz>:
 800c8f0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800c8f4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800c8f8:	d215      	bcs.n	800c926 <__aeabi_d2iz+0x36>
 800c8fa:	d511      	bpl.n	800c920 <__aeabi_d2iz+0x30>
 800c8fc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800c900:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800c904:	d912      	bls.n	800c92c <__aeabi_d2iz+0x3c>
 800c906:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800c90a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800c90e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800c912:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800c916:	fa23 f002 	lsr.w	r0, r3, r2
 800c91a:	bf18      	it	ne
 800c91c:	4240      	negne	r0, r0
 800c91e:	4770      	bx	lr
 800c920:	f04f 0000 	mov.w	r0, #0
 800c924:	4770      	bx	lr
 800c926:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800c92a:	d105      	bne.n	800c938 <__aeabi_d2iz+0x48>
 800c92c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800c930:	bf08      	it	eq
 800c932:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800c936:	4770      	bx	lr
 800c938:	f04f 0000 	mov.w	r0, #0
 800c93c:	4770      	bx	lr
 800c93e:	bf00      	nop

0800c940 <memcpy>:
 800c940:	4684      	mov	ip, r0
 800c942:	ea41 0300 	orr.w	r3, r1, r0
 800c946:	f013 0303 	ands.w	r3, r3, #3
 800c94a:	d16d      	bne.n	800ca28 <memcpy+0xe8>
 800c94c:	3a40      	subs	r2, #64	; 0x40
 800c94e:	d341      	bcc.n	800c9d4 <memcpy+0x94>
 800c950:	f851 3b04 	ldr.w	r3, [r1], #4
 800c954:	f840 3b04 	str.w	r3, [r0], #4
 800c958:	f851 3b04 	ldr.w	r3, [r1], #4
 800c95c:	f840 3b04 	str.w	r3, [r0], #4
 800c960:	f851 3b04 	ldr.w	r3, [r1], #4
 800c964:	f840 3b04 	str.w	r3, [r0], #4
 800c968:	f851 3b04 	ldr.w	r3, [r1], #4
 800c96c:	f840 3b04 	str.w	r3, [r0], #4
 800c970:	f851 3b04 	ldr.w	r3, [r1], #4
 800c974:	f840 3b04 	str.w	r3, [r0], #4
 800c978:	f851 3b04 	ldr.w	r3, [r1], #4
 800c97c:	f840 3b04 	str.w	r3, [r0], #4
 800c980:	f851 3b04 	ldr.w	r3, [r1], #4
 800c984:	f840 3b04 	str.w	r3, [r0], #4
 800c988:	f851 3b04 	ldr.w	r3, [r1], #4
 800c98c:	f840 3b04 	str.w	r3, [r0], #4
 800c990:	f851 3b04 	ldr.w	r3, [r1], #4
 800c994:	f840 3b04 	str.w	r3, [r0], #4
 800c998:	f851 3b04 	ldr.w	r3, [r1], #4
 800c99c:	f840 3b04 	str.w	r3, [r0], #4
 800c9a0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9a4:	f840 3b04 	str.w	r3, [r0], #4
 800c9a8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9ac:	f840 3b04 	str.w	r3, [r0], #4
 800c9b0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9b4:	f840 3b04 	str.w	r3, [r0], #4
 800c9b8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9bc:	f840 3b04 	str.w	r3, [r0], #4
 800c9c0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9c4:	f840 3b04 	str.w	r3, [r0], #4
 800c9c8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9cc:	f840 3b04 	str.w	r3, [r0], #4
 800c9d0:	3a40      	subs	r2, #64	; 0x40
 800c9d2:	d2bd      	bcs.n	800c950 <memcpy+0x10>
 800c9d4:	3230      	adds	r2, #48	; 0x30
 800c9d6:	d311      	bcc.n	800c9fc <memcpy+0xbc>
 800c9d8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9dc:	f840 3b04 	str.w	r3, [r0], #4
 800c9e0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9e4:	f840 3b04 	str.w	r3, [r0], #4
 800c9e8:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9ec:	f840 3b04 	str.w	r3, [r0], #4
 800c9f0:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9f4:	f840 3b04 	str.w	r3, [r0], #4
 800c9f8:	3a10      	subs	r2, #16
 800c9fa:	d2ed      	bcs.n	800c9d8 <memcpy+0x98>
 800c9fc:	320c      	adds	r2, #12
 800c9fe:	d305      	bcc.n	800ca0c <memcpy+0xcc>
 800ca00:	f851 3b04 	ldr.w	r3, [r1], #4
 800ca04:	f840 3b04 	str.w	r3, [r0], #4
 800ca08:	3a04      	subs	r2, #4
 800ca0a:	d2f9      	bcs.n	800ca00 <memcpy+0xc0>
 800ca0c:	3204      	adds	r2, #4
 800ca0e:	d008      	beq.n	800ca22 <memcpy+0xe2>
 800ca10:	07d2      	lsls	r2, r2, #31
 800ca12:	bf1c      	itt	ne
 800ca14:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800ca18:	f800 3b01 	strbne.w	r3, [r0], #1
 800ca1c:	d301      	bcc.n	800ca22 <memcpy+0xe2>
 800ca1e:	880b      	ldrh	r3, [r1, #0]
 800ca20:	8003      	strh	r3, [r0, #0]
 800ca22:	4660      	mov	r0, ip
 800ca24:	4770      	bx	lr
 800ca26:	bf00      	nop
 800ca28:	2a08      	cmp	r2, #8
 800ca2a:	d313      	bcc.n	800ca54 <memcpy+0x114>
 800ca2c:	078b      	lsls	r3, r1, #30
 800ca2e:	d08d      	beq.n	800c94c <memcpy+0xc>
 800ca30:	f010 0303 	ands.w	r3, r0, #3
 800ca34:	d08a      	beq.n	800c94c <memcpy+0xc>
 800ca36:	f1c3 0304 	rsb	r3, r3, #4
 800ca3a:	1ad2      	subs	r2, r2, r3
 800ca3c:	07db      	lsls	r3, r3, #31
 800ca3e:	bf1c      	itt	ne
 800ca40:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800ca44:	f800 3b01 	strbne.w	r3, [r0], #1
 800ca48:	d380      	bcc.n	800c94c <memcpy+0xc>
 800ca4a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800ca4e:	f820 3b02 	strh.w	r3, [r0], #2
 800ca52:	e77b      	b.n	800c94c <memcpy+0xc>
 800ca54:	3a04      	subs	r2, #4
 800ca56:	d3d9      	bcc.n	800ca0c <memcpy+0xcc>
 800ca58:	3a01      	subs	r2, #1
 800ca5a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800ca5e:	f800 3b01 	strb.w	r3, [r0], #1
 800ca62:	d2f9      	bcs.n	800ca58 <memcpy+0x118>
 800ca64:	780b      	ldrb	r3, [r1, #0]
 800ca66:	7003      	strb	r3, [r0, #0]
 800ca68:	784b      	ldrb	r3, [r1, #1]
 800ca6a:	7043      	strb	r3, [r0, #1]
 800ca6c:	788b      	ldrb	r3, [r1, #2]
 800ca6e:	7083      	strb	r3, [r0, #2]
 800ca70:	4660      	mov	r0, ip
 800ca72:	4770      	bx	lr
	...

0800ca80 <__gedf2>:
 800ca80:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 800ca84:	e006      	b.n	800ca94 <__cmpdf2+0x4>
 800ca86:	bf00      	nop

0800ca88 <__ledf2>:
 800ca88:	f04f 0c01 	mov.w	ip, #1
 800ca8c:	e002      	b.n	800ca94 <__cmpdf2+0x4>
 800ca8e:	bf00      	nop

0800ca90 <__cmpdf2>:
 800ca90:	f04f 0c01 	mov.w	ip, #1
 800ca94:	f84d cd04 	str.w	ip, [sp, #-4]!
 800ca98:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800ca9c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800caa0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800caa4:	bf18      	it	ne
 800caa6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800caaa:	d01b      	beq.n	800cae4 <__cmpdf2+0x54>
 800caac:	b001      	add	sp, #4
 800caae:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800cab2:	bf0c      	ite	eq
 800cab4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800cab8:	ea91 0f03 	teqne	r1, r3
 800cabc:	bf02      	ittt	eq
 800cabe:	ea90 0f02 	teqeq	r0, r2
 800cac2:	2000      	moveq	r0, #0
 800cac4:	4770      	bxeq	lr
 800cac6:	f110 0f00 	cmn.w	r0, #0
 800caca:	ea91 0f03 	teq	r1, r3
 800cace:	bf58      	it	pl
 800cad0:	4299      	cmppl	r1, r3
 800cad2:	bf08      	it	eq
 800cad4:	4290      	cmpeq	r0, r2
 800cad6:	bf2c      	ite	cs
 800cad8:	17d8      	asrcs	r0, r3, #31
 800cada:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800cade:	f040 0001 	orr.w	r0, r0, #1
 800cae2:	4770      	bx	lr
 800cae4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800cae8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800caec:	d102      	bne.n	800caf4 <__cmpdf2+0x64>
 800caee:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800caf2:	d107      	bne.n	800cb04 <__cmpdf2+0x74>
 800caf4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800caf8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800cafc:	d1d6      	bne.n	800caac <__cmpdf2+0x1c>
 800cafe:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800cb02:	d0d3      	beq.n	800caac <__cmpdf2+0x1c>
 800cb04:	f85d 0b04 	ldr.w	r0, [sp], #4
 800cb08:	4770      	bx	lr
 800cb0a:	bf00      	nop

0800cb0c <__aeabi_cdrcmple>:
 800cb0c:	4684      	mov	ip, r0
 800cb0e:	4610      	mov	r0, r2
 800cb10:	4662      	mov	r2, ip
 800cb12:	468c      	mov	ip, r1
 800cb14:	4619      	mov	r1, r3
 800cb16:	4663      	mov	r3, ip
 800cb18:	e000      	b.n	800cb1c <__aeabi_cdcmpeq>
 800cb1a:	bf00      	nop

0800cb1c <__aeabi_cdcmpeq>:
 800cb1c:	b501      	push	{r0, lr}
 800cb1e:	f7ff ffb7 	bl	800ca90 <__cmpdf2>
 800cb22:	2800      	cmp	r0, #0
 800cb24:	bf48      	it	mi
 800cb26:	f110 0f00 	cmnmi.w	r0, #0
 800cb2a:	bd01      	pop	{r0, pc}

0800cb2c <__aeabi_dcmpeq>:
 800cb2c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800cb30:	f7ff fff4 	bl	800cb1c <__aeabi_cdcmpeq>
 800cb34:	bf0c      	ite	eq
 800cb36:	2001      	moveq	r0, #1
 800cb38:	2000      	movne	r0, #0
 800cb3a:	f85d fb08 	ldr.w	pc, [sp], #8
 800cb3e:	bf00      	nop

0800cb40 <__aeabi_dcmplt>:
 800cb40:	f84d ed08 	str.w	lr, [sp, #-8]!
 800cb44:	f7ff ffea 	bl	800cb1c <__aeabi_cdcmpeq>
 800cb48:	bf34      	ite	cc
 800cb4a:	2001      	movcc	r0, #1
 800cb4c:	2000      	movcs	r0, #0
 800cb4e:	f85d fb08 	ldr.w	pc, [sp], #8
 800cb52:	bf00      	nop

0800cb54 <__aeabi_dcmple>:
 800cb54:	f84d ed08 	str.w	lr, [sp, #-8]!
 800cb58:	f7ff ffe0 	bl	800cb1c <__aeabi_cdcmpeq>
 800cb5c:	bf94      	ite	ls
 800cb5e:	2001      	movls	r0, #1
 800cb60:	2000      	movhi	r0, #0
 800cb62:	f85d fb08 	ldr.w	pc, [sp], #8
 800cb66:	bf00      	nop

0800cb68 <__aeabi_dcmpge>:
 800cb68:	f84d ed08 	str.w	lr, [sp, #-8]!
 800cb6c:	f7ff ffce 	bl	800cb0c <__aeabi_cdrcmple>
 800cb70:	bf94      	ite	ls
 800cb72:	2001      	movls	r0, #1
 800cb74:	2000      	movhi	r0, #0
 800cb76:	f85d fb08 	ldr.w	pc, [sp], #8
 800cb7a:	bf00      	nop

0800cb7c <__aeabi_dcmpgt>:
 800cb7c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800cb80:	f7ff ffc4 	bl	800cb0c <__aeabi_cdrcmple>
 800cb84:	bf34      	ite	cc
 800cb86:	2001      	movcc	r0, #1
 800cb88:	2000      	movcs	r0, #0
 800cb8a:	f85d fb08 	ldr.w	pc, [sp], #8
 800cb8e:	bf00      	nop

0800cb90 <__aeabi_uldivmod>:
 800cb90:	b953      	cbnz	r3, 800cba8 <__aeabi_uldivmod+0x18>
 800cb92:	b94a      	cbnz	r2, 800cba8 <__aeabi_uldivmod+0x18>
 800cb94:	2900      	cmp	r1, #0
 800cb96:	bf08      	it	eq
 800cb98:	2800      	cmpeq	r0, #0
 800cb9a:	bf1c      	itt	ne
 800cb9c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 800cba0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 800cba4:	f000 b83c 	b.w	800cc20 <__aeabi_idiv0>
 800cba8:	b082      	sub	sp, #8
 800cbaa:	46ec      	mov	ip, sp
 800cbac:	e92d 5000 	stmdb	sp!, {ip, lr}
 800cbb0:	f000 f81e 	bl	800cbf0 <__gnu_uldivmod_helper>
 800cbb4:	f8dd e004 	ldr.w	lr, [sp, #4]
 800cbb8:	b002      	add	sp, #8
 800cbba:	bc0c      	pop	{r2, r3}
 800cbbc:	4770      	bx	lr
 800cbbe:	bf00      	nop

0800cbc0 <__gnu_ldivmod_helper>:
 800cbc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800cbc4:	9c06      	ldr	r4, [sp, #24]
 800cbc6:	4615      	mov	r5, r2
 800cbc8:	4606      	mov	r6, r0
 800cbca:	460f      	mov	r7, r1
 800cbcc:	4698      	mov	r8, r3
 800cbce:	f000 f82f 	bl	800cc30 <__divdi3>
 800cbd2:	fb05 f301 	mul.w	r3, r5, r1
 800cbd6:	fb00 3808 	mla	r8, r0, r8, r3
 800cbda:	fba5 2300 	umull	r2, r3, r5, r0
 800cbde:	1ab2      	subs	r2, r6, r2
 800cbe0:	4443      	add	r3, r8
 800cbe2:	eb67 0303 	sbc.w	r3, r7, r3
 800cbe6:	e9c4 2300 	strd	r2, r3, [r4]
 800cbea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cbee:	bf00      	nop

0800cbf0 <__gnu_uldivmod_helper>:
 800cbf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800cbf4:	9c06      	ldr	r4, [sp, #24]
 800cbf6:	4690      	mov	r8, r2
 800cbf8:	4606      	mov	r6, r0
 800cbfa:	460f      	mov	r7, r1
 800cbfc:	461d      	mov	r5, r3
 800cbfe:	f000 f967 	bl	800ced0 <__udivdi3>
 800cc02:	fb00 f505 	mul.w	r5, r0, r5
 800cc06:	fba0 2308 	umull	r2, r3, r0, r8
 800cc0a:	fb08 5501 	mla	r5, r8, r1, r5
 800cc0e:	1ab2      	subs	r2, r6, r2
 800cc10:	442b      	add	r3, r5
 800cc12:	eb67 0303 	sbc.w	r3, r7, r3
 800cc16:	e9c4 2300 	strd	r2, r3, [r4]
 800cc1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cc1e:	bf00      	nop

0800cc20 <__aeabi_idiv0>:
 800cc20:	4770      	bx	lr
 800cc22:	bf00      	nop
	...

0800cc30 <__divdi3>:
 800cc30:	2900      	cmp	r1, #0
 800cc32:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800cc36:	f2c0 80a6 	blt.w	800cd86 <__divdi3+0x156>
 800cc3a:	2600      	movs	r6, #0
 800cc3c:	2b00      	cmp	r3, #0
 800cc3e:	f2c0 809c 	blt.w	800cd7a <__divdi3+0x14a>
 800cc42:	4688      	mov	r8, r1
 800cc44:	4694      	mov	ip, r2
 800cc46:	469e      	mov	lr, r3
 800cc48:	4615      	mov	r5, r2
 800cc4a:	4604      	mov	r4, r0
 800cc4c:	460f      	mov	r7, r1
 800cc4e:	2b00      	cmp	r3, #0
 800cc50:	d13d      	bne.n	800ccce <__divdi3+0x9e>
 800cc52:	428a      	cmp	r2, r1
 800cc54:	d959      	bls.n	800cd0a <__divdi3+0xda>
 800cc56:	fab2 f382 	clz	r3, r2
 800cc5a:	b13b      	cbz	r3, 800cc6c <__divdi3+0x3c>
 800cc5c:	f1c3 0220 	rsb	r2, r3, #32
 800cc60:	409f      	lsls	r7, r3
 800cc62:	fa20 f202 	lsr.w	r2, r0, r2
 800cc66:	409d      	lsls	r5, r3
 800cc68:	4317      	orrs	r7, r2
 800cc6a:	409c      	lsls	r4, r3
 800cc6c:	0c29      	lsrs	r1, r5, #16
 800cc6e:	0c22      	lsrs	r2, r4, #16
 800cc70:	fbb7 fef1 	udiv	lr, r7, r1
 800cc74:	b2a8      	uxth	r0, r5
 800cc76:	fb01 771e 	mls	r7, r1, lr, r7
 800cc7a:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 800cc7e:	fb00 f30e 	mul.w	r3, r0, lr
 800cc82:	42bb      	cmp	r3, r7
 800cc84:	d90a      	bls.n	800cc9c <__divdi3+0x6c>
 800cc86:	197f      	adds	r7, r7, r5
 800cc88:	f10e 32ff 	add.w	r2, lr, #4294967295	; 0xffffffff
 800cc8c:	f080 8105 	bcs.w	800ce9a <__divdi3+0x26a>
 800cc90:	42bb      	cmp	r3, r7
 800cc92:	f240 8102 	bls.w	800ce9a <__divdi3+0x26a>
 800cc96:	f1ae 0e02 	sub.w	lr, lr, #2
 800cc9a:	442f      	add	r7, r5
 800cc9c:	1aff      	subs	r7, r7, r3
 800cc9e:	b2a4      	uxth	r4, r4
 800cca0:	fbb7 f3f1 	udiv	r3, r7, r1
 800cca4:	fb01 7713 	mls	r7, r1, r3, r7
 800cca8:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 800ccac:	fb00 f003 	mul.w	r0, r0, r3
 800ccb0:	42b8      	cmp	r0, r7
 800ccb2:	d908      	bls.n	800ccc6 <__divdi3+0x96>
 800ccb4:	197f      	adds	r7, r7, r5
 800ccb6:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800ccba:	f080 80f0 	bcs.w	800ce9e <__divdi3+0x26e>
 800ccbe:	42b8      	cmp	r0, r7
 800ccc0:	f240 80ed 	bls.w	800ce9e <__divdi3+0x26e>
 800ccc4:	3b02      	subs	r3, #2
 800ccc6:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 800ccca:	2200      	movs	r2, #0
 800cccc:	e003      	b.n	800ccd6 <__divdi3+0xa6>
 800ccce:	428b      	cmp	r3, r1
 800ccd0:	d90f      	bls.n	800ccf2 <__divdi3+0xc2>
 800ccd2:	2200      	movs	r2, #0
 800ccd4:	4613      	mov	r3, r2
 800ccd6:	1c34      	adds	r4, r6, #0
 800ccd8:	bf18      	it	ne
 800ccda:	2401      	movne	r4, #1
 800ccdc:	4260      	negs	r0, r4
 800ccde:	f04f 0500 	mov.w	r5, #0
 800cce2:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 800cce6:	4058      	eors	r0, r3
 800cce8:	4051      	eors	r1, r2
 800ccea:	1900      	adds	r0, r0, r4
 800ccec:	4169      	adcs	r1, r5
 800ccee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800ccf2:	fab3 f283 	clz	r2, r3
 800ccf6:	2a00      	cmp	r2, #0
 800ccf8:	f040 8086 	bne.w	800ce08 <__divdi3+0x1d8>
 800ccfc:	428b      	cmp	r3, r1
 800ccfe:	d302      	bcc.n	800cd06 <__divdi3+0xd6>
 800cd00:	4584      	cmp	ip, r0
 800cd02:	f200 80db 	bhi.w	800cebc <__divdi3+0x28c>
 800cd06:	2301      	movs	r3, #1
 800cd08:	e7e5      	b.n	800ccd6 <__divdi3+0xa6>
 800cd0a:	b912      	cbnz	r2, 800cd12 <__divdi3+0xe2>
 800cd0c:	2301      	movs	r3, #1
 800cd0e:	fbb3 f5f2 	udiv	r5, r3, r2
 800cd12:	fab5 f085 	clz	r0, r5
 800cd16:	2800      	cmp	r0, #0
 800cd18:	d13b      	bne.n	800cd92 <__divdi3+0x162>
 800cd1a:	1b78      	subs	r0, r7, r5
 800cd1c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800cd20:	fa1f fc85 	uxth.w	ip, r5
 800cd24:	2201      	movs	r2, #1
 800cd26:	fbb0 f8fe 	udiv	r8, r0, lr
 800cd2a:	0c21      	lsrs	r1, r4, #16
 800cd2c:	fb0e 0718 	mls	r7, lr, r8, r0
 800cd30:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 800cd34:	fb0c f308 	mul.w	r3, ip, r8
 800cd38:	42bb      	cmp	r3, r7
 800cd3a:	d907      	bls.n	800cd4c <__divdi3+0x11c>
 800cd3c:	197f      	adds	r7, r7, r5
 800cd3e:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
 800cd42:	d202      	bcs.n	800cd4a <__divdi3+0x11a>
 800cd44:	42bb      	cmp	r3, r7
 800cd46:	f200 80bd 	bhi.w	800cec4 <__divdi3+0x294>
 800cd4a:	4688      	mov	r8, r1
 800cd4c:	1aff      	subs	r7, r7, r3
 800cd4e:	b2a4      	uxth	r4, r4
 800cd50:	fbb7 f3fe 	udiv	r3, r7, lr
 800cd54:	fb0e 7713 	mls	r7, lr, r3, r7
 800cd58:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 800cd5c:	fb0c fc03 	mul.w	ip, ip, r3
 800cd60:	45bc      	cmp	ip, r7
 800cd62:	d907      	bls.n	800cd74 <__divdi3+0x144>
 800cd64:	197f      	adds	r7, r7, r5
 800cd66:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
 800cd6a:	d202      	bcs.n	800cd72 <__divdi3+0x142>
 800cd6c:	45bc      	cmp	ip, r7
 800cd6e:	f200 80a7 	bhi.w	800cec0 <__divdi3+0x290>
 800cd72:	460b      	mov	r3, r1
 800cd74:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800cd78:	e7ad      	b.n	800ccd6 <__divdi3+0xa6>
 800cd7a:	4252      	negs	r2, r2
 800cd7c:	ea6f 0606 	mvn.w	r6, r6
 800cd80:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800cd84:	e75d      	b.n	800cc42 <__divdi3+0x12>
 800cd86:	4240      	negs	r0, r0
 800cd88:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800cd8c:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 800cd90:	e754      	b.n	800cc3c <__divdi3+0xc>
 800cd92:	f1c0 0220 	rsb	r2, r0, #32
 800cd96:	fa24 f102 	lsr.w	r1, r4, r2
 800cd9a:	fa07 f300 	lsl.w	r3, r7, r0
 800cd9e:	4085      	lsls	r5, r0
 800cda0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800cda4:	40d7      	lsrs	r7, r2
 800cda6:	4319      	orrs	r1, r3
 800cda8:	fbb7 f2fe 	udiv	r2, r7, lr
 800cdac:	0c0b      	lsrs	r3, r1, #16
 800cdae:	fb0e 7712 	mls	r7, lr, r2, r7
 800cdb2:	fa1f fc85 	uxth.w	ip, r5
 800cdb6:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 800cdba:	fb0c f702 	mul.w	r7, ip, r2
 800cdbe:	429f      	cmp	r7, r3
 800cdc0:	fa04 f400 	lsl.w	r4, r4, r0
 800cdc4:	d907      	bls.n	800cdd6 <__divdi3+0x1a6>
 800cdc6:	195b      	adds	r3, r3, r5
 800cdc8:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
 800cdcc:	d274      	bcs.n	800ceb8 <__divdi3+0x288>
 800cdce:	429f      	cmp	r7, r3
 800cdd0:	d972      	bls.n	800ceb8 <__divdi3+0x288>
 800cdd2:	3a02      	subs	r2, #2
 800cdd4:	442b      	add	r3, r5
 800cdd6:	1bdf      	subs	r7, r3, r7
 800cdd8:	b289      	uxth	r1, r1
 800cdda:	fbb7 f8fe 	udiv	r8, r7, lr
 800cdde:	fb0e 7318 	mls	r3, lr, r8, r7
 800cde2:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800cde6:	fb0c f708 	mul.w	r7, ip, r8
 800cdea:	429f      	cmp	r7, r3
 800cdec:	d908      	bls.n	800ce00 <__divdi3+0x1d0>
 800cdee:	195b      	adds	r3, r3, r5
 800cdf0:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
 800cdf4:	d25c      	bcs.n	800ceb0 <__divdi3+0x280>
 800cdf6:	429f      	cmp	r7, r3
 800cdf8:	d95a      	bls.n	800ceb0 <__divdi3+0x280>
 800cdfa:	f1a8 0802 	sub.w	r8, r8, #2
 800cdfe:	442b      	add	r3, r5
 800ce00:	1bd8      	subs	r0, r3, r7
 800ce02:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 800ce06:	e78e      	b.n	800cd26 <__divdi3+0xf6>
 800ce08:	f1c2 0320 	rsb	r3, r2, #32
 800ce0c:	fa2c f103 	lsr.w	r1, ip, r3
 800ce10:	fa0e fe02 	lsl.w	lr, lr, r2
 800ce14:	fa20 f703 	lsr.w	r7, r0, r3
 800ce18:	ea41 0e0e 	orr.w	lr, r1, lr
 800ce1c:	fa08 f002 	lsl.w	r0, r8, r2
 800ce20:	fa28 f103 	lsr.w	r1, r8, r3
 800ce24:	ea4f 451e 	mov.w	r5, lr, lsr #16
 800ce28:	4338      	orrs	r0, r7
 800ce2a:	fbb1 f8f5 	udiv	r8, r1, r5
 800ce2e:	0c03      	lsrs	r3, r0, #16
 800ce30:	fb05 1118 	mls	r1, r5, r8, r1
 800ce34:	fa1f f78e 	uxth.w	r7, lr
 800ce38:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800ce3c:	fb07 f308 	mul.w	r3, r7, r8
 800ce40:	428b      	cmp	r3, r1
 800ce42:	fa0c fc02 	lsl.w	ip, ip, r2
 800ce46:	d909      	bls.n	800ce5c <__divdi3+0x22c>
 800ce48:	eb11 010e 	adds.w	r1, r1, lr
 800ce4c:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
 800ce50:	d230      	bcs.n	800ceb4 <__divdi3+0x284>
 800ce52:	428b      	cmp	r3, r1
 800ce54:	d92e      	bls.n	800ceb4 <__divdi3+0x284>
 800ce56:	f1a8 0802 	sub.w	r8, r8, #2
 800ce5a:	4471      	add	r1, lr
 800ce5c:	1ac9      	subs	r1, r1, r3
 800ce5e:	b280      	uxth	r0, r0
 800ce60:	fbb1 f3f5 	udiv	r3, r1, r5
 800ce64:	fb05 1113 	mls	r1, r5, r3, r1
 800ce68:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800ce6c:	fb07 f703 	mul.w	r7, r7, r3
 800ce70:	428f      	cmp	r7, r1
 800ce72:	d908      	bls.n	800ce86 <__divdi3+0x256>
 800ce74:	eb11 010e 	adds.w	r1, r1, lr
 800ce78:	f103 30ff 	add.w	r0, r3, #4294967295	; 0xffffffff
 800ce7c:	d216      	bcs.n	800ceac <__divdi3+0x27c>
 800ce7e:	428f      	cmp	r7, r1
 800ce80:	d914      	bls.n	800ceac <__divdi3+0x27c>
 800ce82:	3b02      	subs	r3, #2
 800ce84:	4471      	add	r1, lr
 800ce86:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800ce8a:	1bc9      	subs	r1, r1, r7
 800ce8c:	fba3 890c 	umull	r8, r9, r3, ip
 800ce90:	4549      	cmp	r1, r9
 800ce92:	d309      	bcc.n	800cea8 <__divdi3+0x278>
 800ce94:	d005      	beq.n	800cea2 <__divdi3+0x272>
 800ce96:	2200      	movs	r2, #0
 800ce98:	e71d      	b.n	800ccd6 <__divdi3+0xa6>
 800ce9a:	4696      	mov	lr, r2
 800ce9c:	e6fe      	b.n	800cc9c <__divdi3+0x6c>
 800ce9e:	4613      	mov	r3, r2
 800cea0:	e711      	b.n	800ccc6 <__divdi3+0x96>
 800cea2:	4094      	lsls	r4, r2
 800cea4:	4544      	cmp	r4, r8
 800cea6:	d2f6      	bcs.n	800ce96 <__divdi3+0x266>
 800cea8:	3b01      	subs	r3, #1
 800ceaa:	e7f4      	b.n	800ce96 <__divdi3+0x266>
 800ceac:	4603      	mov	r3, r0
 800ceae:	e7ea      	b.n	800ce86 <__divdi3+0x256>
 800ceb0:	4688      	mov	r8, r1
 800ceb2:	e7a5      	b.n	800ce00 <__divdi3+0x1d0>
 800ceb4:	46c8      	mov	r8, r9
 800ceb6:	e7d1      	b.n	800ce5c <__divdi3+0x22c>
 800ceb8:	4602      	mov	r2, r0
 800ceba:	e78c      	b.n	800cdd6 <__divdi3+0x1a6>
 800cebc:	4613      	mov	r3, r2
 800cebe:	e70a      	b.n	800ccd6 <__divdi3+0xa6>
 800cec0:	3b02      	subs	r3, #2
 800cec2:	e757      	b.n	800cd74 <__divdi3+0x144>
 800cec4:	f1a8 0802 	sub.w	r8, r8, #2
 800cec8:	442f      	add	r7, r5
 800ceca:	e73f      	b.n	800cd4c <__divdi3+0x11c>
 800cecc:	0000      	movs	r0, r0
	...

0800ced0 <__udivdi3>:
 800ced0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ced4:	2b00      	cmp	r3, #0
 800ced6:	d144      	bne.n	800cf62 <__udivdi3+0x92>
 800ced8:	428a      	cmp	r2, r1
 800ceda:	4615      	mov	r5, r2
 800cedc:	4604      	mov	r4, r0
 800cede:	d94f      	bls.n	800cf80 <__udivdi3+0xb0>
 800cee0:	fab2 f782 	clz	r7, r2
 800cee4:	460e      	mov	r6, r1
 800cee6:	b14f      	cbz	r7, 800cefc <__udivdi3+0x2c>
 800cee8:	f1c7 0320 	rsb	r3, r7, #32
 800ceec:	40b9      	lsls	r1, r7
 800ceee:	fa20 f603 	lsr.w	r6, r0, r3
 800cef2:	fa02 f507 	lsl.w	r5, r2, r7
 800cef6:	430e      	orrs	r6, r1
 800cef8:	fa00 f407 	lsl.w	r4, r0, r7
 800cefc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800cf00:	0c23      	lsrs	r3, r4, #16
 800cf02:	fbb6 f0fe 	udiv	r0, r6, lr
 800cf06:	b2af      	uxth	r7, r5
 800cf08:	fb0e 6110 	mls	r1, lr, r0, r6
 800cf0c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800cf10:	fb07 f100 	mul.w	r1, r7, r0
 800cf14:	4299      	cmp	r1, r3
 800cf16:	d909      	bls.n	800cf2c <__udivdi3+0x5c>
 800cf18:	195b      	adds	r3, r3, r5
 800cf1a:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 800cf1e:	f080 80ec 	bcs.w	800d0fa <__udivdi3+0x22a>
 800cf22:	4299      	cmp	r1, r3
 800cf24:	f240 80e9 	bls.w	800d0fa <__udivdi3+0x22a>
 800cf28:	3802      	subs	r0, #2
 800cf2a:	442b      	add	r3, r5
 800cf2c:	1a5a      	subs	r2, r3, r1
 800cf2e:	b2a4      	uxth	r4, r4
 800cf30:	fbb2 f3fe 	udiv	r3, r2, lr
 800cf34:	fb0e 2213 	mls	r2, lr, r3, r2
 800cf38:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 800cf3c:	fb07 f703 	mul.w	r7, r7, r3
 800cf40:	4297      	cmp	r7, r2
 800cf42:	d908      	bls.n	800cf56 <__udivdi3+0x86>
 800cf44:	1952      	adds	r2, r2, r5
 800cf46:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
 800cf4a:	f080 80d8 	bcs.w	800d0fe <__udivdi3+0x22e>
 800cf4e:	4297      	cmp	r7, r2
 800cf50:	f240 80d5 	bls.w	800d0fe <__udivdi3+0x22e>
 800cf54:	3b02      	subs	r3, #2
 800cf56:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 800cf5a:	2600      	movs	r6, #0
 800cf5c:	4631      	mov	r1, r6
 800cf5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cf62:	428b      	cmp	r3, r1
 800cf64:	d847      	bhi.n	800cff6 <__udivdi3+0x126>
 800cf66:	fab3 f683 	clz	r6, r3
 800cf6a:	2e00      	cmp	r6, #0
 800cf6c:	d148      	bne.n	800d000 <__udivdi3+0x130>
 800cf6e:	428b      	cmp	r3, r1
 800cf70:	d302      	bcc.n	800cf78 <__udivdi3+0xa8>
 800cf72:	4282      	cmp	r2, r0
 800cf74:	f200 80cd 	bhi.w	800d112 <__udivdi3+0x242>
 800cf78:	2001      	movs	r0, #1
 800cf7a:	4631      	mov	r1, r6
 800cf7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cf80:	b912      	cbnz	r2, 800cf88 <__udivdi3+0xb8>
 800cf82:	2501      	movs	r5, #1
 800cf84:	fbb5 f5f2 	udiv	r5, r5, r2
 800cf88:	fab5 f885 	clz	r8, r5
 800cf8c:	f1b8 0f00 	cmp.w	r8, #0
 800cf90:	d177      	bne.n	800d082 <__udivdi3+0x1b2>
 800cf92:	1b4a      	subs	r2, r1, r5
 800cf94:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800cf98:	b2af      	uxth	r7, r5
 800cf9a:	2601      	movs	r6, #1
 800cf9c:	fbb2 f0fe 	udiv	r0, r2, lr
 800cfa0:	0c23      	lsrs	r3, r4, #16
 800cfa2:	fb0e 2110 	mls	r1, lr, r0, r2
 800cfa6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800cfaa:	fb07 f300 	mul.w	r3, r7, r0
 800cfae:	428b      	cmp	r3, r1
 800cfb0:	d907      	bls.n	800cfc2 <__udivdi3+0xf2>
 800cfb2:	1949      	adds	r1, r1, r5
 800cfb4:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 800cfb8:	d202      	bcs.n	800cfc0 <__udivdi3+0xf0>
 800cfba:	428b      	cmp	r3, r1
 800cfbc:	f200 80ba 	bhi.w	800d134 <__udivdi3+0x264>
 800cfc0:	4610      	mov	r0, r2
 800cfc2:	1ac9      	subs	r1, r1, r3
 800cfc4:	b2a4      	uxth	r4, r4
 800cfc6:	fbb1 f3fe 	udiv	r3, r1, lr
 800cfca:	fb0e 1113 	mls	r1, lr, r3, r1
 800cfce:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 800cfd2:	fb07 f703 	mul.w	r7, r7, r3
 800cfd6:	42a7      	cmp	r7, r4
 800cfd8:	d908      	bls.n	800cfec <__udivdi3+0x11c>
 800cfda:	1964      	adds	r4, r4, r5
 800cfdc:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800cfe0:	f080 808f 	bcs.w	800d102 <__udivdi3+0x232>
 800cfe4:	42a7      	cmp	r7, r4
 800cfe6:	f240 808c 	bls.w	800d102 <__udivdi3+0x232>
 800cfea:	3b02      	subs	r3, #2
 800cfec:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 800cff0:	4631      	mov	r1, r6
 800cff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cff6:	2600      	movs	r6, #0
 800cff8:	4630      	mov	r0, r6
 800cffa:	4631      	mov	r1, r6
 800cffc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d000:	f1c6 0420 	rsb	r4, r6, #32
 800d004:	fa22 f504 	lsr.w	r5, r2, r4
 800d008:	40b3      	lsls	r3, r6
 800d00a:	432b      	orrs	r3, r5
 800d00c:	fa20 fc04 	lsr.w	ip, r0, r4
 800d010:	fa01 f706 	lsl.w	r7, r1, r6
 800d014:	fa21 f504 	lsr.w	r5, r1, r4
 800d018:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 800d01c:	ea4c 0707 	orr.w	r7, ip, r7
 800d020:	fbb5 f8fe 	udiv	r8, r5, lr
 800d024:	0c39      	lsrs	r1, r7, #16
 800d026:	fb0e 5518 	mls	r5, lr, r8, r5
 800d02a:	fa1f fc83 	uxth.w	ip, r3
 800d02e:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 800d032:	fb0c f108 	mul.w	r1, ip, r8
 800d036:	42a9      	cmp	r1, r5
 800d038:	fa02 f206 	lsl.w	r2, r2, r6
 800d03c:	d904      	bls.n	800d048 <__udivdi3+0x178>
 800d03e:	18ed      	adds	r5, r5, r3
 800d040:	f108 34ff 	add.w	r4, r8, #4294967295	; 0xffffffff
 800d044:	d367      	bcc.n	800d116 <__udivdi3+0x246>
 800d046:	46a0      	mov	r8, r4
 800d048:	1a6d      	subs	r5, r5, r1
 800d04a:	b2bf      	uxth	r7, r7
 800d04c:	fbb5 f4fe 	udiv	r4, r5, lr
 800d050:	fb0e 5514 	mls	r5, lr, r4, r5
 800d054:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 800d058:	fb0c fc04 	mul.w	ip, ip, r4
 800d05c:	458c      	cmp	ip, r1
 800d05e:	d904      	bls.n	800d06a <__udivdi3+0x19a>
 800d060:	18c9      	adds	r1, r1, r3
 800d062:	f104 35ff 	add.w	r5, r4, #4294967295	; 0xffffffff
 800d066:	d35c      	bcc.n	800d122 <__udivdi3+0x252>
 800d068:	462c      	mov	r4, r5
 800d06a:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 800d06e:	ebcc 0101 	rsb	r1, ip, r1
 800d072:	fba4 2302 	umull	r2, r3, r4, r2
 800d076:	4299      	cmp	r1, r3
 800d078:	d348      	bcc.n	800d10c <__udivdi3+0x23c>
 800d07a:	d044      	beq.n	800d106 <__udivdi3+0x236>
 800d07c:	4620      	mov	r0, r4
 800d07e:	2600      	movs	r6, #0
 800d080:	e76c      	b.n	800cf5c <__udivdi3+0x8c>
 800d082:	f1c8 0420 	rsb	r4, r8, #32
 800d086:	fa01 f308 	lsl.w	r3, r1, r8
 800d08a:	fa05 f508 	lsl.w	r5, r5, r8
 800d08e:	fa20 f704 	lsr.w	r7, r0, r4
 800d092:	40e1      	lsrs	r1, r4
 800d094:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800d098:	431f      	orrs	r7, r3
 800d09a:	fbb1 f6fe 	udiv	r6, r1, lr
 800d09e:	0c3a      	lsrs	r2, r7, #16
 800d0a0:	fb0e 1116 	mls	r1, lr, r6, r1
 800d0a4:	fa1f fc85 	uxth.w	ip, r5
 800d0a8:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 800d0ac:	fb0c f206 	mul.w	r2, ip, r6
 800d0b0:	429a      	cmp	r2, r3
 800d0b2:	fa00 f408 	lsl.w	r4, r0, r8
 800d0b6:	d907      	bls.n	800d0c8 <__udivdi3+0x1f8>
 800d0b8:	195b      	adds	r3, r3, r5
 800d0ba:	f106 31ff 	add.w	r1, r6, #4294967295	; 0xffffffff
 800d0be:	d237      	bcs.n	800d130 <__udivdi3+0x260>
 800d0c0:	429a      	cmp	r2, r3
 800d0c2:	d935      	bls.n	800d130 <__udivdi3+0x260>
 800d0c4:	3e02      	subs	r6, #2
 800d0c6:	442b      	add	r3, r5
 800d0c8:	1a9b      	subs	r3, r3, r2
 800d0ca:	b2bf      	uxth	r7, r7
 800d0cc:	fbb3 f0fe 	udiv	r0, r3, lr
 800d0d0:	fb0e 3310 	mls	r3, lr, r0, r3
 800d0d4:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 800d0d8:	fb0c f100 	mul.w	r1, ip, r0
 800d0dc:	4299      	cmp	r1, r3
 800d0de:	d907      	bls.n	800d0f0 <__udivdi3+0x220>
 800d0e0:	195b      	adds	r3, r3, r5
 800d0e2:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 800d0e6:	d221      	bcs.n	800d12c <__udivdi3+0x25c>
 800d0e8:	4299      	cmp	r1, r3
 800d0ea:	d91f      	bls.n	800d12c <__udivdi3+0x25c>
 800d0ec:	3802      	subs	r0, #2
 800d0ee:	442b      	add	r3, r5
 800d0f0:	1a5a      	subs	r2, r3, r1
 800d0f2:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 800d0f6:	4667      	mov	r7, ip
 800d0f8:	e750      	b.n	800cf9c <__udivdi3+0xcc>
 800d0fa:	4610      	mov	r0, r2
 800d0fc:	e716      	b.n	800cf2c <__udivdi3+0x5c>
 800d0fe:	460b      	mov	r3, r1
 800d100:	e729      	b.n	800cf56 <__udivdi3+0x86>
 800d102:	4613      	mov	r3, r2
 800d104:	e772      	b.n	800cfec <__udivdi3+0x11c>
 800d106:	40b0      	lsls	r0, r6
 800d108:	4290      	cmp	r0, r2
 800d10a:	d2b7      	bcs.n	800d07c <__udivdi3+0x1ac>
 800d10c:	1e60      	subs	r0, r4, #1
 800d10e:	2600      	movs	r6, #0
 800d110:	e724      	b.n	800cf5c <__udivdi3+0x8c>
 800d112:	4630      	mov	r0, r6
 800d114:	e722      	b.n	800cf5c <__udivdi3+0x8c>
 800d116:	42a9      	cmp	r1, r5
 800d118:	d995      	bls.n	800d046 <__udivdi3+0x176>
 800d11a:	f1a8 0802 	sub.w	r8, r8, #2
 800d11e:	441d      	add	r5, r3
 800d120:	e792      	b.n	800d048 <__udivdi3+0x178>
 800d122:	458c      	cmp	ip, r1
 800d124:	d9a0      	bls.n	800d068 <__udivdi3+0x198>
 800d126:	3c02      	subs	r4, #2
 800d128:	4419      	add	r1, r3
 800d12a:	e79e      	b.n	800d06a <__udivdi3+0x19a>
 800d12c:	4610      	mov	r0, r2
 800d12e:	e7df      	b.n	800d0f0 <__udivdi3+0x220>
 800d130:	460e      	mov	r6, r1
 800d132:	e7c9      	b.n	800d0c8 <__udivdi3+0x1f8>
 800d134:	3802      	subs	r0, #2
 800d136:	4429      	add	r1, r5
 800d138:	e743      	b.n	800cfc2 <__udivdi3+0xf2>
 800d13a:	bf00      	nop
 800d13c:	0000      	movs	r0, r0
	...

0800d140 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 800d140:	4770      	bx	lr
 800d142:	bf00      	nop
	...

0800d150 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 800d150:	4770      	bx	lr
 800d152:	bf00      	nop
	...

0800d160 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 800d160:	e7fe      	b.n	800d160 <__default_exit>
 800d162:	bf00      	nop
	...

0800d170 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 800d170:	e7fe      	b.n	800d170 <_unhandled_exception>
 800d172:	bf00      	nop
	...

0800d180 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 800d180:	e7fe      	b.n	800d180 <_idle_thread>
 800d182:	bf00      	nop
	...

0800d190 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 800d190:	4b1d      	ldr	r3, [pc, #116]	; (800d208 <chSysInit+0x78>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 800d192:	4a1e      	ldr	r2, [pc, #120]	; (800d20c <chSysInit+0x7c>)
  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800d194:	481e      	ldr	r0, [pc, #120]	; (800d210 <chSysInit+0x80>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 800d196:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 800d198:	2400      	movs	r4, #0
 800d19a:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800d19c:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800d19e:	4e1d      	ldr	r6, [pc, #116]	; (800d214 <chSysInit+0x84>)
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800d1a0:	4d1d      	ldr	r5, [pc, #116]	; (800d218 <chSysInit+0x88>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 800d1a2:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 800d1a6:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                 |
 800d1a8:	430a      	orrs	r2, r1
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800d1aa:	60da      	str	r2, [r3, #12]
 800d1ac:	68f2      	ldr	r2, [r6, #12]
 800d1ae:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800d1b2:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800d1b4:	6802      	ldr	r2, [r0, #0]
 800d1b6:	f042 0201 	orr.w	r2, r2, #1
 800d1ba:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 800d1bc:	b083      	sub	sp, #12
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800d1be:	f883 4022 	strb.w	r4, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 800d1c2:	f000 f8ed 	bl	800d3a0 <_scheduler_init>
  _vt_init();
 800d1c6:	f000 f873 	bl	800d2b0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 800d1ca:	f000 fb59 	bl	800d880 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 800d1ce:	f000 fd5f 	bl	800dc90 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 800d1d2:	f000 fd8d 	bl	800dcf0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800d1d6:	4628      	mov	r0, r5
 800d1d8:	2140      	movs	r1, #64	; 0x40
 800d1da:	f000 f9f1 	bl	800d5c0 <_thread_init>
 800d1de:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800d1e2:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800d1e4:	6198      	str	r0, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800d1e6:	7702      	strb	r2, [r0, #28]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d1e8:	b662      	cpsie	i
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 800d1ea:	699b      	ldr	r3, [r3, #24]
 800d1ec:	490b      	ldr	r1, [pc, #44]	; (800d21c <chSysInit+0x8c>)
 800d1ee:	6199      	str	r1, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 800d1f0:	f105 0050 	add.w	r0, r5, #80	; 0x50
 800d1f4:	9400      	str	r4, [sp, #0]
 800d1f6:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
 800d1fa:	4b09      	ldr	r3, [pc, #36]	; (800d220 <chSysInit+0x90>)
 800d1fc:	f000 fa40 	bl	800d680 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 800d200:	4b08      	ldr	r3, [pc, #32]	; (800d224 <chSysInit+0x94>)
 800d202:	6183      	str	r3, [r0, #24]
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
  }
#endif
}
 800d204:	b003      	add	sp, #12
 800d206:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d208:	e000ed00 	.word	0xe000ed00
 800d20c:	05fa0300 	.word	0x05fa0300
 800d210:	e0001000 	.word	0xe0001000
 800d214:	e000edf0 	.word	0xe000edf0
 800d218:	200010e8 	.word	0x200010e8
 800d21c:	08016640 	.word	0x08016640
 800d220:	0800d181 	.word	0x0800d181
 800d224:	08016630 	.word	0x08016630
	...

0800d230 <chSysHalt>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d230:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800d232:	4b01      	ldr	r3, [pc, #4]	; (800d238 <chSysHalt+0x8>)
 800d234:	62d8      	str	r0, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
 800d236:	e7fe      	b.n	800d236 <chSysHalt+0x6>
 800d238:	200010b8 	.word	0x200010b8
 800d23c:	00000000 	.word	0x00000000

0800d240 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 800d240:	b570      	push	{r4, r5, r6, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
 800d242:	4c11      	ldr	r4, [pc, #68]	; (800d288 <chSysTimerHandlerI+0x48>)
 800d244:	69a2      	ldr	r2, [r4, #24]
 800d246:	7fd3      	ldrb	r3, [r2, #31]
 800d248:	b10b      	cbz	r3, 800d24e <chSysTimerHandlerI+0xe>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800d24a:	3b01      	subs	r3, #1
 800d24c:	77d3      	strb	r3, [r2, #31]
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
 800d24e:	6a11      	ldr	r1, [r2, #32]

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800d250:	69e3      	ldr	r3, [r4, #28]
 800d252:	4e0e      	ldr	r6, [pc, #56]	; (800d28c <chSysTimerHandlerI+0x4c>)
 800d254:	3101      	adds	r1, #1
 800d256:	6211      	str	r1, [r2, #32]
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 800d258:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800d25a:	42b3      	cmp	r3, r6
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 800d25c:	f102 0201 	add.w	r2, r2, #1
 800d260:	62a2      	str	r2, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800d262:	d010      	beq.n	800d286 <chSysTimerHandlerI+0x46>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 800d264:	689d      	ldr	r5, [r3, #8]
 800d266:	3d01      	subs	r5, #1
 800d268:	609d      	str	r5, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 800d26a:	b965      	cbnz	r5, 800d286 <chSysTimerHandlerI+0x46>
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
      vtp->vt_func = NULL;
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800d26c:	681a      	ldr	r2, [r3, #0]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
 800d26e:	68d9      	ldr	r1, [r3, #12]
      vtp->vt_func = NULL;
 800d270:	60dd      	str	r5, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800d272:	6056      	str	r6, [r2, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800d274:	61e2      	str	r2, [r4, #28]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d276:	b662      	cpsie	i
      chSysUnlockFromISR();
      fn(vtp->vt_par);
 800d278:	6918      	ldr	r0, [r3, #16]
 800d27a:	4788      	blx	r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d27c:	b672      	cpsid	i
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 800d27e:	69e3      	ldr	r3, [r4, #28]
 800d280:	689a      	ldr	r2, [r3, #8]
 800d282:	2a00      	cmp	r2, #0
 800d284:	d0f2      	beq.n	800d26c <chSysTimerHandlerI+0x2c>
 800d286:	bd70      	pop	{r4, r5, r6, pc}
 800d288:	200010b8 	.word	0x200010b8
 800d28c:	200010d4 	.word	0x200010d4

0800d290 <chSysPolledDelayX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800d290:	4a03      	ldr	r2, [pc, #12]	; (800d2a0 <chSysPolledDelayX+0x10>)
 800d292:	6851      	ldr	r1, [r2, #4]
 800d294:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 800d296:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 800d298:	4298      	cmp	r0, r3
 800d29a:	d8fb      	bhi.n	800d294 <chSysPolledDelayX+0x4>
  }
}
 800d29c:	4770      	bx	lr
 800d29e:	bf00      	nop
 800d2a0:	e0001000 	.word	0xe0001000
	...

0800d2b0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800d2b0:	4b05      	ldr	r3, [pc, #20]	; (800d2c8 <_vt_init+0x18>)
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800d2b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800d2b6:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 800d2ba:	2100      	movs	r1, #0
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800d2bc:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 800d2be:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800d2c0:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 800d2c2:	621a      	str	r2, [r3, #32]
 800d2c4:	4770      	bx	lr
 800d2c6:	bf00      	nop
 800d2c8:	200010b8 	.word	0x200010b8
 800d2cc:	00000000 	.word	0x00000000

0800d2d0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800d2d0:	b470      	push	{r4, r5, r6}
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 800d2d2:	4e0d      	ldr	r6, [pc, #52]	; (800d308 <chVTDoSetI+0x38>)
 800d2d4:	69f4      	ldr	r4, [r6, #28]
  while (p->vt_delta < delta) {
 800d2d6:	68a5      	ldr	r5, [r4, #8]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800d2d8:	6103      	str	r3, [r0, #16]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800d2da:	42a9      	cmp	r1, r5

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800d2dc:	60c2      	str	r2, [r0, #12]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800d2de:	d904      	bls.n	800d2ea <chVTDoSetI+0x1a>
    delta -= p->vt_delta;
    p = p->vt_next;
 800d2e0:	6824      	ldr	r4, [r4, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800d2e2:	1b49      	subs	r1, r1, r5
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800d2e4:	68a5      	ldr	r5, [r4, #8]
 800d2e6:	428d      	cmp	r5, r1
 800d2e8:	d3fa      	bcc.n	800d2e0 <chVTDoSetI+0x10>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800d2ea:	6863      	ldr	r3, [r4, #4]
 800d2ec:	6043      	str	r3, [r0, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 800d2ee:	6004      	str	r4, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 800d2f0:	6018      	str	r0, [r3, #0]
  p->vt_prev = vtp;
 800d2f2:	6060      	str	r0, [r4, #4]
  vtp->vt_delta = delta
 800d2f4:	6081      	str	r1, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800d2f6:	68a3      	ldr	r3, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800d2f8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800d2fc:	1a59      	subs	r1, r3, r1
 800d2fe:	60a1      	str	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800d300:	6272      	str	r2, [r6, #36]	; 0x24
}
 800d302:	bc70      	pop	{r4, r5, r6}
 800d304:	4770      	bx	lr
 800d306:	bf00      	nop
 800d308:	200010b8 	.word	0x200010b8
 800d30c:	00000000 	.word	0x00000000

0800d310 <chVTDoResetI>:
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 800d310:	6803      	ldr	r3, [r0, #0]
 800d312:	6882      	ldr	r2, [r0, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 800d314:	6841      	ldr	r1, [r0, #4]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800d316:	b430      	push	{r4, r5}
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 800d318:	689d      	ldr	r5, [r3, #8]
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 800d31a:	4c06      	ldr	r4, [pc, #24]	; (800d334 <chVTDoResetI+0x24>)
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 800d31c:	442a      	add	r2, r5
 800d31e:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 800d320:	600b      	str	r3, [r1, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800d322:	6805      	ldr	r5, [r0, #0]
  vtp->vt_func = NULL;
 800d324:	2200      	movs	r2, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 800d326:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800d32a:	6069      	str	r1, [r5, #4]
  vtp->vt_func = NULL;
 800d32c:	60c2      	str	r2, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 800d32e:	6263      	str	r3, [r4, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800d330:	bc30      	pop	{r4, r5}
 800d332:	4770      	bx	lr
 800d334:	200010b8 	.word	0x200010b8
	...

0800d340 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800d340:	b410      	push	{r4}
 800d342:	b672      	cpsid	i
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 800d344:	7f03      	ldrb	r3, [r0, #28]
 800d346:	2b07      	cmp	r3, #7
 800d348:	d80e      	bhi.n	800d368 <wakeup+0x28>
 800d34a:	e8df f003 	tbb	[pc, r3]
 800d34e:	0d1d      	.short	0x0d1d
 800d350:	0408210d 	.word	0x0408210d
 800d354:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800d356:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800d358:	6893      	ldr	r3, [r2, #8]
 800d35a:	3301      	adds	r3, #1
 800d35c:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800d35e:	e890 000c 	ldmia.w	r0, {r2, r3}
 800d362:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800d364:	6802      	ldr	r2, [r0, #0]
 800d366:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800d368:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d36c:	2200      	movs	r2, #0
 800d36e:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 800d370:	4b09      	ldr	r3, [pc, #36]	; (800d398 <wakeup+0x58>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800d372:	6244      	str	r4, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d374:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800d376:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800d378:	689a      	ldr	r2, [r3, #8]
 800d37a:	428a      	cmp	r2, r1
 800d37c:	d2fb      	bcs.n	800d376 <wakeup+0x36>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800d37e:	685a      	ldr	r2, [r3, #4]
 800d380:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800d382:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800d384:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800d386:	6058      	str	r0, [r3, #4]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d388:	b662      	cpsie	i
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 800d38a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d38e:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 800d390:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800d392:	2200      	movs	r2, #0
 800d394:	601a      	str	r2, [r3, #0]
    break;
 800d396:	e7e7      	b.n	800d368 <wakeup+0x28>
 800d398:	200010b8 	.word	0x200010b8
 800d39c:	00000000 	.word	0x00000000

0800d3a0 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800d3a0:	4b03      	ldr	r3, [pc, #12]	; (800d3b0 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800d3a2:	2200      	movs	r2, #0
 800d3a4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800d3a6:	605b      	str	r3, [r3, #4]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 800d3a8:	611b      	str	r3, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 800d3aa:	615b      	str	r3, [r3, #20]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800d3ac:	609a      	str	r2, [r3, #8]
 800d3ae:	4770      	bx	lr
 800d3b0:	200010b8 	.word	0x200010b8
	...

0800d3c0 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d3c0:	2200      	movs	r2, #0
 800d3c2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 800d3c4:	4b08      	ldr	r3, [pc, #32]	; (800d3e8 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800d3c6:	b410      	push	{r4}
 800d3c8:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d3ca:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800d3cc:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800d3ce:	689a      	ldr	r2, [r3, #8]
 800d3d0:	428a      	cmp	r2, r1
 800d3d2:	d2fb      	bcs.n	800d3cc <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800d3d4:	685a      	ldr	r2, [r3, #4]
 800d3d6:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800d3d8:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 800d3da:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800d3dc:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800d3de:	605c      	str	r4, [r3, #4]

  return tp;
}
 800d3e0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d3e4:	4770      	bx	lr
 800d3e6:	bf00      	nop
 800d3e8:	200010b8 	.word	0x200010b8
 800d3ec:	00000000 	.word	0x00000000

0800d3f0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 800d3f0:	4b08      	ldr	r3, [pc, #32]	; (800d414 <chSchGoSleepS+0x24>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800d3f2:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800d3f4:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 800d3f6:	6999      	ldr	r1, [r3, #24]

  tqp->p_next = tp->p_next;
 800d3f8:	6814      	ldr	r4, [r2, #0]
  otp->p_state = newstate;
 800d3fa:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800d3fc:	2501      	movs	r5, #1
  otp = currp;
  otp->p_state = newstate;
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d3fe:	2004      	movs	r0, #4
 800d400:	77c8      	strb	r0, [r1, #31]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800d402:	6063      	str	r3, [r4, #4]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800d404:	7715      	strb	r5, [r2, #28]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800d406:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 800d408:	4610      	mov	r0, r2
}
 800d40a:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800d40c:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800d40e:	f7fe be7f 	b.w	800c110 <_port_switch>
 800d412:	bf00      	nop
 800d414:	200010b8 	.word	0x200010b8
	...

0800d420 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800d420:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800d422:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800d424:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800d426:	d012      	beq.n	800d44e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800d428:	4c0c      	ldr	r4, [pc, #48]	; (800d45c <chSchGoSleepTimeoutS+0x3c>)
 800d42a:	4a0d      	ldr	r2, [pc, #52]	; (800d460 <chSchGoSleepTimeoutS+0x40>)
 800d42c:	69a3      	ldr	r3, [r4, #24]
 800d42e:	4605      	mov	r5, r0
 800d430:	a801      	add	r0, sp, #4
 800d432:	f7ff ff4d 	bl	800d2d0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800d436:	4628      	mov	r0, r5
 800d438:	f7ff ffda 	bl	800d3f0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800d43c:	9b04      	ldr	r3, [sp, #16]
 800d43e:	b113      	cbz	r3, 800d446 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 800d440:	a801      	add	r0, sp, #4
 800d442:	f7ff ff65 	bl	800d310 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 800d446:	69a3      	ldr	r3, [r4, #24]
}
 800d448:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800d44a:	b007      	add	sp, #28
 800d44c:	bd30      	pop	{r4, r5, pc}
 800d44e:	4c03      	ldr	r4, [pc, #12]	; (800d45c <chSchGoSleepTimeoutS+0x3c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800d450:	f7ff ffce 	bl	800d3f0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 800d454:	69a3      	ldr	r3, [r4, #24]
}
 800d456:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800d458:	b007      	add	sp, #28
 800d45a:	bd30      	pop	{r4, r5, pc}
 800d45c:	200010b8 	.word	0x200010b8
 800d460:	0800d341 	.word	0x0800d341
	...

0800d470 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800d470:	4b14      	ldr	r3, [pc, #80]	; (800d4c4 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800d472:	b470      	push	{r4, r5, r6}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800d474:	699e      	ldr	r6, [r3, #24]
 800d476:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800d478:	4605      	mov	r5, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800d47a:	68b0      	ldr	r0, [r6, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 800d47c:	6269      	str	r1, [r5, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800d47e:	4284      	cmp	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d480:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800d484:	d80b      	bhi.n	800d49e <chSchWakeupS+0x2e>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d486:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800d488:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800d48a:	689a      	ldr	r2, [r3, #8]
 800d48c:	4294      	cmp	r4, r2
 800d48e:	d9fb      	bls.n	800d488 <chSchWakeupS+0x18>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800d490:	685a      	ldr	r2, [r3, #4]
 800d492:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800d494:	602b      	str	r3, [r5, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800d496:	6015      	str	r5, [r2, #0]
  cp->p_prev = tp;
 800d498:	605d      	str	r5, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800d49a:	bc70      	pop	{r4, r5, r6}
 800d49c:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d49e:	7732      	strb	r2, [r6, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 800d4a0:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
 800d4a2:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 800d4a4:	6891      	ldr	r1, [r2, #8]
 800d4a6:	4288      	cmp	r0, r1
 800d4a8:	d9fb      	bls.n	800d4a2 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800d4aa:	6850      	ldr	r0, [r2, #4]
 800d4ac:	6070      	str	r0, [r6, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800d4ae:	2401      	movs	r4, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800d4b0:	6032      	str	r2, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800d4b2:	6006      	str	r6, [r0, #0]
  cp->p_prev = tp;
 800d4b4:	6056      	str	r6, [r2, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800d4b6:	772c      	strb	r4, [r5, #28]
    chSysSwitch(ntp, otp);
 800d4b8:	4631      	mov	r1, r6
 800d4ba:	4628      	mov	r0, r5
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 800d4bc:	619d      	str	r5, [r3, #24]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800d4be:	bc70      	pop	{r4, r5, r6}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 800d4c0:	f7fe be26 	b.w	800c110 <_port_switch>
 800d4c4:	200010b8 	.word	0x200010b8
	...

0800d4d0 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800d4d0:	4b08      	ldr	r3, [pc, #32]	; (800d4f4 <chSchIsPreemptionRequired+0x24>)
  tprio_t p2 = currp->p_prio;
 800d4d2:	699a      	ldr	r2, [r3, #24]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800d4d4:	681b      	ldr	r3, [r3, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 800d4d6:	7fd1      	ldrb	r1, [r2, #31]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800d4d8:	689b      	ldr	r3, [r3, #8]
  tprio_t p2 = currp->p_prio;
 800d4da:	6890      	ldr	r0, [r2, #8]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 800d4dc:	b921      	cbnz	r1, 800d4e8 <chSchIsPreemptionRequired+0x18>
 800d4de:	4283      	cmp	r3, r0
 800d4e0:	bf34      	ite	cc
 800d4e2:	2000      	movcc	r0, #0
 800d4e4:	2001      	movcs	r0, #1
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 800d4e6:	4770      	bx	lr
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 800d4e8:	4283      	cmp	r3, r0
 800d4ea:	bf94      	ite	ls
 800d4ec:	2000      	movls	r0, #0
 800d4ee:	2001      	movhi	r0, #1
 800d4f0:	4770      	bx	lr
 800d4f2:	bf00      	nop
 800d4f4:	200010b8 	.word	0x200010b8
	...

0800d500 <chSchDoRescheduleBehind>:
 * @special
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
 800d500:	4a0e      	ldr	r2, [pc, #56]	; (800d53c <chSchDoRescheduleBehind+0x3c>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800d502:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 800d504:	b4f0      	push	{r4, r5, r6, r7}

  tqp->p_next = tp->p_next;
 800d506:	6803      	ldr	r3, [r0, #0]
  thread_t *otp;

  otp = currp;
 800d508:	6994      	ldr	r4, [r2, #24]
 800d50a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800d50c:	2701      	movs	r7, #1
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d50e:	2604      	movs	r6, #4
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d510:	2500      	movs	r5, #0
 800d512:	68a1      	ldr	r1, [r4, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800d514:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800d516:	7707      	strb	r7, [r0, #28]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800d518:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d51a:	77e6      	strb	r6, [r4, #31]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800d51c:	7725      	strb	r5, [r4, #28]
 800d51e:	e000      	b.n	800d522 <chSchDoRescheduleBehind+0x22>
 800d520:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 800d522:	689a      	ldr	r2, [r3, #8]
 800d524:	428a      	cmp	r2, r1
 800d526:	d2fb      	bcs.n	800d520 <chSchDoRescheduleBehind+0x20>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800d528:	685a      	ldr	r2, [r3, #4]
 800d52a:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800d52c:	6023      	str	r3, [r4, #0]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 800d52e:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800d530:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800d532:	605c      	str	r4, [r3, #4]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
}
 800d534:	bcf0      	pop	{r4, r5, r6, r7}
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 800d536:	f7fe bdeb 	b.w	800c110 <_port_switch>
 800d53a:	bf00      	nop
 800d53c:	200010b8 	.word	0x200010b8

0800d540 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 800d540:	4a0d      	ldr	r2, [pc, #52]	; (800d578 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800d542:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800d544:	b470      	push	{r4, r5, r6}

  tqp->p_next = tp->p_next;
 800d546:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 800d548:	6994      	ldr	r4, [r2, #24]
 800d54a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800d54c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 800d54e:	2500      	movs	r5, #0
 800d550:	68a1      	ldr	r1, [r4, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800d552:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800d554:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800d556:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 800d558:	7725      	strb	r5, [r4, #28]
 800d55a:	e000      	b.n	800d55e <chSchDoRescheduleAhead+0x1e>
 800d55c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800d55e:	689a      	ldr	r2, [r3, #8]
 800d560:	428a      	cmp	r2, r1
 800d562:	d8fb      	bhi.n	800d55c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 800d564:	685a      	ldr	r2, [r3, #4]
 800d566:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800d568:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800d56a:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 800d56c:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 800d56e:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
}
 800d570:	bc70      	pop	{r4, r5, r6}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800d572:	f7fe bdcd 	b.w	800c110 <_port_switch>
 800d576:	bf00      	nop
 800d578:	200010b8 	.word	0x200010b8
 800d57c:	00000000 	.word	0x00000000

0800d580 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 800d580:	4b04      	ldr	r3, [pc, #16]	; (800d594 <chSchRescheduleS+0x14>)
 800d582:	681a      	ldr	r2, [r3, #0]
 800d584:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 800d586:	6892      	ldr	r2, [r2, #8]
 800d588:	689b      	ldr	r3, [r3, #8]
 800d58a:	429a      	cmp	r2, r3
 800d58c:	d800      	bhi.n	800d590 <chSchRescheduleS+0x10>
 800d58e:	4770      	bx	lr
    chSchDoRescheduleAhead();
 800d590:	f7ff bfd6 	b.w	800d540 <chSchDoRescheduleAhead>
 800d594:	200010b8 	.word	0x200010b8
	...

0800d5a0 <chSchDoReschedule>:
void chSchDoReschedule(void) {

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
 800d5a0:	4b03      	ldr	r3, [pc, #12]	; (800d5b0 <chSchDoReschedule+0x10>)
 800d5a2:	699b      	ldr	r3, [r3, #24]
 800d5a4:	7fdb      	ldrb	r3, [r3, #31]
 800d5a6:	b10b      	cbz	r3, 800d5ac <chSchDoReschedule+0xc>
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 800d5a8:	f7ff bfca 	b.w	800d540 <chSchDoRescheduleAhead>
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 800d5ac:	f7ff bfa8 	b.w	800d500 <chSchDoRescheduleBehind>
 800d5b0:	200010b8 	.word	0x200010b8
	...

0800d5c0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 800d5c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d5c4:	4c11      	ldr	r4, [pc, #68]	; (800d60c <_thread_init+0x4c>)
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800d5c6:	6401      	str	r1, [r0, #64]	; 0x40
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d5c8:	6966      	ldr	r6, [r4, #20]
 800d5ca:	6146      	str	r6, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800d5cc:	2200      	movs	r2, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800d5ce:	f100 052c 	add.w	r5, r0, #44	; 0x2c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800d5d2:	f04f 0802 	mov.w	r8, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d5d6:	f04f 0c04 	mov.w	ip, #4
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800d5da:	f04f 0e01 	mov.w	lr, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800d5de:	f100 0728 	add.w	r7, r0, #40	; 0x28
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800d5e2:	6081      	str	r1, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d5e4:	6104      	str	r4, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800d5e6:	f880 801c 	strb.w	r8, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d5ea:	f880 c01f 	strb.w	ip, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800d5ee:	f880 e01e 	strb.w	lr, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800d5f2:	7742      	strb	r2, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800d5f4:	63c2      	str	r2, [r0, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800d5f6:	6382      	str	r2, [r0, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
 800d5f8:	6202      	str	r2, [r0, #32]
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800d5fa:	6182      	str	r2, [r0, #24]
  REG_INSERT(tp);
 800d5fc:	6130      	str	r0, [r6, #16]
 800d5fe:	6160      	str	r0, [r4, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800d600:	6287      	str	r7, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800d602:	62c5      	str	r5, [r0, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 800d604:	6305      	str	r5, [r0, #48]	; 0x30
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 800d606:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d60a:	bf00      	nop
 800d60c:	200010b8 	.word	0x200010b8

0800d610 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 800d610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d614:	3964      	subs	r1, #100	; 0x64
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d616:	4f18      	ldr	r7, [pc, #96]	; (800d678 <chThdCreateI+0x68>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d618:	f8df 9060 	ldr.w	r9, [pc, #96]	; 800d67c <chThdCreateI+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d61c:	f8d7 e014 	ldr.w	lr, [r7, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d620:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800d622:	4401      	add	r1, r0
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800d624:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d626:	60c1      	str	r1, [r0, #12]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800d628:	f04f 0b02 	mov.w	fp, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d62c:	640b      	str	r3, [r1, #64]	; 0x40

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d62e:	f04f 0a04 	mov.w	sl, #4
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800d632:	f100 032c 	add.w	r3, r0, #44	; 0x2c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800d636:	f04f 0801 	mov.w	r8, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800d63a:	f100 0c28 	add.w	ip, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d63e:	644e      	str	r6, [r1, #68]	; 0x44
 800d640:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800d644:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d646:	6107      	str	r7, [r0, #16]
 800d648:	f8c0 e014 	str.w	lr, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800d64c:	6402      	str	r2, [r0, #64]	; 0x40
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800d64e:	f880 b01c 	strb.w	fp, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d652:	f880 a01f 	strb.w	sl, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800d656:	f880 801e 	strb.w	r8, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800d65a:	7745      	strb	r5, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800d65c:	63c5      	str	r5, [r0, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800d65e:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
 800d660:	6205      	str	r5, [r0, #32]
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800d662:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 800d664:	f8ce 0010 	str.w	r0, [lr, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800d668:	f8c0 c028 	str.w	ip, [r0, #40]	; 0x28
 800d66c:	6178      	str	r0, [r7, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800d66e:	62c3      	str	r3, [r0, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 800d670:	6303      	str	r3, [r0, #48]	; 0x30
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
}
 800d672:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d676:	bf00      	nop
 800d678:	200010b8 	.word	0x200010b8
 800d67c:	0800c129 	.word	0x0800c129

0800d680 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 800d680:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d684:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d686:	b672      	cpsid	i
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d688:	4e1a      	ldr	r6, [pc, #104]	; (800d6f4 <chThdCreateStatic+0x74>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d68a:	f8df a06c 	ldr.w	sl, [pc, #108]	; 800d6f8 <chThdCreateStatic+0x78>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d68e:	6977      	ldr	r7, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d690:	3964      	subs	r1, #100	; 0x64
 800d692:	4401      	add	r1, r0
 800d694:	60c1      	str	r1, [r0, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800d696:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d698:	640b      	str	r3, [r1, #64]	; 0x40
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800d69a:	f100 0b2c 	add.w	fp, r0, #44	; 0x2c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800d69e:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800d6a2:	f100 0e28 	add.w	lr, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d6a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d6a8:	644b      	str	r3, [r1, #68]	; 0x44
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800d6aa:	f04f 0902 	mov.w	r9, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d6ae:	f04f 0804 	mov.w	r8, #4

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800d6b2:	f8c1 a060 	str.w	sl, [r1, #96]	; 0x60
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800d6b6:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d6b8:	6106      	str	r6, [r0, #16]
 800d6ba:	6147      	str	r7, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800d6bc:	6402      	str	r2, [r0, #64]	; 0x40
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800d6be:	f880 901c 	strb.w	r9, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800d6c2:	f880 801f 	strb.w	r8, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800d6c6:	f880 c01e 	strb.w	ip, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800d6ca:	7745      	strb	r5, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800d6cc:	63c5      	str	r5, [r0, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800d6ce:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
 800d6d0:	6205      	str	r5, [r0, #32]
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800d6d2:	6185      	str	r5, [r0, #24]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 800d6d4:	4629      	mov	r1, r5
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800d6d6:	6138      	str	r0, [r7, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800d6d8:	f8c0 e028 	str.w	lr, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800d6dc:	f8c0 b02c 	str.w	fp, [r0, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 800d6e0:	f8c0 b030 	str.w	fp, [r0, #48]	; 0x30
 800d6e4:	6170      	str	r0, [r6, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 800d6e6:	f7ff fec3 	bl	800d470 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d6ea:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 800d6ec:	4620      	mov	r0, r4
 800d6ee:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d6f2:	bf00      	nop
 800d6f4:	200010b8 	.word	0x200010b8
 800d6f8:	0800c129 	.word	0x0800c129
 800d6fc:	00000000 	.word	0x00000000

0800d700 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 800d700:	b508      	push	{r3, lr}
 800d702:	4601      	mov	r1, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d704:	b672      	cpsid	i
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800d706:	2008      	movs	r0, #8
 800d708:	f7ff fe8a 	bl	800d420 <chSchGoSleepTimeoutS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d70c:	b662      	cpsie	i
 800d70e:	bd08      	pop	{r3, pc}

0800d710 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 800d710:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 800d712:	4b0e      	ldr	r3, [pc, #56]	; (800d74c <chThdExitS+0x3c>)
 800d714:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800d716:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  tp->p_u.exitcode = msg;
 800d718:	6260      	str	r0, [r4, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800d71a:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800d71e:	429d      	cmp	r5, r3
 800d720:	d007      	beq.n	800d732 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 800d722:	681a      	ldr	r2, [r3, #0]
 800d724:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800d726:	4618      	mov	r0, r3
 800d728:	f7ff fe4a 	bl	800d3c0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800d72c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800d72e:	42ab      	cmp	r3, r5
 800d730:	d1f7      	bne.n	800d722 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 800d732:	7f63      	ldrb	r3, [r4, #29]
 800d734:	079b      	lsls	r3, r3, #30
 800d736:	d104      	bne.n	800d742 <chThdExitS+0x32>
    REG_REMOVE(tp);
 800d738:	6963      	ldr	r3, [r4, #20]
 800d73a:	6922      	ldr	r2, [r4, #16]
 800d73c:	611a      	str	r2, [r3, #16]
 800d73e:	6922      	ldr	r2, [r4, #16]
 800d740:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800d742:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 800d744:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800d748:	f7ff be52 	b.w	800d3f0 <chSchGoSleepS>
 800d74c:	200010b8 	.word	0x200010b8

0800d750 <chThdExit>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d750:	b672      	cpsid	i
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 800d752:	f7ff bfdd 	b.w	800d710 <chThdExitS>
 800d756:	bf00      	nop
	...

0800d760 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 800d760:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800d762:	4c05      	ldr	r4, [pc, #20]	; (800d778 <chThdSuspendS+0x18>)
 800d764:	69a3      	ldr	r3, [r4, #24]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 800d766:	6003      	str	r3, [r0, #0]
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 800d768:	4602      	mov	r2, r0
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->p_u.wttrp = trp;
 800d76a:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 800d76c:	2003      	movs	r0, #3
 800d76e:	f7ff fe3f 	bl	800d3f0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800d772:	69a3      	ldr	r3, [r4, #24]
}
 800d774:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800d776:	bd10      	pop	{r4, pc}
 800d778:	200010b8 	.word	0x200010b8
 800d77c:	00000000 	.word	0x00000000

0800d780 <chThdSuspendTimeoutS>:
 800d780:	4b05      	ldr	r3, [pc, #20]	; (800d798 <chThdSuspendTimeoutS+0x18>)
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 800d782:	4602      	mov	r2, r0
 800d784:	699b      	ldr	r3, [r3, #24]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 800d786:	b121      	cbz	r1, 800d792 <chThdSuspendTimeoutS+0x12>
    return MSG_TIMEOUT;
  }

  *trp = tp;
 800d788:	6003      	str	r3, [r0, #0]
  tp->p_u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800d78a:	2003      	movs	r0, #3
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->p_u.wttrp = trp;
 800d78c:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800d78e:	f7ff be47 	b.w	800d420 <chSchGoSleepTimeoutS>
}
 800d792:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800d796:	4770      	bx	lr
 800d798:	200010b8 	.word	0x200010b8
 800d79c:	00000000 	.word	0x00000000

0800d7a0 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 800d7a0:	6803      	ldr	r3, [r0, #0]
 800d7a2:	b12b      	cbz	r3, 800d7b0 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 800d7a4:	2200      	movs	r2, #0
 800d7a6:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800d7a8:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 800d7aa:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800d7ac:	f7ff be08 	b.w	800d3c0 <chSchReadyI>
 800d7b0:	4770      	bx	lr
 800d7b2:	bf00      	nop
	...

0800d7c0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 800d7c0:	b169      	cbz	r1, 800d7de <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800d7c2:	4b08      	ldr	r3, [pc, #32]	; (800d7e4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 800d7c4:	b410      	push	{r4}
 800d7c6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800d7c8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800d7ca:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800d7cc:	2004      	movs	r0, #4
 800d7ce:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 800d7d2:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 800d7d4:	6053      	str	r3, [r2, #4]
}
 800d7d6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800d7da:	f7ff be21 	b.w	800d420 <chSchGoSleepTimeoutS>
}
 800d7de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800d7e2:	4770      	bx	lr
 800d7e4:	200010b8 	.word	0x200010b8
	...

0800d7f0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800d7f0:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800d7f2:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 800d7f4:	4298      	cmp	r0, r3
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800d7f6:	4604      	mov	r4, r0
 800d7f8:	460d      	mov	r5, r1

  while (queue_notempty(tqp)) {
 800d7fa:	d009      	beq.n	800d810 <chThdDequeueAllI+0x20>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800d7fc:	681a      	ldr	r2, [r3, #0]
 800d7fe:	6022      	str	r2, [r4, #0]
  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
  (void) chSchReadyI(tp);
 800d800:	4618      	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
 800d802:	6054      	str	r4, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 800d804:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800d806:	f7ff fddb 	bl	800d3c0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800d80a:	6823      	ldr	r3, [r4, #0]
 800d80c:	429c      	cmp	r4, r3
 800d80e:	d1f5      	bne.n	800d7fc <chThdDequeueAllI+0xc>
 800d810:	bd38      	pop	{r3, r4, r5, pc}
 800d812:	bf00      	nop
	...

0800d820 <chTMStartMeasurementX>:
 800d820:	4b01      	ldr	r3, [pc, #4]	; (800d828 <chTMStartMeasurementX+0x8>)
 800d822:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 800d824:	6083      	str	r3, [r0, #8]
 800d826:	4770      	bx	lr
 800d828:	e0001000 	.word	0xe0001000
 800d82c:	00000000 	.word	0x00000000

0800d830 <chTMStopMeasurementX>:
 800d830:	4b0f      	ldr	r3, [pc, #60]	; (800d870 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800d832:	4910      	ldr	r1, [pc, #64]	; (800d874 <chTMStopMeasurementX+0x44>)
 800d834:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800d836:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800d838:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800d83a:	6f8f      	ldr	r7, [r1, #120]	; 0x78

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800d83c:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 800d83e:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800d840:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800d844:	1ad3      	subs	r3, r2, r3
 800d846:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 800d848:	18e4      	adds	r4, r4, r3
 800d84a:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800d84e:	3601      	adds	r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 800d850:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800d852:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 800d854:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800d856:	e9c0 4504 	strd	r4, r5, [r0, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 800d85a:	d805      	bhi.n	800d868 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 800d85c:	6802      	ldr	r2, [r0, #0]
 800d85e:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 800d860:	bf38      	it	cc
 800d862:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800d864:	bcf0      	pop	{r4, r5, r6, r7}
 800d866:	4770      	bx	lr
  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 800d868:	6043      	str	r3, [r0, #4]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800d86a:	bcf0      	pop	{r4, r5, r6, r7}
 800d86c:	4770      	bx	lr
 800d86e:	bf00      	nop
 800d870:	e0001000 	.word	0xe0001000
 800d874:	200010b8 	.word	0x200010b8
	...

0800d880 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 800d880:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 800d882:	4c0c      	ldr	r4, [pc, #48]	; (800d8b4 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 800d884:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 800d886:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800d888:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800d88c:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800d88e:	2600      	movs	r6, #0
 800d890:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 800d892:	67a3      	str	r3, [r4, #120]	; 0x78
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 800d894:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 800d896:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 800d898:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800d89a:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800d89c:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800d8a0:	f7ff ffbe 	bl	800d820 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800d8a4:	4668      	mov	r0, sp
 800d8a6:	f7ff ffc3 	bl	800d830 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800d8aa:	9b02      	ldr	r3, [sp, #8]
 800d8ac:	67a3      	str	r3, [r4, #120]	; 0x78
}
 800d8ae:	b006      	add	sp, #24
 800d8b0:	bdd0      	pop	{r4, r6, r7, pc}
 800d8b2:	bf00      	nop
 800d8b4:	200010b8 	.word	0x200010b8
	...

0800d8c0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 800d8c0:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800d8c2:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800d8c4:	6040      	str	r0, [r0, #4]
 800d8c6:	6083      	str	r3, [r0, #8]
 800d8c8:	4770      	bx	lr
 800d8ca:	bf00      	nop
 800d8cc:	0000      	movs	r0, r0
	...

0800d8d0 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 800d8d0:	4b30      	ldr	r3, [pc, #192]	; (800d994 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800d8d2:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 800d8d4:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 800d8d6:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800d8d8:	2a00      	cmp	r2, #0
 800d8da:	d055      	beq.n	800d988 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800d8dc:	68a1      	ldr	r1, [r4, #8]
 800d8de:	6893      	ldr	r3, [r2, #8]
 800d8e0:	4299      	cmp	r1, r3
 800d8e2:	4605      	mov	r5, r0
 800d8e4:	d906      	bls.n	800d8f4 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800d8e6:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 800d8e8:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800d8ea:	2b06      	cmp	r3, #6
 800d8ec:	d033      	beq.n	800d956 <chMtxLockS+0x86>
 800d8ee:	2b07      	cmp	r3, #7
 800d8f0:	d01d      	beq.n	800d92e <chMtxLockS+0x5e>
 800d8f2:	b19b      	cbz	r3, 800d91c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800d8f4:	462b      	mov	r3, r5
 800d8f6:	e003      	b.n	800d900 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800d8f8:	6899      	ldr	r1, [r3, #8]
 800d8fa:	68a2      	ldr	r2, [r4, #8]
 800d8fc:	4291      	cmp	r1, r2
 800d8fe:	d302      	bcc.n	800d906 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800d900:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800d902:	429d      	cmp	r5, r3
 800d904:	d1f8      	bne.n	800d8f8 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800d906:	685a      	ldr	r2, [r3, #4]
 800d908:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800d90a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800d90c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800d90e:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 800d910:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800d912:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 800d914:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800d918:	f7ff bd6a 	b.w	800d3f0 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800d91c:	e892 000a 	ldmia.w	r2, {r1, r3}
 800d920:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800d922:	6811      	ldr	r1, [r2, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800d924:	4610      	mov	r0, r2
 800d926:	604b      	str	r3, [r1, #4]
 800d928:	f7ff fd4a 	bl	800d3c0 <chSchReadyI>
          break;
 800d92c:	e7e2      	b.n	800d8f4 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800d92e:	e892 0009 	ldmia.w	r2, {r0, r3}
 800d932:	6018      	str	r0, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800d934:	6a56      	ldr	r6, [r2, #36]	; 0x24
  tp->p_next->p_prev = tp->p_prev;
 800d936:	6810      	ldr	r0, [r2, #0]
 800d938:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800d93a:	4633      	mov	r3, r6
 800d93c:	e002      	b.n	800d944 <chMtxLockS+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800d93e:	6898      	ldr	r0, [r3, #8]
 800d940:	4288      	cmp	r0, r1
 800d942:	d302      	bcc.n	800d94a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800d944:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800d946:	429e      	cmp	r6, r3
 800d948:	d1f9      	bne.n	800d93e <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800d94a:	6859      	ldr	r1, [r3, #4]
 800d94c:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800d94e:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800d950:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 800d952:	605a      	str	r2, [r3, #4]
 800d954:	e7ce      	b.n	800d8f4 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800d956:	e892 0009 	ldmia.w	r2, {r0, r3}
 800d95a:	6018      	str	r0, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800d95c:	6a56      	ldr	r6, [r2, #36]	; 0x24
  tp->p_next->p_prev = tp->p_prev;
 800d95e:	6810      	ldr	r0, [r2, #0]
 800d960:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800d962:	4633      	mov	r3, r6
 800d964:	e002      	b.n	800d96c <chMtxLockS+0x9c>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800d966:	6898      	ldr	r0, [r3, #8]
 800d968:	4288      	cmp	r0, r1
 800d96a:	d302      	bcc.n	800d972 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800d96c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800d96e:	429e      	cmp	r6, r3
 800d970:	d1f9      	bne.n	800d966 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800d972:	6859      	ldr	r1, [r3, #4]
 800d974:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800d976:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800d978:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 800d97a:	605a      	str	r2, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 800d97c:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800d97e:	68a1      	ldr	r1, [r4, #8]
 800d980:	6893      	ldr	r3, [r2, #8]
 800d982:	428b      	cmp	r3, r1
 800d984:	d3af      	bcc.n	800d8e6 <chMtxLockS+0x16>
 800d986:	e7b5      	b.n	800d8f4 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 800d988:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800d98a:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 800d98c:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 800d98e:	63e0      	str	r0, [r4, #60]	; 0x3c
 800d990:	bd70      	pop	{r4, r5, r6, pc}
 800d992:	bf00      	nop
 800d994:	200010b8 	.word	0x200010b8
	...

0800d9a0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 800d9a0:	b508      	push	{r3, lr}
 800d9a2:	b672      	cpsid	i

  chSysLock();
  chMtxLockS(mp);
 800d9a4:	f7ff ff94 	bl	800d8d0 <chMtxLockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d9a8:	b662      	cpsie	i
 800d9aa:	bd08      	pop	{r3, pc}
 800d9ac:	0000      	movs	r0, r0
	...

0800d9b0 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 800d9b0:	4b14      	ldr	r3, [pc, #80]	; (800da04 <chMtxUnlock+0x54>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 800d9b2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 800d9b4:	699d      	ldr	r5, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d9b6:	b672      	cpsid	i
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800d9b8:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800d9ba:	68c3      	ldr	r3, [r0, #12]
 800d9bc:	63eb      	str	r3, [r5, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800d9be:	42a0      	cmp	r0, r4
 800d9c0:	d01b      	beq.n	800d9fa <chMtxUnlock+0x4a>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 800d9c2:	6c29      	ldr	r1, [r5, #64]	; 0x40
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800d9c4:	b14b      	cbz	r3, 800d9da <chMtxUnlock+0x2a>
 800d9c6:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800d9c8:	4293      	cmp	r3, r2
 800d9ca:	d003      	beq.n	800d9d4 <chMtxUnlock+0x24>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800d9cc:	6892      	ldr	r2, [r2, #8]
 800d9ce:	4291      	cmp	r1, r2
 800d9d0:	bf38      	it	cc
 800d9d2:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 800d9d4:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800d9d6:	2b00      	cmp	r3, #0
 800d9d8:	d1f5      	bne.n	800d9c6 <chMtxUnlock+0x16>
 800d9da:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800d9dc:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 800d9de:	6be6      	ldr	r6, [r4, #60]	; 0x3c
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800d9e0:	60a9      	str	r1, [r5, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800d9e2:	4620      	mov	r0, r4
 800d9e4:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800d9e6:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 800d9e8:	609c      	str	r4, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 800d9ea:	60de      	str	r6, [r3, #12]
      tp->p_mtxlist = mp;
 800d9ec:	63e3      	str	r3, [r4, #60]	; 0x3c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800d9ee:	f7ff fce7 	bl	800d3c0 <chSchReadyI>
      chSchRescheduleS();
 800d9f2:	f7ff fdc5 	bl	800d580 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800d9f6:	b662      	cpsie	i
 800d9f8:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->m_owner = NULL;
 800d9fa:	2300      	movs	r3, #0
 800d9fc:	6083      	str	r3, [r0, #8]
 800d9fe:	b662      	cpsie	i
 800da00:	bd70      	pop	{r4, r5, r6, pc}
 800da02:	bf00      	nop
 800da04:	200010b8 	.word	0x200010b8
	...

0800da10 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800da10:	6b83      	ldr	r3, [r0, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800da12:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800da14:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800da16:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800da18:	6381      	str	r1, [r0, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800da1a:	d00a      	beq.n	800da32 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800da1c:	2a0b      	cmp	r2, #11
 800da1e:	d000      	beq.n	800da22 <chEvtSignalI+0x12>
 800da20:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 800da22:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800da24:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800da26:	428b      	cmp	r3, r1
 800da28:	d1fa      	bne.n	800da20 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800da2a:	2300      	movs	r3, #0
 800da2c:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 800da2e:	f7ff bcc7 	b.w	800d3c0 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800da32:	6a43      	ldr	r3, [r0, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800da34:	4219      	tst	r1, r3
 800da36:	d1f8      	bne.n	800da2a <chEvtSignalI+0x1a>
 800da38:	4770      	bx	lr
 800da3a:	bf00      	nop
 800da3c:	0000      	movs	r0, r0
	...

0800da40 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 800da40:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 800da42:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800da44:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 800da46:	4606      	mov	r6, r0
 800da48:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800da4a:	d00d      	beq.n	800da68 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->el_flags |= flags;
 800da4c:	68e3      	ldr	r3, [r4, #12]
 800da4e:	432b      	orrs	r3, r5
 800da50:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800da52:	b115      	cbz	r5, 800da5a <chEvtBroadcastFlagsI+0x1a>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 800da54:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800da56:	4213      	tst	r3, r2
 800da58:	d003      	beq.n	800da62 <chEvtBroadcastFlagsI+0x22>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 800da5a:	6860      	ldr	r0, [r4, #4]
 800da5c:	68a1      	ldr	r1, [r4, #8]
 800da5e:	f7ff ffd7 	bl	800da10 <chEvtSignalI>
    }
    elp = elp->el_next;
 800da62:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800da64:	42a6      	cmp	r6, r4
 800da66:	d1f1      	bne.n	800da4c <chEvtBroadcastFlagsI+0xc>
 800da68:	bd70      	pop	{r4, r5, r6, pc}
 800da6a:	bf00      	nop
 800da6c:	0000      	movs	r0, r0
	...

0800da70 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 800da70:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800da72:	b672      	cpsid	i

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 800da74:	f7ff ffcc 	bl	800da10 <chEvtSignalI>
  chSchRescheduleS();
 800da78:	f7ff fd82 	bl	800d580 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800da7c:	b662      	cpsie	i
 800da7e:	bd08      	pop	{r3, pc}

0800da80 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 800da80:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 800da82:	4b0a      	ldr	r3, [pc, #40]	; (800daac <chEvtWaitAny+0x2c>)
 800da84:	699d      	ldr	r5, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800da86:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800da88:	6bab      	ldr	r3, [r5, #56]	; 0x38
  if (m == (eventmask_t)0) {
 800da8a:	ea10 0403 	ands.w	r4, r0, r3
 800da8e:	d106      	bne.n	800da9e <chEvtWaitAny+0x1e>
 800da90:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 800da92:	6268      	str	r0, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 800da94:	200a      	movs	r0, #10
 800da96:	f7ff fcab 	bl	800d3f0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800da9a:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800da9c:	401c      	ands	r4, r3
  }
  ctp->p_epending &= ~m;
 800da9e:	ea23 0304 	bic.w	r3, r3, r4
 800daa2:	63ab      	str	r3, [r5, #56]	; 0x38
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800daa4:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 800daa6:	4620      	mov	r0, r4
 800daa8:	bd38      	pop	{r3, r4, r5, pc}
 800daaa:	bf00      	nop
 800daac:	200010b8 	.word	0x200010b8

0800dab0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 800dab0:	b430      	push	{r4, r5}
 800dab2:	9c02      	ldr	r4, [sp, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 800dab4:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800dab6:	2500      	movs	r5, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800dab8:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800daba:	6085      	str	r5, [r0, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800dabc:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800dabe:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800dac0:	6040      	str	r0, [r0, #4]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800dac2:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 800dac4:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 800dac6:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 800dac8:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
}
 800daca:	bc30      	pop	{r4, r5}
 800dacc:	4770      	bx	lr
 800dace:	bf00      	nop

0800dad0 <chIQResetI>:

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 800dad0:	2100      	movs	r1, #0
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 800dad2:	68c2      	ldr	r2, [r0, #12]
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 800dad4:	6081      	str	r1, [r0, #8]
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 800dad6:	6182      	str	r2, [r0, #24]
  iqp->q_wrptr = iqp->q_buffer;
 800dad8:	6142      	str	r2, [r0, #20]
  iqp->q_counter = 0;
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800dada:	f06f 0101 	mvn.w	r1, #1
 800dade:	f7ff be87 	b.w	800d7f0 <chThdDequeueAllI>
 800dae2:	bf00      	nop
	...

0800daf0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 800daf0:	b538      	push	{r3, r4, r5, lr}
 800daf2:	460d      	mov	r5, r1
 800daf4:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800daf6:	b672      	cpsid	i
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 800daf8:	69c3      	ldr	r3, [r0, #28]
 800dafa:	b12b      	cbz	r3, 800db08 <chIQGetTimeout+0x18>
    iqp->q_notify(iqp);
 800dafc:	4798      	blx	r3
 800dafe:	e003      	b.n	800db08 <chIQGetTimeout+0x18>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800db00:	f7ff fe5e 	bl	800d7c0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 800db04:	2800      	cmp	r0, #0
 800db06:	db11      	blt.n	800db2c <chIQGetTimeout+0x3c>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800db08:	68a3      	ldr	r3, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800db0a:	4620      	mov	r0, r4
 800db0c:	4629      	mov	r1, r5
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 800db0e:	2b00      	cmp	r3, #0
 800db10:	d0f6      	beq.n	800db00 <chIQGetTimeout+0x10>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800db12:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800db14:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800db16:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800db18:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800db1a:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800db1c:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800db1e:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800db20:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800db22:	bf28      	it	cs
 800db24:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800db26:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800db28:	bf28      	it	cs
 800db2a:	61a3      	strcs	r3, [r4, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800db2c:	b662      	cpsie	i
  }
  chSysUnlock();

  return (msg_t)b;
}
 800db2e:	bd38      	pop	{r3, r4, r5, pc}

0800db30 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 800db30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800db34:	4604      	mov	r4, r0
 800db36:	4688      	mov	r8, r1
 800db38:	4691      	mov	r9, r2
 800db3a:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 800db3c:	69c7      	ldr	r7, [r0, #28]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800db3e:	b672      	cpsid	i
  size_t r = 0;
 800db40:	2600      	movs	r6, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 800db42:	b12f      	cbz	r7, 800db50 <chIQReadTimeout+0x20>
      nfy(iqp);
 800db44:	4620      	mov	r0, r4
 800db46:	47b8      	blx	r7
 800db48:	e002      	b.n	800db50 <chIQReadTimeout+0x20>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800db4a:	f7ff fe39 	bl	800d7c0 <chThdEnqueueTimeoutS>
 800db4e:	b9c8      	cbnz	r0, 800db84 <chIQReadTimeout+0x54>
 800db50:	68a3      	ldr	r3, [r4, #8]
 800db52:	4620      	mov	r0, r4
 800db54:	4629      	mov	r1, r5
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 800db56:	2b00      	cmp	r3, #0
 800db58:	d0f7      	beq.n	800db4a <chIQReadTimeout+0x1a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800db5a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800db5c:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800db5e:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800db60:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 800db62:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800db64:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800db66:	7813      	ldrb	r3, [r2, #0]
 800db68:	f808 3b01 	strb.w	r3, [r8], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 800db6c:	6923      	ldr	r3, [r4, #16]
 800db6e:	69a2      	ldr	r2, [r4, #24]
 800db70:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 800db72:	bf24      	itt	cs
 800db74:	68e3      	ldrcs	r3, [r4, #12]
 800db76:	61a3      	strcs	r3, [r4, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800db78:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 800db7a:	3601      	adds	r6, #1
    if (--n == 0U) {
 800db7c:	45b1      	cmp	r9, r6
 800db7e:	d002      	beq.n	800db86 <chIQReadTimeout+0x56>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800db80:	b672      	cpsid	i
 800db82:	e7de      	b.n	800db42 <chIQReadTimeout+0x12>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800db84:	b662      	cpsie	i
      return r;
    }

    chSysLock();
  }
}
 800db86:	4630      	mov	r0, r6
 800db88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800db8c:	0000      	movs	r0, r0
	...

0800db90 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 800db90:	b430      	push	{r4, r5}
 800db92:	9c02      	ldr	r4, [sp, #8]
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 800db94:	6204      	str	r4, [r0, #32]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800db96:	188d      	adds	r5, r1, r2
 800db98:	6105      	str	r5, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800db9a:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800db9c:	6040      	str	r0, [r0, #4]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800db9e:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 800dba0:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 800dba2:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 800dba4:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 800dba6:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
}
 800dba8:	bc30      	pop	{r4, r5}
 800dbaa:	4770      	bx	lr
 800dbac:	0000      	movs	r0, r0
	...

0800dbb0 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 800dbb0:	b410      	push	{r4}

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 800dbb2:	6902      	ldr	r2, [r0, #16]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 800dbb4:	68c4      	ldr	r4, [r0, #12]
 800dbb6:	6184      	str	r4, [r0, #24]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 800dbb8:	1b12      	subs	r2, r2, r4
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
 800dbba:	6144      	str	r4, [r0, #20]
  oqp->q_counter = chQSizeX(oqp);
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 800dbbc:	f06f 0101 	mvn.w	r1, #1

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 800dbc0:	6082      	str	r2, [r0, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
}
 800dbc2:	f85d 4b04 	ldr.w	r4, [sp], #4
  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 800dbc6:	f7ff be13 	b.w	800d7f0 <chThdDequeueAllI>
 800dbca:	bf00      	nop
 800dbcc:	0000      	movs	r0, r0
	...

0800dbd0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 800dbd0:	b570      	push	{r4, r5, r6, lr}
 800dbd2:	4604      	mov	r4, r0
 800dbd4:	460e      	mov	r6, r1
 800dbd6:	4615      	mov	r5, r2
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800dbd8:	b672      	cpsid	i
 800dbda:	e003      	b.n	800dbe4 <chOQPutTimeout+0x14>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 800dbdc:	f7ff fdf0 	bl	800d7c0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 800dbe0:	2800      	cmp	r0, #0
 800dbe2:	db18      	blt.n	800dc16 <chOQPutTimeout+0x46>
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800dbe4:	68a3      	ldr	r3, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 800dbe6:	4620      	mov	r0, r4
 800dbe8:	4629      	mov	r1, r5
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800dbea:	2b00      	cmp	r3, #0
 800dbec:	d0f6      	beq.n	800dbdc <chOQPutTimeout+0xc>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 800dbee:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800dbf0:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800dbf2:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800dbf4:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 800dbf6:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800dbf8:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800dbfa:	7016      	strb	r6, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800dbfc:	6923      	ldr	r3, [r4, #16]
 800dbfe:	6962      	ldr	r2, [r4, #20]
 800dc00:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 800dc02:	bf24      	itt	cs
 800dc04:	68e3      	ldrcs	r3, [r4, #12]
 800dc06:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 800dc08:	69e3      	ldr	r3, [r4, #28]
 800dc0a:	b10b      	cbz	r3, 800dc10 <chOQPutTimeout+0x40>
    oqp->q_notify(oqp);
 800dc0c:	4620      	mov	r0, r4
 800dc0e:	4798      	blx	r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800dc10:	b662      	cpsie	i
  }
  chSysUnlock();

  return Q_OK;
 800dc12:	2000      	movs	r0, #0
}
 800dc14:	bd70      	pop	{r4, r5, r6, pc}
 800dc16:	b662      	cpsie	i
  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
 800dc18:	bd70      	pop	{r4, r5, r6, pc}
 800dc1a:	bf00      	nop
 800dc1c:	0000      	movs	r0, r0
	...

0800dc20 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 800dc20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800dc24:	4604      	mov	r4, r0
 800dc26:	460d      	mov	r5, r1
 800dc28:	4616      	mov	r6, r2
 800dc2a:	4699      	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
 800dc2c:	f8d0 801c 	ldr.w	r8, [r0, #28]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800dc30:	b672      	cpsid	i
  size_t w = 0;
 800dc32:	2700      	movs	r7, #0
 800dc34:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800dc36:	f105 0a01 	add.w	sl, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 800dc3a:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800dc3c:	b1f3      	cbz	r3, 800dc7c <chOQWriteTimeout+0x5c>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800dc3e:	6962      	ldr	r2, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800dc40:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800dc42:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800dc44:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 800dc46:	6161      	str	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800dc48:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800dc4a:	782b      	ldrb	r3, [r5, #0]
 800dc4c:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800dc4e:	6923      	ldr	r3, [r4, #16]
 800dc50:	6962      	ldr	r2, [r4, #20]
 800dc52:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 800dc54:	bf24      	itt	cs
 800dc56:	68e3      	ldrcs	r3, [r4, #12]
 800dc58:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 800dc5a:	f1b8 0f00 	cmp.w	r8, #0
 800dc5e:	d000      	beq.n	800dc62 <chOQWriteTimeout+0x42>
      nfy(oqp);
 800dc60:	47c0      	blx	r8
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800dc62:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 800dc64:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 800dc66:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 800dc6a:	d00e      	beq.n	800dc8a <chOQWriteTimeout+0x6a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800dc6c:	b672      	cpsid	i
 800dc6e:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800dc70:	4655      	mov	r5, sl
 800dc72:	f105 0a01 	add.w	sl, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 800dc76:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800dc78:	2b00      	cmp	r3, #0
 800dc7a:	d1e0      	bne.n	800dc3e <chOQWriteTimeout+0x1e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800dc7c:	4620      	mov	r0, r4
 800dc7e:	4649      	mov	r1, r9
 800dc80:	f7ff fd9e 	bl	800d7c0 <chThdEnqueueTimeoutS>
 800dc84:	2800      	cmp	r0, #0
 800dc86:	d0d5      	beq.n	800dc34 <chOQWriteTimeout+0x14>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800dc88:	b662      	cpsie	i
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 800dc8a:	4638      	mov	r0, r7
 800dc8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800dc90 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800dc90:	4a05      	ldr	r2, [pc, #20]	; (800dca8 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800dc92:	4b06      	ldr	r3, [pc, #24]	; (800dcac <_core_init+0x1c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800dc94:	4806      	ldr	r0, [pc, #24]	; (800dcb0 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800dc96:	4907      	ldr	r1, [pc, #28]	; (800dcb4 <_core_init+0x24>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800dc98:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800dc9c:	f023 0307 	bic.w	r3, r3, #7
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800dca0:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800dca2:	600b      	str	r3, [r1, #0]
 800dca4:	4770      	bx	lr
 800dca6:	bf00      	nop
 800dca8:	20006c13 	.word	0x20006c13
 800dcac:	20020000 	.word	0x20020000
 800dcb0:	20001314 	.word	0x20001314
 800dcb4:	20001310 	.word	0x20001310
	...

0800dcc0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 800dcc0:	b410      	push	{r4}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800dcc2:	b672      	cpsid	i

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800dcc4:	4c08      	ldr	r4, [pc, #32]	; (800dce8 <chCoreAlloc+0x28>)
 800dcc6:	4b09      	ldr	r3, [pc, #36]	; (800dcec <chCoreAlloc+0x2c>)
 800dcc8:	6822      	ldr	r2, [r4, #0]
 800dcca:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 800dccc:	1dc3      	adds	r3, r0, #7
 800dcce:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800dcd2:	1a89      	subs	r1, r1, r2
 800dcd4:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 800dcd6:	bf9d      	ittte	ls
 800dcd8:	189b      	addls	r3, r3, r2
 800dcda:	6023      	strls	r3, [r4, #0]

  return p;
 800dcdc:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 800dcde:	2000      	movhi	r0, #0
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800dce0:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800dce2:	f85d 4b04 	ldr.w	r4, [sp], #4
 800dce6:	4770      	bx	lr
 800dce8:	20001314 	.word	0x20001314
 800dcec:	20001310 	.word	0x20001310

0800dcf0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 800dcf0:	4b04      	ldr	r3, [pc, #16]	; (800dd04 <_heap_init+0x14>)
 800dcf2:	4a05      	ldr	r2, [pc, #20]	; (800dd08 <_heap_init+0x18>)
 800dcf4:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 800dcf6:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = NULL;
 800dcfa:	2200      	movs	r2, #0
 800dcfc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 800dcfe:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 800dd00:	f7ff bdde 	b.w	800d8c0 <chMtxObjectInit>
 800dd04:	20001318 	.word	0x20001318
 800dd08:	0800dcc1 	.word	0x0800dcc1
 800dd0c:	00000000 	.word	0x00000000

0800dd10 <PendSV_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 800dd10:	4a05      	ldr	r2, [pc, #20]	; (800dd28 <PendSV_Handler+0x18>)
 800dd12:	6853      	ldr	r3, [r2, #4]
 800dd14:	f023 0301 	bic.w	r3, r3, #1
 800dd18:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800dd1a:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800dd1e:	3368      	adds	r3, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800dd20:	f383 8809 	msr	PSP, r3
 800dd24:	4770      	bx	lr
 800dd26:	bf00      	nop
 800dd28:	e000ef30 	.word	0xe000ef30
 800dd2c:	00000000 	.word	0x00000000

0800dd30 <_port_irq_epilogue>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800dd30:	b672      	cpsid	i
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 800dd32:	4b11      	ldr	r3, [pc, #68]	; (800dd78 <_port_irq_epilogue+0x48>)
 800dd34:	685b      	ldr	r3, [r3, #4]
 800dd36:	051b      	lsls	r3, r3, #20
 800dd38:	d401      	bmi.n	800dd3e <_port_irq_epilogue+0xe>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800dd3a:	b662      	cpsie	i
 800dd3c:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 800dd3e:	b510      	push	{r4, lr}
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 800dd40:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800dd44:	f3ef 8409 	mrs	r4, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800dd48:	4b0c      	ldr	r3, [pc, #48]	; (800dd7c <_port_irq_epilogue+0x4c>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800dd4a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800dd4e:	68db      	ldr	r3, [r3, #12]
 800dd50:	f844 3c08 	str.w	r3, [r4, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800dd54:	f844 2c4c 	str.w	r2, [r4, #-76]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800dd58:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800dd5c:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800dd60:	f7ff fbb6 	bl	800d4d0 <chSchIsPreemptionRequired>
 800dd64:	b118      	cbz	r0, 800dd6e <_port_irq_epilogue+0x3e>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800dd66:	4b06      	ldr	r3, [pc, #24]	; (800dd80 <_port_irq_epilogue+0x50>)
 800dd68:	f844 3c50 	str.w	r3, [r4, #-80]
 800dd6c:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800dd6e:	4b05      	ldr	r3, [pc, #20]	; (800dd84 <_port_irq_epilogue+0x54>)
 800dd70:	f844 3c50 	str.w	r3, [r4, #-80]
 800dd74:	bd10      	pop	{r4, pc}
 800dd76:	bf00      	nop
 800dd78:	e000ed00 	.word	0xe000ed00
 800dd7c:	e000ef30 	.word	0xe000ef30
 800dd80:	0800c135 	.word	0x0800c135
 800dd84:	0800c138 	.word	0x0800c138
	...

0800dd90 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 800dd90:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 800dd92:	f001 f825 	bl	800ede0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800dd96:	480c      	ldr	r0, [pc, #48]	; (800ddc8 <halInit+0x38>)
 800dd98:	f001 fe12 	bl	800f9c0 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800dd9c:	f000 f820 	bl	800dde0 <adcInit>
#endif
#if (HAL_USE_CAN == TRUE) || defined(__DOXYGEN__)
  canInit();
 800dda0:	f000 f856 	bl	800de50 <canInit>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
 800dda4:	f000 f884 	bl	800deb0 <extInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 800dda8:	f000 f8b2 	bl	800df10 <i2cInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 800ddac:	f000 f900 	bl	800dfb0 <pwmInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 800ddb0:	f000 faae 	bl	800e310 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 800ddb4:	f000 fb0c 	bl	800e3d0 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 800ddb8:	f000 f9b2 	bl	800e120 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 800ddbc:	f003 f928 	bl	8011010 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 800ddc0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800ddc4:	f000 b804 	b.w	800ddd0 <stInit>
 800ddc8:	080167d0 	.word	0x080167d0
 800ddcc:	00000000 	.word	0x00000000

0800ddd0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 800ddd0:	f001 b8b6 	b.w	800ef40 <st_lld_init>
	...

0800dde0 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 800dde0:	f001 b8be 	b.w	800ef60 <adc_lld_init>
	...

0800ddf0 <adcObjectInit>:
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 800ddf0:	2300      	movs	r3, #0
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 800ddf2:	2201      	movs	r2, #1
 800ddf4:	7002      	strb	r2, [r0, #0]
  adcp->config   = NULL;
 800ddf6:	6043      	str	r3, [r0, #4]
  adcp->samples  = NULL;
 800ddf8:	6083      	str	r3, [r0, #8]
  adcp->depth    = 0;
 800ddfa:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = NULL;
 800ddfc:	6103      	str	r3, [r0, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 800ddfe:	6143      	str	r3, [r0, #20]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 800de00:	3018      	adds	r0, #24
 800de02:	f7ff bd5d 	b.w	800d8c0 <chMtxObjectInit>
 800de06:	bf00      	nop
	...

0800de10 <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
 800de10:	b510      	push	{r4, lr}
 800de12:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800de14:	b672      	cpsid	i
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 800de16:	6041      	str	r1, [r0, #4]
  adc_lld_start(adcp);
 800de18:	f001 f8c2 	bl	800efa0 <adc_lld_start>
  adcp->state = ADC_READY;
 800de1c:	2302      	movs	r3, #2
 800de1e:	7023      	strb	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800de20:	b662      	cpsie	i
 800de22:	bd10      	pop	{r4, pc}
	...

0800de30 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 800de30:	b538      	push	{r3, r4, r5, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800de32:	b672      	cpsid	i
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 800de34:	2503      	movs	r5, #3
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 800de36:	6082      	str	r2, [r0, #8]
  adcp->depth    = depth;
 800de38:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = grpp;
 800de3a:	6101      	str	r1, [r0, #16]
  adcp->state    = ADC_ACTIVE;
 800de3c:	7005      	strb	r5, [r0, #0]
  adc_lld_start_conversion(adcp);
 800de3e:	f001 f8e7 	bl	800f010 <adc_lld_start_conversion>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800de42:	b662      	cpsie	i
 800de44:	bd38      	pop	{r3, r4, r5, pc}
 800de46:	bf00      	nop
	...

0800de50 <canInit>:
 *
 * @init
 */
void canInit(void) {

  can_lld_init();
 800de50:	f001 bd9e 	b.w	800f990 <can_lld_init>
	...

0800de60 <canObjectInit>:
 *
 * @param[out] canp     pointer to the @p CANDriver object
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {
 800de60:	b5f0      	push	{r4, r5, r6, r7, lr}

  canp->state    = CAN_STOP;
  canp->config   = NULL;
  osalThreadQueueObjectInit(&canp->txqueue);
 800de62:	f100 0208 	add.w	r2, r0, #8
  osalThreadQueueObjectInit(&canp->rxqueue);
 800de66:	f100 0310 	add.w	r3, r0, #16
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 800de6a:	f04f 0c01 	mov.w	ip, #1
  canp->config   = NULL;
 800de6e:	f04f 0e00 	mov.w	lr, #0
  osalThreadQueueObjectInit(&canp->txqueue);
  osalThreadQueueObjectInit(&canp->rxqueue);
  osalEventObjectInit(&canp->rxfull_event);
 800de72:	f100 0718 	add.w	r7, r0, #24
  osalEventObjectInit(&canp->txempty_event);
 800de76:	f100 061c 	add.w	r6, r0, #28
  osalEventObjectInit(&canp->error_event);
 800de7a:	f100 0520 	add.w	r5, r0, #32
#if CAN_USE_SLEEP_MODE == TRUE
  osalEventObjectInit(&canp->sleep_event);
 800de7e:	f100 0424 	add.w	r4, r0, #36	; 0x24
  osalEventObjectInit(&canp->wakeup_event);
 800de82:	f100 0128 	add.w	r1, r0, #40	; 0x28
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 800de86:	f880 c000 	strb.w	ip, [r0]
  canp->config   = NULL;
 800de8a:	f8c0 e004 	str.w	lr, [r0, #4]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 800de8e:	6187      	str	r7, [r0, #24]
 800de90:	61c6      	str	r6, [r0, #28]
 800de92:	6205      	str	r5, [r0, #32]
 800de94:	6244      	str	r4, [r0, #36]	; 0x24
 800de96:	6281      	str	r1, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800de98:	6082      	str	r2, [r0, #8]
  tqp->p_prev = (thread_t *)tqp;
 800de9a:	60c2      	str	r2, [r0, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800de9c:	6103      	str	r3, [r0, #16]
  tqp->p_prev = (thread_t *)tqp;
 800de9e:	6143      	str	r3, [r0, #20]
 800dea0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800dea2:	bf00      	nop
	...

0800deb0 <extInit>:
 *
 * @init
 */
void extInit(void) {

  ext_lld_init();
 800deb0:	f001 bb96 	b.w	800f5e0 <ext_lld_init>
	...

0800dec0 <extObjectInit>:
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
 800dec0:	2201      	movs	r2, #1
  extp->config = NULL;
 800dec2:	2300      	movs	r3, #0
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
 800dec4:	7002      	strb	r2, [r0, #0]
  extp->config = NULL;
 800dec6:	6043      	str	r3, [r0, #4]
 800dec8:	4770      	bx	lr
 800deca:	bf00      	nop
 800decc:	0000      	movs	r0, r0
	...

0800ded0 <extStart>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] config    pointer to the @p EXTConfig object
 *
 * @api
 */
void extStart(EXTDriver *extp, const EXTConfig *config) {
 800ded0:	b510      	push	{r4, lr}
 800ded2:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ded4:	b672      	cpsid	i
  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
 800ded6:	6041      	str	r1, [r0, #4]
  ext_lld_start(extp);
 800ded8:	f001 fbf2 	bl	800f6c0 <ext_lld_start>
  extp->state = EXT_ACTIVE;
 800dedc:	2302      	movs	r3, #2
 800dede:	7023      	strb	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800dee0:	b662      	cpsie	i
 800dee2:	bd10      	pop	{r4, pc}
	...

0800def0 <extChannelEnable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be enabled
 *
 * @api
 */
void extChannelEnable(EXTDriver *extp, expchannel_t channel) {
 800def0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800def2:	b672      	cpsid	i
  osalSysLock();
  osalDbgAssert((extp->state == EXT_ACTIVE) &&
                ((extp->config->channels[channel].mode &
                  EXT_CH_MODE_EDGES_MASK) != EXT_CH_MODE_DISABLED),
                "invalid state");
  extChannelEnableI(extp, channel);
 800def4:	f001 fb7c 	bl	800f5f0 <ext_lld_channel_enable>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800def8:	b662      	cpsie	i
 800defa:	bd08      	pop	{r3, pc}
 800defc:	0000      	movs	r0, r0
	...

0800df00 <extChannelDisable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be disabled
 *
 * @api
 */
void extChannelDisable(EXTDriver *extp, expchannel_t channel) {
 800df00:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800df02:	b672      	cpsid	i
  osalSysLock();
  osalDbgAssert((extp->state == EXT_ACTIVE) &&
                ((extp->config->channels[channel].mode &
                  EXT_CH_MODE_EDGES_MASK) != EXT_CH_MODE_DISABLED),
                "invalid state");
  extChannelDisableI(extp, channel);
 800df04:	f001 fbc4 	bl	800f690 <ext_lld_channel_disable>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800df08:	b662      	cpsie	i
 800df0a:	bd08      	pop	{r3, pc}
 800df0c:	0000      	movs	r0, r0
	...

0800df10 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 800df10:	f002 b806 	b.w	800ff20 <i2c_lld_init>
	...

0800df20 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 800df20:	2201      	movs	r2, #1
  i2cp->config = NULL;
 800df22:	2300      	movs	r3, #0
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 800df24:	7002      	strb	r2, [r0, #0]
  i2cp->config = NULL;
 800df26:	6043      	str	r3, [r0, #4]
 800df28:	300c      	adds	r0, #12
 800df2a:	f7ff bcc9 	b.w	800d8c0 <chMtxObjectInit>
 800df2e:	bf00      	nop

0800df30 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 800df30:	b510      	push	{r4, lr}
 800df32:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800df34:	b672      	cpsid	i
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800df36:	6041      	str	r1, [r0, #4]
  i2c_lld_start(i2cp);
 800df38:	f002 f81a 	bl	800ff70 <i2c_lld_start>
  i2cp->state = I2C_READY;
 800df3c:	2302      	movs	r3, #2
 800df3e:	7023      	strb	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800df40:	b662      	cpsie	i
 800df42:	bd10      	pop	{r4, pc}
	...

0800df50 <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
 800df50:	b5f0      	push	{r4, r5, r6, r7, lr}
 800df52:	b085      	sub	sp, #20
 800df54:	4604      	mov	r4, r0
 800df56:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800df58:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800df5a:	b672      	cpsid	i

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 800df5c:	f04f 0e03 	mov.w	lr, #3
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 800df60:	9601      	str	r6, [sp, #4]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800df62:	2500      	movs	r5, #0
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 800df64:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800df66:	9700      	str	r7, [sp, #0]
 800df68:	9602      	str	r6, [sp, #8]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800df6a:	6085      	str	r5, [r0, #8]
  i2cp->state = I2C_ACTIVE_TX;
 800df6c:	f880 e000 	strb.w	lr, [r0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 800df70:	f002 f8f6 	bl	8010160 <i2c_lld_master_transmit_timeout>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 800df74:	1c43      	adds	r3, r0, #1
    i2cp->state = I2C_LOCKED;
 800df76:	bf0c      	ite	eq
 800df78:	2305      	moveq	r3, #5
  }
  else {
    i2cp->state = I2C_READY;
 800df7a:	2302      	movne	r3, #2
 800df7c:	7023      	strb	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800df7e:	b662      	cpsie	i
  }
  osalSysUnlock();
  return rdymsg;
}
 800df80:	b005      	add	sp, #20
 800df82:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800df90 <i2cAcquireBus>:
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800df90:	300c      	adds	r0, #12
 800df92:	f7ff bd05 	b.w	800d9a0 <chMtxLock>
 800df96:	bf00      	nop
	...

0800dfa0 <i2cReleaseBus>:
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800dfa0:	300c      	adds	r0, #12
 800dfa2:	f7ff bd05 	b.w	800d9b0 <chMtxUnlock>
 800dfa6:	bf00      	nop
	...

0800dfb0 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
 800dfb0:	f003 b816 	b.w	8010fe0 <pwm_lld_init>
	...

0800dfc0 <pwmObjectInit>:
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 800dfc0:	2300      	movs	r3, #0
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 800dfc2:	2201      	movs	r2, #1
 800dfc4:	7002      	strb	r2, [r0, #0]
  pwmp->config   = NULL;
 800dfc6:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 800dfc8:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 800dfca:	7403      	strb	r3, [r0, #16]
 800dfcc:	4770      	bx	lr
 800dfce:	bf00      	nop

0800dfd0 <onotify>:
/**
 * @brief   Notification of data inserted into the output queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void onotify(io_queue_t *qp) {
 800dfd0:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = qGetLink(qp);
 800dfd2:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800dfd4:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800dfd8:	6813      	ldr	r3, [r2, #0]
 800dfda:	7819      	ldrb	r1, [r3, #0]
 800dfdc:	2904      	cmp	r1, #4
 800dfde:	d000      	beq.n	800dfe2 <onotify+0x12>
 800dfe0:	bd10      	pop	{r4, pc}
 800dfe2:	7a21      	ldrb	r1, [r4, #8]
 800dfe4:	2902      	cmp	r1, #2
 800dfe6:	d1fb      	bne.n	800dfe0 <onotify+0x10>
    return;
  }

  /* If there is not an ongoing transaction and the output queue contains
     data then a new transaction is started.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800dfe8:	7911      	ldrb	r1, [r2, #4]
 800dfea:	891a      	ldrh	r2, [r3, #8]
 800dfec:	2301      	movs	r3, #1
 800dfee:	408b      	lsls	r3, r1
 800dff0:	4213      	tst	r3, r2
 800dff2:	d1f5      	bne.n	800dfe0 <onotify+0x10>
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800dff4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800dff6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800dff8:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800dffa:	1ad3      	subs	r3, r2, r3
    if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 800dffc:	1a5b      	subs	r3, r3, r1
 800dffe:	d0ef      	beq.n	800dfe0 <onotify+0x10>
 800e000:	b662      	cpsie	i
      osalSysUnlock();

      usbPrepareQueuedTransmit(sdup->config->usbp,
 800e002:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800e006:	6810      	ldr	r0, [r2, #0]
 800e008:	7911      	ldrb	r1, [r2, #4]
 800e00a:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800e00e:	f000 fa37 	bl	800e480 <usbPrepareQueuedTransmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e012:	b672      	cpsid	i
                               sdup->config->bulk_in,
                               &sdup->oqueue, n);

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 800e014:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
    }
  }
}
 800e018:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usbPrepareQueuedTransmit(sdup->config->usbp,
                               sdup->config->bulk_in,
                               &sdup->oqueue, n);

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 800e01c:	6818      	ldr	r0, [r3, #0]
 800e01e:	7919      	ldrb	r1, [r3, #4]
 800e020:	f000 ba56 	b.w	800e4d0 <usbStartTransmitI>
	...

0800e030 <inotify>:
/**
 * @brief   Notification of data removed from the input queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void inotify(io_queue_t *qp) {
 800e030:	b510      	push	{r4, lr}
  size_t n, maxsize;
  SerialUSBDriver *sdup = qGetLink(qp);
 800e032:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800e034:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800e038:	6813      	ldr	r3, [r2, #0]
 800e03a:	7819      	ldrb	r1, [r3, #0]
 800e03c:	2904      	cmp	r1, #4
 800e03e:	d000      	beq.n	800e042 <inotify+0x12>
 800e040:	bd10      	pop	{r4, pc}
 800e042:	7a21      	ldrb	r1, [r4, #8]
 800e044:	2902      	cmp	r1, #2
 800e046:	d1fb      	bne.n	800e040 <inotify+0x10>
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800e048:	7951      	ldrb	r1, [r2, #5]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800e04a:	8958      	ldrh	r0, [r3, #10]
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800e04c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800e050:	2201      	movs	r2, #1
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800e052:	68db      	ldr	r3, [r3, #12]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800e054:	408a      	lsls	r2, r1
 800e056:	4202      	tst	r2, r0
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800e058:	8a5b      	ldrh	r3, [r3, #18]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800e05a:	d1f1      	bne.n	800e040 <inotify+0x10>
 */
static inline size_t chIQGetEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 800e05c:	69a2      	ldr	r2, [r4, #24]
 800e05e:	69e1      	ldr	r1, [r4, #28]
 800e060:	6960      	ldr	r0, [r4, #20]
 800e062:	1a89      	subs	r1, r1, r2
 800e064:	1a0a      	subs	r2, r1, r0
    if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 800e066:	4293      	cmp	r3, r2
 800e068:	d8ea      	bhi.n	800e040 <inotify+0x10>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e06a:	b662      	cpsie	i
      osalSysUnlock();

      n = (n / maxsize) * maxsize;
 800e06c:	fbb2 f2f3 	udiv	r2, r2, r3
      usbPrepareQueuedReceive(sdup->config->usbp,
 800e070:	f8d4 1254 	ldr.w	r1, [r4, #596]	; 0x254
 800e074:	fb03 f302 	mul.w	r3, r3, r2
 800e078:	6808      	ldr	r0, [r1, #0]
 800e07a:	7949      	ldrb	r1, [r1, #5]
 800e07c:	f104 020c 	add.w	r2, r4, #12
 800e080:	f000 f9ee 	bl	800e460 <usbPrepareQueuedReceive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e084:	b672      	cpsid	i
                              sdup->config->bulk_out,
                              &sdup->iqueue, n);

      osalSysLock();
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 800e086:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
    }
  }
}
 800e08a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usbPrepareQueuedReceive(sdup->config->usbp,
                              sdup->config->bulk_out,
                              &sdup->iqueue, n);

      osalSysLock();
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 800e08e:	6818      	ldr	r0, [r3, #0]
 800e090:	7959      	ldrb	r1, [r3, #5]
 800e092:	f000 ba05 	b.w	800e4a0 <usbStartReceiveI>
 800e096:	bf00      	nop
	...

0800e0a0 <readt>:
  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp, n, timeout);
 800e0a0:	300c      	adds	r0, #12
 800e0a2:	f7ff bd45 	b.w	800db30 <chIQReadTimeout>
 800e0a6:	bf00      	nop
	...

0800e0b0 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp,
 800e0b0:	300c      	adds	r0, #12
 800e0b2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800e0b6:	f7ff bd3b 	b.w	800db30 <chIQReadTimeout>
 800e0ba:	bf00      	nop
 800e0bc:	0000      	movs	r0, r0
	...

0800e0c0 <writet>:
  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
 800e0c0:	3030      	adds	r0, #48	; 0x30
 800e0c2:	f7ff bdad 	b.w	800dc20 <chOQWriteTimeout>
 800e0c6:	bf00      	nop
	...

0800e0d0 <write>:
 * Interface implementation.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp,
 800e0d0:	3030      	adds	r0, #48	; 0x30
 800e0d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800e0d6:	f7ff bda3 	b.w	800dc20 <chOQWriteTimeout>
 800e0da:	bf00      	nop
 800e0dc:	0000      	movs	r0, r0
	...

0800e0e0 <gett>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
 800e0e0:	300c      	adds	r0, #12
 800e0e2:	f7ff bd05 	b.w	800daf0 <chIQGetTimeout>
 800e0e6:	bf00      	nop
	...

0800e0f0 <get>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, TIME_INFINITE);
 800e0f0:	300c      	adds	r0, #12
 800e0f2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800e0f6:	f7ff bcfb 	b.w	800daf0 <chIQGetTimeout>
 800e0fa:	bf00      	nop
 800e0fc:	0000      	movs	r0, r0
	...

0800e100 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
 800e100:	3030      	adds	r0, #48	; 0x30
 800e102:	f7ff bd65 	b.w	800dbd0 <chOQPutTimeout>
 800e106:	bf00      	nop
	...

0800e110 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
 800e110:	3030      	adds	r0, #48	; 0x30
 800e112:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800e116:	f7ff bd5b 	b.w	800dbd0 <chOQPutTimeout>
 800e11a:	bf00      	nop
 800e11c:	0000      	movs	r0, r0
	...

0800e120 <sduInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
 800e120:	4770      	bx	lr
 800e122:	bf00      	nop
	...

0800e130 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800e130:	b510      	push	{r4, lr}

  sdup->vmt = &vmt;
 800e132:	4603      	mov	r3, r0
 800e134:	4a0e      	ldr	r2, [pc, #56]	; (800e170 <sduObjectInit+0x40>)
 800e136:	f843 2b04 	str.w	r2, [r3], #4
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800e13a:	b082      	sub	sp, #8
 800e13c:	4604      	mov	r4, r0

  sdup->vmt = &vmt;
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 800e13e:	2201      	movs	r2, #1
  iqObjectInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
 800e140:	9000      	str	r0, [sp, #0]
 800e142:	f104 0154 	add.w	r1, r4, #84	; 0x54
 800e146:	6043      	str	r3, [r0, #4]
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 800e148:	7202      	strb	r2, [r0, #8]
  iqObjectInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
 800e14a:	4b0a      	ldr	r3, [pc, #40]	; (800e174 <sduObjectInit+0x44>)
 800e14c:	300c      	adds	r0, #12
 800e14e:	f44f 7280 	mov.w	r2, #256	; 0x100
 800e152:	f7ff fcad 	bl	800dab0 <chIQObjectInit>
  oqObjectInit(&sdup->oqueue, sdup->ob, SERIAL_USB_BUFFERS_SIZE, onotify, sdup);
 800e156:	9400      	str	r4, [sp, #0]
 800e158:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800e15c:	f504 71aa 	add.w	r1, r4, #340	; 0x154
 800e160:	f44f 7280 	mov.w	r2, #256	; 0x100
 800e164:	4b04      	ldr	r3, [pc, #16]	; (800e178 <sduObjectInit+0x48>)
 800e166:	f7ff fd13 	bl	800db90 <chOQObjectInit>
}
 800e16a:	b002      	add	sp, #8
 800e16c:	bd10      	pop	{r4, pc}
 800e16e:	bf00      	nop
 800e170:	08016660 	.word	0x08016660
 800e174:	0800e031 	.word	0x0800e031
 800e178:	0800dfd1 	.word	0x0800dfd1
 800e17c:	00000000 	.word	0x00000000

0800e180 <sduStart>:
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
  USBDriver *usbp = config->usbp;
 800e180:	680b      	ldr	r3, [r1, #0]
 800e182:	b672      	cpsid	i
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800e184:	790a      	ldrb	r2, [r1, #4]
 800e186:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800e18a:	6190      	str	r0, [r2, #24]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800e18c:	794a      	ldrb	r2, [r1, #5]
 800e18e:	3209      	adds	r2, #9
 800e190:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 800e194:	798a      	ldrb	r2, [r1, #6]
 800e196:	b112      	cbz	r2, 800e19e <sduStart+0x1e>
    usbp->in_params[config->int_in - 1U]  = sdup;
 800e198:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800e19c:	6198      	str	r0, [r3, #24]
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 800e19e:	2302      	movs	r3, #2
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  usbp->out_params[config->bulk_out - 1U] = sdup;
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
  }
  sdup->config = config;
 800e1a0:	f8c0 1254 	str.w	r1, [r0, #596]	; 0x254
  sdup->state = SDU_READY;
 800e1a4:	7203      	strb	r3, [r0, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e1a6:	b662      	cpsie	i
 800e1a8:	4770      	bx	lr
 800e1aa:	bf00      	nop
 800e1ac:	0000      	movs	r0, r0
	...

0800e1b0 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800e1b0:	b570      	push	{r4, r5, r6, lr}
  USBDriver *usbp = sdup->config->usbp;
 800e1b2:	f8d0 3254 	ldr.w	r3, [r0, #596]	; 0x254

  iqResetI(&sdup->iqueue);
 800e1b6:	f100 060c 	add.w	r6, r0, #12
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800e1ba:	4604      	mov	r4, r0
  USBDriver *usbp = sdup->config->usbp;

  iqResetI(&sdup->iqueue);
 800e1bc:	4630      	mov	r0, r6
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
  USBDriver *usbp = sdup->config->usbp;
 800e1be:	681d      	ldr	r5, [r3, #0]

  iqResetI(&sdup->iqueue);
 800e1c0:	f7ff fc86 	bl	800dad0 <chIQResetI>
  oqResetI(&sdup->oqueue);
 800e1c4:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800e1c8:	f7ff fcf2 	bl	800dbb0 <chOQResetI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800e1cc:	1d20      	adds	r0, r4, #4
 800e1ce:	2101      	movs	r1, #1
 800e1d0:	f7ff fc36 	bl	800da40 <chEvtBroadcastFlagsI>
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 800e1d4:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800e1d8:	7959      	ldrb	r1, [r3, #5]
 800e1da:	eb05 0381 	add.w	r3, r5, r1, lsl #2
  iqResetI(&sdup->iqueue);
  oqResetI(&sdup->oqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 800e1de:	4628      	mov	r0, r5
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 800e1e0:	68db      	ldr	r3, [r3, #12]
  iqResetI(&sdup->iqueue);
  oqResetI(&sdup->oqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 800e1e2:	4632      	mov	r2, r6
 800e1e4:	8a5b      	ldrh	r3, [r3, #18]
 800e1e6:	f000 f93b 	bl	800e460 <usbPrepareQueuedReceive>
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 800e1ea:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800e1ee:	4628      	mov	r0, r5
 800e1f0:	7959      	ldrb	r1, [r3, #5]
}
 800e1f2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 800e1f6:	f000 b953 	b.w	800e4a0 <usbStartReceiveI>
 800e1fa:	bf00      	nop
 800e1fc:	0000      	movs	r0, r0
	...

0800e200 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 800e200:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 800e204:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800e208:	2b20      	cmp	r3, #32
 800e20a:	d001      	beq.n	800e210 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 800e20c:	2000      	movs	r0, #0
    }
  }
  return false;
}
 800e20e:	4770      	bx	lr
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
    switch (usbp->setup[1]) {
 800e210:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 800e214:	2b21      	cmp	r3, #33	; 0x21
 800e216:	d003      	beq.n	800e220 <sduRequestsHook+0x20>
 800e218:	2b22      	cmp	r3, #34	; 0x22
 800e21a:	d009      	beq.n	800e230 <sduRequestsHook+0x30>
 800e21c:	2b20      	cmp	r3, #32
 800e21e:	d1f5      	bne.n	800e20c <sduRequestsHook+0xc>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800e220:	4b06      	ldr	r3, [pc, #24]	; (800e23c <sduRequestsHook+0x3c>)
 800e222:	6383      	str	r3, [r0, #56]	; 0x38
 800e224:	2207      	movs	r2, #7
 800e226:	2300      	movs	r3, #0
 800e228:	63c2      	str	r2, [r0, #60]	; 0x3c
 800e22a:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 800e22c:	2001      	movs	r0, #1
 800e22e:	4770      	bx	lr
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800e230:	2300      	movs	r3, #0
 800e232:	6383      	str	r3, [r0, #56]	; 0x38
 800e234:	63c3      	str	r3, [r0, #60]	; 0x3c
 800e236:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 800e238:	2001      	movs	r0, #1
 800e23a:	4770      	bx	lr
 800e23c:	20000800 	.word	0x20000800

0800e240 <sduDataTransmitted>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800e240:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800e244:	b570      	push	{r4, r5, r6, lr}
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800e246:	699c      	ldr	r4, [r3, #24]

  if (sdup == NULL) {
 800e248:	b19c      	cbz	r4, 800e272 <sduDataTransmitted+0x32>
 800e24a:	460e      	mov	r6, r1
 800e24c:	4605      	mov	r5, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e24e:	b672      	cpsid	i
 800e250:	2108      	movs	r1, #8
 800e252:	1d20      	adds	r0, r4, #4
 800e254:	f7ff fbf4 	bl	800da40 <chEvtBroadcastFlagsI>
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800e258:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800e25a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800e25c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800e25e:	1ad3      	subs	r3, r2, r3

  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 800e260:	1a5b      	subs	r3, r3, r1
 800e262:	d10b      	bne.n	800e27c <sduDataTransmitted+0x3c>
    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800e264:	eb05 0386 	add.w	r3, r5, r6, lsl #2
 800e268:	68db      	ldr	r3, [r3, #12]
 800e26a:	695a      	ldr	r2, [r3, #20]
 800e26c:	6852      	ldr	r2, [r2, #4]
 800e26e:	b90a      	cbnz	r2, 800e274 <sduDataTransmitted+0x34>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e270:	b662      	cpsie	i
 800e272:	bd70      	pop	{r4, r5, r6, pc}
           ((usbp->epc[ep]->in_state->txsize &
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 800e274:	8a1b      	ldrh	r3, [r3, #16]
 800e276:	3b01      	subs	r3, #1
    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800e278:	4013      	ands	r3, r2
 800e27a:	d1f9      	bne.n	800e270 <sduDataTransmitted+0x30>
 800e27c:	b662      	cpsie	i
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    osalSysUnlockFromISR();

    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, 0);
 800e27e:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800e282:	4628      	mov	r0, r5
 800e284:	4631      	mov	r1, r6
 800e286:	f000 f8fb 	bl	800e480 <usbPrepareQueuedTransmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e28a:	b672      	cpsid	i

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
 800e28c:	4628      	mov	r0, r5
 800e28e:	4631      	mov	r1, r6
 800e290:	f000 f91e 	bl	800e4d0 <usbStartTransmitI>
 800e294:	e7ec      	b.n	800e270 <sduDataTransmitted+0x30>
 800e296:	bf00      	nop
	...

0800e2a0 <sduDataReceived>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800e2a0:	f101 0309 	add.w	r3, r1, #9
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 800e2a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800e2a8:	f850 6023 	ldr.w	r6, [r0, r3, lsl #2]

  if (sdup == NULL) {
 800e2ac:	b196      	cbz	r6, 800e2d4 <sduDataReceived+0x34>
 800e2ae:	4680      	mov	r8, r0
 800e2b0:	460f      	mov	r7, r1
 800e2b2:	b672      	cpsid	i
 800e2b4:	2104      	movs	r1, #4
 800e2b6:	1870      	adds	r0, r6, r1
 800e2b8:	f7ff fbc2 	bl	800da40 <chEvtBroadcastFlagsI>
  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Writes to the input queue can only happen when there is enough space
     to hold at least one packet.*/
  maxsize = usbp->epc[ep]->out_maxsize;
 800e2bc:	eb08 0387 	add.w	r3, r8, r7, lsl #2
 */
static inline size_t chIQGetEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 800e2c0:	69b4      	ldr	r4, [r6, #24]
 800e2c2:	68da      	ldr	r2, [r3, #12]
 800e2c4:	69f5      	ldr	r5, [r6, #28]
 800e2c6:	6973      	ldr	r3, [r6, #20]
 800e2c8:	8a51      	ldrh	r1, [r2, #18]
 800e2ca:	1b2d      	subs	r5, r5, r4
 800e2cc:	1aec      	subs	r4, r5, r3
  if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 800e2ce:	42a1      	cmp	r1, r4
 800e2d0:	d902      	bls.n	800e2d8 <sduDataReceived+0x38>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e2d2:	b662      	cpsie	i
 800e2d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e2d8:	b662      	cpsie	i
    /* The endpoint cannot be busy, we are in the context of the callback,
       so a packet is in the buffer for sure.*/
    osalSysUnlockFromISR();

    n = (n / maxsize) * maxsize;
 800e2da:	fbb4 f3f1 	udiv	r3, r4, r1
    usbPrepareQueuedReceive(usbp, ep, &sdup->iqueue, n);
 800e2de:	f106 020c 	add.w	r2, r6, #12
 800e2e2:	fb01 f303 	mul.w	r3, r1, r3
 800e2e6:	4640      	mov	r0, r8
 800e2e8:	4639      	mov	r1, r7
 800e2ea:	f000 f8b9 	bl	800e460 <usbPrepareQueuedReceive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e2ee:	b672      	cpsid	i

    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, ep);
 800e2f0:	4640      	mov	r0, r8
 800e2f2:	4639      	mov	r1, r7
 800e2f4:	f000 f8d4 	bl	800e4a0 <usbStartReceiveI>
 800e2f8:	e7eb      	b.n	800e2d2 <sduDataReceived+0x32>
 800e2fa:	bf00      	nop
 800e2fc:	0000      	movs	r0, r0
	...

0800e300 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 800e300:	4770      	bx	lr
 800e302:	bf00      	nop
	...

0800e310 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
 800e310:	f002 bd46 	b.w	8010da0 <spi_lld_init>
	...

0800e320 <spiObjectInit>:
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
  spip->config = NULL;
 800e320:	2300      	movs	r3, #0
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 800e322:	2201      	movs	r2, #1
 800e324:	7002      	strb	r2, [r0, #0]
  spip->config = NULL;
 800e326:	6043      	str	r3, [r0, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 800e328:	6083      	str	r3, [r0, #8]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 800e32a:	300c      	adds	r0, #12
 800e32c:	f7ff bac8 	b.w	800d8c0 <chMtxObjectInit>

0800e330 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 800e330:	b510      	push	{r4, lr}
 800e332:	4604      	mov	r4, r0
 800e334:	b672      	cpsid	i
  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 800e336:	6041      	str	r1, [r0, #4]
  spi_lld_start(spip);
 800e338:	f002 fd5a 	bl	8010df0 <spi_lld_start>
  spip->state = SPI_READY;
 800e33c:	2302      	movs	r3, #2
 800e33e:	7023      	strb	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e340:	b662      	cpsie	i
 800e342:	bd10      	pop	{r4, pc}
	...

0800e350 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 800e350:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e352:	b672      	cpsid	i

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 800e354:	f002 fd9c 	bl	8010e90 <spi_lld_select>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e358:	b662      	cpsie	i
 800e35a:	bd08      	pop	{r3, pc}
 800e35c:	0000      	movs	r0, r0
	...

0800e360 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 800e360:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e362:	b672      	cpsid	i

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
 800e364:	f002 fd9c 	bl	8010ea0 <spi_lld_unselect>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e368:	b662      	cpsie	i
 800e36a:	bd08      	pop	{r3, pc}
 800e36c:	0000      	movs	r0, r0
	...

0800e370 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 800e370:	b538      	push	{r3, r4, r5, lr}
 800e372:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e374:	b672      	cpsid	i
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 800e376:	2503      	movs	r5, #3
 800e378:	f804 5b08 	strb.w	r5, [r4], #8
 800e37c:	f002 fd98 	bl	8010eb0 <spi_lld_exchange>
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 800e380:	4620      	mov	r0, r4
 800e382:	f7ff f9ed 	bl	800d760 <chThdSuspendS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e386:	b662      	cpsie	i
 800e388:	bd38      	pop	{r3, r4, r5, pc}
 800e38a:	bf00      	nop
 800e38c:	0000      	movs	r0, r0
	...

0800e390 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 800e390:	b510      	push	{r4, lr}
 800e392:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e394:	b672      	cpsid	i
  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
 800e396:	2303      	movs	r3, #3
 800e398:	f804 3b08 	strb.w	r3, [r4], #8
 800e39c:	f002 fda8 	bl	8010ef0 <spi_lld_send>
 800e3a0:	4620      	mov	r0, r4
 800e3a2:	f7ff f9dd 	bl	800d760 <chThdSuspendS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e3a6:	b662      	cpsie	i
 800e3a8:	bd10      	pop	{r4, pc}
 800e3aa:	bf00      	nop
 800e3ac:	0000      	movs	r0, r0
	...

0800e3b0 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 800e3b0:	b510      	push	{r4, lr}
 800e3b2:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e3b4:	b672      	cpsid	i
  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartReceiveI(spip, n, rxbuf);
 800e3b6:	2303      	movs	r3, #3
 800e3b8:	f804 3b08 	strb.w	r3, [r4], #8
 800e3bc:	f002 fdb8 	bl	8010f30 <spi_lld_receive>
 800e3c0:	4620      	mov	r0, r4
 800e3c2:	f7ff f9cd 	bl	800d760 <chThdSuspendS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e3c6:	b662      	cpsie	i
 800e3c8:	bd10      	pop	{r4, pc}
 800e3ca:	bf00      	nop
 800e3cc:	0000      	movs	r0, r0
	...

0800e3d0 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 800e3d0:	f002 b8ce 	b.w	8010570 <usb_lld_init>
	...

0800e3e0 <usbObjectInit>:
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 800e3e0:	2300      	movs	r3, #0
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 800e3e2:	2201      	movs	r2, #1
 800e3e4:	7002      	strb	r2, [r0, #0]
  usbp->config       = NULL;
 800e3e6:	6043      	str	r3, [r0, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800e3e8:	61c3      	str	r3, [r0, #28]
    usbp->out_params[i] = NULL;
 800e3ea:	6283      	str	r3, [r0, #40]	; 0x28
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800e3ec:	6203      	str	r3, [r0, #32]
    usbp->out_params[i] = NULL;
 800e3ee:	62c3      	str	r3, [r0, #44]	; 0x2c
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800e3f0:	6243      	str	r3, [r0, #36]	; 0x24
    usbp->out_params[i] = NULL;
 800e3f2:	6303      	str	r3, [r0, #48]	; 0x30
  }
  usbp->transmitting = 0;
 800e3f4:	8103      	strh	r3, [r0, #8]
  usbp->receiving    = 0;
 800e3f6:	8143      	strh	r3, [r0, #10]
 800e3f8:	4770      	bx	lr
 800e3fa:	bf00      	nop
 800e3fc:	0000      	movs	r0, r0
	...

0800e400 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 800e400:	b510      	push	{r4, lr}
 800e402:	4604      	mov	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e404:	b672      	cpsid	i
  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 800e406:	2300      	movs	r3, #0
 800e408:	60c3      	str	r3, [r0, #12]
 800e40a:	6103      	str	r3, [r0, #16]
 800e40c:	6143      	str	r3, [r0, #20]
 800e40e:	6183      	str	r3, [r0, #24]
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 800e410:	6041      	str	r1, [r0, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 800e412:	f002 f8c5 	bl	80105a0 <usb_lld_start>
  usbp->state = USB_READY;
 800e416:	2302      	movs	r3, #2
 800e418:	7023      	strb	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e41a:	b662      	cpsie	i
 800e41c:	bd10      	pop	{r4, pc}
 800e41e:	bf00      	nop

0800e420 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 800e420:	b570      	push	{r4, r5, r6, lr}
 800e422:	4606      	mov	r6, r0
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 800e424:	6950      	ldr	r0, [r2, #20]
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 800e426:	4614      	mov	r4, r2
 800e428:	460d      	mov	r5, r1
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 800e42a:	b118      	cbz	r0, 800e434 <usbInitEndpointI+0x14>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 800e42c:	2100      	movs	r1, #0
 800e42e:	2214      	movs	r2, #20
 800e430:	f004 fb46 	bl	8012ac0 <memset>
  }
  if (epcp->out_state != NULL) {
 800e434:	69a0      	ldr	r0, [r4, #24]
 800e436:	b118      	cbz	r0, 800e440 <usbInitEndpointI+0x20>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800e438:	2100      	movs	r1, #0
 800e43a:	2214      	movs	r2, #20
 800e43c:	f004 fb40 	bl	8012ac0 <memset>
  }

  usbp->epc[ep] = epcp;
 800e440:	eb06 0385 	add.w	r3, r6, r5, lsl #2

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800e444:	4630      	mov	r0, r6
  }
  if (epcp->out_state != NULL) {
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
  }

  usbp->epc[ep] = epcp;
 800e446:	60dc      	str	r4, [r3, #12]

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800e448:	4629      	mov	r1, r5
}
 800e44a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }

  usbp->epc[ep] = epcp;

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800e44e:	f002 b997 	b.w	8010780 <usb_lld_init_endpoint>
 800e452:	bf00      	nop
	...

0800e460 <usbPrepareQueuedReceive>:
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
 800e460:	b470      	push	{r4, r5, r6}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800e462:	eb00 0481 	add.w	r4, r0, r1, lsl #2

  osp->rxqueued           = true;
 800e466:	2601      	movs	r6, #1
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800e468:	68e4      	ldr	r4, [r4, #12]
 800e46a:	69a4      	ldr	r4, [r4, #24]

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800e46c:	2500      	movs	r5, #0
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
 800e46e:	60e2      	str	r2, [r4, #12]
  osp->rxsize             = n;
 800e470:	6063      	str	r3, [r4, #4]
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
 800e472:	7026      	strb	r6, [r4, #0]
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800e474:	60a5      	str	r5, [r4, #8]

  usb_lld_prepare_receive(usbp, ep);
}
 800e476:	bc70      	pop	{r4, r5, r6}
  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 800e478:	f002 ba62 	b.w	8010940 <usb_lld_prepare_receive>
 800e47c:	0000      	movs	r0, r0
	...

0800e480 <usbPrepareQueuedTransmit>:
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
 800e480:	b470      	push	{r4, r5, r6}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800e482:	eb00 0481 	add.w	r4, r0, r1, lsl #2

  isp->txqueued           = true;
 800e486:	2601      	movs	r6, #1
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800e488:	68e4      	ldr	r4, [r4, #12]
 800e48a:	6964      	ldr	r4, [r4, #20]

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;
 800e48c:	2500      	movs	r5, #0
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
 800e48e:	60e2      	str	r2, [r4, #12]
  isp->txsize             = n;
 800e490:	6063      	str	r3, [r4, #4]
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
 800e492:	7026      	strb	r6, [r4, #0]
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;
 800e494:	60a5      	str	r5, [r4, #8]

  usb_lld_prepare_transmit(usbp, ep);
}
 800e496:	bc70      	pop	{r4, r5, r6}
  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800e498:	f002 baca 	b.w	8010a30 <usb_lld_prepare_transmit>
 800e49c:	0000      	movs	r0, r0
	...

0800e4a0 <usbStartReceiveI>:
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 800e4a0:	2201      	movs	r2, #1
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {
 800e4a2:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 800e4a4:	fa02 f301 	lsl.w	r3, r2, r1
 800e4a8:	8944      	ldrh	r4, [r0, #10]
 800e4aa:	b29b      	uxth	r3, r3
 800e4ac:	ea13 0604 	ands.w	r6, r3, r4
 800e4b0:	d001      	beq.n	800e4b6 <usbStartReceiveI+0x16>
    return true;
 800e4b2:	4610      	mov	r0, r2
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_out(usbp, ep);
  return false;
}
 800e4b4:	bd70      	pop	{r4, r5, r6, pc}

  if (usbGetReceiveStatusI(usbp, ep)) {
    return true;
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800e4b6:	4323      	orrs	r3, r4
 800e4b8:	8143      	strh	r3, [r0, #10]
  usb_lld_start_out(usbp, ep);
 800e4ba:	f002 fbb9 	bl	8010c30 <usb_lld_start_out>
  return false;
 800e4be:	4630      	mov	r0, r6
 800e4c0:	bd70      	pop	{r4, r5, r6, pc}
 800e4c2:	bf00      	nop
	...

0800e4d0 <usbStartTransmitI>:
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 800e4d0:	2201      	movs	r2, #1
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {
 800e4d2:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 800e4d4:	fa02 f301 	lsl.w	r3, r2, r1
 800e4d8:	8904      	ldrh	r4, [r0, #8]
 800e4da:	b29b      	uxth	r3, r3
 800e4dc:	ea13 0604 	ands.w	r6, r3, r4
 800e4e0:	d001      	beq.n	800e4e6 <usbStartTransmitI+0x16>
    return true;
 800e4e2:	4610      	mov	r0, r2
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_in(usbp, ep);
  return false;
}
 800e4e4:	bd70      	pop	{r4, r5, r6, pc}

  if (usbGetTransmitStatusI(usbp, ep)) {
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800e4e6:	4323      	orrs	r3, r4
 800e4e8:	8103      	strh	r3, [r0, #8]
  usb_lld_start_in(usbp, ep);
 800e4ea:	f002 fbb1 	bl	8010c50 <usb_lld_start_in>
  return false;
 800e4ee:	4630      	mov	r0, r6
 800e4f0:	bd70      	pop	{r4, r5, r6, pc}
 800e4f2:	bf00      	nop
	...

0800e500 <_usb_reset>:
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
  usbp->status        = 0;
 800e500:	2200      	movs	r2, #0
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
 800e502:	2102      	movs	r1, #2
 800e504:	7001      	strb	r1, [r0, #0]
  usbp->status        = 0;
 800e506:	f8a0 204c 	strh.w	r2, [r0, #76]	; 0x4c
  usbp->address       = 0;
 800e50a:	f880 204e 	strb.w	r2, [r0, #78]	; 0x4e
  usbp->configuration = 0;
 800e50e:	f880 204f 	strb.w	r2, [r0, #79]	; 0x4f
  usbp->transmitting  = 0;
 800e512:	8102      	strh	r2, [r0, #8]
  usbp->receiving     = 0;
 800e514:	8142      	strh	r2, [r0, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 800e516:	60c2      	str	r2, [r0, #12]
 800e518:	6102      	str	r2, [r0, #16]
 800e51a:	6142      	str	r2, [r0, #20]
 800e51c:	6182      	str	r2, [r0, #24]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800e51e:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

  /* Low level reset.*/
  usb_lld_reset(usbp);
 800e522:	f002 b8b5 	b.w	8010690 <usb_lld_reset>
 800e526:	bf00      	nop
	...

0800e530 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800e530:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800e532:	2300      	movs	r3, #0
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800e534:	4604      	mov	r4, r0
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800e536:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  usbReadSetup(usbp, ep, usbp->setup);
 800e53a:	f100 0244 	add.w	r2, r0, #68	; 0x44
 800e53e:	f002 f9ef 	bl	8010920 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 800e542:	6863      	ldr	r3, [r4, #4]
 800e544:	689b      	ldr	r3, [r3, #8]
 800e546:	b34b      	cbz	r3, 800e59c <_usb_ep0setup+0x6c>
      !(usbp->config->requests_hook_cb(usbp))) {
 800e548:	4620      	mov	r0, r4
 800e54a:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 800e54c:	b330      	cbz	r0, 800e59c <_usb_ep0setup+0x6c>
 800e54e:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 800e550:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800e554:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 800e558:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 800e55c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 800e560:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 800e562:	bf3c      	itt	cc
 800e564:	63e2      	strcc	r2, [r4, #60]	; 0x3c
 800e566:	4615      	movcc	r5, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800e568:	f013 0f80 	tst.w	r3, #128	; 0x80
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800e56c:	68e3      	ldr	r3, [r4, #12]
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800e56e:	f040 8081 	bne.w	800e674 <_usb_ep0setup+0x144>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 800e572:	2d00      	cmp	r5, #0
 800e574:	d169      	bne.n	800e64a <_usb_ep0setup+0x11a>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800e576:	695b      	ldr	r3, [r3, #20]
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 800e578:	2205      	movs	r2, #5
 800e57a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800e57e:	4620      	mov	r0, r4
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800e580:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 800e582:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800e584:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800e586:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800e588:	4629      	mov	r1, r5
 800e58a:	f002 fa51 	bl	8010a30 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e58e:	b672      	cpsid	i
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 800e590:	4620      	mov	r0, r4
 800e592:	4629      	mov	r1, r5
 800e594:	f7ff ff9c 	bl	800e4d0 <usbStartTransmitI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e598:	b662      	cpsie	i
 800e59a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800e59c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e5a0:	f013 0760 	ands.w	r7, r3, #96	; 0x60
 800e5a4:	d011      	beq.n	800e5ca <_usb_ep0setup+0x9a>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 800e5a6:	4620      	mov	r0, r4
 800e5a8:	2100      	movs	r1, #0
 800e5aa:	f002 fb79 	bl	8010ca0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800e5ae:	4620      	mov	r0, r4
 800e5b0:	2100      	movs	r1, #0
 800e5b2:	f002 fb65 	bl	8010c80 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800e5b6:	6863      	ldr	r3, [r4, #4]
 800e5b8:	681b      	ldr	r3, [r3, #0]
 800e5ba:	b113      	cbz	r3, 800e5c2 <_usb_ep0setup+0x92>
 800e5bc:	4620      	mov	r0, r4
 800e5be:	2105      	movs	r1, #5
 800e5c0:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800e5c2:	2306      	movs	r3, #6
 800e5c4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return;
 800e5c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 800e5ca:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800e5ce:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 800e5d2:	ea42 2605 	orr.w	r6, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800e5d6:	f5b6 7f40 	cmp.w	r6, #768	; 0x300
 800e5da:	f000 80f6 	beq.w	800e7ca <_usb_ep0setup+0x29a>
 800e5de:	d916      	bls.n	800e60e <_usb_ep0setup+0xde>
 800e5e0:	f5b6 6fc0 	cmp.w	r6, #1536	; 0x600
 800e5e4:	f000 80d8 	beq.w	800e798 <_usb_ep0setup+0x268>
 800e5e8:	d96d      	bls.n	800e6c6 <_usb_ep0setup+0x196>
 800e5ea:	f5b6 6f10 	cmp.w	r6, #2304	; 0x900
 800e5ee:	d07d      	beq.n	800e6ec <_usb_ep0setup+0x1bc>
 800e5f0:	f640 4202 	movw	r2, #3074	; 0xc02
 800e5f4:	4296      	cmp	r6, r2
 800e5f6:	f000 80fb 	beq.w	800e7f0 <_usb_ep0setup+0x2c0>
 800e5fa:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 800e5fe:	d1d2      	bne.n	800e5a6 <_usb_ep0setup+0x76>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 800e600:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 800e604:	2501      	movs	r5, #1
 800e606:	6427      	str	r7, [r4, #64]	; 0x40
 800e608:	63a2      	str	r2, [r4, #56]	; 0x38
 800e60a:	63e5      	str	r5, [r4, #60]	; 0x3c
 800e60c:	e7a2      	b.n	800e554 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800e60e:	2e02      	cmp	r6, #2
 800e610:	f000 80ab 	beq.w	800e76a <_usb_ep0setup+0x23a>
 800e614:	f240 80a0 	bls.w	800e758 <_usb_ep0setup+0x228>
 800e618:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 800e61c:	f000 808c 	beq.w	800e738 <_usb_ep0setup+0x208>
 800e620:	f5b6 7f81 	cmp.w	r6, #258	; 0x102
 800e624:	d1bf      	bne.n	800e5a6 <_usb_ep0setup+0x76>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800e626:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800e62a:	2a00      	cmp	r2, #0
 800e62c:	d1bb      	bne.n	800e5a6 <_usb_ep0setup+0x76>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800e62e:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 800e632:	f012 010f 	ands.w	r1, r2, #15
 800e636:	d054      	beq.n	800e6e2 <_usb_ep0setup+0x1b2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800e638:	0612      	lsls	r2, r2, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800e63a:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800e63c:	f100 8100 	bmi.w	800e840 <_usb_ep0setup+0x310>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 800e640:	f002 fb3e 	bl	8010cc0 <usb_lld_clear_out>
 800e644:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e648:	e04b      	b.n	800e6e2 <_usb_ep0setup+0x1b2>
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800e64a:	699b      	ldr	r3, [r3, #24]
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
 800e64c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800e64e:	2600      	movs	r6, #0
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 800e650:	2104      	movs	r1, #4
 800e652:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 800e656:	4620      	mov	r0, r4
 800e658:	4631      	mov	r1, r6
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
 800e65a:	60da      	str	r2, [r3, #12]
  osp->rxsize             = n;
 800e65c:	605d      	str	r5, [r3, #4]
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800e65e:	701e      	strb	r6, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800e660:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 800e662:	f002 f96d 	bl	8010940 <usb_lld_prepare_receive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e666:	b672      	cpsid	i
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      (void) usbStartReceiveI(usbp, 0);
 800e668:	4620      	mov	r0, r4
 800e66a:	4631      	mov	r1, r6
 800e66c:	f7ff ff18 	bl	800e4a0 <usbStartReceiveI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e670:	b662      	cpsie	i
 800e672:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 800e674:	b1a5      	cbz	r5, 800e6a0 <_usb_ep0setup+0x170>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800e676:	695b      	ldr	r3, [r3, #20]
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
 800e678:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800e67a:	2600      	movs	r6, #0
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 800e67c:	2101      	movs	r1, #1
 800e67e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800e682:	4620      	mov	r0, r4
 800e684:	4631      	mov	r1, r6
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
 800e686:	60da      	str	r2, [r3, #12]
  isp->txsize             = n;
 800e688:	605d      	str	r5, [r3, #4]
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800e68a:	701e      	strb	r6, [r3, #0]
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;
 800e68c:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800e68e:	f002 f9cf 	bl	8010a30 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e692:	b672      	cpsid	i
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 800e694:	4620      	mov	r0, r4
 800e696:	4631      	mov	r1, r6
 800e698:	f7ff ff1a 	bl	800e4d0 <usbStartTransmitI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e69c:	b662      	cpsie	i
 800e69e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800e6a0:	699b      	ldr	r3, [r3, #24]
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 800e6a2:	2203      	movs	r2, #3
 800e6a4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 800e6a8:	4620      	mov	r0, r4
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800e6aa:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 800e6ac:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 800e6ae:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 800e6b0:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 800e6b2:	4629      	mov	r1, r5
 800e6b4:	f002 f944 	bl	8010940 <usb_lld_prepare_receive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e6b8:	b672      	cpsid	i
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareReceive(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartReceiveI(usbp, 0);
 800e6ba:	4620      	mov	r0, r4
 800e6bc:	4629      	mov	r1, r5
 800e6be:	f7ff feef 	bl	800e4a0 <usbStartReceiveI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e6c2:	b662      	cpsie	i
 800e6c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800e6c6:	f240 3202 	movw	r2, #770	; 0x302
 800e6ca:	4296      	cmp	r6, r2
 800e6cc:	d021      	beq.n	800e712 <_usb_ep0setup+0x1e2>
 800e6ce:	f5b6 6fa0 	cmp.w	r6, #1280	; 0x500
 800e6d2:	f47f af68 	bne.w	800e5a6 <_usb_ep0setup+0x76>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800e6d6:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
 800e6da:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800e6de:	f000 809d 	beq.w	800e81c <_usb_ep0setup+0x2ec>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800e6e2:	2500      	movs	r5, #0
 800e6e4:	63a5      	str	r5, [r4, #56]	; 0x38
 800e6e6:	63e5      	str	r5, [r4, #60]	; 0x3c
 800e6e8:	6425      	str	r5, [r4, #64]	; 0x40
 800e6ea:	e733      	b.n	800e554 <_usb_ep0setup+0x24>
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 800e6ec:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800e6f0:	f884 204f 	strb.w	r2, [r4, #79]	; 0x4f
    if (usbp->configuration == 0U) {
 800e6f4:	2a00      	cmp	r2, #0
 800e6f6:	f040 8082 	bne.w	800e7fe <_usb_ep0setup+0x2ce>
      usbp->state = USB_SELECTED;
 800e6fa:	2203      	movs	r2, #3
 800e6fc:	7022      	strb	r2, [r4, #0]
    }
    else {
      usbp->state = USB_ACTIVE;
    }
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800e6fe:	6862      	ldr	r2, [r4, #4]
 800e700:	6812      	ldr	r2, [r2, #0]
 800e702:	2a00      	cmp	r2, #0
 800e704:	d0ed      	beq.n	800e6e2 <_usb_ep0setup+0x1b2>
 800e706:	4620      	mov	r0, r4
 800e708:	2102      	movs	r1, #2
 800e70a:	4790      	blx	r2
 800e70c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e710:	e7e7      	b.n	800e6e2 <_usb_ep0setup+0x1b2>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800e712:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800e716:	2a00      	cmp	r2, #0
 800e718:	f47f af45 	bne.w	800e5a6 <_usb_ep0setup+0x76>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800e71c:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 800e720:	f012 010f 	ands.w	r1, r2, #15
 800e724:	d0dd      	beq.n	800e6e2 <_usb_ep0setup+0x1b2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800e726:	0613      	lsls	r3, r2, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800e728:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800e72a:	f100 808e 	bmi.w	800e84a <_usb_ep0setup+0x31a>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 800e72e:	f002 faa7 	bl	8010c80 <usb_lld_stall_out>
 800e732:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e736:	e7d4      	b.n	800e6e2 <_usb_ep0setup+0x1b2>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800e738:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800e73c:	2a01      	cmp	r2, #1
 800e73e:	f47f af32 	bne.w	800e5a6 <_usb_ep0setup+0x76>
      usbp->status &= ~2U;
 800e742:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800e746:	63a7      	str	r7, [r4, #56]	; 0x38
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 800e748:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800e74c:	63e7      	str	r7, [r4, #60]	; 0x3c
 800e74e:	6427      	str	r7, [r4, #64]	; 0x40
 800e750:	463d      	mov	r5, r7
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 800e752:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 800e756:	e6fd      	b.n	800e554 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800e758:	2e00      	cmp	r6, #0
 800e75a:	d146      	bne.n	800e7ea <_usb_ep0setup+0x2ba>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 800e75c:	f104 024c 	add.w	r2, r4, #76	; 0x4c
 800e760:	2502      	movs	r5, #2
 800e762:	6426      	str	r6, [r4, #64]	; 0x40
 800e764:	63a2      	str	r2, [r4, #56]	; 0x38
 800e766:	63e5      	str	r5, [r4, #60]	; 0x3c
 800e768:	e6f4      	b.n	800e554 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800e76a:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
 800e76e:	f011 0f80 	tst.w	r1, #128	; 0x80
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800e772:	4620      	mov	r0, r4
 800e774:	f001 010f 	and.w	r1, r1, #15
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800e778:	d144      	bne.n	800e804 <_usb_ep0setup+0x2d4>
      default:
        return false;
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 800e77a:	f002 f8b1 	bl	80108e0 <usb_lld_get_status_out>
 800e77e:	2801      	cmp	r0, #1
 800e780:	d044      	beq.n	800e80c <_usb_ep0setup+0x2dc>
 800e782:	2802      	cmp	r0, #2
 800e784:	f47f af0f 	bne.w	800e5a6 <_usb_ep0setup+0x76>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800e788:	4b32      	ldr	r3, [pc, #200]	; (800e854 <_usb_ep0setup+0x324>)
 800e78a:	63a3      	str	r3, [r4, #56]	; 0x38
 800e78c:	63e0      	str	r0, [r4, #60]	; 0x3c
 800e78e:	6427      	str	r7, [r4, #64]	; 0x40
 800e790:	4605      	mov	r5, r0
 800e792:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e796:	e6dd      	b.n	800e554 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800e798:	6862      	ldr	r2, [r4, #4]

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800e79a:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 800e79e:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800e7a2:	6855      	ldr	r5, [r2, #4]
 800e7a4:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 800e7a8:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800e7ac:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800e7b0:	4620      	mov	r0, r4
 800e7b2:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 800e7b4:	2800      	cmp	r0, #0
 800e7b6:	f43f aef6 	beq.w	800e5a6 <_usb_ep0setup+0x76>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800e7ba:	6843      	ldr	r3, [r0, #4]
 800e7bc:	6805      	ldr	r5, [r0, #0]
 800e7be:	63e5      	str	r5, [r4, #60]	; 0x3c
 800e7c0:	63a3      	str	r3, [r4, #56]	; 0x38
 800e7c2:	6427      	str	r7, [r4, #64]	; 0x40
 800e7c4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e7c8:	e6c4      	b.n	800e554 <_usb_ep0setup+0x24>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800e7ca:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800e7ce:	2a01      	cmp	r2, #1
 800e7d0:	f47f aee9 	bne.w	800e5a6 <_usb_ep0setup+0x76>
      usbp->status |= 2U;
 800e7d4:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800e7d8:	63a7      	str	r7, [r4, #56]	; 0x38
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 800e7da:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800e7de:	63e7      	str	r7, [r4, #60]	; 0x3c
 800e7e0:	6427      	str	r7, [r4, #64]	; 0x40
 800e7e2:	463d      	mov	r5, r7
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 800e7e4:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 800e7e8:	e6b4      	b.n	800e554 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800e7ea:	2e01      	cmp	r6, #1
 800e7ec:	f47f aedb 	bne.w	800e5a6 <_usb_ep0setup+0x76>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 800e7f0:	4a19      	ldr	r2, [pc, #100]	; (800e858 <_usb_ep0setup+0x328>)
 800e7f2:	63a2      	str	r2, [r4, #56]	; 0x38
 800e7f4:	2502      	movs	r5, #2
 800e7f6:	2200      	movs	r2, #0
 800e7f8:	63e5      	str	r5, [r4, #60]	; 0x3c
 800e7fa:	6422      	str	r2, [r4, #64]	; 0x40
 800e7fc:	e6aa      	b.n	800e554 <_usb_ep0setup+0x24>
    usbp->configuration = usbp->setup[2];
    if (usbp->configuration == 0U) {
      usbp->state = USB_SELECTED;
    }
    else {
      usbp->state = USB_ACTIVE;
 800e7fe:	2204      	movs	r2, #4
 800e800:	7022      	strb	r2, [r4, #0]
 800e802:	e77c      	b.n	800e6fe <_usb_ep0setup+0x1ce>
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800e804:	f002 f87c 	bl	8010900 <usb_lld_get_status_in>
 800e808:	2801      	cmp	r0, #1
 800e80a:	d1ba      	bne.n	800e782 <_usb_ep0setup+0x252>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800e80c:	4b13      	ldr	r3, [pc, #76]	; (800e85c <_usb_ep0setup+0x32c>)
 800e80e:	63a3      	str	r3, [r4, #56]	; 0x38
 800e810:	63e6      	str	r6, [r4, #60]	; 0x3c
 800e812:	6427      	str	r7, [r4, #64]	; 0x40
 800e814:	4635      	mov	r5, r6
 800e816:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e81a:	e69b      	b.n	800e554 <_usb_ep0setup+0x24>
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 800e81c:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800e820:	f884 304e 	strb.w	r3, [r4, #78]	; 0x4e
  usb_lld_set_address(usbp);
 800e824:	4620      	mov	r0, r4
 800e826:	f001 ff9b 	bl	8010760 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 800e82a:	6863      	ldr	r3, [r4, #4]
 800e82c:	681b      	ldr	r3, [r3, #0]
 800e82e:	b113      	cbz	r3, 800e836 <_usb_ep0setup+0x306>
 800e830:	4620      	mov	r0, r4
 800e832:	2101      	movs	r1, #1
 800e834:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800e836:	2203      	movs	r2, #3
 800e838:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e83c:	7022      	strb	r2, [r4, #0]
 800e83e:	e750      	b.n	800e6e2 <_usb_ep0setup+0x1b2>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800e840:	f002 fa4e 	bl	8010ce0 <usb_lld_clear_in>
 800e844:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e848:	e74b      	b.n	800e6e2 <_usb_ep0setup+0x1b2>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800e84a:	f002 fa29 	bl	8010ca0 <usb_lld_stall_in>
 800e84e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800e852:	e746      	b.n	800e6e2 <_usb_ep0setup+0x1b2>
 800e854:	08016690 	.word	0x08016690
 800e858:	08016680 	.word	0x08016680
 800e85c:	080166a0 	.word	0x080166a0

0800e860 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 800e860:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800e862:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 800e866:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800e868:	2b06      	cmp	r3, #6
 800e86a:	d815      	bhi.n	800e898 <_usb_ep0in+0x38>
 800e86c:	e8df f003 	tbb	[pc, r3]
 800e870:	041c3104 	.word	0x041c3104
 800e874:	1504      	.short	0x1504
 800e876:	04          	.byte	0x04
 800e877:	00          	.byte	0x00
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800e878:	2100      	movs	r1, #0
 800e87a:	f002 fa11 	bl	8010ca0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800e87e:	4620      	mov	r0, r4
 800e880:	2100      	movs	r1, #0
 800e882:	f002 f9fd 	bl	8010c80 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800e886:	6863      	ldr	r3, [r4, #4]
 800e888:	681b      	ldr	r3, [r3, #0]
 800e88a:	b113      	cbz	r3, 800e892 <_usb_ep0in+0x32>
 800e88c:	4620      	mov	r0, r4
 800e88e:	2105      	movs	r1, #5
 800e890:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800e892:	2306      	movs	r3, #6
 800e894:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800e898:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 800e89a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800e89c:	b103      	cbz	r3, 800e8a0 <_usb_ep0in+0x40>
      usbp->ep0endcb(usbp);
 800e89e:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800e8a0:	2300      	movs	r3, #0
 800e8a2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return;
 800e8a6:	bd38      	pop	{r3, r4, r5, pc}
 800e8a8:	68c3      	ldr	r3, [r0, #12]
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800e8aa:	699b      	ldr	r3, [r3, #24]

  osp->rxqueued           = false;
 800e8ac:	2500      	movs	r5, #0
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 800e8ae:	2203      	movs	r2, #3
 800e8b0:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 800e8b4:	4629      	mov	r1, r5
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800e8b6:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 800e8b8:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 800e8ba:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 800e8bc:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 800e8be:	4620      	mov	r0, r4
 800e8c0:	f002 f83e 	bl	8010940 <usb_lld_prepare_receive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e8c4:	b672      	cpsid	i
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareReceive(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, 0);
 800e8c6:	4620      	mov	r0, r4
 800e8c8:	4629      	mov	r1, r5
 800e8ca:	f7ff fde9 	bl	800e4a0 <usbStartReceiveI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e8ce:	b662      	cpsie	i
 800e8d0:	bd38      	pop	{r3, r4, r5, pc}

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800e8d2:	f890 204b 	ldrb.w	r2, [r0, #75]	; 0x4b
 800e8d6:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800e8da:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 800e8dc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800e8e0:	428b      	cmp	r3, r1
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800e8e2:	68c3      	ldr	r3, [r0, #12]
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800e8e4:	d9e1      	bls.n	800e8aa <_usb_ep0in+0x4a>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800e8e6:	8a1d      	ldrh	r5, [r3, #16]
 800e8e8:	fbb1 f2f5 	udiv	r2, r1, r5
 800e8ec:	fb05 1512 	mls	r5, r5, r2, r1
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800e8f0:	2d00      	cmp	r5, #0
 800e8f2:	d1da      	bne.n	800e8aa <_usb_ep0in+0x4a>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800e8f4:	695b      	ldr	r3, [r3, #20]
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800e8f6:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800e8f8:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 800e8fa:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800e8fc:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800e8fe:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800e900:	f002 f896 	bl	8010a30 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e904:	b672      	cpsid	i
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 800e906:	4629      	mov	r1, r5
 800e908:	4620      	mov	r0, r4
 800e90a:	f7ff fde1 	bl	800e4d0 <usbStartTransmitI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e90e:	b662      	cpsie	i
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 800e910:	2302      	movs	r3, #2
 800e912:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return;
 800e916:	bd38      	pop	{r3, r4, r5, pc}
	...

0800e920 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 800e920:	f890 2034 	ldrb.w	r2, [r0, #52]	; 0x34
 800e924:	2a06      	cmp	r2, #6
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 800e926:	b538      	push	{r3, r4, r5, lr}
 800e928:	d80a      	bhi.n	800e940 <_usb_ep0out+0x20>
 800e92a:	2301      	movs	r3, #1
 800e92c:	4093      	lsls	r3, r2
 800e92e:	f013 0f67 	tst.w	r3, #103	; 0x67
 800e932:	4604      	mov	r4, r0
 800e934:	d111      	bne.n	800e95a <_usb_ep0out+0x3a>
 800e936:	f013 0508 	ands.w	r5, r3, #8
 800e93a:	d102      	bne.n	800e942 <_usb_ep0out+0x22>
 800e93c:	06db      	lsls	r3, r3, #27
 800e93e:	d41d      	bmi.n	800e97c <_usb_ep0out+0x5c>
 800e940:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeI(usbp, 0) != 0U) {
 800e942:	68c3      	ldr	r3, [r0, #12]
 800e944:	699b      	ldr	r3, [r3, #24]
 800e946:	689b      	ldr	r3, [r3, #8]
 800e948:	2b00      	cmp	r3, #0
 800e94a:	d1f9      	bne.n	800e940 <_usb_ep0out+0x20>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800e94c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800e94e:	b103      	cbz	r3, 800e952 <_usb_ep0out+0x32>
      usbp->ep0endcb(usbp);
 800e950:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800e952:	2300      	movs	r3, #0
 800e954:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return;
 800e958:	bd38      	pop	{r3, r4, r5, pc}
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800e95a:	2100      	movs	r1, #0
 800e95c:	f002 f9a0 	bl	8010ca0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800e960:	4620      	mov	r0, r4
 800e962:	2100      	movs	r1, #0
 800e964:	f002 f98c 	bl	8010c80 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800e968:	6863      	ldr	r3, [r4, #4]
 800e96a:	681b      	ldr	r3, [r3, #0]
 800e96c:	b113      	cbz	r3, 800e974 <_usb_ep0out+0x54>
 800e96e:	4620      	mov	r0, r4
 800e970:	2105      	movs	r1, #5
 800e972:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800e974:	2306      	movs	r3, #6
 800e976:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800e97a:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800e97c:	68c3      	ldr	r3, [r0, #12]
 800e97e:	695b      	ldr	r3, [r3, #20]

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 800e980:	2205      	movs	r2, #5
 800e982:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800e986:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800e988:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 800e98a:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800e98c:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800e98e:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800e990:	f002 f84e 	bl	8010a30 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e994:	b672      	cpsid	i
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareTransmit(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, 0);
 800e996:	4620      	mov	r0, r4
 800e998:	4629      	mov	r1, r5
 800e99a:	f7ff fd99 	bl	800e4d0 <usbStartTransmitI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800e99e:	b662      	cpsie	i
 800e9a0:	bd38      	pop	{r3, r4, r5, pc}
 800e9a2:	bf00      	nop
	...

0800e9b0 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800e9b0:	0943      	lsrs	r3, r0, #5
 800e9b2:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 800e9b4:	b410      	push	{r4}
 800e9b6:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800e9ba:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800e9be:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 800e9c2:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 800e9c6:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800e9c8:	f000 001f 	and.w	r0, r0, #31
 800e9cc:	2201      	movs	r2, #1
 800e9ce:	4082      	lsls	r2, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800e9d0:	b2c9      	uxtb	r1, r1
 800e9d2:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800e9d6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 800e9da:	601a      	str	r2, [r3, #0]
}
 800e9dc:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e9e0:	4770      	bx	lr
 800e9e2:	bf00      	nop
	...

0800e9f0 <nvicSetSystemHandlerPriority>:
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {

  osalDbgCheck(handler <= 12);

  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 800e9f0:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800e9f4:	f500 406d 	add.w	r0, r0, #60672	; 0xed00
 800e9f8:	0109      	lsls	r1, r1, #4
 800e9fa:	b2c9      	uxtb	r1, r1
 800e9fc:	7601      	strb	r1, [r0, #24]
 800e9fe:	4770      	bx	lr

0800ea00 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 800ea00:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800ea02:	4b07      	ldr	r3, [pc, #28]	; (800ea20 <Vector6C+0x20>)
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 800ea04:	4a07      	ldr	r2, [pc, #28]	; (800ea24 <Vector6C+0x24>)
OSAL_IRQ_HANDLER(Vector6C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800ea06:	6819      	ldr	r1, [r3, #0]
 800ea08:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0;
 800ea0c:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 800ea0e:	6813      	ldr	r3, [r2, #0]
 800ea10:	b10b      	cbz	r3, 800ea16 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 800ea12:	6850      	ldr	r0, [r2, #4]
 800ea14:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800ea16:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ea1a:	f7ff b989 	b.w	800dd30 <_port_irq_epilogue>
 800ea1e:	bf00      	nop
 800ea20:	40026000 	.word	0x40026000
 800ea24:	20001338 	.word	0x20001338
	...

0800ea30 <Vector70>:
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800ea30:	4b08      	ldr	r3, [pc, #32]	; (800ea54 <Vector70+0x24>)
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 800ea32:	4809      	ldr	r0, [pc, #36]	; (800ea58 <Vector70+0x28>)
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800ea34:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 800ea36:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800ea38:	0989      	lsrs	r1, r1, #6
 800ea3a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 800ea3e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
 800ea40:	018c      	lsls	r4, r1, #6
 800ea42:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 800ea44:	b10a      	cbz	r2, 800ea4a <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 800ea46:	68c0      	ldr	r0, [r0, #12]
 800ea48:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ea4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ea4e:	f7ff b96f 	b.w	800dd30 <_port_irq_epilogue>
 800ea52:	bf00      	nop
 800ea54:	40026000 	.word	0x40026000
 800ea58:	20001338 	.word	0x20001338
 800ea5c:	00000000 	.word	0x00000000

0800ea60 <Vector74>:
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800ea60:	4b08      	ldr	r3, [pc, #32]	; (800ea84 <Vector74+0x24>)
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 800ea62:	4809      	ldr	r0, [pc, #36]	; (800ea88 <Vector74+0x28>)
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800ea64:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 800ea66:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800ea68:	0c09      	lsrs	r1, r1, #16
 800ea6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 800ea6e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
 800ea70:	040c      	lsls	r4, r1, #16
 800ea72:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 800ea74:	b10a      	cbz	r2, 800ea7a <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 800ea76:	6940      	ldr	r0, [r0, #20]
 800ea78:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ea7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ea7e:	f7ff b957 	b.w	800dd30 <_port_irq_epilogue>
 800ea82:	bf00      	nop
 800ea84:	40026000 	.word	0x40026000
 800ea88:	20001338 	.word	0x20001338
 800ea8c:	00000000 	.word	0x00000000

0800ea90 <Vector78>:
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800ea90:	4b08      	ldr	r3, [pc, #32]	; (800eab4 <Vector78+0x24>)
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 800ea92:	4809      	ldr	r0, [pc, #36]	; (800eab8 <Vector78+0x28>)
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800ea94:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 800ea96:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800ea98:	0d89      	lsrs	r1, r1, #22
 800ea9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 800ea9e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
 800eaa0:	058c      	lsls	r4, r1, #22
 800eaa2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 800eaa4:	b10a      	cbz	r2, 800eaaa <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 800eaa6:	69c0      	ldr	r0, [r0, #28]
 800eaa8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800eaaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800eaae:	f7ff b93f 	b.w	800dd30 <_port_irq_epilogue>
 800eab2:	bf00      	nop
 800eab4:	40026000 	.word	0x40026000
 800eab8:	20001338 	.word	0x20001338
 800eabc:	00000000 	.word	0x00000000

0800eac0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 800eac0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800eac2:	4b07      	ldr	r3, [pc, #28]	; (800eae0 <Vector7C+0x20>)
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 800eac4:	4807      	ldr	r0, [pc, #28]	; (800eae4 <Vector7C+0x24>)
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800eac6:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 800eac8:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800eaca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0;
 800eace:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 800ead0:	b10a      	cbz	r2, 800ead6 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 800ead2:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800ead4:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ead6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800eada:	f7ff b929 	b.w	800dd30 <_port_irq_epilogue>
 800eade:	bf00      	nop
 800eae0:	40026000 	.word	0x40026000
 800eae4:	20001338 	.word	0x20001338
	...

0800eaf0 <Vector80>:
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800eaf0:	4b08      	ldr	r3, [pc, #32]	; (800eb14 <Vector80+0x24>)
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 800eaf2:	4809      	ldr	r0, [pc, #36]	; (800eb18 <Vector80+0x28>)
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800eaf4:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 800eaf6:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800eaf8:	0989      	lsrs	r1, r1, #6
 800eafa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 800eafe:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
 800eb00:	018c      	lsls	r4, r1, #6
 800eb02:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 800eb04:	b10a      	cbz	r2, 800eb0a <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 800eb06:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800eb08:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800eb0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800eb0e:	f7ff b90f 	b.w	800dd30 <_port_irq_epilogue>
 800eb12:	bf00      	nop
 800eb14:	40026000 	.word	0x40026000
 800eb18:	20001338 	.word	0x20001338
 800eb1c:	00000000 	.word	0x00000000

0800eb20 <Vector84>:
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800eb20:	4b08      	ldr	r3, [pc, #32]	; (800eb44 <Vector84+0x24>)
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 800eb22:	4809      	ldr	r0, [pc, #36]	; (800eb48 <Vector84+0x28>)
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800eb24:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 800eb26:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800eb28:	0c09      	lsrs	r1, r1, #16
 800eb2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 800eb2e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
 800eb30:	040c      	lsls	r4, r1, #16
 800eb32:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 800eb34:	b10a      	cbz	r2, 800eb3a <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 800eb36:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800eb38:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800eb3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800eb3e:	f7ff b8f7 	b.w	800dd30 <_port_irq_epilogue>
 800eb42:	bf00      	nop
 800eb44:	40026000 	.word	0x40026000
 800eb48:	20001338 	.word	0x20001338
 800eb4c:	00000000 	.word	0x00000000

0800eb50 <VectorFC>:
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800eb50:	4b08      	ldr	r3, [pc, #32]	; (800eb74 <VectorFC+0x24>)
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 800eb52:	4809      	ldr	r0, [pc, #36]	; (800eb78 <VectorFC+0x28>)
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800eb54:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 800eb56:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800eb58:	0d89      	lsrs	r1, r1, #22
 800eb5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 800eb5e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
 800eb60:	058c      	lsls	r4, r1, #22
 800eb62:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 800eb64:	b10a      	cbz	r2, 800eb6a <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 800eb66:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 800eb68:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800eb6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800eb6e:	f7ff b8df 	b.w	800dd30 <_port_irq_epilogue>
 800eb72:	bf00      	nop
 800eb74:	40026000 	.word	0x40026000
 800eb78:	20001338 	.word	0x20001338
 800eb7c:	00000000 	.word	0x00000000

0800eb80 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 800eb80:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800eb82:	4b07      	ldr	r3, [pc, #28]	; (800eba0 <Vector120+0x20>)
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 800eb84:	4807      	ldr	r0, [pc, #28]	; (800eba4 <Vector120+0x24>)
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800eb86:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 800eb88:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800eb8a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0;
 800eb8e:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 800eb90:	b10a      	cbz	r2, 800eb96 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 800eb92:	6c40      	ldr	r0, [r0, #68]	; 0x44
 800eb94:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800eb96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800eb9a:	f7ff b8c9 	b.w	800dd30 <_port_irq_epilogue>
 800eb9e:	bf00      	nop
 800eba0:	40026400 	.word	0x40026400
 800eba4:	20001338 	.word	0x20001338
	...

0800ebb0 <Vector124>:
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800ebb0:	4b08      	ldr	r3, [pc, #32]	; (800ebd4 <Vector124+0x24>)
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 800ebb2:	4809      	ldr	r0, [pc, #36]	; (800ebd8 <Vector124+0x28>)
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800ebb4:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 800ebb6:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800ebb8:	0989      	lsrs	r1, r1, #6
 800ebba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 800ebbe:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
 800ebc0:	018c      	lsls	r4, r1, #6
 800ebc2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 800ebc4:	b10a      	cbz	r2, 800ebca <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 800ebc6:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 800ebc8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ebca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ebce:	f7ff b8af 	b.w	800dd30 <_port_irq_epilogue>
 800ebd2:	bf00      	nop
 800ebd4:	40026400 	.word	0x40026400
 800ebd8:	20001338 	.word	0x20001338
 800ebdc:	00000000 	.word	0x00000000

0800ebe0 <Vector128>:
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800ebe0:	4b08      	ldr	r3, [pc, #32]	; (800ec04 <Vector128+0x24>)
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 800ebe2:	4809      	ldr	r0, [pc, #36]	; (800ec08 <Vector128+0x28>)
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800ebe4:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 800ebe6:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800ebe8:	0c09      	lsrs	r1, r1, #16
 800ebea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 800ebee:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
 800ebf0:	040c      	lsls	r4, r1, #16
 800ebf2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 800ebf4:	b10a      	cbz	r2, 800ebfa <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 800ebf6:	6d40      	ldr	r0, [r0, #84]	; 0x54
 800ebf8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ebfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ebfe:	f7ff b897 	b.w	800dd30 <_port_irq_epilogue>
 800ec02:	bf00      	nop
 800ec04:	40026400 	.word	0x40026400
 800ec08:	20001338 	.word	0x20001338
 800ec0c:	00000000 	.word	0x00000000

0800ec10 <Vector12C>:
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800ec10:	4b08      	ldr	r3, [pc, #32]	; (800ec34 <Vector12C+0x24>)
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 800ec12:	4809      	ldr	r0, [pc, #36]	; (800ec38 <Vector12C+0x28>)
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800ec14:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 800ec16:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800ec18:	0d89      	lsrs	r1, r1, #22
 800ec1a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 800ec1e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
 800ec20:	058c      	lsls	r4, r1, #22
 800ec22:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 800ec24:	b10a      	cbz	r2, 800ec2a <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 800ec26:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 800ec28:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ec2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ec2e:	f7ff b87f 	b.w	800dd30 <_port_irq_epilogue>
 800ec32:	bf00      	nop
 800ec34:	40026400 	.word	0x40026400
 800ec38:	20001338 	.word	0x20001338
 800ec3c:	00000000 	.word	0x00000000

0800ec40 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 800ec40:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800ec42:	4b07      	ldr	r3, [pc, #28]	; (800ec60 <Vector130+0x20>)
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 800ec44:	4807      	ldr	r0, [pc, #28]	; (800ec64 <Vector130+0x24>)
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800ec46:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 800ec48:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800ec4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0;
 800ec4e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 800ec50:	b10a      	cbz	r2, 800ec56 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 800ec52:	6e40      	ldr	r0, [r0, #100]	; 0x64
 800ec54:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ec56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ec5a:	f7ff b869 	b.w	800dd30 <_port_irq_epilogue>
 800ec5e:	bf00      	nop
 800ec60:	40026400 	.word	0x40026400
 800ec64:	20001338 	.word	0x20001338
	...

0800ec70 <Vector150>:
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800ec70:	4b08      	ldr	r3, [pc, #32]	; (800ec94 <Vector150+0x24>)
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 800ec72:	4809      	ldr	r0, [pc, #36]	; (800ec98 <Vector150+0x28>)
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800ec74:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 800ec76:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800ec78:	0989      	lsrs	r1, r1, #6
 800ec7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector150) {
 800ec7e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
 800ec80:	018c      	lsls	r4, r1, #6
 800ec82:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 800ec84:	b10a      	cbz	r2, 800ec8a <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 800ec86:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 800ec88:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ec8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ec8e:	f7ff b84f 	b.w	800dd30 <_port_irq_epilogue>
 800ec92:	bf00      	nop
 800ec94:	40026400 	.word	0x40026400
 800ec98:	20001338 	.word	0x20001338
 800ec9c:	00000000 	.word	0x00000000

0800eca0 <Vector154>:
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800eca0:	4b08      	ldr	r3, [pc, #32]	; (800ecc4 <Vector154+0x24>)
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 800eca2:	4809      	ldr	r0, [pc, #36]	; (800ecc8 <Vector154+0x28>)
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800eca4:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 800eca6:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800eca8:	0c09      	lsrs	r1, r1, #16
 800ecaa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector154) {
 800ecae:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
 800ecb0:	040c      	lsls	r4, r1, #16
 800ecb2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 800ecb4:	b10a      	cbz	r2, 800ecba <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 800ecb6:	6f40      	ldr	r0, [r0, #116]	; 0x74
 800ecb8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ecba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ecbe:	f7ff b837 	b.w	800dd30 <_port_irq_epilogue>
 800ecc2:	bf00      	nop
 800ecc4:	40026400 	.word	0x40026400
 800ecc8:	20001338 	.word	0x20001338
 800eccc:	00000000 	.word	0x00000000

0800ecd0 <Vector158>:
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800ecd0:	4b08      	ldr	r3, [pc, #32]	; (800ecf4 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 800ecd2:	4809      	ldr	r0, [pc, #36]	; (800ecf8 <Vector158+0x28>)
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800ecd4:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 800ecd6:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800ecd8:	0d89      	lsrs	r1, r1, #22
 800ecda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector158) {
 800ecde:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
 800ece0:	058c      	lsls	r4, r1, #22
 800ece2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 800ece4:	b10a      	cbz	r2, 800ecea <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 800ece6:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 800ece8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800ecea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ecee:	f7ff b81f 	b.w	800dd30 <_port_irq_epilogue>
 800ecf2:	bf00      	nop
 800ecf4:	40026400 	.word	0x40026400
 800ecf8:	20001338 	.word	0x20001338
 800ecfc:	00000000 	.word	0x00000000

0800ed00 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 800ed00:	4b0d      	ldr	r3, [pc, #52]	; (800ed38 <dmaInit+0x38>)
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 800ed02:	b430      	push	{r4, r5}
  int i;

  dma_streams_mask = 0;
 800ed04:	2200      	movs	r2, #0
 800ed06:	4d0d      	ldr	r5, [pc, #52]	; (800ed3c <dmaInit+0x3c>)
 800ed08:	4c0d      	ldr	r4, [pc, #52]	; (800ed40 <dmaInit+0x40>)
 800ed0a:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
 800ed0c:	4611      	mov	r1, r2
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800ed0e:	4613      	mov	r3, r2
    _stm32_dma_streams[i].stream->CR = 0;
 800ed10:	58a8      	ldr	r0, [r5, r2]
 800ed12:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 800ed14:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800ed18:	3301      	adds	r3, #1
 800ed1a:	2b10      	cmp	r3, #16
 800ed1c:	f102 020c 	add.w	r2, r2, #12
 800ed20:	d1f6      	bne.n	800ed10 <dmaInit+0x10>
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 800ed22:	4908      	ldr	r1, [pc, #32]	; (800ed44 <dmaInit+0x44>)
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
 800ed24:	4a08      	ldr	r2, [pc, #32]	; (800ed48 <dmaInit+0x48>)
  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 800ed26:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ed2a:	608b      	str	r3, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
  DMA2->HIFCR = 0xFFFFFFFF;
}
 800ed2c:	bc30      	pop	{r4, r5}
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
  DMA1->HIFCR = 0xFFFFFFFF;
 800ed2e:	60cb      	str	r3, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 800ed30:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 800ed32:	60d3      	str	r3, [r2, #12]
}
 800ed34:	4770      	bx	lr
 800ed36:	bf00      	nop
 800ed38:	200013b8 	.word	0x200013b8
 800ed3c:	080166b0 	.word	0x080166b0
 800ed40:	20001338 	.word	0x20001338
 800ed44:	40026000 	.word	0x40026000
 800ed48:	40026400 	.word	0x40026400
 800ed4c:	00000000 	.word	0x00000000

0800ed50 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 800ed50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 800ed52:	4f1f      	ldr	r7, [pc, #124]	; (800edd0 <dmaStreamAllocate+0x80>)
 800ed54:	7a46      	ldrb	r6, [r0, #9]
 800ed56:	683d      	ldr	r5, [r7, #0]
 800ed58:	2401      	movs	r4, #1
 800ed5a:	fa04 fe06 	lsl.w	lr, r4, r6
 800ed5e:	ea1e 0f05 	tst.w	lr, r5
 800ed62:	d131      	bne.n	800edc8 <dmaStreamAllocate+0x78>
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800ed64:	4c1b      	ldr	r4, [pc, #108]	; (800edd4 <dmaStreamAllocate+0x84>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 800ed66:	ea4e 0505 	orr.w	r5, lr, r5
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800ed6a:	eb04 0cc6 	add.w	ip, r4, r6, lsl #3
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 800ed6e:	f015 0fff 	tst.w	r5, #255	; 0xff
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 800ed72:	603d      	str	r5, [r7, #0]
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800ed74:	f844 2036 	str.w	r2, [r4, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800ed78:	f8cc 3004 	str.w	r3, [ip, #4]
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 800ed7c:	d004      	beq.n	800ed88 <dmaStreamAllocate+0x38>
    rccEnableDMA1(FALSE);
 800ed7e:	4c16      	ldr	r4, [pc, #88]	; (800edd8 <dmaStreamAllocate+0x88>)
 800ed80:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800ed82:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800ed86:	6323      	str	r3, [r4, #48]	; 0x30
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
 800ed88:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
 800ed8c:	d116      	bne.n	800edbc <dmaStreamAllocate+0x6c>
    rccEnableDMA2(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800ed8e:	6805      	ldr	r5, [r0, #0]
 800ed90:	682b      	ldr	r3, [r5, #0]
 800ed92:	f023 031f 	bic.w	r3, r3, #31
 800ed96:	602b      	str	r3, [r5, #0]
 800ed98:	682b      	ldr	r3, [r5, #0]
 800ed9a:	f013 0401 	ands.w	r4, r3, #1
 800ed9e:	d1fb      	bne.n	800ed98 <dmaStreamAllocate+0x48>
 800eda0:	7a07      	ldrb	r7, [r0, #8]
 800eda2:	6846      	ldr	r6, [r0, #4]
 800eda4:	233d      	movs	r3, #61	; 0x3d
 800eda6:	40bb      	lsls	r3, r7
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800eda8:	2721      	movs	r7, #33	; 0x21
    rccEnableDMA1(FALSE);
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
    rccEnableDMA2(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800edaa:	6033      	str	r3, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 800edac:	602c      	str	r4, [r5, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800edae:	616f      	str	r7, [r5, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 800edb0:	b162      	cbz	r2, 800edcc <dmaStreamAllocate+0x7c>
    nvicEnableVector(dmastp->vector, priority);
 800edb2:	7a80      	ldrb	r0, [r0, #10]
 800edb4:	f7ff fdfc 	bl	800e9b0 <nvicEnableVector>

  return FALSE;
 800edb8:	4620      	mov	r0, r4
 800edba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
    rccEnableDMA2(FALSE);
 800edbc:	4c06      	ldr	r4, [pc, #24]	; (800edd8 <dmaStreamAllocate+0x88>)
 800edbe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800edc0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800edc4:	6323      	str	r3, [r4, #48]	; 0x30
 800edc6:	e7e2      	b.n	800ed8e <dmaStreamAllocate+0x3e>

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;
 800edc8:	4620      	mov	r0, r4
 800edca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
    nvicEnableVector(dmastp->vector, priority);

  return FALSE;
 800edcc:	4610      	mov	r0, r2
}
 800edce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800edd0:	200013b8 	.word	0x200013b8
 800edd4:	20001338 	.word	0x20001338
 800edd8:	40023800 	.word	0x40023800
 800eddc:	00000000 	.word	0x00000000

0800ede0 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 800ede0:	4b17      	ldr	r3, [pc, #92]	; (800ee40 <hal_lld_init+0x60>)
 800ede2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800ede6:	691a      	ldr	r2, [r3, #16]
 800ede8:	2200      	movs	r2, #0
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 800edea:	b410      	push	{r4}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 800edec:	6119      	str	r1, [r3, #16]
 800edee:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 800edf0:	6958      	ldr	r0, [r3, #20]
 800edf2:	6159      	str	r1, [r3, #20]
 800edf4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800edf6:	6a18      	ldr	r0, [r3, #32]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800edf8:	4c12      	ldr	r4, [pc, #72]	; (800ee44 <hal_lld_init+0x64>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800edfa:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 800edfe:	6218      	str	r0, [r3, #32]
 800ee00:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 800ee02:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800ee04:	6259      	str	r1, [r3, #36]	; 0x24
 800ee06:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800ee08:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800ee0a:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 800ee0e:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800ee10:	6821      	ldr	r1, [r4, #0]
 800ee12:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800ee16:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800ee18:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800ee1a:	f401 7140 	and.w	r1, r1, #768	; 0x300
 800ee1e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800ee22:	d003      	beq.n	800ee2c <hal_lld_init+0x4c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800ee24:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800ee28:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800ee2a:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800ee2c:	4a05      	ldr	r2, [pc, #20]	; (800ee44 <hal_lld_init+0x64>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800ee2e:	f85d 4b04 	ldr.w	r4, [sp], #4

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800ee32:	6853      	ldr	r3, [r2, #4]
 800ee34:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800ee38:	6053      	str	r3, [r2, #4]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800ee3a:	f7ff bf61 	b.w	800ed00 <dmaInit>
 800ee3e:	bf00      	nop
 800ee40:	40023800 	.word	0x40023800
 800ee44:	40007000 	.word	0x40007000
	...

0800ee50 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800ee50:	492c      	ldr	r1, [pc, #176]	; (800ef04 <stm32_clock_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800ee52:	4b2d      	ldr	r3, [pc, #180]	; (800ef08 <stm32_clock_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800ee54:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800ee58:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800ee5c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800ee5e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800ee60:	680b      	ldr	r3, [r1, #0]
 800ee62:	f043 0301 	orr.w	r3, r3, #1
 800ee66:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800ee68:	680a      	ldr	r2, [r1, #0]
 800ee6a:	4b26      	ldr	r3, [pc, #152]	; (800ef04 <stm32_clock_init+0xb4>)
 800ee6c:	0790      	lsls	r0, r2, #30
 800ee6e:	d5fb      	bpl.n	800ee68 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800ee70:	689a      	ldr	r2, [r3, #8]
 800ee72:	f022 0203 	bic.w	r2, r2, #3
 800ee76:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800ee78:	689a      	ldr	r2, [r3, #8]
 800ee7a:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800ee7c:	4619      	mov	r1, r3
 800ee7e:	688b      	ldr	r3, [r1, #8]
 800ee80:	4a20      	ldr	r2, [pc, #128]	; (800ef04 <stm32_clock_init+0xb4>)
 800ee82:	f013 030c 	ands.w	r3, r3, #12
 800ee86:	d1fa      	bne.n	800ee7e <stm32_clock_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800ee88:	6811      	ldr	r1, [r2, #0]
 800ee8a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800ee8e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800ee90:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 800ee92:	6813      	ldr	r3, [r2, #0]
 800ee94:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800ee98:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800ee9a:	6811      	ldr	r1, [r2, #0]
 800ee9c:	4b19      	ldr	r3, [pc, #100]	; (800ef04 <stm32_clock_init+0xb4>)
 800ee9e:	0389      	lsls	r1, r1, #14
 800eea0:	d5fb      	bpl.n	800ee9a <stm32_clock_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800eea2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800eea4:	f042 0201 	orr.w	r2, r2, #1
 800eea8:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800eeaa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800eeac:	4915      	ldr	r1, [pc, #84]	; (800ef04 <stm32_clock_init+0xb4>)
 800eeae:	0790      	lsls	r0, r2, #30
 800eeb0:	d5fb      	bpl.n	800eeaa <stm32_clock_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800eeb2:	4b16      	ldr	r3, [pc, #88]	; (800ef0c <stm32_clock_init+0xbc>)
 800eeb4:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800eeb6:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800eeb8:	4a13      	ldr	r2, [pc, #76]	; (800ef08 <stm32_clock_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800eeba:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800eebe:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800eec0:	6853      	ldr	r3, [r2, #4]
 800eec2:	0459      	lsls	r1, r3, #17
 800eec4:	d5fc      	bpl.n	800eec0 <stm32_clock_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800eec6:	490f      	ldr	r1, [pc, #60]	; (800ef04 <stm32_clock_init+0xb4>)
 800eec8:	680a      	ldr	r2, [r1, #0]
 800eeca:	4b0e      	ldr	r3, [pc, #56]	; (800ef04 <stm32_clock_init+0xb4>)
 800eecc:	0192      	lsls	r2, r2, #6
 800eece:	d5fb      	bpl.n	800eec8 <stm32_clock_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800eed0:	4a0f      	ldr	r2, [pc, #60]	; (800ef10 <stm32_clock_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800eed2:	4910      	ldr	r1, [pc, #64]	; (800ef14 <stm32_clock_init+0xc4>)
 800eed4:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800eed6:	f240 7105 	movw	r1, #1797	; 0x705
 800eeda:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800eedc:	689a      	ldr	r2, [r3, #8]
 800eede:	f042 0202 	orr.w	r2, r2, #2
 800eee2:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800eee4:	461a      	mov	r2, r3
 800eee6:	6893      	ldr	r3, [r2, #8]
 800eee8:	4906      	ldr	r1, [pc, #24]	; (800ef04 <stm32_clock_init+0xb4>)
 800eeea:	f003 030c 	and.w	r3, r3, #12
 800eeee:	2b08      	cmp	r3, #8
 800eef0:	d1f9      	bne.n	800eee6 <stm32_clock_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800eef2:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 800eef4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800eef8:	644b      	str	r3, [r1, #68]	; 0x44
 800eefa:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 800eefc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800ef00:	664b      	str	r3, [r1, #100]	; 0x64
 800ef02:	4770      	bx	lr
 800ef04:	40023800 	.word	0x40023800
 800ef08:	40007000 	.word	0x40007000
 800ef0c:	07405408 	.word	0x07405408
 800ef10:	40023c00 	.word	0x40023c00
 800ef14:	38089400 	.word	0x38089400
	...

0800ef20 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 800ef20:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ef22:	b672      	cpsid	i
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 800ef24:	f7fe f98c 	bl	800d240 <chSysTimerHandlerI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ef28:	b662      	cpsie	i
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 800ef2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 800ef2e:	f7fe beff 	b.w	800dd30 <_port_irq_epilogue>
 800ef32:	bf00      	nop
	...

0800ef40 <st_lld_init>:
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 800ef40:	4b05      	ldr	r3, [pc, #20]	; (800ef58 <st_lld_init+0x18>)
 800ef42:	f244 109f 	movw	r0, #16799	; 0x419f
  SysTick->VAL = 0;
 800ef46:	2100      	movs	r1, #0
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 800ef48:	2207      	movs	r2, #7
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 800ef4a:	6058      	str	r0, [r3, #4]
  SysTick->VAL = 0;
 800ef4c:	6099      	str	r1, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 800ef4e:	200b      	movs	r0, #11
 800ef50:	2108      	movs	r1, #8
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 800ef52:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 800ef54:	f7ff bd4c 	b.w	800e9f0 <nvicSetSystemHandlerPriority>
 800ef58:	e000e010 	.word	0xe000e010
 800ef5c:	00000000 	.word	0x00000000

0800ef60 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 800ef60:	b510      	push	{r4, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 800ef62:	4c08      	ldr	r4, [pc, #32]	; (800ef84 <adc_lld_init+0x24>)
 800ef64:	4620      	mov	r0, r4
 800ef66:	f7fe ff43 	bl	800ddf0 <adcObjectInit>
  ADCD1.adc = ADC1;
 800ef6a:	4907      	ldr	r1, [pc, #28]	; (800ef88 <adc_lld_init+0x28>)
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 800ef6c:	4a07      	ldr	r2, [pc, #28]	; (800ef8c <adc_lld_init+0x2c>)
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 800ef6e:	4b08      	ldr	r3, [pc, #32]	; (800ef90 <adc_lld_init+0x30>)
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 800ef70:	62a1      	str	r1, [r4, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 800ef72:	62e2      	str	r2, [r4, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 800ef74:	6323      	str	r3, [r4, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(ADC_IRQn, STM32_ADC_IRQ_PRIORITY);
 800ef76:	2012      	movs	r0, #18
 800ef78:	2106      	movs	r1, #6
}
 800ef7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(ADC_IRQn, STM32_ADC_IRQ_PRIORITY);
 800ef7e:	f7ff bd17 	b.w	800e9b0 <nvicEnableVector>
 800ef82:	bf00      	nop
 800ef84:	200013bc 	.word	0x200013bc
 800ef88:	40012000 	.word	0x40012000
 800ef8c:	08016740 	.word	0x08016740
 800ef90:	00022c16 	.word	0x00022c16
	...

0800efa0 <adc_lld_start>:
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 800efa0:	7803      	ldrb	r3, [r0, #0]
 800efa2:	2b01      	cmp	r3, #1
 800efa4:	d000      	beq.n	800efa8 <adc_lld_start+0x8>
 800efa6:	4770      	bx	lr
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800efa8:	4b11      	ldr	r3, [pc, #68]	; (800eff0 <adc_lld_start+0x50>)
 800efaa:	4298      	cmp	r0, r3
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 800efac:	b510      	push	{r4, lr}
 800efae:	4604      	mov	r4, r0

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800efb0:	d00d      	beq.n	800efce <adc_lld_start+0x2e>
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800efb2:	4810      	ldr	r0, [pc, #64]	; (800eff4 <adc_lld_start+0x54>)
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 800efb4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800efb6:	6843      	ldr	r3, [r0, #4]
 800efb8:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 800efbc:	2100      	movs	r1, #0
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800efbe:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
    adcp->adc->CR2 = 0;
    adcp->adc->CR2 = ADC_CR2_ADON;
 800efc2:	2401      	movs	r4, #1
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800efc4:	6043      	str	r3, [r0, #4]
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 800efc6:	6051      	str	r1, [r2, #4]
    adcp->adc->CR2 = 0;
 800efc8:	6091      	str	r1, [r2, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
 800efca:	6094      	str	r4, [r2, #8]
 800efcc:	bd10      	pop	{r4, pc}
  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
 800efce:	4a0a      	ldr	r2, [pc, #40]	; (800eff8 <adc_lld_start+0x58>)
 800efd0:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800efd2:	2106      	movs	r1, #6
 800efd4:	4623      	mov	r3, r4
 800efd6:	f7ff febb 	bl	800ed50 <dmaStreamAllocate>
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800efda:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      rccEnableADC1(FALSE);
 800efdc:	4a07      	ldr	r2, [pc, #28]	; (800effc <adc_lld_start+0x5c>)
      b = dmaStreamAllocate(adcp->dmastp,
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800efde:	681b      	ldr	r3, [r3, #0]
 800efe0:	4907      	ldr	r1, [pc, #28]	; (800f000 <adc_lld_start+0x60>)
 800efe2:	6099      	str	r1, [r3, #8]
      rccEnableADC1(FALSE);
 800efe4:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800efe6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800efea:	6453      	str	r3, [r2, #68]	; 0x44
 800efec:	e7e1      	b.n	800efb2 <adc_lld_start+0x12>
 800efee:	bf00      	nop
 800eff0:	200013bc 	.word	0x200013bc
 800eff4:	40012300 	.word	0x40012300
 800eff8:	0800f151 	.word	0x0800f151
 800effc:	40023800 	.word	0x40023800
 800f000:	4001204c 	.word	0x4001204c
	...

0800f010 <adc_lld_start_conversion>:
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
  uint32_t mode;
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;
 800f010:	6903      	ldr	r3, [r0, #16]

  /* DMA setup.*/
  mode = adcp->dmamode;
 800f012:	6b01      	ldr	r1, [r0, #48]	; 0x30
  if (grpp->circular) {
 800f014:	781a      	ldrb	r2, [r3, #0]
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 800f016:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
    mode |= STM32_DMA_CR_CIRC;
    if (adcp->depth > 1) {
 800f01a:	68c4      	ldr	r4, [r0, #12]
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
 800f01c:	b12a      	cbz	r2, 800f02a <adc_lld_start_conversion+0x1a>
    mode |= STM32_DMA_CR_CIRC;
    if (adcp->depth > 1) {
 800f01e:	2c01      	cmp	r4, #1
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
    mode |= STM32_DMA_CR_CIRC;
 800f020:	bf94      	ite	ls
 800f022:	f441 7180 	orrls.w	r1, r1, #256	; 0x100
    if (adcp->depth > 1) {
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
 800f026:	f441 7184 	orrhi.w	r1, r1, #264	; 0x108
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800f02a:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800f02c:	885a      	ldrh	r2, [r3, #2]
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800f02e:	682d      	ldr	r5, [r5, #0]
 800f030:	6886      	ldr	r6, [r0, #8]
 800f032:	60ee      	str	r6, [r5, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800f034:	fb02 f204 	mul.w	r2, r2, r4
  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
 800f038:	f103 0818 	add.w	r8, r3, #24
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800f03c:	606a      	str	r2, [r5, #4]
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800f03e:	68dc      	ldr	r4, [r3, #12]
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
 800f040:	6029      	str	r1, [r5, #0]
  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
 800f042:	e898 5100 	ldmia.w	r8, {r8, ip, lr}
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);
 800f046:	682e      	ldr	r6, [r5, #0]

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;

  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 800f048:	6919      	ldr	r1, [r3, #16]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800f04a:	6a82      	ldr	r2, [r0, #40]	; 0x28
  adcp->adc->SMPR1 = grpp->smpr1;
 800f04c:	f8d3 9014 	ldr.w	r9, [r3, #20]
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;
 800f050:	6a5f      	ldr	r7, [r3, #36]	; 0x24

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800f052:	f044 6380 	orr.w	r3, r4, #67108864	; 0x4000000
 800f056:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);
 800f05a:	f046 0001 	orr.w	r0, r6, #1

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800f05e:	2400      	movs	r4, #0
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);
 800f060:	6028      	str	r0, [r5, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800f062:	6014      	str	r4, [r2, #0]
  adcp->adc->SMPR1 = grpp->smpr1;
 800f064:	f8c2 900c 	str.w	r9, [r2, #12]
  adcp->adc->SMPR2 = grpp->smpr2;
 800f068:	f8c2 8010 	str.w	r8, [r2, #16]
  adcp->adc->SQR1  = grpp->sqr1;
 800f06c:	f8c2 c02c 	str.w	ip, [r2, #44]	; 0x2c
  adcp->adc->SQR2  = grpp->sqr2;
 800f070:	f8c2 e030 	str.w	lr, [r2, #48]	; 0x30
  adcp->adc->SQR3  = grpp->sqr3;
 800f074:	6357      	str	r7, [r2, #52]	; 0x34

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800f076:	6053      	str	r3, [r2, #4]
  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
 800f078:	004b      	lsls	r3, r1, #1
 800f07a:	d406      	bmi.n	800f08a <adc_lld_start_conversion+0x7a>

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;

  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 800f07c:	f441 7140 	orr.w	r1, r1, #768	; 0x300
 800f080:	f041 0101 	orr.w	r1, r1, #1

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
  }
  else
    adcp->adc->CR2 = cr2;
 800f084:	6091      	str	r1, [r2, #8]
 800f086:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800f08a:	f021 4380 	bic.w	r3, r1, #1073741824	; 0x40000000
 800f08e:	f023 0302 	bic.w	r3, r3, #2
 800f092:	f443 7340 	orr.w	r3, r3, #768	; 0x300

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800f096:	f441 7140 	orr.w	r1, r1, #768	; 0x300

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800f09a:	f043 0303 	orr.w	r3, r3, #3

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800f09e:	f041 0103 	orr.w	r1, r1, #3

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800f0a2:	6093      	str	r3, [r2, #8]

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800f0a4:	6091      	str	r1, [r2, #8]
 800f0a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800f0aa:	bf00      	nop
 800f0ac:	0000      	movs	r0, r0
	...

0800f0b0 <adc_lld_stop_conversion>:
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800f0b0:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800f0b2:	680a      	ldr	r2, [r1, #0]
 800f0b4:	6813      	ldr	r3, [r2, #0]
 800f0b6:	f023 031f 	bic.w	r3, r3, #31
 800f0ba:	6013      	str	r3, [r2, #0]
 800f0bc:	6813      	ldr	r3, [r2, #0]
 800f0be:	f013 0301 	ands.w	r3, r3, #1
 800f0c2:	d1fb      	bne.n	800f0bc <adc_lld_stop_conversion+0xc>
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 800f0c4:	b430      	push	{r4, r5}

  dmaStreamDisable(adcp->dmastp);
 800f0c6:	7a0d      	ldrb	r5, [r1, #8]
 800f0c8:	684c      	ldr	r4, [r1, #4]
  adcp->adc->CR1 = 0;
 800f0ca:	6a82      	ldr	r2, [r0, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800f0cc:	213d      	movs	r1, #61	; 0x3d
 800f0ce:	40a9      	lsls	r1, r5
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 800f0d0:	2001      	movs	r0, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800f0d2:	6021      	str	r1, [r4, #0]
  adcp->adc->CR1 = 0;
 800f0d4:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
}
 800f0d6:	bc30      	pop	{r4, r5}
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
 800f0d8:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800f0da:	6090      	str	r0, [r2, #8]
}
 800f0dc:	4770      	bx	lr
 800f0de:	bf00      	nop

0800f0e0 <Vector88>:
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 800f0e0:	4b16      	ldr	r3, [pc, #88]	; (800f13c <Vector88+0x5c>)
 800f0e2:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
 800f0e4:	2100      	movs	r1, #0
 800f0e6:	6019      	str	r1, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 800f0e8:	0693      	lsls	r3, r2, #26
 800f0ea:	d524      	bpl.n	800f136 <Vector88+0x56>
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector88) {
 800f0ec:	b510      	push	{r4, lr}
#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
  ADC1->SR = 0;
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 800f0ee:	4c14      	ldr	r4, [pc, #80]	; (800f140 <Vector88+0x60>)
 800f0f0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800f0f2:	681b      	ldr	r3, [r3, #0]
 800f0f4:	685b      	ldr	r3, [r3, #4]
 800f0f6:	b1d3      	cbz	r3, 800f12e <Vector88+0x4e>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 800f0f8:	6923      	ldr	r3, [r4, #16]
 800f0fa:	b1c3      	cbz	r3, 800f12e <Vector88+0x4e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800f0fc:	4620      	mov	r0, r4
 800f0fe:	f7ff ffd7 	bl	800f0b0 <adc_lld_stop_conversion>
 800f102:	6923      	ldr	r3, [r4, #16]
 800f104:	689b      	ldr	r3, [r3, #8]
 800f106:	b14b      	cbz	r3, 800f11c <Vector88+0x3c>
 800f108:	2205      	movs	r2, #5
 800f10a:	7022      	strb	r2, [r4, #0]
 800f10c:	4620      	mov	r0, r4
 800f10e:	2101      	movs	r1, #1
 800f110:	4798      	blx	r3
 800f112:	7823      	ldrb	r3, [r4, #0]
 800f114:	2b05      	cmp	r3, #5
 800f116:	bf04      	itt	eq
 800f118:	2302      	moveq	r3, #2
 800f11a:	7023      	strbeq	r3, [r4, #0]
 800f11c:	2300      	movs	r3, #0
 800f11e:	6123      	str	r3, [r4, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f120:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800f122:	4808      	ldr	r0, [pc, #32]	; (800f144 <Vector88+0x64>)
 800f124:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800f128:	f7fe fb3a 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f12c:	b662      	cpsie	i
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
}
 800f12e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 800f132:	f7fe bdfd 	b.w	800dd30 <_port_irq_epilogue>
 800f136:	f7fe bdfb 	b.w	800dd30 <_port_irq_epilogue>
 800f13a:	bf00      	nop
 800f13c:	40012000 	.word	0x40012000
 800f140:	200013bc 	.word	0x200013bc
 800f144:	200013d0 	.word	0x200013d0
	...

0800f150 <adc_lld_serve_rx_interrupt>:
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800f150:	f011 0f0c 	tst.w	r1, #12
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 800f154:	b570      	push	{r4, r5, r6, lr}
 800f156:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800f158:	d119      	bne.n	800f18e <adc_lld_serve_rx_interrupt+0x3e>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 800f15a:	6903      	ldr	r3, [r0, #16]
 800f15c:	b1b3      	cbz	r3, 800f18c <adc_lld_serve_rx_interrupt+0x3c>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 800f15e:	068d      	lsls	r5, r1, #26
 800f160:	d512      	bpl.n	800f188 <adc_lld_serve_rx_interrupt+0x38>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800f162:	781a      	ldrb	r2, [r3, #0]
 800f164:	2a00      	cmp	r2, #0
 800f166:	d03a      	beq.n	800f1de <adc_lld_serve_rx_interrupt+0x8e>
 800f168:	685d      	ldr	r5, [r3, #4]
 800f16a:	b17d      	cbz	r5, 800f18c <adc_lld_serve_rx_interrupt+0x3c>
 800f16c:	68c2      	ldr	r2, [r0, #12]
 800f16e:	2a01      	cmp	r2, #1
 800f170:	d930      	bls.n	800f1d4 <adc_lld_serve_rx_interrupt+0x84>
 800f172:	885b      	ldrh	r3, [r3, #2]
 800f174:	6881      	ldr	r1, [r0, #8]
 800f176:	0852      	lsrs	r2, r2, #1
 800f178:	fb03 f302 	mul.w	r3, r3, r2
 800f17c:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 800f180:	462b      	mov	r3, r5
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800f182:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800f186:	4718      	bx	r3
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 800f188:	06ca      	lsls	r2, r1, #27
 800f18a:	d41a      	bmi.n	800f1c2 <adc_lld_serve_rx_interrupt+0x72>
 800f18c:	bd70      	pop	{r4, r5, r6, pc}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800f18e:	f7ff ff8f 	bl	800f0b0 <adc_lld_stop_conversion>
 800f192:	6923      	ldr	r3, [r4, #16]
 800f194:	689b      	ldr	r3, [r3, #8]
 800f196:	b14b      	cbz	r3, 800f1ac <adc_lld_serve_rx_interrupt+0x5c>
 800f198:	2205      	movs	r2, #5
 800f19a:	7022      	strb	r2, [r4, #0]
 800f19c:	4620      	mov	r0, r4
 800f19e:	2100      	movs	r1, #0
 800f1a0:	4798      	blx	r3
 800f1a2:	7823      	ldrb	r3, [r4, #0]
 800f1a4:	2b05      	cmp	r3, #5
 800f1a6:	bf04      	itt	eq
 800f1a8:	2302      	moveq	r3, #2
 800f1aa:	7023      	strbeq	r3, [r4, #0]
 800f1ac:	2300      	movs	r3, #0
 800f1ae:	6123      	str	r3, [r4, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f1b0:	b672      	cpsid	i
 800f1b2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800f1b6:	f104 0014 	add.w	r0, r4, #20
 800f1ba:	f7fe faf1 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f1be:	b662      	cpsie	i
 800f1c0:	bd70      	pop	{r4, r5, r6, pc}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800f1c2:	685b      	ldr	r3, [r3, #4]
 800f1c4:	2b00      	cmp	r3, #0
 800f1c6:	d0e1      	beq.n	800f18c <adc_lld_serve_rx_interrupt+0x3c>
 800f1c8:	68c2      	ldr	r2, [r0, #12]
 800f1ca:	6881      	ldr	r1, [r0, #8]
 800f1cc:	0852      	lsrs	r2, r2, #1
      }
    }
  }
}
 800f1ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800f1d2:	4718      	bx	r3
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800f1d4:	462b      	mov	r3, r5
 800f1d6:	6881      	ldr	r1, [r0, #8]
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800f1d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800f1dc:	4718      	bx	r3
 800f1de:	f7ff ff67 	bl	800f0b0 <adc_lld_stop_conversion>
 800f1e2:	6923      	ldr	r3, [r4, #16]
 800f1e4:	685b      	ldr	r3, [r3, #4]
 800f1e6:	b183      	cbz	r3, 800f20a <adc_lld_serve_rx_interrupt+0xba>
 800f1e8:	2204      	movs	r2, #4
 800f1ea:	7022      	strb	r2, [r4, #0]
 800f1ec:	4620      	mov	r0, r4
 800f1ee:	68a1      	ldr	r1, [r4, #8]
 800f1f0:	68e2      	ldr	r2, [r4, #12]
 800f1f2:	4798      	blx	r3
 800f1f4:	7823      	ldrb	r3, [r4, #0]
 800f1f6:	2b04      	cmp	r3, #4
 800f1f8:	d007      	beq.n	800f20a <adc_lld_serve_rx_interrupt+0xba>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f1fa:	b672      	cpsid	i
 800f1fc:	2100      	movs	r1, #0
 800f1fe:	f104 0014 	add.w	r0, r4, #20
 800f202:	f7fe facd 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f206:	b662      	cpsie	i
 800f208:	bd70      	pop	{r4, r5, r6, pc}
 800f20a:	2202      	movs	r2, #2
 800f20c:	2300      	movs	r3, #0
 800f20e:	7022      	strb	r2, [r4, #0]
 800f210:	6123      	str	r3, [r4, #16]
 800f212:	e7f2      	b.n	800f1fa <adc_lld_serve_rx_interrupt+0xaa>
	...

0800f220 <adcSTM32EnableTSVREFE>:
 *          temperature sensor and internal reference voltage.
 * @note    This is an STM32-only functionality.
 */
void adcSTM32EnableTSVREFE(void) {

  ADC->CCR |= ADC_CCR_TSVREFE;
 800f220:	4a02      	ldr	r2, [pc, #8]	; (800f22c <adcSTM32EnableTSVREFE+0xc>)
 800f222:	6853      	ldr	r3, [r2, #4]
 800f224:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800f228:	6053      	str	r3, [r2, #4]
 800f22a:	4770      	bx	lr
 800f22c:	40012300 	.word	0x40012300

0800f230 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 800f230:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800f232:	4806      	ldr	r0, [pc, #24]	; (800f24c <Vector58+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 800f234:	4a06      	ldr	r2, [pc, #24]	; (800f250 <Vector58+0x20>)
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800f236:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 800f238:	2101      	movs	r1, #1
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800f23a:	685b      	ldr	r3, [r3, #4]
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 800f23c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800f23e:	2100      	movs	r1, #0
 800f240:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f242:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
  EXTD1.config->channels[0].cb(&EXTD1, 0);

  OSAL_IRQ_EPILOGUE();
 800f246:	f7fe bd73 	b.w	800dd30 <_port_irq_epilogue>
 800f24a:	bf00      	nop
 800f24c:	200013f0 	.word	0x200013f0
 800f250:	40013c00 	.word	0x40013c00
	...

0800f260 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 800f260:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800f262:	4806      	ldr	r0, [pc, #24]	; (800f27c <Vector5C+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 800f264:	4a06      	ldr	r2, [pc, #24]	; (800f280 <Vector5C+0x20>)
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800f266:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 800f268:	2102      	movs	r1, #2
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800f26a:	68db      	ldr	r3, [r3, #12]
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 800f26c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800f26e:	2101      	movs	r1, #1
 800f270:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f272:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
  EXTD1.config->channels[1].cb(&EXTD1, 1);

  OSAL_IRQ_EPILOGUE();
 800f276:	f7fe bd5b 	b.w	800dd30 <_port_irq_epilogue>
 800f27a:	bf00      	nop
 800f27c:	200013f0 	.word	0x200013f0
 800f280:	40013c00 	.word	0x40013c00
	...

0800f290 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector60) {
 800f290:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800f292:	4806      	ldr	r0, [pc, #24]	; (800f2ac <Vector60+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 800f294:	4a06      	ldr	r2, [pc, #24]	; (800f2b0 <Vector60+0x20>)
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800f296:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 800f298:	2104      	movs	r1, #4
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800f29a:	695b      	ldr	r3, [r3, #20]
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 800f29c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800f29e:	2102      	movs	r1, #2
 800f2a0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f2a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
  EXTD1.config->channels[2].cb(&EXTD1, 2);

  OSAL_IRQ_EPILOGUE();
 800f2a6:	f7fe bd43 	b.w	800dd30 <_port_irq_epilogue>
 800f2aa:	bf00      	nop
 800f2ac:	200013f0 	.word	0x200013f0
 800f2b0:	40013c00 	.word	0x40013c00
	...

0800f2c0 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector64) {
 800f2c0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800f2c2:	4806      	ldr	r0, [pc, #24]	; (800f2dc <Vector64+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 800f2c4:	4a06      	ldr	r2, [pc, #24]	; (800f2e0 <Vector64+0x20>)
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800f2c6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 800f2c8:	2108      	movs	r1, #8
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800f2ca:	69db      	ldr	r3, [r3, #28]
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 800f2cc:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800f2ce:	2103      	movs	r1, #3
 800f2d0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f2d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
  EXTD1.config->channels[3].cb(&EXTD1, 3);

  OSAL_IRQ_EPILOGUE();
 800f2d6:	f7fe bd2b 	b.w	800dd30 <_port_irq_epilogue>
 800f2da:	bf00      	nop
 800f2dc:	200013f0 	.word	0x200013f0
 800f2e0:	40013c00 	.word	0x40013c00
	...

0800f2f0 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector68) {
 800f2f0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 800f2f2:	4806      	ldr	r0, [pc, #24]	; (800f30c <Vector68+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 800f2f4:	4a06      	ldr	r2, [pc, #24]	; (800f310 <Vector68+0x20>)
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 800f2f6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 800f2f8:	2110      	movs	r1, #16
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 800f2fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 800f2fc:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 800f2fe:	2104      	movs	r1, #4
 800f300:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f302:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
  EXTD1.config->channels[4].cb(&EXTD1, 4);

  OSAL_IRQ_EPILOGUE();
 800f306:	f7fe bd13 	b.w	800dd30 <_port_irq_epilogue>
 800f30a:	bf00      	nop
 800f30c:	200013f0 	.word	0x200013f0
 800f310:	40013c00 	.word	0x40013c00
	...

0800f320 <Vector9C>:
OSAL_IRQ_HANDLER(Vector9C) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
 800f320:	4b18      	ldr	r3, [pc, #96]	; (800f384 <Vector9C+0x64>)
/**
 * @brief   EXTI[5]...EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector9C) {
 800f322:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
 800f324:	695c      	ldr	r4, [r3, #20]
 800f326:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
 800f32a:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 5))
 800f32c:	06a3      	lsls	r3, r4, #26
 800f32e:	d422      	bmi.n	800f376 <Vector9C+0x56>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
 800f330:	0660      	lsls	r0, r4, #25
 800f332:	d41a      	bmi.n	800f36a <Vector9C+0x4a>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
 800f334:	0621      	lsls	r1, r4, #24
 800f336:	d412      	bmi.n	800f35e <Vector9C+0x3e>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
  if (pr & (1 << 8))
 800f338:	05e2      	lsls	r2, r4, #23
 800f33a:	d40a      	bmi.n	800f352 <Vector9C+0x32>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
  if (pr & (1 << 9))
 800f33c:	05a3      	lsls	r3, r4, #22
 800f33e:	d504      	bpl.n	800f34a <Vector9C+0x2a>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 800f340:	4811      	ldr	r0, [pc, #68]	; (800f388 <Vector9C+0x68>)
 800f342:	6843      	ldr	r3, [r0, #4]
 800f344:	2109      	movs	r1, #9
 800f346:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800f348:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f34a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 8))
    EXTD1.config->channels[8].cb(&EXTD1, 8);
  if (pr & (1 << 9))
    EXTD1.config->channels[9].cb(&EXTD1, 9);

  OSAL_IRQ_EPILOGUE();
 800f34e:	f7fe bcef 	b.w	800dd30 <_port_irq_epilogue>
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
    EXTD1.config->channels[7].cb(&EXTD1, 7);
  if (pr & (1 << 8))
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 800f352:	480d      	ldr	r0, [pc, #52]	; (800f388 <Vector9C+0x68>)
 800f354:	6843      	ldr	r3, [r0, #4]
 800f356:	2108      	movs	r1, #8
 800f358:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f35a:	4798      	blx	r3
 800f35c:	e7ee      	b.n	800f33c <Vector9C+0x1c>
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 800f35e:	480a      	ldr	r0, [pc, #40]	; (800f388 <Vector9C+0x68>)
 800f360:	6843      	ldr	r3, [r0, #4]
 800f362:	2107      	movs	r1, #7
 800f364:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f366:	4798      	blx	r3
 800f368:	e7e6      	b.n	800f338 <Vector9C+0x18>
  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
  EXTI->PR = pr;
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 800f36a:	4807      	ldr	r0, [pc, #28]	; (800f388 <Vector9C+0x68>)
 800f36c:	6843      	ldr	r3, [r0, #4]
 800f36e:	2106      	movs	r1, #6
 800f370:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f372:	4798      	blx	r3
 800f374:	e7de      	b.n	800f334 <Vector9C+0x14>
  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
  EXTI->PR = pr;
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 800f376:	4804      	ldr	r0, [pc, #16]	; (800f388 <Vector9C+0x68>)
 800f378:	6843      	ldr	r3, [r0, #4]
 800f37a:	2105      	movs	r1, #5
 800f37c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f37e:	4798      	blx	r3
 800f380:	e7d6      	b.n	800f330 <Vector9C+0x10>
 800f382:	bf00      	nop
 800f384:	40013c00 	.word	0x40013c00
 800f388:	200013f0 	.word	0x200013f0
 800f38c:	00000000 	.word	0x00000000

0800f390 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
 800f390:	4b1c      	ldr	r3, [pc, #112]	; (800f404 <VectorE0+0x74>)
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 800f392:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
 800f394:	695c      	ldr	r4, [r3, #20]
 800f396:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                   (1 << 15));
  EXTI->PR = pr;
 800f39a:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 10))
 800f39c:	0562      	lsls	r2, r4, #21
 800f39e:	d42a      	bmi.n	800f3f6 <VectorE0+0x66>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
 800f3a0:	0523      	lsls	r3, r4, #20
 800f3a2:	d422      	bmi.n	800f3ea <VectorE0+0x5a>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
 800f3a4:	04e0      	lsls	r0, r4, #19
 800f3a6:	d41a      	bmi.n	800f3de <VectorE0+0x4e>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
 800f3a8:	04a1      	lsls	r1, r4, #18
 800f3aa:	d412      	bmi.n	800f3d2 <VectorE0+0x42>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
  if (pr & (1 << 14))
 800f3ac:	0462      	lsls	r2, r4, #17
 800f3ae:	d40a      	bmi.n	800f3c6 <VectorE0+0x36>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
  if (pr & (1 << 15))
 800f3b0:	0423      	lsls	r3, r4, #16
 800f3b2:	d504      	bpl.n	800f3be <VectorE0+0x2e>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 800f3b4:	4814      	ldr	r0, [pc, #80]	; (800f408 <VectorE0+0x78>)
 800f3b6:	6843      	ldr	r3, [r0, #4]
 800f3b8:	210f      	movs	r1, #15
 800f3ba:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800f3bc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f3be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 14))
    EXTD1.config->channels[14].cb(&EXTD1, 14);
  if (pr & (1 << 15))
    EXTD1.config->channels[15].cb(&EXTD1, 15);

  OSAL_IRQ_EPILOGUE();
 800f3c2:	f7fe bcb5 	b.w	800dd30 <_port_irq_epilogue>
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
    EXTD1.config->channels[13].cb(&EXTD1, 13);
  if (pr & (1 << 14))
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 800f3c6:	4810      	ldr	r0, [pc, #64]	; (800f408 <VectorE0+0x78>)
 800f3c8:	6843      	ldr	r3, [r0, #4]
 800f3ca:	210e      	movs	r1, #14
 800f3cc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800f3ce:	4798      	blx	r3
 800f3d0:	e7ee      	b.n	800f3b0 <VectorE0+0x20>
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 800f3d2:	480d      	ldr	r0, [pc, #52]	; (800f408 <VectorE0+0x78>)
 800f3d4:	6843      	ldr	r3, [r0, #4]
 800f3d6:	210d      	movs	r1, #13
 800f3d8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f3da:	4798      	blx	r3
 800f3dc:	e7e6      	b.n	800f3ac <VectorE0+0x1c>
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 800f3de:	480a      	ldr	r0, [pc, #40]	; (800f408 <VectorE0+0x78>)
 800f3e0:	6843      	ldr	r3, [r0, #4]
 800f3e2:	210c      	movs	r1, #12
 800f3e4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800f3e6:	4798      	blx	r3
 800f3e8:	e7de      	b.n	800f3a8 <VectorE0+0x18>
                   (1 << 15));
  EXTI->PR = pr;
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 800f3ea:	4807      	ldr	r0, [pc, #28]	; (800f408 <VectorE0+0x78>)
 800f3ec:	6843      	ldr	r3, [r0, #4]
 800f3ee:	210b      	movs	r1, #11
 800f3f0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800f3f2:	4798      	blx	r3
 800f3f4:	e7d6      	b.n	800f3a4 <VectorE0+0x14>

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
                   (1 << 15));
  EXTI->PR = pr;
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 800f3f6:	4804      	ldr	r0, [pc, #16]	; (800f408 <VectorE0+0x78>)
 800f3f8:	6843      	ldr	r3, [r0, #4]
 800f3fa:	210a      	movs	r1, #10
 800f3fc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f3fe:	4798      	blx	r3
 800f400:	e7ce      	b.n	800f3a0 <VectorE0+0x10>
 800f402:	bf00      	nop
 800f404:	40013c00 	.word	0x40013c00
 800f408:	200013f0 	.word	0x200013f0
 800f40c:	00000000 	.word	0x00000000

0800f410 <Vector44>:
/**
 * @brief   EXTI[16] interrupt handler (PVD).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector44) {
 800f410:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 800f412:	4807      	ldr	r0, [pc, #28]	; (800f430 <Vector44+0x20>)
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 800f414:	4a07      	ldr	r2, [pc, #28]	; (800f434 <Vector44+0x24>)
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 800f416:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 800f418:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 800f41c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 800f420:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 800f422:	2110      	movs	r1, #16
 800f424:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f426:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
  EXTD1.config->channels[16].cb(&EXTD1, 16);

  OSAL_IRQ_EPILOGUE();
 800f42a:	f7fe bc81 	b.w	800dd30 <_port_irq_epilogue>
 800f42e:	bf00      	nop
 800f430:	200013f0 	.word	0x200013f0
 800f434:	40013c00 	.word	0x40013c00
	...

0800f440 <VectorE4>:
/**
 * @brief   EXTI[17] interrupt handler (RTC_ALARM).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE4) {
 800f440:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800f442:	4807      	ldr	r0, [pc, #28]	; (800f460 <VectorE4+0x20>)
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 800f444:	4a07      	ldr	r2, [pc, #28]	; (800f464 <VectorE4+0x24>)
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800f446:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 800f448:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800f44c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 800f450:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800f452:	2111      	movs	r1, #17
 800f454:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f456:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
  EXTD1.config->channels[17].cb(&EXTD1, 17);

  OSAL_IRQ_EPILOGUE();
 800f45a:	f7fe bc69 	b.w	800dd30 <_port_irq_epilogue>
 800f45e:	bf00      	nop
 800f460:	200013f0 	.word	0x200013f0
 800f464:	40013c00 	.word	0x40013c00
	...

0800f470 <VectorE8>:
/**
 * @brief   EXTI[18] interrupt handler (OTG_FS_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE8) {
 800f470:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800f472:	4807      	ldr	r0, [pc, #28]	; (800f490 <VectorE8+0x20>)
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 800f474:	4a07      	ldr	r2, [pc, #28]	; (800f494 <VectorE8+0x24>)
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800f476:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 800f478:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800f47c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 800f480:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800f482:	2112      	movs	r1, #18
 800f484:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f486:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
  EXTD1.config->channels[18].cb(&EXTD1, 18);

  OSAL_IRQ_EPILOGUE();
 800f48a:	f7fe bc51 	b.w	800dd30 <_port_irq_epilogue>
 800f48e:	bf00      	nop
 800f490:	200013f0 	.word	0x200013f0
 800f494:	40013c00 	.word	0x40013c00
	...

0800f4a0 <Vector138>:
/**
 * @brief   EXTI[19] interrupt handler (ETH_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector138) {
 800f4a0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800f4a2:	4807      	ldr	r0, [pc, #28]	; (800f4c0 <Vector138+0x20>)
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 800f4a4:	4a07      	ldr	r2, [pc, #28]	; (800f4c4 <Vector138+0x24>)
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800f4a6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 800f4a8:	f44f 2100 	mov.w	r1, #524288	; 0x80000
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800f4ac:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 800f4b0:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800f4b2:	2113      	movs	r1, #19
 800f4b4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f4b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
  EXTD1.config->channels[19].cb(&EXTD1, 19);

  OSAL_IRQ_EPILOGUE();
 800f4ba:	f7fe bc39 	b.w	800dd30 <_port_irq_epilogue>
 800f4be:	bf00      	nop
 800f4c0:	200013f0 	.word	0x200013f0
 800f4c4:	40013c00 	.word	0x40013c00
	...

0800f4d0 <Vector170>:
/**
 * @brief   EXTI[20] interrupt handler (OTG_HS_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector170) {
 800f4d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 800f4d2:	4807      	ldr	r0, [pc, #28]	; (800f4f0 <Vector170+0x20>)
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 800f4d4:	4a07      	ldr	r2, [pc, #28]	; (800f4f4 <Vector170+0x24>)
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 800f4d6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 800f4d8:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 800f4dc:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 800f4e0:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 800f4e2:	2114      	movs	r1, #20
 800f4e4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f4e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
  EXTD1.config->channels[20].cb(&EXTD1, 20);

  OSAL_IRQ_EPILOGUE();
 800f4ea:	f7fe bc21 	b.w	800dd30 <_port_irq_epilogue>
 800f4ee:	bf00      	nop
 800f4f0:	200013f0 	.word	0x200013f0
 800f4f4:	40013c00 	.word	0x40013c00
	...

0800f500 <Vector48>:
/**
 * @brief   EXTI[21] interrupt handler (TAMPER_STAMP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector48) {
 800f500:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 800f502:	4807      	ldr	r0, [pc, #28]	; (800f520 <Vector48+0x20>)
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 800f504:	4a07      	ldr	r2, [pc, #28]	; (800f524 <Vector48+0x24>)
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 800f506:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 800f508:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 800f50c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 800f510:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 800f512:	2115      	movs	r1, #21
 800f514:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f516:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
  EXTD1.config->channels[21].cb(&EXTD1, 21);

  OSAL_IRQ_EPILOGUE();
 800f51a:	f7fe bc09 	b.w	800dd30 <_port_irq_epilogue>
 800f51e:	bf00      	nop
 800f520:	200013f0 	.word	0x200013f0
 800f524:	40013c00 	.word	0x40013c00
	...

0800f530 <Vector4C>:
/**
 * @brief   EXTI[22] interrupt handler (RTC_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector4C) {
 800f530:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800f532:	4807      	ldr	r0, [pc, #28]	; (800f550 <Vector4C+0x20>)
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 800f534:	4a07      	ldr	r2, [pc, #28]	; (800f554 <Vector4C+0x24>)
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800f536:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 800f538:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800f53c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 800f540:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800f542:	2116      	movs	r1, #22
 800f544:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f546:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
  EXTD1.config->channels[22].cb(&EXTD1, 22);

  OSAL_IRQ_EPILOGUE();
 800f54a:	f7fe bbf1 	b.w	800dd30 <_port_irq_epilogue>
 800f54e:	bf00      	nop
 800f550:	200013f0 	.word	0x200013f0
 800f554:	40013c00 	.word	0x40013c00
	...

0800f560 <ext_lld_exti_irq_enable>:
 *
 * @notapi
 */
void ext_lld_exti_irq_enable(void) {

  nvicEnableVector(EXTI0_IRQn, STM32_EXT_EXTI0_IRQ_PRIORITY);
 800f560:	2006      	movs	r0, #6
/**
 * @brief   Enables EXTI IRQ sources.
 *
 * @notapi
 */
void ext_lld_exti_irq_enable(void) {
 800f562:	b508      	push	{r3, lr}

  nvicEnableVector(EXTI0_IRQn, STM32_EXT_EXTI0_IRQ_PRIORITY);
 800f564:	4601      	mov	r1, r0
 800f566:	f7ff fa23 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_EXT_EXTI1_IRQ_PRIORITY);
 800f56a:	2007      	movs	r0, #7
 800f56c:	2106      	movs	r1, #6
 800f56e:	f7ff fa1f 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_EXT_EXTI2_IRQ_PRIORITY);
 800f572:	2008      	movs	r0, #8
 800f574:	2106      	movs	r1, #6
 800f576:	f7ff fa1b 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_EXT_EXTI3_IRQ_PRIORITY);
 800f57a:	2009      	movs	r0, #9
 800f57c:	2106      	movs	r1, #6
 800f57e:	f7ff fa17 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_EXT_EXTI4_IRQ_PRIORITY);
 800f582:	200a      	movs	r0, #10
 800f584:	2106      	movs	r1, #6
 800f586:	f7ff fa13 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_EXT_EXTI5_9_IRQ_PRIORITY);
 800f58a:	2017      	movs	r0, #23
 800f58c:	2106      	movs	r1, #6
 800f58e:	f7ff fa0f 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_EXT_EXTI10_15_IRQ_PRIORITY);
 800f592:	2028      	movs	r0, #40	; 0x28
 800f594:	2106      	movs	r1, #6
 800f596:	f7ff fa0b 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(PVD_IRQn, STM32_EXT_EXTI16_IRQ_PRIORITY);
 800f59a:	2001      	movs	r0, #1
 800f59c:	2106      	movs	r1, #6
 800f59e:	f7ff fa07 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(RTC_Alarm_IRQn, STM32_EXT_EXTI17_IRQ_PRIORITY);
 800f5a2:	2029      	movs	r0, #41	; 0x29
 800f5a4:	210f      	movs	r1, #15
 800f5a6:	f7ff fa03 	bl	800e9b0 <nvicEnableVector>
  nvicEnableVector(OTG_FS_WKUP_IRQn, STM32_EXT_EXTI18_IRQ_PRIORITY);
 800f5aa:	202a      	movs	r0, #42	; 0x2a
 800f5ac:	2106      	movs	r1, #6
 800f5ae:	f7ff f9ff 	bl	800e9b0 <nvicEnableVector>
#if STM32_HAS_ETH
  nvicEnableVector(ETH_WKUP_IRQn, STM32_EXT_EXTI19_IRQ_PRIORITY);
 800f5b2:	203e      	movs	r0, #62	; 0x3e
 800f5b4:	2106      	movs	r1, #6
 800f5b6:	f7ff f9fb 	bl	800e9b0 <nvicEnableVector>
#endif
#if STM32_HAS_OTG2
  nvicEnableVector(OTG_HS_WKUP_IRQn, STM32_EXT_EXTI20_IRQ_PRIORITY);
 800f5ba:	204c      	movs	r0, #76	; 0x4c
 800f5bc:	2106      	movs	r1, #6
 800f5be:	f7ff f9f7 	bl	800e9b0 <nvicEnableVector>
#endif
#if !defined(STM32F401xx)
  nvicEnableVector(TAMP_STAMP_IRQn, STM32_EXT_EXTI21_IRQ_PRIORITY);
 800f5c2:	2002      	movs	r0, #2
 800f5c4:	210f      	movs	r1, #15
 800f5c6:	f7ff f9f3 	bl	800e9b0 <nvicEnableVector>
#endif /* !defined(STM32F401xx) */
  nvicEnableVector(RTC_WKUP_IRQn, STM32_EXT_EXTI22_IRQ_PRIORITY);
 800f5ca:	2003      	movs	r0, #3
 800f5cc:	210f      	movs	r1, #15
}
 800f5ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  nvicEnableVector(OTG_HS_WKUP_IRQn, STM32_EXT_EXTI20_IRQ_PRIORITY);
#endif
#if !defined(STM32F401xx)
  nvicEnableVector(TAMP_STAMP_IRQn, STM32_EXT_EXTI21_IRQ_PRIORITY);
#endif /* !defined(STM32F401xx) */
  nvicEnableVector(RTC_WKUP_IRQn, STM32_EXT_EXTI22_IRQ_PRIORITY);
 800f5d2:	f7ff b9ed 	b.w	800e9b0 <nvicEnableVector>
 800f5d6:	bf00      	nop
	...

0800f5e0 <ext_lld_init>:
 * @notapi
 */
void ext_lld_init(void) {

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
 800f5e0:	4801      	ldr	r0, [pc, #4]	; (800f5e8 <ext_lld_init+0x8>)
 800f5e2:	f7fe bc6d 	b.w	800dec0 <extObjectInit>
 800f5e6:	bf00      	nop
 800f5e8:	200013f0 	.word	0x200013f0
 800f5ec:	00000000 	.word	0x00000000

0800f5f0 <ext_lld_channel_enable>:
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
 800f5f0:	290f      	cmp	r1, #15
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be enabled
 *
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {
 800f5f2:	b4f0      	push	{r4, r5, r6, r7}

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
 800f5f4:	d920      	bls.n	800f638 <ext_lld_channel_enable+0x48>
 800f5f6:	6842      	ldr	r2, [r0, #4]
 800f5f8:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 800f5fc:	07c3      	lsls	r3, r0, #31
 800f5fe:	d534      	bpl.n	800f66a <ext_lld_channel_enable+0x7a>
      EXTI->RTSR |= (1 << channel);
 800f600:	4d22      	ldr	r5, [pc, #136]	; (800f68c <ext_lld_channel_enable+0x9c>)
 800f602:	2301      	movs	r3, #1
 800f604:	68ac      	ldr	r4, [r5, #8]
 800f606:	408b      	lsls	r3, r1
 800f608:	431c      	orrs	r4, r3
 800f60a:	60ac      	str	r4, [r5, #8]
 800f60c:	43dc      	mvns	r4, r3
    else
      EXTI->RTSR &= ~(1 << channel);
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
      EXTI->FTSR |= (1 << channel);
 800f60e:	4d1f      	ldr	r5, [pc, #124]	; (800f68c <ext_lld_channel_enable+0x9c>)
    else
      EXTI->FTSR &= ~(1 << channel);

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 800f610:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
      EXTI->RTSR |= (1 << channel);
    else
      EXTI->RTSR &= ~(1 << channel);
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
 800f614:	f010 0f02 	tst.w	r0, #2
      EXTI->FTSR |= (1 << channel);
 800f618:	68e8      	ldr	r0, [r5, #12]
    else
      EXTI->FTSR &= ~(1 << channel);

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 800f61a:	684a      	ldr	r2, [r1, #4]
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
      EXTI->RTSR |= (1 << channel);
    else
      EXTI->RTSR &= ~(1 << channel);
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
      EXTI->FTSR |= (1 << channel);
 800f61c:	bf14      	ite	ne
 800f61e:	4318      	orrne	r0, r3
    else
      EXTI->FTSR &= ~(1 << channel);
 800f620:	4020      	andeq	r0, r4
 800f622:	60e8      	str	r0, [r5, #12]

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 800f624:	b34a      	cbz	r2, 800f67a <ext_lld_channel_enable+0x8a>
      EXTI->IMR |= (1 << channel);
 800f626:	4a19      	ldr	r2, [pc, #100]	; (800f68c <ext_lld_channel_enable+0x9c>)
 800f628:	6811      	ldr	r1, [r2, #0]
 800f62a:	430b      	orrs	r3, r1
 800f62c:	6013      	str	r3, [r2, #0]
      EXTI->EMR &= ~(1 << channel);
 800f62e:	6853      	ldr	r3, [r2, #4]
 800f630:	4023      	ands	r3, r4
 800f632:	6053      	str	r3, [r2, #4]
      EXTI->EMR2 |= (1 << (32 - channel));
      EXTI->IMR2 &= ~(1 << (32 - channel));
    }
  }
#endif
}
 800f634:	bcf0      	pop	{r4, r5, r6, r7}
 800f636:	4770      	bx	lr
 800f638:	f021 0303 	bic.w	r3, r1, #3

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
    uint32_t port = ((extp->config->channels[channel].mode &
 800f63c:	6842      	ldr	r2, [r0, #4]
 800f63e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800f642:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
 800f646:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 800f64a:	689f      	ldr	r7, [r3, #8]
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 800f64c:	f001 0403 	and.w	r4, r1, #3
 800f650:	00a4      	lsls	r4, r4, #2
 800f652:	260f      	movs	r6, #15
 800f654:	40a6      	lsls	r6, r4
    uint32_t port = ((extp->config->channels[channel].mode &
                      EXT_MODE_GPIO_MASK) >>
 800f656:	f3c0 1503 	ubfx	r5, r0, #4, #4
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 800f65a:	ea27 0606 	bic.w	r6, r7, r6

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
    uint32_t port = ((extp->config->channels[channel].mode &
 800f65e:	fa05 f404 	lsl.w	r4, r5, r4
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 800f662:	4334      	orrs	r4, r6
 800f664:	609c      	str	r4, [r3, #8]

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 800f666:	07c3      	lsls	r3, r0, #31
 800f668:	d4ca      	bmi.n	800f600 <ext_lld_channel_enable+0x10>
      EXTI->RTSR |= (1 << channel);
    else
      EXTI->RTSR &= ~(1 << channel);
 800f66a:	4e08      	ldr	r6, [pc, #32]	; (800f68c <ext_lld_channel_enable+0x9c>)
 800f66c:	2301      	movs	r3, #1
 800f66e:	68b5      	ldr	r5, [r6, #8]
 800f670:	408b      	lsls	r3, r1
 800f672:	43dc      	mvns	r4, r3
 800f674:	4025      	ands	r5, r4
 800f676:	60b5      	str	r5, [r6, #8]
 800f678:	e7c9      	b.n	800f60e <ext_lld_channel_enable+0x1e>
    if (extp->config->channels[channel].cb != NULL) {
      EXTI->IMR |= (1 << channel);
      EXTI->EMR &= ~(1 << channel);
    }
    else {
      EXTI->EMR |= (1 << channel);
 800f67a:	4a04      	ldr	r2, [pc, #16]	; (800f68c <ext_lld_channel_enable+0x9c>)
 800f67c:	6851      	ldr	r1, [r2, #4]
 800f67e:	430b      	orrs	r3, r1
 800f680:	6053      	str	r3, [r2, #4]
      EXTI->IMR &= ~(1 << channel);
 800f682:	6813      	ldr	r3, [r2, #0]
 800f684:	4023      	ands	r3, r4
 800f686:	6013      	str	r3, [r2, #0]
      EXTI->EMR2 |= (1 << (32 - channel));
      EXTI->IMR2 &= ~(1 << (32 - channel));
    }
  }
#endif
}
 800f688:	bcf0      	pop	{r4, r5, r6, r7}
 800f68a:	4770      	bx	lr
 800f68c:	40013c00 	.word	0x40013c00

0800f690 <ext_lld_channel_disable>:
  (void)extp;

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    EXTI->IMR   &= ~(1 << channel);
 800f690:	4b08      	ldr	r3, [pc, #32]	; (800f6b4 <ext_lld_channel_disable+0x24>)
 800f692:	2201      	movs	r2, #1
 800f694:	6818      	ldr	r0, [r3, #0]
 800f696:	408a      	lsls	r2, r1
 800f698:	43d1      	mvns	r1, r2
 800f69a:	4008      	ands	r0, r1
 800f69c:	6018      	str	r0, [r3, #0]
    EXTI->EMR   &= ~(1 << channel);
 800f69e:	6858      	ldr	r0, [r3, #4]
 800f6a0:	4008      	ands	r0, r1
 800f6a2:	6058      	str	r0, [r3, #4]
    EXTI->RTSR  &= ~(1 << channel);
 800f6a4:	6898      	ldr	r0, [r3, #8]
 800f6a6:	4008      	ands	r0, r1
 800f6a8:	6098      	str	r0, [r3, #8]
    EXTI->FTSR  &= ~(1 << channel);
 800f6aa:	68d8      	ldr	r0, [r3, #12]
 800f6ac:	4001      	ands	r1, r0
 800f6ae:	60d9      	str	r1, [r3, #12]
    EXTI->PR     =  (1 << channel);
 800f6b0:	615a      	str	r2, [r3, #20]
 800f6b2:	4770      	bx	lr
 800f6b4:	40013c00 	.word	0x40013c00
	...

0800f6c0 <ext_lld_start>:
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 800f6c0:	b538      	push	{r3, r4, r5, lr}
  unsigned i;

  if (extp->state == EXT_STOP)
 800f6c2:	7803      	ldrb	r3, [r0, #0]
 800f6c4:	2b01      	cmp	r3, #1
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 800f6c6:	4605      	mov	r5, r0
  unsigned i;

  if (extp->state == EXT_STOP)
 800f6c8:	d016      	beq.n	800f6f8 <ext_lld_start+0x38>
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 800f6ca:	2400      	movs	r4, #0
 800f6cc:	e004      	b.n	800f6d8 <ext_lld_start+0x18>

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 800f6ce:	3401      	adds	r4, #1
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, i);
 800f6d0:	f7ff ff8e 	bl	800f5f0 <ext_lld_channel_enable>

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 800f6d4:	2c17      	cmp	r4, #23
 800f6d6:	d00e      	beq.n	800f6f6 <ext_lld_start+0x36>
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
 800f6d8:	686b      	ldr	r3, [r5, #4]
 800f6da:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 800f6de:	f013 0f04 	tst.w	r3, #4
      ext_lld_channel_enable(extp, i);
 800f6e2:	4628      	mov	r0, r5
 800f6e4:	4621      	mov	r1, r4
  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
 800f6e6:	d1f2      	bne.n	800f6ce <ext_lld_start+0xe>
      ext_lld_channel_enable(extp, i);
    else
      ext_lld_channel_disable(extp, i);
 800f6e8:	4621      	mov	r1, r4
 800f6ea:	4628      	mov	r0, r5

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 800f6ec:	3401      	adds	r4, #1
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, i);
    else
      ext_lld_channel_disable(extp, i);
 800f6ee:	f7ff ffcf 	bl	800f690 <ext_lld_channel_disable>

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 800f6f2:	2c17      	cmp	r4, #23
 800f6f4:	d1f0      	bne.n	800f6d8 <ext_lld_start+0x18>
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, i);
    else
      ext_lld_channel_disable(extp, i);
}
 800f6f6:	bd38      	pop	{r3, r4, r5, pc}
 */
void ext_lld_start(EXTDriver *extp) {
  unsigned i;

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();
 800f6f8:	f7ff ff32 	bl	800f560 <ext_lld_exti_irq_enable>
 800f6fc:	e7e5      	b.n	800f6ca <ext_lld_start+0xa>
 800f6fe:	bf00      	nop

0800f700 <can_lld_set_filters>:
 *
 * @notapi
 */
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {
 800f700:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 800f702:	4c43      	ldr	r4, [pc, #268]	; (800f810 <can_lld_set_filters+0x110>)

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 800f704:	4d43      	ldr	r5, [pc, #268]	; (800f814 <can_lld_set_filters+0x114>)
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 800f706:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800f708:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800f70c:	6423      	str	r3, [r4, #64]	; 0x40

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 800f70e:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
 800f712:	0c1b      	lsrs	r3, r3, #16
 800f714:	041b      	lsls	r3, r3, #16
 800f716:	f043 0301 	orr.w	r3, r3, #1
 800f71a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800f71e:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
  if (num > 0) {
 800f722:	2900      	cmp	r1, #0
 800f724:	d04e      	beq.n	800f7c4 <can_lld_set_filters+0xc4>
    uint32_t i, fmask;

    /* All filters cleared.*/
    CAN1->FA1R = 0;
 800f726:	2300      	movs	r3, #0
 800f728:	f8c5 321c 	str.w	r3, [r5, #540]	; 0x21c
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800f72c:	4618      	mov	r0, r3
  if (num > 0) {
    uint32_t i, fmask;

    /* All filters cleared.*/
    CAN1->FA1R = 0;
    CAN1->FM1R = 0;
 800f72e:	f8c5 3204 	str.w	r3, [r5, #516]	; 0x204
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
      CAN1->sFilterRegister[i].FR1 = 0;
 800f732:	461c      	mov	r4, r3
    uint32_t i, fmask;

    /* All filters cleared.*/
    CAN1->FA1R = 0;
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
 800f734:	f8c5 320c 	str.w	r3, [r5, #524]	; 0x20c
    CAN1->FFA1R = 0;
 800f738:	f8c5 3214 	str.w	r3, [r5, #532]	; 0x214
 800f73c:	00c3      	lsls	r3, r0, #3
 800f73e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800f742:	f503 43c8 	add.w	r3, r3, #25600	; 0x6400
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800f746:	3001      	adds	r0, #1
 800f748:	281c      	cmp	r0, #28
      CAN1->sFilterRegister[i].FR1 = 0;
 800f74a:	f8c3 4240 	str.w	r4, [r3, #576]	; 0x240
      CAN1->sFilterRegister[i].FR2 = 0;
 800f74e:	f8c3 4244 	str.w	r4, [r3, #580]	; 0x244
    /* All filters cleared.*/
    CAN1->FA1R = 0;
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800f752:	d1f3      	bne.n	800f73c <can_lld_set_filters+0x3c>

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
      fmask = 1 << cfp->filter;
      if (cfp->mode)
        CAN1->FM1R |= fmask;
 800f754:	482f      	ldr	r0, [pc, #188]	; (800f814 <can_lld_set_filters+0x114>)
    /* All filters cleared.*/
    CAN1->FA1R = 0;
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800f756:	2600      	movs	r6, #0
      CAN1->sFilterRegister[i].FR2 = 0;
    }

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
      fmask = 1 << cfp->filter;
 800f758:	2701      	movs	r7, #1
 800f75a:	6815      	ldr	r5, [r2, #0]
      if (cfp->mode)
 800f75c:	7914      	ldrb	r4, [r2, #4]
 800f75e:	00eb      	lsls	r3, r5, #3
 800f760:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800f764:	f014 0f01 	tst.w	r4, #1
 800f768:	f503 43c8 	add.w	r3, r3, #25600	; 0x6400
      CAN1->sFilterRegister[i].FR1 = 0;
      CAN1->sFilterRegister[i].FR2 = 0;
    }

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
 800f76c:	f106 0601 	add.w	r6, r6, #1
      fmask = 1 << cfp->filter;
 800f770:	fa07 f505 	lsl.w	r5, r7, r5
      if (cfp->mode)
 800f774:	d005      	beq.n	800f782 <can_lld_set_filters+0x82>
        CAN1->FM1R |= fmask;
 800f776:	f8d0 e204 	ldr.w	lr, [r0, #516]	; 0x204
 800f77a:	ea45 0e0e 	orr.w	lr, r5, lr
 800f77e:	f8c0 e204 	str.w	lr, [r0, #516]	; 0x204
      if (cfp->scale)
 800f782:	f014 0f02 	tst.w	r4, #2
 800f786:	d005      	beq.n	800f794 <can_lld_set_filters+0x94>
        CAN1->FS1R |= fmask;
 800f788:	f8d0 e20c 	ldr.w	lr, [r0, #524]	; 0x20c
 800f78c:	ea45 0e0e 	orr.w	lr, r5, lr
 800f790:	f8c0 e20c 	str.w	lr, [r0, #524]	; 0x20c
      if (cfp->assignment)
 800f794:	0764      	lsls	r4, r4, #29
 800f796:	d504      	bpl.n	800f7a2 <can_lld_set_filters+0xa2>
        CAN1->FFA1R |= fmask;
 800f798:	f8d0 4214 	ldr.w	r4, [r0, #532]	; 0x214
 800f79c:	432c      	orrs	r4, r5
 800f79e:	f8c0 4214 	str.w	r4, [r0, #532]	; 0x214
      CAN1->sFilterRegister[cfp->filter].FR1 = cfp->register1;
 800f7a2:	6894      	ldr	r4, [r2, #8]
 800f7a4:	f8c3 4240 	str.w	r4, [r3, #576]	; 0x240
      CAN1->sFilterRegister[cfp->filter].FR2 = cfp->register2;
 800f7a8:	68d4      	ldr	r4, [r2, #12]
 800f7aa:	f8c3 4244 	str.w	r4, [r3, #580]	; 0x244
      CAN1->FA1R |= fmask;
 800f7ae:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
      CAN1->sFilterRegister[i].FR1 = 0;
      CAN1->sFilterRegister[i].FR2 = 0;
    }

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
 800f7b2:	428e      	cmp	r6, r1
        CAN1->FS1R |= fmask;
      if (cfp->assignment)
        CAN1->FFA1R |= fmask;
      CAN1->sFilterRegister[cfp->filter].FR1 = cfp->register1;
      CAN1->sFilterRegister[cfp->filter].FR2 = cfp->register2;
      CAN1->FA1R |= fmask;
 800f7b4:	ea43 0305 	orr.w	r3, r3, r5
      cfp++;
 800f7b8:	f102 0210 	add.w	r2, r2, #16
        CAN1->FS1R |= fmask;
      if (cfp->assignment)
        CAN1->FFA1R |= fmask;
      CAN1->sFilterRegister[cfp->filter].FR1 = cfp->register1;
      CAN1->sFilterRegister[cfp->filter].FR2 = cfp->register2;
      CAN1->FA1R |= fmask;
 800f7bc:	f8c0 321c 	str.w	r3, [r0, #540]	; 0x21c
      CAN1->sFilterRegister[i].FR1 = 0;
      CAN1->sFilterRegister[i].FR2 = 0;
    }

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
 800f7c0:	d1cb      	bne.n	800f75a <can_lld_set_filters+0x5a>
 800f7c2:	e018      	b.n	800f7f6 <can_lld_set_filters+0xf6>
 800f7c4:	00c2      	lsls	r2, r0, #3
 800f7c6:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    CAN1->sFilterRegister[can2sb].FR2 = 0;
#endif
    CAN1->FM1R = 0;
    CAN1->FFA1R = 0;
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
 800f7ca:	2301      	movs	r3, #1
 800f7cc:	f502 42c8 	add.w	r2, r2, #25600	; 0x6400
 800f7d0:	4083      	lsls	r3, r0
 800f7d2:	f043 0301 	orr.w	r3, r3, #1
    }
  }
  else {
    /* Setting up a single default filter that enables everything for both
       CANs.*/
    CAN1->sFilterRegister[0].FR1 = 0;
 800f7d6:	f8c5 1240 	str.w	r1, [r5, #576]	; 0x240
    CAN1->sFilterRegister[0].FR2 = 0;
 800f7da:	f8c5 1244 	str.w	r1, [r5, #580]	; 0x244
#if STM32_HAS_CAN2
    CAN1->sFilterRegister[can2sb].FR1 = 0;
 800f7de:	f8c2 1240 	str.w	r1, [r2, #576]	; 0x240
    CAN1->sFilterRegister[can2sb].FR2 = 0;
 800f7e2:	f8c2 1244 	str.w	r1, [r2, #580]	; 0x244
#endif
    CAN1->FM1R = 0;
 800f7e6:	f8c5 1204 	str.w	r1, [r5, #516]	; 0x204
    CAN1->FFA1R = 0;
 800f7ea:	f8c5 1214 	str.w	r1, [r5, #532]	; 0x214
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
 800f7ee:	f8c5 320c 	str.w	r3, [r5, #524]	; 0x20c
    CAN1->FA1R = 1 | (1 << can2sb);
 800f7f2:	f8c5 321c 	str.w	r3, [r5, #540]	; 0x21c
#else
    CAN1->FS1R = 1;
    CAN1->FA1R = 1;
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 800f7f6:	4907      	ldr	r1, [pc, #28]	; (800f814 <can_lld_set_filters+0x114>)

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  rccDisableCAN1(FALSE);
 800f7f8:	4a05      	ldr	r2, [pc, #20]	; (800f810 <can_lld_set_filters+0x110>)
#else
    CAN1->FS1R = 1;
    CAN1->FA1R = 1;
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 800f7fa:	f8d1 3200 	ldr.w	r3, [r1, #512]	; 0x200
 800f7fe:	f023 0301 	bic.w	r3, r3, #1
 800f802:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  rccDisableCAN1(FALSE);
 800f806:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800f808:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 800f80c:	6413      	str	r3, [r2, #64]	; 0x40
 800f80e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800f810:	40023800 	.word	0x40023800
 800f814:	40006400 	.word	0x40006400
	...

0800f820 <Vector8C>:
/**
 * @brief   CAN1 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 800f820:	b510      	push	{r4, lr}
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {

  /* No more events until a message is transmitted.*/
  canp->can->TSR = CAN_TSR_RQCP0 | CAN_TSR_RQCP1 | CAN_TSR_RQCP2;
 800f822:	4c0a      	ldr	r4, [pc, #40]	; (800f84c <Vector8C+0x2c>)
 800f824:	4a0a      	ldr	r2, [pc, #40]	; (800f850 <Vector8C+0x30>)
 800f826:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800f828:	609a      	str	r2, [r3, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f82a:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800f82c:	2100      	movs	r1, #0
 800f82e:	f104 0008 	add.w	r0, r4, #8
 800f832:	f7fd ffdd 	bl	800d7f0 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800f836:	f104 001c 	add.w	r0, r4, #28
 800f83a:	2101      	movs	r1, #1
 800f83c:	f7fe f900 	bl	800da40 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f840:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800f842:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800f846:	f7fe ba73 	b.w	800dd30 <_port_irq_epilogue>
 800f84a:	bf00      	nop
 800f84c:	200013f8 	.word	0x200013f8
 800f850:	00010101 	.word	0x00010101
	...

0800f860 <Vector90>:
/*
 * @brief   CAN1 RX0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 800f860:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
 800f862:	4d12      	ldr	r5, [pc, #72]	; (800f8ac <Vector90+0x4c>)
 800f864:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800f866:	68dc      	ldr	r4, [r3, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 800f868:	07a2      	lsls	r2, r4, #30
 800f86a:	d10d      	bne.n	800f888 <Vector90+0x28>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(1));
    osalSysUnlockFromISR();
  }
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 800f86c:	06e3      	lsls	r3, r4, #27
 800f86e:	d507      	bpl.n	800f880 <Vector90+0x20>
    /* Overflow events handling.*/
    canp->can->RF0R = CAN_RF0R_FOVR0;
 800f870:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800f872:	2110      	movs	r1, #16
 800f874:	60d9      	str	r1, [r3, #12]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f876:	b672      	cpsid	i
 800f878:	480d      	ldr	r0, [pc, #52]	; (800f8b0 <Vector90+0x50>)
 800f87a:	f7fe f8e1 	bl	800da40 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f87e:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800f880:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800f884:	f7fe ba54 	b.w	800dd30 <_port_irq_epilogue>
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE0;
 800f888:	695a      	ldr	r2, [r3, #20]
 800f88a:	f022 0202 	bic.w	r2, r2, #2
 800f88e:	615a      	str	r2, [r3, #20]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f890:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800f892:	2100      	movs	r1, #0
 800f894:	f105 0010 	add.w	r0, r5, #16
 800f898:	f7fd ffaa 	bl	800d7f0 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800f89c:	f105 0018 	add.w	r0, r5, #24
 800f8a0:	2101      	movs	r1, #1
 800f8a2:	f7fe f8cd 	bl	800da40 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f8a6:	b662      	cpsie	i
 800f8a8:	e7e0      	b.n	800f86c <Vector90+0xc>
 800f8aa:	bf00      	nop
 800f8ac:	200013f8 	.word	0x200013f8
 800f8b0:	20001418 	.word	0x20001418
	...

0800f8c0 <Vector94>:
/**
 * @brief   CAN1 RX1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX1_HANDLER) {
 800f8c0:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
 800f8c2:	4d12      	ldr	r5, [pc, #72]	; (800f90c <Vector94+0x4c>)
 800f8c4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800f8c6:	691c      	ldr	r4, [r3, #16]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 800f8c8:	07a2      	lsls	r2, r4, #30
 800f8ca:	d10d      	bne.n	800f8e8 <Vector94+0x28>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(2));
    osalSysUnlockFromISR();
  }
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 800f8cc:	06e3      	lsls	r3, r4, #27
 800f8ce:	d507      	bpl.n	800f8e0 <Vector94+0x20>
    /* Overflow events handling.*/
    canp->can->RF1R = CAN_RF1R_FOVR1;
 800f8d0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800f8d2:	2110      	movs	r1, #16
 800f8d4:	6119      	str	r1, [r3, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f8d6:	b672      	cpsid	i
 800f8d8:	480d      	ldr	r0, [pc, #52]	; (800f910 <Vector94+0x50>)
 800f8da:	f7fe f8b1 	bl	800da40 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f8de:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800f8e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800f8e4:	f7fe ba24 	b.w	800dd30 <_port_irq_epilogue>
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE1;
 800f8e8:	695a      	ldr	r2, [r3, #20]
 800f8ea:	f022 0210 	bic.w	r2, r2, #16
 800f8ee:	615a      	str	r2, [r3, #20]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f8f0:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800f8f2:	2100      	movs	r1, #0
 800f8f4:	f105 0010 	add.w	r0, r5, #16
 800f8f8:	f7fd ff7a 	bl	800d7f0 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800f8fc:	f105 0018 	add.w	r0, r5, #24
 800f900:	2102      	movs	r1, #2
 800f902:	f7fe f89d 	bl	800da40 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f906:	b662      	cpsie	i
 800f908:	e7e0      	b.n	800f8cc <Vector94+0xc>
 800f90a:	bf00      	nop
 800f90c:	200013f8 	.word	0x200013f8
 800f910:	20001418 	.word	0x20001418
	...

0800f920 <Vector98>:
/**
 * @brief   CAN1 SCE interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_SCE_HANDLER) {
 800f920:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
static void can_lld_sce_handler(CANDriver *canp) {
  uint32_t msr;

  msr = canp->can->MSR;
 800f922:	4d17      	ldr	r5, [pc, #92]	; (800f980 <Vector98+0x60>)
 800f924:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800f926:	685c      	ldr	r4, [r3, #4]
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
 800f928:	221c      	movs	r2, #28
 800f92a:	605a      	str	r2, [r3, #4]
  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
 800f92c:	0722      	lsls	r2, r4, #28
 800f92e:	d419      	bmi.n	800f964 <Vector98+0x44>
    osalEventBroadcastFlagsI(&canp->wakeup_event, 0);
    osalSysUnlockFromISR();
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 800f930:	0763      	lsls	r3, r4, #29
 800f932:	d513      	bpl.n	800f95c <Vector98+0x3c>
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;
 800f934:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800f936:	6993      	ldr	r3, [r2, #24]

    canp->can->ESR &= ~CAN_ESR_LEC;
 800f938:	6991      	ldr	r1, [r2, #24]
 800f93a:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 800f93e:	6191      	str	r1, [r2, #24]
    flags = (eventflags_t)(esr & 7);
    if ((esr & CAN_ESR_LEC) > 0)
 800f940:	f013 0f70 	tst.w	r3, #112	; 0x70
  if (msr & CAN_MSR_ERRI) {
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;

    canp->can->ESR &= ~CAN_ESR_LEC;
    flags = (eventflags_t)(esr & 7);
 800f944:	f003 0107 	and.w	r1, r3, #7
    if ((esr & CAN_ESR_LEC) > 0)
      flags |= CAN_FRAMING_ERROR;
 800f948:	bf18      	it	ne
 800f94a:	f041 0108 	orrne.w	r1, r1, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f94e:	b672      	cpsid	i
 800f950:	480c      	ldr	r0, [pc, #48]	; (800f984 <Vector98+0x64>)
 800f952:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800f956:	f7fe f873 	bl	800da40 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f95a:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800f95c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800f960:	f7fe b9e6 	b.w	800dd30 <_port_irq_epilogue>
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800f964:	681a      	ldr	r2, [r3, #0]
  msr = canp->can->MSR;
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
 800f966:	4628      	mov	r0, r5
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800f968:	f022 0202 	bic.w	r2, r2, #2
  msr = canp->can->MSR;
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
 800f96c:	2103      	movs	r1, #3
 800f96e:	f800 1b28 	strb.w	r1, [r0], #40
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800f972:	601a      	str	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f974:	b672      	cpsid	i
 800f976:	2100      	movs	r1, #0
 800f978:	f7fe f862 	bl	800da40 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f97c:	b662      	cpsie	i
 800f97e:	e7d7      	b.n	800f930 <Vector98+0x10>
 800f980:	200013f8 	.word	0x200013f8
 800f984:	20001418 	.word	0x20001418
	...

0800f990 <can_lld_init>:
/**
 * @brief   Low level CAN driver initialization.
 *
 * @notapi
 */
void can_lld_init(void) {
 800f990:	b510      	push	{r4, lr}

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
 800f992:	4c06      	ldr	r4, [pc, #24]	; (800f9ac <can_lld_init+0x1c>)
 800f994:	4620      	mov	r0, r4
 800f996:	f7fe fa63 	bl	800de60 <canObjectInit>
  CAND2.can = CAN2;
#endif

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800f99a:	2100      	movs	r1, #0
void can_lld_init(void) {

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
  CAND1.can = CAN1;
 800f99c:	4b04      	ldr	r3, [pc, #16]	; (800f9b0 <can_lld_init+0x20>)
 800f99e:	62e3      	str	r3, [r4, #44]	; 0x2c
  CAND2.can = CAN2;
#endif

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800f9a0:	460a      	mov	r2, r1
 800f9a2:	200e      	movs	r0, #14
#else
  can_lld_set_filters(STM32_CAN_MAX_FILTERS, 0, NULL);
#endif
}
 800f9a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CAND2.can = CAN2;
#endif

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800f9a8:	f7ff beaa 	b.w	800f700 <can_lld_set_filters>
 800f9ac:	200013f8 	.word	0x200013f8
 800f9b0:	40006400 	.word	0x40006400
	...

0800f9c0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 800f9c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800f9c4:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 800fb7c <_pal_lld_init+0x1bc>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800f9c8:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 800fb80 <_pal_lld_init+0x1c0>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800f9cc:	f8d8 a030 	ldr.w	sl, [r8, #48]	; 0x30
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800f9d0:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 800fb84 <_pal_lld_init+0x1c4>
 800f9d4:	4f63      	ldr	r7, [pc, #396]	; (800fb64 <_pal_lld_init+0x1a4>)
 800f9d6:	4e64      	ldr	r6, [pc, #400]	; (800fb68 <_pal_lld_init+0x1a8>)
 800f9d8:	4d64      	ldr	r5, [pc, #400]	; (800fb6c <_pal_lld_init+0x1ac>)
 800f9da:	4c65      	ldr	r4, [pc, #404]	; (800fb70 <_pal_lld_init+0x1b0>)
 800f9dc:	4965      	ldr	r1, [pc, #404]	; (800fb74 <_pal_lld_init+0x1b4>)
 800f9de:	4a66      	ldr	r2, [pc, #408]	; (800fb78 <_pal_lld_init+0x1b8>)
 800f9e0:	f8df b1a4 	ldr.w	fp, [pc, #420]	; 800fb88 <_pal_lld_init+0x1c8>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800f9e4:	f240 19ff 	movw	r9, #511	; 0x1ff
 800f9e8:	ea4a 0a09 	orr.w	sl, sl, r9
 800f9ec:	f8c8 a030 	str.w	sl, [r8, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 800f9f0:	f8d8 a050 	ldr.w	sl, [r8, #80]	; 0x50
 800f9f4:	ea4a 0909 	orr.w	r9, sl, r9
 800f9f8:	f8c8 9050 	str.w	r9, [r8, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800f9fc:	6843      	ldr	r3, [r0, #4]
 800f9fe:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fa02:	6883      	ldr	r3, [r0, #8]
 800fa04:	f8cc 3008 	str.w	r3, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 800fa08:	68c3      	ldr	r3, [r0, #12]
 800fa0a:	f8cc 300c 	str.w	r3, [ip, #12]
  gpiop->ODR     = config->odr;
 800fa0e:	6903      	ldr	r3, [r0, #16]
 800fa10:	f8cc 3014 	str.w	r3, [ip, #20]
  gpiop->AFRL    = config->afrl;
 800fa14:	6943      	ldr	r3, [r0, #20]
 800fa16:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 800fa1a:	6983      	ldr	r3, [r0, #24]
 800fa1c:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fa20:	6803      	ldr	r3, [r0, #0]
 800fa22:	f8cc 3000 	str.w	r3, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800fa26:	6a03      	ldr	r3, [r0, #32]
 800fa28:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fa2c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800fa2e:	f8ce 3008 	str.w	r3, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 800fa32:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800fa34:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 800fa38:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fa3a:	f8ce 3014 	str.w	r3, [lr, #20]
  gpiop->AFRL    = config->afrl;
 800fa3e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800fa40:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 800fa44:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fa46:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fa4a:	69c3      	ldr	r3, [r0, #28]
 800fa4c:	f8ce 3000 	str.w	r3, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800fa50:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800fa52:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fa54:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800fa56:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 800fa58:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800fa5a:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 800fa5c:	6c83      	ldr	r3, [r0, #72]	; 0x48
 800fa5e:	617b      	str	r3, [r7, #20]
  gpiop->AFRL    = config->afrl;
 800fa60:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800fa62:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 800fa64:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800fa66:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fa68:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800fa6a:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800fa6c:	6d87      	ldr	r7, [r0, #88]	; 0x58
 800fa6e:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fa70:	6dc7      	ldr	r7, [r0, #92]	; 0x5c
 800fa72:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 800fa74:	6e07      	ldr	r7, [r0, #96]	; 0x60
 800fa76:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 800fa78:	6e47      	ldr	r7, [r0, #100]	; 0x64
 800fa7a:	6177      	str	r7, [r6, #20]
  gpiop->AFRL    = config->afrl;
 800fa7c:	6e87      	ldr	r7, [r0, #104]	; 0x68
 800fa7e:	6237      	str	r7, [r6, #32]
  gpiop->AFRH    = config->afrh;
 800fa80:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
 800fa82:	6277      	str	r7, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fa84:	6d47      	ldr	r7, [r0, #84]	; 0x54
 800fa86:	6037      	str	r7, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800fa88:	6f46      	ldr	r6, [r0, #116]	; 0x74
 800fa8a:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fa8c:	6f86      	ldr	r6, [r0, #120]	; 0x78
 800fa8e:	60ae      	str	r6, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 800fa90:	6fc6      	ldr	r6, [r0, #124]	; 0x7c
 800fa92:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
 800fa94:	f8d0 6080 	ldr.w	r6, [r0, #128]	; 0x80
 800fa98:	616e      	str	r6, [r5, #20]
  gpiop->AFRL    = config->afrl;
 800fa9a:	f8d0 6084 	ldr.w	r6, [r0, #132]	; 0x84
 800fa9e:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 800faa0:	f8d0 6088 	ldr.w	r6, [r0, #136]	; 0x88
 800faa4:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800faa6:	6f06      	ldr	r6, [r0, #112]	; 0x70
 800faa8:	602e      	str	r6, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800faaa:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
 800faae:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fab0:	f8d0 5094 	ldr.w	r5, [r0, #148]	; 0x94
 800fab4:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 800fab6:	f8d0 5098 	ldr.w	r5, [r0, #152]	; 0x98
 800faba:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 800fabc:	f8d0 509c 	ldr.w	r5, [r0, #156]	; 0x9c
 800fac0:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 800fac2:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 800fac6:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 800fac8:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4
 800facc:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800face:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
 800fad2:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800fad4:	f8d0 40ac 	ldr.w	r4, [r0, #172]	; 0xac
 800fad8:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fada:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 800fade:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 800fae0:	f8d0 40b4 	ldr.w	r4, [r0, #180]	; 0xb4
 800fae4:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 800fae6:	f8d0 40b8 	ldr.w	r4, [r0, #184]	; 0xb8
 800faea:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800faec:	f8d0 40bc 	ldr.w	r4, [r0, #188]	; 0xbc
 800faf0:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800faf2:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
 800faf6:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800faf8:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 800fafc:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800fafe:	f8d0 10c8 	ldr.w	r1, [r0, #200]	; 0xc8
 800fb02:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fb04:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
 800fb08:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800fb0a:	f8d0 10d0 	ldr.w	r1, [r0, #208]	; 0xd0
 800fb0e:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 800fb10:	f8d0 10d4 	ldr.w	r1, [r0, #212]	; 0xd4
 800fb14:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800fb16:	f8d0 10d8 	ldr.w	r1, [r0, #216]	; 0xd8
 800fb1a:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 800fb1c:	f8d0 10dc 	ldr.w	r1, [r0, #220]	; 0xdc
 800fb20:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fb22:	f8d0 10c4 	ldr.w	r1, [r0, #196]	; 0xc4
 800fb26:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800fb28:	f8d0 20e4 	ldr.w	r2, [r0, #228]	; 0xe4
 800fb2c:	f8cb 2004 	str.w	r2, [fp, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fb30:	f8d0 20e8 	ldr.w	r2, [r0, #232]	; 0xe8
 800fb34:	f8cb 2008 	str.w	r2, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
 800fb38:	f8d0 20ec 	ldr.w	r2, [r0, #236]	; 0xec
 800fb3c:	f8cb 200c 	str.w	r2, [fp, #12]
  gpiop->ODR     = config->odr;
 800fb40:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 800fb44:	f8cb 2014 	str.w	r2, [fp, #20]
  gpiop->AFRL    = config->afrl;
 800fb48:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 800fb4c:	f8cb 2020 	str.w	r2, [fp, #32]
  gpiop->AFRH    = config->afrh;
 800fb50:	f8d0 20f8 	ldr.w	r2, [r0, #248]	; 0xf8
 800fb54:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fb58:	f8d0 20e0 	ldr.w	r2, [r0, #224]	; 0xe0
 800fb5c:	f8cb 2000 	str.w	r2, [fp]
 800fb60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fb64:	40020800 	.word	0x40020800
 800fb68:	40020c00 	.word	0x40020c00
 800fb6c:	40021000 	.word	0x40021000
 800fb70:	40021400 	.word	0x40021400
 800fb74:	40021800 	.word	0x40021800
 800fb78:	40021c00 	.word	0x40021c00
 800fb7c:	40023800 	.word	0x40023800
 800fb80:	40020000 	.word	0x40020000
 800fb84:	40020400 	.word	0x40020400
 800fb88:	40022000 	.word	0x40022000
 800fb8c:	00000000 	.word	0x00000000

0800fb90 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 800fb90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
 800fb94:	f04f 0c0f 	mov.w	ip, #15
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800fb98:	f002 0e03 	and.w	lr, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800fb9c:	f3c2 0780 	ubfx	r7, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800fba0:	f3c2 06c1 	ubfx	r6, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 800fba4:	f3c2 1541 	ubfx	r5, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 800fba8:	2400      	movs	r4, #0

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800fbaa:	f3c2 12c3 	ubfx	r2, r2, #7, #4
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 800fbae:	f04f 0901 	mov.w	r9, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800fbb2:	f04f 0803 	mov.w	r8, #3
 800fbb6:	e02b      	b.n	800fc10 <_pal_lld_setgroupmode+0x80>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 800fbb8:	f8d0 b020 	ldr.w	fp, [r0, #32]
 800fbbc:	ea2b 0303 	bic.w	r3, fp, r3
 800fbc0:	ea43 030a 	orr.w	r3, r3, sl
 800fbc4:	6203      	str	r3, [r0, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800fbc6:	6843      	ldr	r3, [r0, #4]
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 800fbc8:	fa09 fa04 	lsl.w	sl, r9, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800fbcc:	ea23 030a 	bic.w	r3, r3, sl
 800fbd0:	433b      	orrs	r3, r7
 800fbd2:	6043      	str	r3, [r0, #4]
 800fbd4:	ea4f 0a44 	mov.w	sl, r4, lsl #1
      m2 = 3 << (bit * 2);
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800fbd8:	6883      	ldr	r3, [r0, #8]
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800fbda:	fa08 fa0a 	lsl.w	sl, r8, sl
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800fbde:	ea6f 0a0a 	mvn.w	sl, sl
 800fbe2:	ea0a 0303 	and.w	r3, sl, r3
 800fbe6:	4333      	orrs	r3, r6
 800fbe8:	6083      	str	r3, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800fbea:	68c3      	ldr	r3, [r0, #12]
 800fbec:	ea0a 0303 	and.w	r3, sl, r3
 800fbf0:	432b      	orrs	r3, r5
 800fbf2:	60c3      	str	r3, [r0, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 800fbf4:	6803      	ldr	r3, [r0, #0]
 800fbf6:	ea0a 0303 	and.w	r3, sl, r3
 800fbfa:	ea43 030e 	orr.w	r3, r3, lr
 800fbfe:	6003      	str	r3, [r0, #0]
    }
    mask >>= 1;
    if (!mask)
 800fc00:	0849      	lsrs	r1, r1, #1
 800fc02:	d019      	beq.n	800fc38 <_pal_lld_setgroupmode+0xa8>
      return;
    otyper <<= 1;
 800fc04:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
 800fc06:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 800fc08:	00ad      	lsls	r5, r5, #2
    moder <<= 2;
 800fc0a:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    bit++;
 800fc0e:	3401      	adds	r4, #1
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800fc10:	f004 0307 	and.w	r3, r4, #7
 800fc14:	009b      	lsls	r3, r3, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 800fc16:	f011 0f01 	tst.w	r1, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800fc1a:	fa02 fa03 	lsl.w	sl, r2, r3
      m4 = 15 << ((bit & 7) * 4);
 800fc1e:	fa0c f303 	lsl.w	r3, ip, r3
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 800fc22:	d0ed      	beq.n	800fc00 <_pal_lld_setgroupmode+0x70>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
 800fc24:	2c07      	cmp	r4, #7
 800fc26:	d9c7      	bls.n	800fbb8 <_pal_lld_setgroupmode+0x28>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 800fc28:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 800fc2c:	ea2b 0303 	bic.w	r3, fp, r3
 800fc30:	ea43 030a 	orr.w	r3, r3, sl
 800fc34:	6243      	str	r3, [r0, #36]	; 0x24
 800fc36:	e7c6      	b.n	800fbc6 <_pal_lld_setgroupmode+0x36>
 800fc38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fc3c:	0000      	movs	r0, r0
	...

0800fc40 <i2c_lld_serve_event_interrupt>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
 800fc40:	b538      	push	{r3, r4, r5, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 800fc42:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800fc44:	4a38      	ldr	r2, [pc, #224]	; (800fd28 <i2c_lld_serve_event_interrupt+0xe8>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 800fc46:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 800fc48:	6965      	ldr	r5, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800fc4a:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 800fc4e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800fc52:	4293      	cmp	r3, r2
 800fc54:	d04b      	beq.n	800fcee <i2c_lld_serve_event_interrupt+0xae>
 800fc56:	d81b      	bhi.n	800fc90 <i2c_lld_serve_event_interrupt+0x50>
 800fc58:	3a07      	subs	r2, #7
 800fc5a:	4293      	cmp	r3, r2
 800fc5c:	d03b      	beq.n	800fcd6 <i2c_lld_serve_event_interrupt+0x96>
 800fc5e:	3201      	adds	r2, #1
 800fc60:	4293      	cmp	r3, r2
 800fc62:	d110      	bne.n	800fc86 <i2c_lld_serve_event_interrupt+0x46>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fc64:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 800fc66:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fc68:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 800fc6c:	681b      	ldr	r3, [r3, #0]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fc6e:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 800fc70:	681a      	ldr	r2, [r3, #0]
 800fc72:	f042 0201 	orr.w	r2, r2, #1
 800fc76:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 800fc78:	6862      	ldr	r2, [r4, #4]
 800fc7a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800fc7e:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 800fc80:	685b      	ldr	r3, [r3, #4]
 800fc82:	2b01      	cmp	r3, #1
 800fc84:	d94a      	bls.n	800fd1c <i2c_lld_serve_event_interrupt+0xdc>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 800fc86:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 800fc8a:	bf18      	it	ne
 800fc8c:	69a3      	ldrne	r3, [r4, #24]
 800fc8e:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800fc90:	4a26      	ldr	r2, [pc, #152]	; (800fd2c <i2c_lld_serve_event_interrupt+0xec>)
 800fc92:	4293      	cmp	r3, r2
 800fc94:	d010      	beq.n	800fcb8 <i2c_lld_serve_event_interrupt+0x78>
 800fc96:	3202      	adds	r2, #2
 800fc98:	4293      	cmp	r3, r2
 800fc9a:	d1f4      	bne.n	800fc86 <i2c_lld_serve_event_interrupt+0x46>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 800fc9c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fc9e:	681b      	ldr	r3, [r3, #0]
 800fca0:	6859      	ldr	r1, [r3, #4]
 800fca2:	2900      	cmp	r1, #0
 800fca4:	d02c      	beq.n	800fd00 <i2c_lld_serve_event_interrupt+0xc0>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800fca6:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800fca8:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800fcaa:	f042 0201 	orr.w	r2, r2, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800fcae:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800fcb2:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800fcb4:	6023      	str	r3, [r4, #0]
      return;
 800fcb6:	bd38      	pop	{r3, r4, r5, pc}
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fcb8:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800fcba:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fcbc:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 800fcc0:	6812      	ldr	r2, [r2, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fcc2:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800fcc4:	6813      	ldr	r3, [r2, #0]
 800fcc6:	f043 0301 	orr.w	r3, r3, #1
 800fcca:	6013      	str	r3, [r2, #0]
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 800fccc:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 800fcd0:	bf18      	it	ne
 800fcd2:	69a3      	ldrne	r3, [r4, #24]
 800fcd4:	bd38      	pop	{r3, r4, r5, pc}
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 800fcd6:	8c03      	ldrh	r3, [r0, #32]
 800fcd8:	0a1a      	lsrs	r2, r3, #8
 800fcda:	d00b      	beq.n	800fcf4 <i2c_lld_serve_event_interrupt+0xb4>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 800fcdc:	f003 0301 	and.w	r3, r3, #1
 800fce0:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 800fce4:	f002 0206 	and.w	r2, r2, #6
 800fce8:	4313      	orrs	r3, r2
 800fcea:	6123      	str	r3, [r4, #16]
 800fcec:	e7cb      	b.n	800fc86 <i2c_lld_serve_event_interrupt+0x46>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 800fcee:	8c03      	ldrh	r3, [r0, #32]
 800fcf0:	f3c3 0347 	ubfx	r3, r3, #1, #8
 800fcf4:	6123      	str	r3, [r4, #16]
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 800fcf6:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 800fcfa:	bf18      	it	ne
 800fcfc:	69a3      	ldrne	r3, [r4, #24]
 800fcfe:	bd38      	pop	{r3, r4, r5, pc}
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fd00:	6863      	ldr	r3, [r4, #4]
 800fd02:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800fd06:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 800fd08:	6823      	ldr	r3, [r4, #0]
 800fd0a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800fd0e:	6023      	str	r3, [r4, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800fd10:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800fd12:	301c      	adds	r0, #28
 800fd14:	f7fd fd44 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fd18:	b662      	cpsie	i
 800fd1a:	e7b4      	b.n	800fc86 <i2c_lld_serve_event_interrupt+0x46>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 800fd1c:	6823      	ldr	r3, [r4, #0]
 800fd1e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800fd22:	6023      	str	r3, [r4, #0]
 800fd24:	e7af      	b.n	800fc86 <i2c_lld_serve_event_interrupt+0x46>
 800fd26:	bf00      	nop
 800fd28:	00030008 	.word	0x00030008
 800fd2c:	00070082 	.word	0x00070082

0800fd30 <i2c_lld_serve_error_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in]  sr       content of the SR1 register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {
 800fd30:	b570      	push	{r4, r5, r6, lr}

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800fd32:	6b05      	ldr	r5, [r0, #48]	; 0x30
 800fd34:	682a      	ldr	r2, [r5, #0]
 800fd36:	6813      	ldr	r3, [r2, #0]
 800fd38:	f023 031f 	bic.w	r3, r3, #31
 800fd3c:	6013      	str	r3, [r2, #0]
 800fd3e:	6813      	ldr	r3, [r2, #0]
 800fd40:	07de      	lsls	r6, r3, #31
 800fd42:	d4fc      	bmi.n	800fd3e <i2c_lld_serve_error_interrupt+0xe>
 800fd44:	7a2e      	ldrb	r6, [r5, #8]
  dmaStreamDisable(i2cp->dmarx);
 800fd46:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800fd48:	686d      	ldr	r5, [r5, #4]
  dmaStreamDisable(i2cp->dmarx);
 800fd4a:	6822      	ldr	r2, [r4, #0]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800fd4c:	233d      	movs	r3, #61	; 0x3d
 800fd4e:	40b3      	lsls	r3, r6
 800fd50:	602b      	str	r3, [r5, #0]
  dmaStreamDisable(i2cp->dmarx);
 800fd52:	6813      	ldr	r3, [r2, #0]
 800fd54:	f023 031f 	bic.w	r3, r3, #31
 800fd58:	6013      	str	r3, [r2, #0]
 800fd5a:	6813      	ldr	r3, [r2, #0]
 800fd5c:	f013 0301 	ands.w	r3, r3, #1
 800fd60:	d1fb      	bne.n	800fd5a <i2c_lld_serve_error_interrupt+0x2a>
 800fd62:	7a25      	ldrb	r5, [r4, #8]
 800fd64:	6864      	ldr	r4, [r4, #4]
 800fd66:	223d      	movs	r2, #61	; 0x3d
 800fd68:	40aa      	lsls	r2, r5

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 800fd6a:	05cd      	lsls	r5, r1, #23
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 800fd6c:	6022      	str	r2, [r4, #0]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 800fd6e:	bf48      	it	mi
 800fd70:	2301      	movmi	r3, #1

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 800fd72:	058c      	lsls	r4, r1, #22
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 800fd74:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;
 800fd76:	bf44      	itt	mi
 800fd78:	f043 0302 	orrmi.w	r3, r3, #2
 800fd7c:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 800fd7e:	054a      	lsls	r2, r1, #21
 800fd80:	d50b      	bpl.n	800fd9a <i2c_lld_serve_error_interrupt+0x6a>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800fd82:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800fd84:	6854      	ldr	r4, [r2, #4]
 800fd86:	f424 7400 	bic.w	r4, r4, #512	; 0x200
 800fd8a:	6054      	str	r4, [r2, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800fd8c:	6814      	ldr	r4, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 800fd8e:	f043 0304 	orr.w	r3, r3, #4
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800fd92:	f444 7400 	orr.w	r4, r4, #512	; 0x200
 800fd96:	6014      	str	r4, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 800fd98:	6083      	str	r3, [r0, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 800fd9a:	050e      	lsls	r6, r1, #20
    i2cp->errors |= I2C_OVERRUN;
 800fd9c:	bf44      	itt	mi
 800fd9e:	f043 0308 	orrmi.w	r3, r3, #8
 800fda2:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 800fda4:	044d      	lsls	r5, r1, #17
    i2cp->errors |= I2C_TIMEOUT;
 800fda6:	bf44      	itt	mi
 800fda8:	f043 0320 	orrmi.w	r3, r3, #32
 800fdac:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 800fdae:	04cc      	lsls	r4, r1, #19
 800fdb0:	d50c      	bpl.n	800fdcc <i2c_lld_serve_error_interrupt+0x9c>
    i2cp->errors |= I2C_PEC_ERROR;
 800fdb2:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800fdb6:	0409      	lsls	r1, r1, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 800fdb8:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800fdba:	d40c      	bmi.n	800fdd6 <i2c_lld_serve_error_interrupt+0xa6>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800fdbc:	b672      	cpsid	i
 800fdbe:	f06f 0101 	mvn.w	r1, #1
 800fdc2:	301c      	adds	r0, #28
 800fdc4:	f7fd fcec 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fdc8:	b662      	cpsie	i
 800fdca:	bd70      	pop	{r4, r5, r6, pc}
 800fdcc:	040a      	lsls	r2, r1, #16
 800fdce:	d402      	bmi.n	800fdd6 <i2c_lld_serve_error_interrupt+0xa6>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 800fdd0:	2b00      	cmp	r3, #0
 800fdd2:	d1f3      	bne.n	800fdbc <i2c_lld_serve_error_interrupt+0x8c>
 800fdd4:	bd70      	pop	{r4, r5, r6, pc}

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 800fdd6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800fdda:	6083      	str	r3, [r0, #8]
 800fddc:	e7ee      	b.n	800fdbc <i2c_lld_serve_error_interrupt+0x8c>
 800fdde:	bf00      	nop

0800fde0 <i2c_lld_serve_tx_end_irq>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800fde0:	f011 0f0c 	tst.w	r1, #12
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 800fde4:	b538      	push	{r3, r4, r5, lr}
 800fde6:	4605      	mov	r5, r0
  I2C_TypeDef *dp = i2cp->i2c;
 800fde8:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800fdea:	d112      	bne.n	800fe12 <i2c_lld_serve_tx_end_irq+0x32>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 800fdec:	6b29      	ldr	r1, [r5, #48]	; 0x30
 800fdee:	680a      	ldr	r2, [r1, #0]
 800fdf0:	6813      	ldr	r3, [r2, #0]
 800fdf2:	f023 031f 	bic.w	r3, r3, #31
 800fdf6:	6013      	str	r3, [r2, #0]
 800fdf8:	6813      	ldr	r3, [r2, #0]
 800fdfa:	07db      	lsls	r3, r3, #31
 800fdfc:	d4fc      	bmi.n	800fdf8 <i2c_lld_serve_tx_end_irq+0x18>
 800fdfe:	7a08      	ldrb	r0, [r1, #8]
 800fe00:	684a      	ldr	r2, [r1, #4]
 800fe02:	233d      	movs	r3, #61	; 0x3d
 800fe04:	4083      	lsls	r3, r0
 800fe06:	6013      	str	r3, [r2, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800fe08:	6863      	ldr	r3, [r4, #4]
 800fe0a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800fe0e:	6063      	str	r3, [r4, #4]
 800fe10:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 800fe12:	4802      	ldr	r0, [pc, #8]	; (800fe1c <i2c_lld_serve_tx_end_irq+0x3c>)
 800fe14:	f7fd fa0c 	bl	800d230 <chSysHalt>
 800fe18:	e7e8      	b.n	800fdec <i2c_lld_serve_tx_end_irq+0xc>
 800fe1a:	bf00      	nop
 800fe1c:	08016770 	.word	0x08016770

0800fe20 <i2c_lld_serve_rx_end_irq>:
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800fe20:	f011 0f0c 	tst.w	r1, #12
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 800fe24:	b538      	push	{r3, r4, r5, lr}
 800fe26:	4605      	mov	r5, r0
  I2C_TypeDef *dp = i2cp->i2c;
 800fe28:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800fe2a:	d121      	bne.n	800fe70 <i2c_lld_serve_rx_end_irq+0x50>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 800fe2c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800fe2e:	6813      	ldr	r3, [r2, #0]
 800fe30:	6819      	ldr	r1, [r3, #0]
 800fe32:	f021 011f 	bic.w	r1, r1, #31
 800fe36:	6019      	str	r1, [r3, #0]
 800fe38:	6819      	ldr	r1, [r3, #0]
 800fe3a:	f011 0101 	ands.w	r1, r1, #1
 800fe3e:	d1fb      	bne.n	800fe38 <i2c_lld_serve_rx_end_irq+0x18>
 800fe40:	7a10      	ldrb	r0, [r2, #8]
 800fe42:	6852      	ldr	r2, [r2, #4]
 800fe44:	233d      	movs	r3, #61	; 0x3d
 800fe46:	4083      	lsls	r3, r0
 800fe48:	6013      	str	r3, [r2, #0]

  dp->CR2 &= ~I2C_CR2_LAST;
 800fe4a:	6863      	ldr	r3, [r4, #4]
 800fe4c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800fe50:	6063      	str	r3, [r4, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 800fe52:	6823      	ldr	r3, [r4, #0]
 800fe54:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800fe58:	6023      	str	r3, [r4, #0]
  dp->CR1 |= I2C_CR1_STOP;
 800fe5a:	6823      	ldr	r3, [r4, #0]
 800fe5c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800fe60:	6023      	str	r3, [r4, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800fe62:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800fe64:	f105 001c 	add.w	r0, r5, #28
 800fe68:	f7fd fc9a 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fe6c:	b662      	cpsie	i
 800fe6e:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 800fe70:	4801      	ldr	r0, [pc, #4]	; (800fe78 <i2c_lld_serve_rx_end_irq+0x58>)
 800fe72:	f7fd f9dd 	bl	800d230 <chSysHalt>
 800fe76:	e7d9      	b.n	800fe2c <i2c_lld_serve_rx_end_irq+0xc>
 800fe78:	08016770 	.word	0x08016770
 800fe7c:	00000000 	.word	0x00000000

0800fe80 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 800fe80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);
 800fe82:	4803      	ldr	r0, [pc, #12]	; (800fe90 <VectorBC+0x10>)
 800fe84:	f7ff fedc 	bl	800fc40 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 800fe88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 800fe8c:	f7fd bf50 	b.w	800dd30 <_port_irq_epilogue>
 800fe90:	20001428 	.word	0x20001428
	...

0800fea0 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 800fea0:	4807      	ldr	r0, [pc, #28]	; (800fec0 <VectorC0+0x20>)
 800fea2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800fea4:	6951      	ldr	r1, [r2, #20]
}

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 800fea6:	b508      	push	{r3, lr}
 800fea8:	b289      	uxth	r1, r1
  uint16_t sr = I2CD1.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 800feaa:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 800feae:	43db      	mvns	r3, r3
 800feb0:	6153      	str	r3, [r2, #20]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);
 800feb2:	f7ff ff3d 	bl	800fd30 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 800feb6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 800feba:	f7fd bf39 	b.w	800dd30 <_port_irq_epilogue>
 800febe:	bf00      	nop
 800fec0:	20001428 	.word	0x20001428
	...

0800fed0 <VectorC4>:
/**
 * @brief   I2C2 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {
 800fed0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);
 800fed2:	4803      	ldr	r0, [pc, #12]	; (800fee0 <VectorC4+0x10>)
 800fed4:	f7ff feb4 	bl	800fc40 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 800fed8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 800fedc:	f7fd bf28 	b.w	800dd30 <_port_irq_epilogue>
 800fee0:	20001460 	.word	0x20001460
	...

0800fef0 <VectorC8>:
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 800fef0:	4807      	ldr	r0, [pc, #28]	; (800ff10 <VectorC8+0x20>)
 800fef2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800fef4:	6951      	ldr	r1, [r2, #20]
/**
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
 800fef6:	b508      	push	{r3, lr}
 800fef8:	b289      	uxth	r1, r1
  uint16_t sr = I2CD2.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 800fefa:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 800fefe:	43db      	mvns	r3, r3
 800ff00:	6153      	str	r3, [r2, #20]
  i2c_lld_serve_error_interrupt(&I2CD2, sr);
 800ff02:	f7ff ff15 	bl	800fd30 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 800ff06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 800ff0a:	f7fd bf11 	b.w	800dd30 <_port_irq_epilogue>
 800ff0e:	bf00      	nop
 800ff10:	20001460 	.word	0x20001460
	...

0800ff20 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 800ff20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 800ff22:	4e0d      	ldr	r6, [pc, #52]	; (800ff58 <i2c_lld_init+0x38>)
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 800ff24:	4d0d      	ldr	r5, [pc, #52]	; (800ff5c <i2c_lld_init+0x3c>)

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800ff26:	4c0e      	ldr	r4, [pc, #56]	; (800ff60 <i2c_lld_init+0x40>)
 * @notapi
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 800ff28:	4630      	mov	r0, r6
 800ff2a:	f7fd fff9 	bl	800df20 <i2cObjectInit>
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 800ff2e:	4b0d      	ldr	r3, [pc, #52]	; (800ff64 <i2c_lld_init+0x44>)
 800ff30:	6373      	str	r3, [r6, #52]	; 0x34
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 800ff32:	2700      	movs	r7, #0
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 800ff34:	f104 0348 	add.w	r3, r4, #72	; 0x48
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 800ff38:	4628      	mov	r0, r5

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800ff3a:	62f4      	str	r4, [r6, #44]	; 0x2c
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 800ff3c:	6333      	str	r3, [r6, #48]	; 0x30
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 800ff3e:	61f7      	str	r7, [r6, #28]
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 800ff40:	f7fd ffee 	bl	800df20 <i2cObjectInit>
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 800ff44:	f104 0318 	add.w	r3, r4, #24
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 800ff48:	4a07      	ldr	r2, [pc, #28]	; (800ff68 <i2c_lld_init+0x48>)
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 800ff4a:	61ef      	str	r7, [r5, #28]
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 800ff4c:	3454      	adds	r4, #84	; 0x54
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 800ff4e:	636a      	str	r2, [r5, #52]	; 0x34
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 800ff50:	62eb      	str	r3, [r5, #44]	; 0x2c
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 800ff52:	632c      	str	r4, [r5, #48]	; 0x30
 800ff54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ff56:	bf00      	nop
 800ff58:	20001428 	.word	0x20001428
 800ff5c:	20001460 	.word	0x20001460
 800ff60:	080166b0 	.word	0x080166b0
 800ff64:	40005400 	.word	0x40005400
 800ff68:	40005800 	.word	0x40005800
 800ff6c:	00000000 	.word	0x00000000

0800ff70 <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 800ff70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800ff74:	7803      	ldrb	r3, [r0, #0]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800ff76:	6b45      	ldr	r5, [r0, #52]	; 0x34

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800ff78:	f240 4256 	movw	r2, #1110	; 0x456
 800ff7c:	6282      	str	r2, [r0, #40]	; 0x28
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800ff7e:	2b01      	cmp	r3, #1

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800ff80:	f240 4216 	movw	r2, #1046	; 0x416
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 800ff84:	4604      	mov	r4, r0

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800ff86:	6242      	str	r2, [r0, #36]	; 0x24
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800ff88:	d043      	beq.n	8010012 <i2c_lld_start+0xa2>
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800ff8a:	462b      	mov	r3, r5
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800ff8c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800ff8e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800ff90:	6860      	ldr	r0, [r4, #4]
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800ff92:	f8d1 9000 	ldr.w	r9, [r1]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800ff96:	f8d2 8000 	ldr.w	r8, [r2]
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 800ff9a:	6844      	ldr	r4, [r0, #4]
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 800ff9c:	f890 e008 	ldrb.w	lr, [r0, #8]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 800ffa0:	4e64      	ldr	r6, [pc, #400]	; (8010134 <i2c_lld_start+0x1c4>)
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800ffa2:	f105 0110 	add.w	r1, r5, #16
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 800ffa6:	f44f 6710 	mov.w	r7, #2304	; 0x900
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 800ffaa:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
  dp->CR1 = 0;
 800ffae:	2200      	movs	r2, #0
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800ffb0:	f8c9 1008 	str.w	r1, [r9, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800ffb4:	f8c8 1008 	str.w	r1, [r8, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 800ffb8:	f8c5 c000 	str.w	ip, [r5]
  dp->CR1 = 0;
 800ffbc:	602a      	str	r2, [r5, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 800ffbe:	606f      	str	r7, [r5, #4]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 800ffc0:	685f      	ldr	r7, [r3, #4]
 800ffc2:	f64f 71c0 	movw	r1, #65472	; 0xffc0
 800ffc6:	4039      	ands	r1, r7
 800ffc8:	6059      	str	r1, [r3, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 800ffca:	6859      	ldr	r1, [r3, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 800ffcc:	42b4      	cmp	r4, r6
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 800ffce:	f041 012a 	orr.w	r1, r1, #42	; 0x2a
 800ffd2:	6059      	str	r1, [r3, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 800ffd4:	dd54      	ble.n	8010080 <i2c_lld_start+0x110>
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
 800ffd6:	4958      	ldr	r1, [pc, #352]	; (8010138 <i2c_lld_start+0x1c8>)
 800ffd8:	428c      	cmp	r4, r1
 800ffda:	dc09      	bgt.n	800fff0 <i2c_lld_start+0x80>
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 800ffdc:	f1be 0f02 	cmp.w	lr, #2
 800ffe0:	d06d      	beq.n	80100be <i2c_lld_start+0x14e>
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 800ffe2:	f1be 0f03 	cmp.w	lr, #3
 800ffe6:	d05d      	beq.n	80100a4 <i2c_lld_start+0x134>
 800ffe8:	f648 72ff 	movw	r2, #36863	; 0x8fff
    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 800ffec:	210d      	movs	r1, #13
 800ffee:	6219      	str	r1, [r3, #32]
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");

  dp->CCR = regCCR;
 800fff0:	61da      	str	r2, [r3, #28]
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 800fff2:	7801      	ldrb	r1, [r0, #0]
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 800fff4:	681a      	ldr	r2, [r3, #0]
  switch (opmode) {
 800fff6:	2902      	cmp	r1, #2
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 800fff8:	b292      	uxth	r2, r2
  switch (opmode) {
 800fffa:	d04d      	beq.n	8010098 <i2c_lld_start+0x128>
 800fffc:	2903      	cmp	r1, #3
 800fffe:	d048      	beq.n	8010092 <i2c_lld_start+0x122>
 8010000:	2901      	cmp	r1, #1
 8010002:	d039      	beq.n	8010078 <i2c_lld_start+0x108>
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  }
  dp->CR1 = regCR1;
 8010004:	601a      	str	r2, [r3, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8010006:	682b      	ldr	r3, [r5, #0]
 8010008:	f043 0301 	orr.w	r3, r3, #1
 801000c:	602b      	str	r3, [r5, #0]
 801000e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 8010012:	4b4a      	ldr	r3, [pc, #296]	; (801013c <i2c_lld_start+0x1cc>)
 8010014:	4298      	cmp	r0, r3
 8010016:	d060      	beq.n	80100da <i2c_lld_start+0x16a>
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
    }
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
 8010018:	4b49      	ldr	r3, [pc, #292]	; (8010140 <i2c_lld_start+0x1d0>)
 801001a:	4298      	cmp	r0, r3
 801001c:	d1b5      	bne.n	800ff8a <i2c_lld_start+0x1a>
      bool b;

      rccResetI2C2();
 801001e:	4e49      	ldr	r6, [pc, #292]	; (8010144 <i2c_lld_start+0x1d4>)
      b = dmaStreamAllocate(i2cp->dmarx,
 8010020:	6ac0      	ldr	r0, [r0, #44]	; 0x2c

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      bool b;

      rccResetI2C2();
 8010022:	6a33      	ldr	r3, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 8010024:	4a48      	ldr	r2, [pc, #288]	; (8010148 <i2c_lld_start+0x1d8>)

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      bool b;

      rccResetI2C2();
 8010026:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 801002a:	2700      	movs	r7, #0
 801002c:	6233      	str	r3, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 801002e:	2105      	movs	r1, #5
 8010030:	4623      	mov	r3, r4

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      bool b;

      rccResetI2C2();
 8010032:	6237      	str	r7, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 8010034:	f7fe fe8c 	bl	800ed50 <dmaStreamAllocate>
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(i2cp->dmatx,
 8010038:	4a44      	ldr	r2, [pc, #272]	; (801014c <i2c_lld_start+0x1dc>)
 801003a:	6b20      	ldr	r0, [r4, #48]	; 0x30
 801003c:	2105      	movs	r1, #5
 801003e:	4623      	mov	r3, r4
 8010040:	f7fe fe86 	bl	800ed50 <dmaStreamAllocate>
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
 8010044:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8010046:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 801004a:	6433      	str	r3, [r6, #64]	; 0x40
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
 801004c:	2021      	movs	r0, #33	; 0x21
 801004e:	2105      	movs	r1, #5
 8010050:	f7fe fcae 	bl	800e9b0 <nvicEnableVector>
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
 8010054:	2105      	movs	r1, #5
 8010056:	2022      	movs	r0, #34	; 0x22
 8010058:	f7fe fcaa 	bl	800e9b0 <nvicEnableVector>

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 801005c:	6a61      	ldr	r1, [r4, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 801005e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8010060:	6b63      	ldr	r3, [r4, #52]	; 0x34
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8010062:	f041 6160 	orr.w	r1, r1, #234881024	; 0xe000000
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8010066:	f042 6260 	orr.w	r2, r2, #234881024	; 0xe000000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 801006a:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 801006e:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8010072:	6261      	str	r1, [r4, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8010074:	62a2      	str	r2, [r4, #40]	; 0x28
 8010076:	e789      	b.n	800ff8c <i2c_lld_start+0x1c>
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8010078:	f022 020a 	bic.w	r2, r2, #10
 801007c:	b292      	uxth	r2, r2
 801007e:	e7c1      	b.n	8010004 <i2c_lld_start+0x94>
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8010080:	212b      	movs	r1, #43	; 0x2b
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8010082:	0064      	lsls	r4, r4, #1
 8010084:	4a32      	ldr	r2, [pc, #200]	; (8010150 <i2c_lld_start+0x1e0>)
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8010086:	6219      	str	r1, [r3, #32]
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8010088:	fbb2 f2f4 	udiv	r2, r2, r4
 801008c:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8010090:	e7ae      	b.n	800fff0 <i2c_lld_start+0x80>
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8010092:	f042 020a 	orr.w	r2, r2, #10
 8010096:	e7b5      	b.n	8010004 <i2c_lld_start+0x94>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8010098:	f022 0208 	bic.w	r2, r2, #8
 801009c:	b292      	uxth	r2, r2
 801009e:	f042 0202 	orr.w	r2, r2, #2
 80100a2:	e7af      	b.n	8010004 <i2c_lld_start+0x94>
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 80100a4:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 80100a8:	eb02 0482 	add.w	r4, r2, r2, lsl #2
 80100ac:	4a28      	ldr	r2, [pc, #160]	; (8010150 <i2c_lld_start+0x1e0>)
 80100ae:	fbb2 f2f4 	udiv	r2, r2, r4
 80100b2:	ea6f 4282 	mvn.w	r2, r2, lsl #18
 80100b6:	ea6f 4292 	mvn.w	r2, r2, lsr #18
 80100ba:	b292      	uxth	r2, r2
 80100bc:	e796      	b.n	800ffec <i2c_lld_start+0x7c>

    if (duty == FAST_DUTY_CYCLE_2) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 80100be:	f101 711e 	add.w	r1, r1, #41418752	; 0x2780000
 80100c2:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 80100c6:	f501 3131 	add.w	r1, r1, #181248	; 0x2c400
 80100ca:	fbb1 f2f2 	udiv	r2, r1, r2
 80100ce:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 80100d2:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 80100d6:	b292      	uxth	r2, r2
 80100d8:	e788      	b.n	800ffec <i2c_lld_start+0x7c>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 80100da:	4e1a      	ldr	r6, [pc, #104]	; (8010144 <i2c_lld_start+0x1d4>)
      b = dmaStreamAllocate(i2cp->dmarx,
 80100dc:	6ac0      	ldr	r0, [r0, #44]	; 0x2c

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 80100de:	6a33      	ldr	r3, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 80100e0:	4a19      	ldr	r2, [pc, #100]	; (8010148 <i2c_lld_start+0x1d8>)

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 80100e2:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80100e6:	2700      	movs	r7, #0
 80100e8:	6233      	str	r3, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 80100ea:	2105      	movs	r1, #5
 80100ec:	4623      	mov	r3, r4

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 80100ee:	6237      	str	r7, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 80100f0:	f7fe fe2e 	bl	800ed50 <dmaStreamAllocate>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(i2cp->dmatx,
 80100f4:	4a15      	ldr	r2, [pc, #84]	; (801014c <i2c_lld_start+0x1dc>)
 80100f6:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80100f8:	2105      	movs	r1, #5
 80100fa:	4623      	mov	r3, r4
 80100fc:	f7fe fe28 	bl	800ed50 <dmaStreamAllocate>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 8010100:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8010102:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8010106:	6433      	str	r3, [r6, #64]	; 0x40
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
 8010108:	201f      	movs	r0, #31
 801010a:	2105      	movs	r1, #5
 801010c:	f7fe fc50 	bl	800e9b0 <nvicEnableVector>
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
 8010110:	2105      	movs	r1, #5
 8010112:	2020      	movs	r0, #32
 8010114:	f7fe fc4c 	bl	800e9b0 <nvicEnableVector>

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8010118:	6a61      	ldr	r1, [r4, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 801011a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 801011c:	6b63      	ldr	r3, [r4, #52]	; 0x34
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 801011e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8010122:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8010126:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 801012a:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 801012e:	6261      	str	r1, [r4, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8010130:	62a2      	str	r2, [r4, #40]	; 0x28
 8010132:	e72b      	b.n	800ff8c <i2c_lld_start+0x1c>
 8010134:	000186a0 	.word	0x000186a0
 8010138:	00061a80 	.word	0x00061a80
 801013c:	20001428 	.word	0x20001428
 8010140:	20001460 	.word	0x20001460
 8010144:	40023800 	.word	0x40023800
 8010148:	0800fe21 	.word	0x0800fe21
 801014c:	0800fde1 	.word	0x0800fde1
 8010150:	0280de80 	.word	0x0280de80
	...

08010160 <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8010160:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8010164:	0049      	lsls	r1, r1, #1
#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 8010166:	2400      	movs	r4, #0

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8010168:	8401      	strh	r1, [r0, #32]
#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 801016a:	6084      	str	r4, [r0, #8]
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 801016c:	4694      	mov	ip, r2
 801016e:	4698      	mov	r8, r3
  I2C_TypeDef *dp = i2cp->i2c;
 8010170:	6b44      	ldr	r4, [r0, #52]	; 0x34
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8010172:	f8dd 901c 	ldr.w	r9, [sp, #28]
 8010176:	9908      	ldr	r1, [sp, #32]
 8010178:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
 801017c:	b662      	cpsie	i

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 801017e:	6b05      	ldr	r5, [r0, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8010180:	6ac2      	ldr	r2, [r0, #44]	; 0x2c

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8010182:	682f      	ldr	r7, [r5, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8010184:	6816      	ldr	r6, [r2, #0]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8010186:	6a83      	ldr	r3, [r0, #40]	; 0x28
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8010188:	6a42      	ldr	r2, [r0, #36]	; 0x24
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 801018a:	4d15      	ldr	r5, [pc, #84]	; (80101e0 <i2c_lld_master_transmit_timeout+0x80>)

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 801018c:	603b      	str	r3, [r7, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 801018e:	f8c7 c00c 	str.w	ip, [r7, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8010192:	f8c7 8004 	str.w	r8, [r7, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8010196:	6032      	str	r2, [r6, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8010198:	f8c6 900c 	str.w	r9, [r6, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 801019c:	6071      	str	r1, [r6, #4]
 801019e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80101a0:	e000      	b.n	80101a4 <i2c_lld_master_transmit_timeout+0x44>
 80101a2:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80101a4:	b672      	cpsid	i
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 80101a6:	69a3      	ldr	r3, [r4, #24]
 80101a8:	0799      	lsls	r1, r3, #30
 80101aa:	d402      	bmi.n	80101b2 <i2c_lld_master_transmit_timeout+0x52>
 80101ac:	6823      	ldr	r3, [r4, #0]
 80101ae:	059b      	lsls	r3, r3, #22
 80101b0:	d508      	bpl.n	80101c4 <i2c_lld_master_transmit_timeout+0x64>
 80101b2:	6aab      	ldr	r3, [r5, #40]	; 0x28
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((time - start) < (end - start));
 80101b4:	1a9b      	subs	r3, r3, r2
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 80101b6:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 80101ba:	d3f2      	bcc.n	80101a2 <i2c_lld_master_transmit_timeout+0x42>
  dp->CR2 |= I2C_CR2_ITEVTEN;
  dp->CR1 |= I2C_CR1_START;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 80101bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80101c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 80101c4:	6863      	ldr	r3, [r4, #4]
 80101c6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80101ca:	6063      	str	r3, [r4, #4]
  dp->CR1 |= I2C_CR1_START;
 80101cc:	6823      	ldr	r3, [r4, #0]
 80101ce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 * @sclass
 */
static inline msg_t osalThreadSuspendTimeoutS(thread_reference_t *trp,
                                              systime_t timeout) {

  return chThdSuspendTimeoutS(trp, timeout);
 80101d2:	4671      	mov	r1, lr
 80101d4:	6023      	str	r3, [r4, #0]
 80101d6:	301c      	adds	r0, #28

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 80101d8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80101dc:	f7fd bad0 	b.w	800d780 <chThdSuspendTimeoutS>
 80101e0:	200010b8 	.word	0x200010b8
	...

080101f0 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 80101f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80101f4:	4ba7      	ldr	r3, [pc, #668]	; (8010494 <usb_lld_pump+0x2a4>)
 80101f6:	4aa8      	ldr	r2, [pc, #672]	; (8010498 <usb_lld_pump+0x2a8>)
 80101f8:	699b      	ldr	r3, [r3, #24]
  USBDriver *usbp = (USBDriver *)p;
  stm32_otg_t *otgp = usbp->otg;
 80101fa:	f8d0 a050 	ldr.w	sl, [r0, #80]	; 0x50
 80101fe:	619a      	str	r2, [r3, #24]
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8010200:	b085      	sub	sp, #20
 8010202:	b672      	cpsid	i
 8010204:	f100 0360 	add.w	r3, r0, #96	; 0x60
 8010208:	46d3      	mov	fp, sl
 801020a:	9303      	str	r3, [sp, #12]
 801020c:	4682      	mov	sl, r0
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 801020e:	f89a 3000 	ldrb.w	r3, [sl]
 8010212:	2b01      	cmp	r3, #1
 8010214:	d006      	beq.n	8010224 <usb_lld_pump+0x34>
 8010216:	f8da 305c 	ldr.w	r3, [sl, #92]	; 0x5c
 801021a:	b963      	cbnz	r3, 8010236 <usb_lld_pump+0x46>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 801021c:	f8db 3014 	ldr.w	r3, [fp, #20]
 8010220:	06da      	lsls	r2, r3, #27
 8010222:	d408      	bmi.n	8010236 <usb_lld_pump+0x46>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 8010224:	f8db 3018 	ldr.w	r3, [fp, #24]
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 8010228:	9803      	ldr	r0, [sp, #12]
 801022a:	f043 0310 	orr.w	r3, r3, #16
 801022e:	f8cb 3018 	str.w	r3, [fp, #24]
 8010232:	f7fd fa95 	bl	800d760 <chThdSuspendS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8010236:	b662      	cpsie	i
 8010238:	f04f 0800 	mov.w	r8, #0

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 801023c:	f8db 3014 	ldr.w	r3, [fp, #20]
 8010240:	06db      	lsls	r3, r3, #27
 8010242:	d523      	bpl.n	801028c <usb_lld_pump+0x9c>
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 8010244:	f8da 2050 	ldr.w	r2, [sl, #80]	; 0x50
 8010248:	6a13      	ldr	r3, [r2, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 801024a:	f403 11f0 	and.w	r1, r3, #1966080	; 0x1e0000
 801024e:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 8010252:	d02e      	beq.n	80102b2 <usb_lld_pump+0xc2>
 8010254:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 8010258:	d1f0      	bne.n	801023c <usb_lld_pump+0x4c>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 801025a:	f003 010f 	and.w	r1, r3, #15
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 801025e:	eb0a 0181 	add.w	r1, sl, r1, lsl #2
  sts = usbp->otg->GRXSTSP;
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8010262:	f3c3 130a 	ubfx	r3, r3, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8010266:	68c9      	ldr	r1, [r1, #12]
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 8010268:	3303      	adds	r3, #3
  max = (max + 3) / 4;
  while (n) {
 801026a:	089b      	lsrs	r3, r3, #2
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 801026c:	6a0c      	ldr	r4, [r1, #32]
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 801026e:	d0e5      	beq.n	801023c <usb_lld_pump+0x4c>
 8010270:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8010274:	2102      	movs	r1, #2
    uint32_t w = *fifop;
 8010276:	6810      	ldr	r0, [r2, #0]
    if (max) {
 8010278:	b111      	cbz	r1, 8010280 <usb_lld_pump+0x90>
      /* Note, this line relies on the Cortex-M3/M4 ability to perform
         unaligned word accesses and on the LSB-first memory organization.*/
      *((PACKED_VAR uint32_t *)buf) = w;
 801027a:	f844 0b04 	str.w	r0, [r4], #4
      buf += 4;
      max--;
 801027e:	3901      	subs	r1, #1
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 8010280:	3b01      	subs	r3, #1
 8010282:	d1f8      	bne.n	8010276 <usb_lld_pump+0x86>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8010284:	f8db 3014 	ldr.w	r3, [fp, #20]
 8010288:	06db      	lsls	r3, r3, #27
 801028a:	d4db      	bmi.n	8010244 <usb_lld_pump+0x54>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 801028c:	2201      	movs	r2, #1
      if (usbp->txpending & epmask) {
 801028e:	f8da 305c 	ldr.w	r3, [sl, #92]	; 0x5c
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 8010292:	fa02 f208 	lsl.w	r2, r2, r8
      if (usbp->txpending & epmask) {
 8010296:	421a      	tst	r2, r3
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 8010298:	9201      	str	r2, [sp, #4]
      if (usbp->txpending & epmask) {
 801029a:	d162      	bne.n	8010362 <usb_lld_pump+0x172>
 801029c:	f108 0801 	add.w	r8, r8, #1
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80102a0:	f8da 3054 	ldr.w	r3, [sl, #84]	; 0x54
 80102a4:	689b      	ldr	r3, [r3, #8]
 80102a6:	fa5f f888 	uxtb.w	r8, r8
 80102aa:	4598      	cmp	r8, r3
 80102ac:	d9c6      	bls.n	801023c <usb_lld_pump+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80102ae:	b672      	cpsid	i
 80102b0:	e7ad      	b.n	801020e <usb_lld_pump+0x1e>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 80102b2:	f003 050f 	and.w	r5, r3, #15
 80102b6:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 80102ba:	f3c3 140a 	ubfx	r4, r3, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    if (usbp->epc[ep]->out_state->rxqueued) {
 80102be:	68eb      	ldr	r3, [r5, #12]
 80102c0:	6998      	ldr	r0, [r3, #24]
 80102c2:	7803      	ldrb	r3, [r0, #0]
 80102c4:	b9db      	cbnz	r3, 80102fe <usb_lld_pump+0x10e>
 80102c6:	6843      	ldr	r3, [r0, #4]
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 80102c8:	6881      	ldr	r1, [r0, #8]
      otg_fifo_read_to_queue(usbp->otg->FIFO[0],
                             usbp->epc[ep]->out_state->mode.queue.rxqueue,
                             cnt);
    }
    else {
      otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80102ca:	68c6      	ldr	r6, [r0, #12]
 80102cc:	3303      	adds	r3, #3
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 80102ce:	1a59      	subs	r1, r3, r1
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 80102d0:	1ce3      	adds	r3, r4, #3
  max = (max + 3) / 4;
  while (n) {
 80102d2:	089b      	lsrs	r3, r3, #2
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 80102d4:	ea4f 0191 	mov.w	r1, r1, lsr #2
  while (n) {
 80102d8:	d009      	beq.n	80102ee <usb_lld_pump+0xfe>
 80102da:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 80102de:	46b6      	mov	lr, r6
    uint32_t w = *fifop;
 80102e0:	6817      	ldr	r7, [r2, #0]
    if (max) {
 80102e2:	b111      	cbz	r1, 80102ea <usb_lld_pump+0xfa>
      /* Note, this line relies on the Cortex-M3/M4 ability to perform
         unaligned word accesses and on the LSB-first memory organization.*/
      *((PACKED_VAR uint32_t *)buf) = w;
 80102e4:	f84e 7b04 	str.w	r7, [lr], #4
      buf += 4;
      max--;
 80102e8:	3901      	subs	r1, #1
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 80102ea:	3b01      	subs	r3, #1
 80102ec:	d1f8      	bne.n	80102e0 <usb_lld_pump+0xf0>
      otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                              usbp->epc[ep]->out_state->mode.linear.rxbuf,
                              cnt,
                              usbp->epc[ep]->out_state->rxsize -
                              usbp->epc[ep]->out_state->rxcnt);
      usbp->epc[ep]->out_state->mode.linear.rxbuf += cnt;
 80102ee:	4426      	add	r6, r4
 80102f0:	60c6      	str	r6, [r0, #12]
    }
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80102f2:	68eb      	ldr	r3, [r5, #12]
 80102f4:	699a      	ldr	r2, [r3, #24]
 80102f6:	6893      	ldr	r3, [r2, #8]
 80102f8:	4423      	add	r3, r4
 80102fa:	6093      	str	r3, [r2, #8]
 80102fc:	e79e      	b.n	801023c <usb_lld_pump+0x4c>
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    if (usbp->epc[ep]->out_state->rxqueued) {
      /* Queue associated.*/
      otg_fifo_read_to_queue(usbp->otg->FIFO[0],
 80102fe:	68c0      	ldr	r0, [r0, #12]
                                   input_queue_t *iqp,
                                   size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8010300:	b324      	cbz	r4, 801034c <usb_lld_pump+0x15c>
 8010302:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8010306:	4626      	mov	r6, r4
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 8010308:	2e03      	cmp	r6, #3
      size_t streak;
      uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
 801030a:	6941      	ldr	r1, [r0, #20]
  ntogo = n;
  while (ntogo > 0) {
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 801030c:	d907      	bls.n	801031e <usb_lld_pump+0x12e>
      size_t streak;
      uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
      if (iqp->q_wrptr >= iqp->q_top) {
 801030e:	6903      	ldr	r3, [r0, #16]
 8010310:	4299      	cmp	r1, r3
 8010312:	d304      	bcc.n	801031e <usb_lld_pump+0x12e>
        iqp->q_wrptr = iqp->q_buffer;
 8010314:	68c3      	ldr	r3, [r0, #12]
 8010316:	6143      	str	r3, [r0, #20]
  ntogo = n;
  while (ntogo > 0) {
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 8010318:	2e03      	cmp	r6, #3
      size_t streak;
      uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
 801031a:	6941      	ldr	r1, [r0, #20]
  ntogo = n;
  while (ntogo > 0) {
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 801031c:	d8f7      	bhi.n	801030e <usb_lld_pump+0x11e>
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
      break;

    /* One byte at time.*/
    w = *fifop;
 801031e:	f8d2 e000 	ldr.w	lr, [r2]
 8010322:	2700      	movs	r7, #0
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      *iqp->q_wrptr++ = (uint8_t)(w >> (i * 8));
 8010324:	f101 0c01 	add.w	ip, r1, #1
 8010328:	fa2e f307 	lsr.w	r3, lr, r7
 801032c:	f8c0 c014 	str.w	ip, [r0, #20]
 8010330:	700b      	strb	r3, [r1, #0]
      if (iqp->q_wrptr >= iqp->q_top)
 8010332:	6903      	ldr	r3, [r0, #16]
 8010334:	6941      	ldr	r1, [r0, #20]
 8010336:	4299      	cmp	r1, r3
        iqp->q_wrptr = iqp->q_buffer;
 8010338:	bf24      	itt	cs
 801033a:	68c3      	ldrcs	r3, [r0, #12]
 801033c:	6143      	strcs	r3, [r0, #20]
      break;

    /* One byte at time.*/
    w = *fifop;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 801033e:	3e01      	subs	r6, #1
 8010340:	d004      	beq.n	801034c <usb_lld_pump+0x15c>
 8010342:	2f18      	cmp	r7, #24
 8010344:	d0e0      	beq.n	8010308 <usb_lld_pump+0x118>
 8010346:	3708      	adds	r7, #8
 8010348:	6941      	ldr	r1, [r0, #20]
 801034a:	e7eb      	b.n	8010324 <usb_lld_pump+0x134>
 801034c:	b672      	cpsid	i
    }
  }

  /* Updating queue.*/
  osalSysLock();
  iqp->q_counter += n;
 801034e:	6883      	ldr	r3, [r0, #8]
 8010350:	4423      	add	r3, r4
 8010352:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8010354:	2100      	movs	r1, #0
 8010356:	f7fd fa4b 	bl	800d7f0 <chThdDequeueAllI>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 801035a:	f7fd f911 	bl	800d580 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 801035e:	b662      	cpsie	i
 8010360:	e7c7      	b.n	80102f2 <usb_lld_pump+0x102>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8010362:	b672      	cpsid	i
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8010364:	f8db 2008 	ldr.w	r2, [fp, #8]
        usbp->txpending &= ~epmask;
 8010368:	f8da 305c 	ldr.w	r3, [sl, #92]	; 0x5c
 801036c:	9901      	ldr	r1, [sp, #4]
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 801036e:	f022 0201 	bic.w	r2, r2, #1
        usbp->txpending &= ~epmask;
 8010372:	ea23 0301 	bic.w	r3, r3, r1
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8010376:	f8cb 2008 	str.w	r2, [fp, #8]
        usbp->txpending &= ~epmask;
 801037a:	f8ca 305c 	str.w	r3, [sl, #92]	; 0x5c
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 801037e:	b662      	cpsie	i
 8010380:	eb0a 0988 	add.w	r9, sl, r8, lsl #2
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8010384:	f8d9 000c 	ldr.w	r0, [r9, #12]
 8010388:	6941      	ldr	r1, [r0, #20]
 801038a:	688a      	ldr	r2, [r1, #8]
 801038c:	684b      	ldr	r3, [r1, #4]
 801038e:	429a      	cmp	r2, r3
 8010390:	f080 80a9 	bcs.w	80104e6 <usb_lld_pump+0x2f6>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8010394:	f8da 6050 	ldr.w	r6, [sl, #80]	; 0x50
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 8010398:	8a07      	ldrh	r7, [r0, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 801039a:	ea4f 1048 	mov.w	r0, r8, lsl #5
 801039e:	4604      	mov	r4, r0
 80103a0:	1830      	adds	r0, r6, r0
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 80103a2:	1a9b      	subs	r3, r3, r2
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80103a4:	f8d0 2918 	ldr.w	r2, [r0, #2328]	; 0x918
 80103a8:	429f      	cmp	r7, r3
 80103aa:	bf28      	it	cs
 80103ac:	461f      	movcs	r7, r3
 80103ae:	b293      	uxth	r3, r2
 80103b0:	ebb7 0f83 	cmp.w	r7, r3, lsl #2
 80103b4:	f108 0801 	add.w	r8, r8, #1
 80103b8:	d82e      	bhi.n	8010418 <usb_lld_pump+0x228>
 80103ba:	f8cd b008 	str.w	fp, [sp, #8]
 80103be:	46a3      	mov	fp, r4

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    /* Handles the two cases: linear buffer or queue.*/
    if (usbp->epc[ep]->in_state->txqueued) {
 80103c0:	780b      	ldrb	r3, [r1, #0]
 80103c2:	2b00      	cmp	r3, #0
 80103c4:	d139      	bne.n	801043a <usb_lld_pump+0x24a>
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {

  otg_do_push(fifop, (uint8_t *)buf, (n + 3) / 4);
 80103c6:	1cfb      	adds	r3, r7, #3
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80103c8:	68cc      	ldr	r4, [r1, #12]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 80103ca:	089b      	lsrs	r3, r3, #2
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80103cc:	eb06 3608 	add.w	r6, r6, r8, lsl #12
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 80103d0:	bf18      	it	ne
 80103d2:	4622      	movne	r2, r4
 80103d4:	d004      	beq.n	80103e0 <usb_lld_pump+0x1f0>
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses and on the LSB-first memory organization.*/
    *fifop = *((PACKED_VAR uint32_t *)buf);
 80103d6:	f852 0b04 	ldr.w	r0, [r2], #4
 80103da:	6030      	str	r0, [r6, #0]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 80103dc:	3b01      	subs	r3, #1
 80103de:	d1fa      	bne.n	80103d6 <usb_lld_pump+0x1e6>
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
                                 usbp->epc[ep]->in_state->mode.linear.txbuf,
                                 n);
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
 80103e0:	443c      	add	r4, r7
 80103e2:	60cc      	str	r4, [r1, #12]
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80103e4:	f8d9 000c 	ldr.w	r0, [r9, #12]
 80103e8:	6941      	ldr	r1, [r0, #20]
 80103ea:	688b      	ldr	r3, [r1, #8]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80103ec:	684a      	ldr	r2, [r1, #4]
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80103ee:	443b      	add	r3, r7
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80103f0:	429a      	cmp	r2, r3
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80103f2:	608b      	str	r3, [r1, #8]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80103f4:	d973      	bls.n	80104de <usb_lld_pump+0x2ee>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80103f6:	f8da 6050 	ldr.w	r6, [sl, #80]	; 0x50
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 80103fa:	8a00      	ldrh	r0, [r0, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80103fc:	eb06 040b 	add.w	r4, r6, fp
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8010400:	1ad7      	subs	r7, r2, r3
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8010402:	f8d4 3918 	ldr.w	r3, [r4, #2328]	; 0x918
 8010406:	4287      	cmp	r7, r0
 8010408:	bf28      	it	cs
 801040a:	4607      	movcs	r7, r0
 801040c:	b29b      	uxth	r3, r3
 801040e:	ebb7 0f83 	cmp.w	r7, r3, lsl #2
 8010412:	d9d5      	bls.n	80103c0 <usb_lld_pump+0x1d0>
 8010414:	f8dd b008 	ldr.w	fp, [sp, #8]
      return FALSE;
 8010418:	2200      	movs	r2, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 801041a:	b672      	cpsid	i
        osalSysUnlock();

        done = otg_txfifo_handler(usbp, ep);

        osalSysLock();
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 801041c:	f8db 3008 	ldr.w	r3, [fp, #8]
 8010420:	f043 0301 	orr.w	r3, r3, #1
 8010424:	f8cb 3008 	str.w	r3, [fp, #8]
        if (!done)
 8010428:	b92a      	cbnz	r2, 8010436 <usb_lld_pump+0x246>
          otgp->DIEPEMPMSK |= epmask;
 801042a:	f8db 3834 	ldr.w	r3, [fp, #2100]	; 0x834
 801042e:	9a01      	ldr	r2, [sp, #4]
 8010430:	431a      	orrs	r2, r3
 8010432:	f8cb 2834 	str.w	r2, [fp, #2100]	; 0x834
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8010436:	b662      	cpsie	i
 8010438:	e732      	b.n	80102a0 <usb_lld_pump+0xb0>
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    /* Handles the two cases: linear buffer or queue.*/
    if (usbp->epc[ep]->in_state->txqueued) {
      /* Queue associated.*/
      otg_fifo_write_from_queue(usbp->otg->FIFO[ep],
 801043a:	eb06 3608 	add.w	r6, r6, r8, lsl #12
 801043e:	68c8      	ldr	r0, [r1, #12]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8010440:	b1e7      	cbz	r7, 801047c <usb_lld_pump+0x28c>
 8010442:	f8d0 e010 	ldr.w	lr, [r0, #16]
 8010446:	463a      	mov	r2, r7
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 8010448:	0893      	lsrs	r3, r2, #2
 801044a:	d127      	bne.n	801049c <usb_lld_pump+0x2ac>
 801044c:	6983      	ldr	r3, [r0, #24]
      }
    }

    /* If this condition is not satisfied then there is a word lying across
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
 801044e:	2100      	movs	r1, #0
 8010450:	460c      	mov	r4, r1

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 8010452:	1c5d      	adds	r5, r3, #1
 8010454:	6185      	str	r5, [r0, #24]
 8010456:	781b      	ldrb	r3, [r3, #0]
      if (oqp->q_rdptr >= oqp->q_top)
 8010458:	4575      	cmp	r5, lr

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 801045a:	fa03 f301 	lsl.w	r3, r3, r1
 801045e:	ea44 0403 	orr.w	r4, r4, r3
      if (oqp->q_rdptr >= oqp->q_top)
        oqp->q_rdptr = oqp->q_buffer;
 8010462:	bf24      	itt	cs
 8010464:	68c3      	ldrcs	r3, [r0, #12]
 8010466:	6183      	strcs	r3, [r0, #24]
      break;

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 8010468:	3a01      	subs	r2, #1
 801046a:	d004      	beq.n	8010476 <usb_lld_pump+0x286>
 801046c:	2918      	cmp	r1, #24
 801046e:	d002      	beq.n	8010476 <usb_lld_pump+0x286>
 8010470:	3108      	adds	r1, #8
 8010472:	6983      	ldr	r3, [r0, #24]
 8010474:	e7ed      	b.n	8010452 <usb_lld_pump+0x262>
      if (oqp->q_rdptr >= oqp->q_top)
        oqp->q_rdptr = oqp->q_buffer;
      ntogo--;
      i++;
    }
    *fifop = w;
 8010476:	6034      	str	r4, [r6, #0]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8010478:	2a00      	cmp	r2, #0
 801047a:	d1e5      	bne.n	8010448 <usb_lld_pump+0x258>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 801047c:	b672      	cpsid	i
    *fifop = w;
  }

  /* Updating queue.*/
  osalSysLock();
  oqp->q_counter += n;
 801047e:	6883      	ldr	r3, [r0, #8]
 8010480:	443b      	add	r3, r7
 8010482:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8010484:	2100      	movs	r1, #0
 8010486:	f7fd f9b3 	bl	800d7f0 <chThdDequeueAllI>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 801048a:	f7fd f879 	bl	800d580 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 801048e:	b662      	cpsie	i
 8010490:	e7a8      	b.n	80103e4 <usb_lld_pump+0x1f4>
 8010492:	bf00      	nop
 8010494:	200010b8 	.word	0x200010b8
 8010498:	08016790 	.word	0x08016790
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;
 801049c:	6984      	ldr	r4, [r0, #24]
 801049e:	ebbe 0104 	subs.w	r1, lr, r4
 80104a2:	bf48      	it	mi
 80104a4:	3103      	addmi	r1, #3
 80104a6:	1089      	asrs	r1, r1, #2

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
 80104a8:	428b      	cmp	r3, r1
 80104aa:	bf28      	it	cs
 80104ac:	460b      	movcs	r3, r1
 80104ae:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 80104b2:	ebcc 0202 	rsb	r2, ip, r2
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 80104b6:	b133      	cbz	r3, 80104c6 <usb_lld_pump+0x2d6>
 80104b8:	4621      	mov	r1, r4
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses and on the LSB-first memory organization.*/
    *fifop = *((PACKED_VAR uint32_t *)buf);
 80104ba:	f851 5b04 	ldr.w	r5, [r1], #4
 80104be:	6035      	str	r5, [r6, #0]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 80104c0:	3b01      	subs	r3, #1
 80104c2:	d1fa      	bne.n	80104ba <usb_lld_pump+0x2ca>
 80104c4:	4464      	add	r4, ip
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
      if (oqp->q_rdptr >= oqp->q_top) {
 80104c6:	45a6      	cmp	lr, r4
    if (nw > 0) {
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
 80104c8:	6184      	str	r4, [r0, #24]
      if (oqp->q_rdptr >= oqp->q_top) {
 80104ca:	d804      	bhi.n	80104d6 <usb_lld_pump+0x2e6>
        oqp->q_rdptr = oqp->q_buffer;
 80104cc:	68c3      	ldr	r3, [r0, #12]
 80104ce:	6183      	str	r3, [r0, #24]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 80104d0:	2a00      	cmp	r2, #0
 80104d2:	d1b9      	bne.n	8010448 <usb_lld_pump+0x258>
 80104d4:	e7d2      	b.n	801047c <usb_lld_pump+0x28c>
      }
    }

    /* If this condition is not satisfied then there is a word lying across
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
 80104d6:	2a00      	cmp	r2, #0
 80104d8:	d0d0      	beq.n	801047c <usb_lld_pump+0x28c>
 80104da:	4623      	mov	r3, r4
 80104dc:	e7b7      	b.n	801044e <usb_lld_pump+0x25e>
 80104de:	f8dd b008 	ldr.w	fp, [sp, #8]
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;
 80104e2:	2201      	movs	r2, #1
 80104e4:	e799      	b.n	801041a <usb_lld_pump+0x22a>
 80104e6:	f108 0801 	add.w	r8, r8, #1
 80104ea:	e7fa      	b.n	80104e2 <usb_lld_pump+0x2f2>
 80104ec:	0000      	movs	r0, r0
	...

080104f0 <otg_disable_ep.isra.0>:
  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
    ;
}

static void otg_disable_ep(USBDriver *usbp) {
 80104f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80104f2:	2400      	movs	r4, #0
 80104f4:	f8d1 e008 	ldr.w	lr, [r1, #8]
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
 80104f8:	4625      	mov	r5, r4
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".*/
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0) {
      otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
 80104fa:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
    otgp->ie[i].DIEPTSIZ = 0;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80104fe:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8010502:	e014      	b.n	801052e <otg_disable_ep.isra.0+0x3e>
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
 8010504:	f8c1 5900 	str.w	r5, [r1, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
 8010508:	18c2      	adds	r2, r0, r3
 801050a:	f8c2 5910 	str.w	r5, [r2, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 801050e:	f8c2 7908 	str.w	r7, [r2, #2312]	; 0x908
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".
       Note that the attempt to disable the OUT EP0 is ignored by the
       hardware but the code is simpler this way.*/
    if ((otgp->oe[i].DOEPCTL & DOEPCTL_EPENA) != 0) {
 8010512:	f8d1 6b00 	ldr.w	r6, [r1, #2816]	; 0xb00
 8010516:	2e00      	cmp	r6, #0
 8010518:	db17      	blt.n	801054a <otg_disable_ep.isra.0+0x5a>
      /* Wait for endpoint disable.*/
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
        ;
    }
    else
      otgp->oe[i].DOEPCTL = 0;
 801051a:	f8c1 5b00 	str.w	r5, [r1, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 801051e:	4403      	add	r3, r0

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8010520:	3401      	adds	r4, #1
 8010522:	45a6      	cmp	lr, r4
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
        ;
    }
    else
      otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
 8010524:	f8c3 5b10 	str.w	r5, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8010528:	f8c3 7b08 	str.w	r7, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 801052c:	d314      	bcc.n	8010558 <otg_disable_ep.isra.0+0x68>
 801052e:	0163      	lsls	r3, r4, #5
 8010530:	18c1      	adds	r1, r0, r3
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".*/
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0) {
 8010532:	f8d1 2900 	ldr.w	r2, [r1, #2304]	; 0x900
 8010536:	2a00      	cmp	r2, #0
 8010538:	dae4      	bge.n	8010504 <otg_disable_ep.isra.0+0x14>
      otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
 801053a:	f8c1 c900 	str.w	ip, [r1, #2304]	; 0x900
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
 801053e:	460e      	mov	r6, r1
 8010540:	f8d6 2908 	ldr.w	r2, [r6, #2312]	; 0x908
 8010544:	0792      	lsls	r2, r2, #30
 8010546:	d5fb      	bpl.n	8010540 <otg_disable_ep.isra.0+0x50>
 8010548:	e7de      	b.n	8010508 <otg_disable_ep.isra.0+0x18>
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".
       Note that the attempt to disable the OUT EP0 is ignored by the
       hardware but the code is simpler this way.*/
    if ((otgp->oe[i].DOEPCTL & DOEPCTL_EPENA) != 0) {
      otgp->oe[i].DOEPCTL = DOEPCTL_EPDIS;
 801054a:	f8c1 cb00 	str.w	ip, [r1, #2816]	; 0xb00
      /* Wait for endpoint disable.*/
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
 801054e:	f8d2 1b08 	ldr.w	r1, [r2, #2824]	; 0xb08
 8010552:	06c9      	lsls	r1, r1, #27
 8010554:	d5fb      	bpl.n	801054e <otg_disable_ep.isra.0+0x5e>
 8010556:	e7e2      	b.n	801051e <otg_disable_ep.isra.0+0x2e>
    else
      otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8010558:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 801055c:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
 8010560:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010562:	bf00      	nop
	...

08010570 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8010570:	b510      	push	{r4, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8010572:	4c06      	ldr	r4, [pc, #24]	; (801058c <usb_lld_init+0x1c>)
 8010574:	4620      	mov	r0, r4
 8010576:	f7fd ff33 	bl	800e3e0 <usbObjectInit>
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 801057a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
  USBD1.otgparams = &fsparams;
 801057e:	4a04      	ldr	r2, [pc, #16]	; (8010590 <usb_lld_init+0x20>)

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 8010580:	6523      	str	r3, [r4, #80]	; 0x50
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 8010582:	2300      	movs	r3, #0
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 8010584:	6562      	str	r2, [r4, #84]	; 0x54
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 8010586:	6623      	str	r3, [r4, #96]	; 0x60
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8010588:	6663      	str	r3, [r4, #100]	; 0x64
 801058a:	bd10      	pop	{r4, pc}
 801058c:	20001498 	.word	0x20001498
 8010590:	08016780 	.word	0x08016780
	...

080105a0 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 80105a0:	b570      	push	{r4, r5, r6, lr}
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 80105a2:	7803      	ldrb	r3, [r0, #0]
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 80105a4:	6d06      	ldr	r6, [r0, #80]	; 0x50

  if (usbp->state == USB_STOP) {
 80105a6:	2b01      	cmp	r3, #1
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 80105a8:	b082      	sub	sp, #8
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 80105aa:	d001      	beq.n	80105b0 <usb_lld_start+0x10>
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
  }
}
 80105ac:	b002      	add	sp, #8
 80105ae:	bd70      	pop	{r4, r5, r6, pc}
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 80105b0:	4b30      	ldr	r3, [pc, #192]	; (8010674 <usb_lld_start+0xd4>)
 80105b2:	4298      	cmp	r0, r3
 80105b4:	4605      	mov	r5, r0
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 80105b6:	bf18      	it	ne
 80105b8:	4634      	movne	r4, r6

  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 80105ba:	d03a      	beq.n	8010632 <usb_lld_start+0x92>
      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
    }
#endif

    usbp->txpending = 0;
 80105bc:	2300      	movs	r3, #0

    /* - Forced device mode.
       - USB turn-around time = TRDT_VALUE.
       - Full Speed 1.1 PHY.*/
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 80105be:	482e      	ldr	r0, [pc, #184]	; (8010678 <usb_lld_start+0xd8>)

    /* 48MHz 1.1 PHY.*/
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80105c0:	492e      	ldr	r1, [pc, #184]	; (801067c <usb_lld_start+0xdc>)
      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
    }
#endif

    usbp->txpending = 0;
 80105c2:	65eb      	str	r3, [r5, #92]	; 0x5c
    /* PHY enabled.*/
    otgp->PCGCCTL = 0;

    /* Internal FS PHY activation.*/
#if defined(BOARD_OTG_NOVBUSSENS)
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
 80105c4:	f44f 1234 	mov.w	r2, #2949120	; 0x2d0000
    usbp->txpending = 0;

    /* - Forced device mode.
       - USB turn-around time = TRDT_VALUE.
       - Full Speed 1.1 PHY.*/
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 80105c8:	60f0      	str	r0, [r6, #12]

    /* 48MHz 1.1 PHY.*/
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80105ca:	f8c6 1800 	str.w	r1, [r6, #2048]	; 0x800
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 80105ce:	2020      	movs	r0, #32

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 80105d0:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00

    /* Internal FS PHY activation.*/
#if defined(BOARD_OTG_NOVBUSSENS)
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
 80105d4:	63b2      	str	r2, [r6, #56]	; 0x38
 80105d6:	f7fc fe5b 	bl	800d290 <chSysPolledDelayX>
  stm32_otg_t *otgp = usbp->otg;

  osalSysPolledDelayX(32);

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 80105da:	2301      	movs	r3, #1
 80105dc:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 80105de:	6923      	ldr	r3, [r4, #16]
 80105e0:	07db      	lsls	r3, r3, #31
 80105e2:	d4fc      	bmi.n	80105de <usb_lld_start+0x3e>
 80105e4:	200c      	movs	r0, #12
 80105e6:	f7fc fe53 	bl	800d290 <chSysPolledDelayX>
    ;

  osalSysPolledDelayX(12);

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 80105ea:	6923      	ldr	r3, [r4, #16]
 80105ec:	2b00      	cmp	r3, #0
 80105ee:	dafc      	bge.n	80105ea <usb_lld_start+0x4a>

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 80105f0:	2400      	movs	r4, #0
 80105f2:	60b4      	str	r4, [r6, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 80105f4:	6d28      	ldr	r0, [r5, #80]	; 0x50
 80105f6:	6d69      	ldr	r1, [r5, #84]	; 0x54
 80105f8:	f7ff ff7a 	bl	80104f0 <otg_disable_ep.isra.0>
    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 80105fc:	686b      	ldr	r3, [r5, #4]
    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 80105fe:	f8c6 4810 	str.w	r4, [r6, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 8010602:	68db      	ldr	r3, [r3, #12]
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
 8010604:	f8c6 4814 	str.w	r4, [r6, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8010608:	f8c6 481c 	str.w	r4, [r6, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 801060c:	b16b      	cbz	r3, 801062a <usb_lld_start+0x8a>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM  |*/;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 801060e:	f243 0308 	movw	r3, #12296	; 0x3008
 8010612:	61b3      	str	r3, [r6, #24]
                       GINTMSK_ESUSPM */ | GINTMSK_SOFM;
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8010614:	6e6b      	ldr	r3, [r5, #100]	; 0x64
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM  |*/;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM */ | GINTMSK_SOFM;
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */
 8010616:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 801061a:	6172      	str	r2, [r6, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 801061c:	b1d3      	cbz	r3, 8010654 <usb_lld_start+0xb4>
      chSchRescheduleS();
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 801061e:	68b3      	ldr	r3, [r6, #8]
 8010620:	f043 0301 	orr.w	r3, r3, #1
 8010624:	60b3      	str	r3, [r6, #8]
  }
}
 8010626:	b002      	add	sp, #8
 8010628:	bd70      	pop	{r4, r5, r6, pc}
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 801062a:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 801062e:	61b3      	str	r3, [r6, #24]
 8010630:	e7f0      	b.n	8010614 <usb_lld_start+0x74>
  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
 8010632:	4b13      	ldr	r3, [pc, #76]	; (8010680 <usb_lld_start+0xe0>)
 8010634:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8010636:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801063a:	635a      	str	r2, [r3, #52]	; 0x34
      rccResetOTG_FS();
 801063c:	695a      	ldr	r2, [r3, #20]
 801063e:	2100      	movs	r1, #0
 8010640:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8010644:	615a      	str	r2, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8010646:	2043      	movs	r0, #67	; 0x43
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
      rccResetOTG_FS();
 8010648:	6159      	str	r1, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 801064a:	210e      	movs	r1, #14
 801064c:	f7fe f9b0 	bl	800e9b0 <nvicEnableVector>
 8010650:	6d2c      	ldr	r4, [r5, #80]	; 0x50
 8010652:	e7b3      	b.n	80105bc <usb_lld_start+0x1c>
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8010654:	f44f 7106 	mov.w	r1, #536	; 0x218
 8010658:	2202      	movs	r2, #2
 801065a:	4b0a      	ldr	r3, [pc, #40]	; (8010684 <usb_lld_start+0xe4>)
 801065c:	9500      	str	r5, [sp, #0]
 801065e:	f105 0068 	add.w	r0, r5, #104	; 0x68
 8010662:	f7fc ffd5 	bl	800d610 <chThdCreateI>
 8010666:	6668      	str	r0, [r5, #100]	; 0x64
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8010668:	f7fc feaa 	bl	800d3c0 <chSchReadyI>
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
      chSchRescheduleS();
 801066c:	f7fc ff88 	bl	800d580 <chSchRescheduleS>
 8010670:	e7d5      	b.n	801061e <usb_lld_start+0x7e>
 8010672:	bf00      	nop
 8010674:	20001498 	.word	0x20001498
 8010678:	40001440 	.word	0x40001440
 801067c:	02200003 	.word	0x02200003
 8010680:	40023800 	.word	0x40023800
 8010684:	080101f1 	.word	0x080101f1
	...

08010690 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8010690:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8010692:	6d05      	ldr	r5, [r0, #80]	; 0x50
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010694:	2320      	movs	r3, #32
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8010696:	4607      	mov	r7, r0
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010698:	612b      	str	r3, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 801069a:	692b      	ldr	r3, [r5, #16]
 801069c:	f013 0420 	ands.w	r4, r3, #32
 80106a0:	d1fb      	bne.n	801069a <usb_lld_reset+0xa>
 80106a2:	200c      	movs	r0, #12
 80106a4:	f7fc fdf4 	bl	800d290 <chSysPolledDelayX>
 80106a8:	f8d7 e054 	ldr.w	lr, [r7, #84]	; 0x54
 80106ac:	f8de 6008 	ldr.w	r6, [lr, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80106b0:	4623      	mov	r3, r4
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80106b2:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFF;
 80106b6:	21ff      	movs	r1, #255	; 0xff
 80106b8:	eb05 1243 	add.w	r2, r5, r3, lsl #5

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80106bc:	3301      	adds	r3, #1
 80106be:	42b3      	cmp	r3, r6
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80106c0:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 80106c4:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFF;
 80106c8:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFF;
 80106cc:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80106d0:	d9f2      	bls.n	80106b8 <usb_lld_reset+0x28>
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80106d2:	f8de 3000 	ldr.w	r3, [lr]
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 80106d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80106da:	f04f 1101 	mov.w	r1, #65537	; 0x10001
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 80106de:	f8c5 2818 	str.w	r2, [r5, #2072]	; 0x818
 80106e2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80106e4:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80106e8:	65bb      	str	r3, [r7, #88]	; 0x58

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80106ea:	f8de 3000 	ldr.w	r3, [lr]
 80106ee:	626b      	str	r3, [r5, #36]	; 0x24
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80106f0:	2310      	movs	r3, #16
 80106f2:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80106f4:	6913      	ldr	r3, [r2, #16]
 80106f6:	f013 0410 	ands.w	r4, r3, #16
 80106fa:	d1fb      	bne.n	80106f4 <usb_lld_reset+0x64>
 80106fc:	200c      	movs	r0, #12
 80106fe:	f7fc fdc7 	bl	800d290 <chSysPolledDelayX>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8010702:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8010706:	4a11      	ldr	r2, [pc, #68]	; (801074c <usb_lld_reset+0xbc>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8010708:	4811      	ldr	r0, [pc, #68]	; (8010750 <usb_lld_reset+0xc0>)
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 801070a:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 801070e:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8010712:	69ab      	ldr	r3, [r5, #24]
 8010714:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8010718:	f043 0310 	orr.w	r3, r3, #16
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 801071c:	2109      	movs	r1, #9

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 801071e:	61ab      	str	r3, [r5, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8010720:	f8c5 1810 	str.w	r1, [r5, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8010724:	f8c5 1814 	str.w	r1, [r5, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8010728:	60f8      	str	r0, [r7, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 801072a:	f8c5 4b10 	str.w	r4, [r5, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 801072e:	f8c5 2b00 	str.w	r2, [r5, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8010732:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8010736:	f8c5 2900 	str.w	r2, [r5, #2304]	; 0x900
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 801073a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  usbp->pmnext += size;
 801073c:	f103 0210 	add.w	r2, r3, #16
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8010740:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8010744:	65ba      	str	r2, [r7, #88]	; 0x58
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8010746:	62ab      	str	r3, [r5, #40]	; 0x28
 8010748:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801074a:	bf00      	nop
 801074c:	10008040 	.word	0x10008040
 8010750:	080167a0 	.word	0x080167a0
	...

08010760 <usb_lld_set_address>:
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8010760:	6d02      	ldr	r2, [r0, #80]	; 0x50

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8010762:	f890 104e 	ldrb.w	r1, [r0, #78]	; 0x4e
 8010766:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 801076a:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 801076e:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8010772:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 8010776:	4770      	bx	lr
	...

08010780 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8010780:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010784:	fa0f f881 	sxth.w	r8, r1
 8010788:	eb00 0788 	add.w	r7, r0, r8, lsl #2
 801078c:	460d      	mov	r5, r1
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 801078e:	68fb      	ldr	r3, [r7, #12]
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 8010790:	6d04      	ldr	r4, [r0, #80]	; 0x50

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8010792:	681a      	ldr	r2, [r3, #0]
 8010794:	f002 0203 	and.w	r2, r2, #3
 8010798:	2a02      	cmp	r2, #2
 801079a:	d05c      	beq.n	8010856 <usb_lld_init_endpoint+0xd6>
 801079c:	2a03      	cmp	r2, #3
 801079e:	d05c      	beq.n	801085a <usb_lld_init_endpoint+0xda>
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 80107a0:	4e4a      	ldr	r6, [pc, #296]	; (80108cc <usb_lld_init_endpoint+0x14c>)
 80107a2:	494b      	ldr	r1, [pc, #300]	; (80108d0 <usb_lld_init_endpoint+0x150>)
 80107a4:	2a01      	cmp	r2, #1
 80107a6:	bf18      	it	ne
 80107a8:	460e      	movne	r6, r1
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 80107aa:	016a      	lsls	r2, r5, #5
  if (usbp->epc[ep]->out_cb != NULL) {
 80107ac:	68d9      	ldr	r1, [r3, #12]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 80107ae:	eb04 0e02 	add.w	lr, r4, r2
 80107b2:	f04f 0c00 	mov.w	ip, #0
 80107b6:	f8ce cb10 	str.w	ip, [lr, #2832]	; 0xb10
  if (usbp->epc[ep]->out_cb != NULL) {
 80107ba:	2900      	cmp	r1, #0
 80107bc:	d071      	beq.n	80108a2 <usb_lld_init_endpoint+0x122>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 80107be:	f8b3 e012 	ldrh.w	lr, [r3, #18]
 80107c2:	f105 0158 	add.w	r1, r5, #88	; 0x58
 80107c6:	0149      	lsls	r1, r1, #5
 80107c8:	ea46 0e0e 	orr.w	lr, r6, lr
 80107cc:	f844 e001 	str.w	lr, [r4, r1]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 80107d0:	f105 0c10 	add.w	ip, r5, #16
 80107d4:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
 80107d8:	f04f 0e01 	mov.w	lr, #1
 80107dc:	fa0e fe0c 	lsl.w	lr, lr, ip
 80107e0:	ea4e 0101 	orr.w	r1, lr, r1
 80107e4:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80107e8:	4422      	add	r2, r4
  if (usbp->epc[ep]->in_cb != NULL) {
 80107ea:	6899      	ldr	r1, [r3, #8]
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80107ec:	f04f 0e00 	mov.w	lr, #0
 80107f0:	f8c2 e910 	str.w	lr, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_cb != NULL) {
 80107f4:	b399      	cbz	r1, 801085e <usb_lld_init_endpoint+0xde>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 80107f6:	8b99      	ldrh	r1, [r3, #28]

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80107f8:	8a1a      	ldrh	r2, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 80107fa:	2901      	cmp	r1, #1

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80107fc:	ea4f 0392 	mov.w	r3, r2, lsr #2
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
 8010800:	bf88      	it	hi
 8010802:	434b      	mulhi	r3, r1
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8010804:	f105 0e3f 	add.w	lr, r5, #63	; 0x3f
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8010808:	6d81      	ldr	r1, [r0, #88]	; 0x58
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 801080a:	eb04 0e8e 	add.w	lr, r4, lr, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 801080e:	01aa      	lsls	r2, r5, #6
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8010810:	eb03 0c01 	add.w	ip, r3, r1
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010814:	f042 0220 	orr.w	r2, r2, #32
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8010818:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 801081c:	f8c0 c058 	str.w	ip, [r0, #88]	; 0x58
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8010820:	f8ce 3004 	str.w	r3, [lr, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010824:	6122      	str	r2, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8010826:	6923      	ldr	r3, [r4, #16]
 8010828:	069a      	lsls	r2, r3, #26
 801082a:	d4fc      	bmi.n	8010826 <usb_lld_init_endpoint+0xa6>
 801082c:	200c      	movs	r0, #12
 801082e:	f7fc fd2f 	bl	800d290 <chSysPolledDelayX>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8010832:	68fb      	ldr	r3, [r7, #12]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 8010834:	8a1a      	ldrh	r2, [r3, #16]
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8010836:	f105 0348 	add.w	r3, r5, #72	; 0x48
 801083a:	015b      	lsls	r3, r3, #5
 801083c:	ea42 5285 	orr.w	r2, r2, r5, lsl #22
                           DIEPCTL_TXFNUM(ep) |
 8010840:	4332      	orrs	r2, r6
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8010842:	50e2      	str	r2, [r4, r3]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8010844:	2301      	movs	r3, #1
 8010846:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 801084a:	40ab      	lsls	r3, r5
 801084c:	4313      	orrs	r3, r2
 801084e:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
 8010852:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8010856:	4e1f      	ldr	r6, [pc, #124]	; (80108d4 <usb_lld_init_endpoint+0x154>)
    break;
 8010858:	e7a7      	b.n	80107aa <usb_lld_init_endpoint+0x2a>
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 801085a:	4e1f      	ldr	r6, [pc, #124]	; (80108d8 <usb_lld_init_endpoint+0x158>)
    break;
 801085c:	e7a5      	b.n	80107aa <usb_lld_init_endpoint+0x2a>
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 801085e:	f105 023f 	add.w	r2, r5, #63	; 0x3f
 8010862:	eb04 0282 	add.w	r2, r4, r2, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010866:	01ab      	lsls	r3, r5, #6
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8010868:	491c      	ldr	r1, [pc, #112]	; (80108dc <usb_lld_init_endpoint+0x15c>)
 801086a:	6051      	str	r1, [r2, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 801086c:	f043 0320 	orr.w	r3, r3, #32
 8010870:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8010872:	6923      	ldr	r3, [r4, #16]
 8010874:	069b      	lsls	r3, r3, #26
 8010876:	d4fc      	bmi.n	8010872 <usb_lld_init_endpoint+0xf2>
 8010878:	eb04 1848 	add.w	r8, r4, r8, lsl #5
 801087c:	200c      	movs	r0, #12
 801087e:	f7fc fd07 	bl	800d290 <chSysPolledDelayX>
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8010882:	f8d8 2900 	ldr.w	r2, [r8, #2304]	; 0x900
 8010886:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 801088a:	f8c8 2900 	str.w	r2, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 801088e:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 8010892:	2301      	movs	r3, #1
 8010894:	40ab      	lsls	r3, r5
 8010896:	ea22 0303 	bic.w	r3, r2, r3
 801089a:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
 801089e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80108a2:	eb04 1148 	add.w	r1, r4, r8, lsl #5
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 80108a6:	f105 0c10 	add.w	ip, r5, #16
  if (usbp->epc[ep]->out_cb != NULL) {
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 80108aa:	f8d1 eb00 	ldr.w	lr, [r1, #2816]	; 0xb00
 80108ae:	f42e 4e00 	bic.w	lr, lr, #32768	; 0x8000
 80108b2:	f8c1 eb00 	str.w	lr, [r1, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 80108b6:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
 80108ba:	f04f 0e01 	mov.w	lr, #1
 80108be:	fa0e fe0c 	lsl.w	lr, lr, ip
 80108c2:	ea21 010e 	bic.w	r1, r1, lr
 80108c6:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
 80108ca:	e78d      	b.n	80107e8 <usb_lld_init_endpoint+0x68>
 80108cc:	10048000 	.word	0x10048000
 80108d0:	10008000 	.word	0x10008000
 80108d4:	10088000 	.word	0x10088000
 80108d8:	100c8000 	.word	0x100c8000
 80108dc:	02000400 	.word	0x02000400

080108e0 <usb_lld_get_status_out>:
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 80108e0:	3158      	adds	r1, #88	; 0x58
 80108e2:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80108e4:	0149      	lsls	r1, r1, #5
 80108e6:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 80108e8:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 80108ec:	d004      	beq.n	80108f8 <usb_lld_get_status_out+0x18>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
 80108ee:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
    return EP_STATUS_STALLED;
  return EP_STATUS_ACTIVE;
 80108f2:	bf14      	ite	ne
 80108f4:	2001      	movne	r0, #1
 80108f6:	2002      	moveq	r0, #2
}
 80108f8:	4770      	bx	lr
 80108fa:	bf00      	nop
 80108fc:	0000      	movs	r0, r0
	...

08010900 <usb_lld_get_status_in>:
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8010900:	3148      	adds	r1, #72	; 0x48
 8010902:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8010904:	0149      	lsls	r1, r1, #5
 8010906:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 8010908:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 801090c:	d004      	beq.n	8010918 <usb_lld_get_status_in+0x18>
    return EP_STATUS_DISABLED;
  if (ctl & DIEPCTL_STALL)
 801090e:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
    return EP_STATUS_STALLED;
  return EP_STATUS_ACTIVE;
 8010912:	bf14      	ite	ne
 8010914:	2001      	movne	r0, #1
 8010916:	2002      	moveq	r0, #2
}
 8010918:	4770      	bx	lr
 801091a:	bf00      	nop
 801091c:	0000      	movs	r0, r0
	...

08010920 <usb_lld_read_setup>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8010920:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8010924:	68cb      	ldr	r3, [r1, #12]
 8010926:	6a1b      	ldr	r3, [r3, #32]
 8010928:	6819      	ldr	r1, [r3, #0]
 801092a:	685b      	ldr	r3, [r3, #4]
 801092c:	6053      	str	r3, [r2, #4]
 801092e:	6011      	str	r1, [r2, #0]
 8010930:	4770      	bx	lr
 8010932:	bf00      	nop
	...

08010940 <usb_lld_prepare_receive>:
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8010940:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
 8010944:	b430      	push	{r4, r5}
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8010946:	68dd      	ldr	r5, [r3, #12]
 8010948:	69ac      	ldr	r4, [r5, #24]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 801094a:	6863      	ldr	r3, [r4, #4]
 801094c:	6123      	str	r3, [r4, #16]
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
 801094e:	b931      	cbnz	r1, 801095e <usb_lld_prepare_receive+0x1e>
 8010950:	2b40      	cmp	r3, #64	; 0x40
 8010952:	d904      	bls.n	801095e <usb_lld_prepare_receive+0x1e>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8010954:	2340      	movs	r3, #64	; 0x40
 8010956:	6063      	str	r3, [r4, #4]
 8010958:	4a09      	ldr	r2, [pc, #36]	; (8010980 <usb_lld_prepare_receive+0x40>)
 801095a:	243f      	movs	r4, #63	; 0x3f
 801095c:	e002      	b.n	8010964 <usb_lld_prepare_receive+0x24>
 801095e:	1e5c      	subs	r4, r3, #1
 8010960:	f043 42c0 	orr.w	r2, r3, #1610612736	; 0x60000000

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8010964:	6d00      	ldr	r0, [r0, #80]	; 0x50
  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8010966:	8a6d      	ldrh	r5, [r5, #18]
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8010968:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 801096c:	1963      	adds	r3, r4, r5
 801096e:	fbb3 f3f5 	udiv	r3, r3, r5
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8010972:	ea42 43c3 	orr.w	r3, r2, r3, lsl #19
 8010976:	f8c1 3b10 	str.w	r3, [r1, #2832]	; 0xb10
                               DOEPTSIZ_XFRSIZ(osp->rxsize);

}
 801097a:	bc30      	pop	{r4, r5}
 801097c:	4770      	bx	lr
 801097e:	bf00      	nop
 8010980:	60000040 	.word	0x60000040
	...

08010990 <otg_epout_handler.constprop.7>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8010990:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8010994:	4e24      	ldr	r6, [pc, #144]	; (8010a28 <otg_epout_handler.constprop.7+0x98>)
 8010996:	6d37      	ldr	r7, [r6, #80]	; 0x50
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8010998:	eb07 1340 	add.w	r3, r7, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 801099c:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->oe[ep].DOEPINT;
 801099e:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 80109a2:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 80109a6:	0720      	lsls	r0, r4, #28
 80109a8:	d503      	bpl.n	80109b2 <otg_epout_handler.constprop.7+0x22>
 80109aa:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 80109ae:	0719      	lsls	r1, r3, #28
 80109b0:	d41d      	bmi.n	80109ee <otg_epout_handler.constprop.7+0x5e>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);

  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 80109b2:	07e2      	lsls	r2, r4, #31
 80109b4:	d519      	bpl.n	80109ea <otg_epout_handler.constprop.7+0x5a>
 80109b6:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 80109ba:	07db      	lsls	r3, r3, #31
 80109bc:	d515      	bpl.n	80109ea <otg_epout_handler.constprop.7+0x5a>
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80109be:	eb06 0685 	add.w	r6, r6, r5, lsl #2
 80109c2:	4c19      	ldr	r4, [pc, #100]	; (8010a28 <otg_epout_handler.constprop.7+0x98>)
 80109c4:	68f1      	ldr	r1, [r6, #12]
 80109c6:	698b      	ldr	r3, [r1, #24]

    if (osp->rxsize < osp->totsize) {
 80109c8:	6858      	ldr	r0, [r3, #4]
 80109ca:	691a      	ldr	r2, [r3, #16]
 80109cc:	4290      	cmp	r0, r2
 80109ce:	d316      	bcc.n	80109fe <otg_epout_handler.constprop.7+0x6e>
      usb_lld_start_out(usbp, ep);
      chSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 80109d0:	8962      	ldrh	r2, [r4, #10]
 80109d2:	68ce      	ldr	r6, [r1, #12]
 80109d4:	2301      	movs	r3, #1
 80109d6:	40ab      	lsls	r3, r5
 80109d8:	ea22 0303 	bic.w	r3, r2, r3
 80109dc:	8163      	strh	r3, [r4, #10]
 80109de:	4629      	mov	r1, r5
 80109e0:	4620      	mov	r0, r4
 80109e2:	4633      	mov	r3, r6
    }
  }
}
 80109e4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      usb_lld_start_out(usbp, ep);
      chSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 80109e8:	4718      	bx	r3
 80109ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 80109ee:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 80109f2:	4630      	mov	r0, r6
 80109f4:	68db      	ldr	r3, [r3, #12]
 80109f6:	4629      	mov	r1, r5
 80109f8:	685b      	ldr	r3, [r3, #4]
 80109fa:	4798      	blx	r3
 80109fc:	e7d9      	b.n	80109b2 <otg_epout_handler.constprop.7+0x22>

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 80109fe:	1a12      	subs	r2, r2, r0
      osp->rxcnt  = 0;
 8010a00:	2100      	movs	r1, #0
 8010a02:	6099      	str	r1, [r3, #8]

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8010a04:	605a      	str	r2, [r3, #4]
      osp->rxcnt  = 0;
      usb_lld_prepare_receive(usbp, ep);
 8010a06:	4620      	mov	r0, r4
 8010a08:	4629      	mov	r1, r5
 8010a0a:	f7ff ff99 	bl	8010940 <usb_lld_prepare_receive>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8010a0e:	b672      	cpsid	i
 8010a10:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a12:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 8010a16:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
 8010a1a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8010a1e:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8010a22:	b662      	cpsie	i
 8010a24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010a28:	20001498 	.word	0x20001498
 8010a2c:	00000000 	.word	0x00000000

08010a30 <usb_lld_prepare_transmit>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8010a30:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
 8010a34:	b410      	push	{r4}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8010a36:	68dc      	ldr	r4, [r3, #12]
 8010a38:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 8010a3a:	6853      	ldr	r3, [r2, #4]
 8010a3c:	6113      	str	r3, [r2, #16]
  if (isp->txsize == 0) {
 8010a3e:	b1ab      	cbz	r3, 8010a6c <usb_lld_prepare_transmit+0x3c>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 8010a40:	b171      	cbz	r1, 8010a60 <usb_lld_prepare_transmit+0x30>
 8010a42:	1e5a      	subs	r2, r3, #1
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8010a44:	6d00      	ldr	r0, [r0, #80]	; 0x50
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8010a46:	8a24      	ldrh	r4, [r4, #16]
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8010a48:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8010a4c:	4422      	add	r2, r4
 8010a4e:	fbb2 f2f4 	udiv	r2, r2, r4
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8010a52:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8010a56:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 8010a5a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010a5e:	4770      	bx	lr
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 8010a60:	2b40      	cmp	r3, #64	; 0x40
 8010a62:	d9ee      	bls.n	8010a42 <usb_lld_prepare_transmit+0x12>
      isp->txsize = EP0_MAX_INSIZE;
 8010a64:	2340      	movs	r3, #64	; 0x40
 8010a66:	6053      	str	r3, [r2, #4]
 8010a68:	223f      	movs	r2, #63	; 0x3f
 8010a6a:	e7eb      	b.n	8010a44 <usb_lld_prepare_transmit+0x14>

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8010a6c:	6d03      	ldr	r3, [r0, #80]	; 0x50
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 8010a6e:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8010a72:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8010a76:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8010a7a:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 8010a7e:	4770      	bx	lr

08010a80 <otg_epin_handler.constprop.8>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8010a80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
 8010a82:	4f2b      	ldr	r7, [pc, #172]	; (8010b30 <otg_epin_handler.constprop.8+0xb0>)
 8010a84:	6d3d      	ldr	r5, [r7, #80]	; 0x50
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8010a86:	eb05 1340 	add.w	r3, r5, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8010a8a:	4606      	mov	r6, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8010a8c:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908

  otgp->ie[ep].DIEPINT = epint;
 8010a90:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8010a94:	07e1      	lsls	r1, r4, #31
 8010a96:	d503      	bpl.n	8010aa0 <otg_epin_handler.constprop.8+0x20>
 8010a98:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 8010a9c:	07da      	lsls	r2, r3, #31
 8010a9e:	d408      	bmi.n	8010ab2 <otg_epin_handler.constprop.8+0x32>
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8010aa0:	0623      	lsls	r3, r4, #24
 8010aa2:	d505      	bpl.n	8010ab0 <otg_epin_handler.constprop.8+0x30>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8010aa4:	2301      	movs	r3, #1
 8010aa6:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
 8010aaa:	40b3      	lsls	r3, r6
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8010aac:	4213      	tst	r3, r2
 8010aae:	d123      	bne.n	8010af8 <otg_epin_handler.constprop.8+0x78>
 8010ab0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8010ab2:	eb07 0380 	add.w	r3, r7, r0, lsl #2
 8010ab6:	68d9      	ldr	r1, [r3, #12]
 8010ab8:	694b      	ldr	r3, [r1, #20]

    if (isp->txsize < isp->totsize) {
 8010aba:	6858      	ldr	r0, [r3, #4]
 8010abc:	691a      	ldr	r2, [r3, #16]
 8010abe:	4290      	cmp	r0, r2
 8010ac0:	d22a      	bcs.n	8010b18 <otg_epin_handler.constprop.8+0x98>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 8010ac2:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 8010ac4:	2100      	movs	r1, #0
 8010ac6:	6099      	str	r1, [r3, #8]

    if (isp->txsize < isp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 8010ac8:	605a      	str	r2, [r3, #4]
      isp->txcnt  = 0;
      usb_lld_prepare_transmit(usbp, ep);
 8010aca:	4638      	mov	r0, r7
 8010acc:	4631      	mov	r1, r6
 8010ace:	f7ff ffaf 	bl	8010a30 <usb_lld_prepare_transmit>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8010ad2:	b672      	cpsid	i
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8010ad4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010ad6:	eb03 1046 	add.w	r0, r3, r6, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8010ada:	2201      	movs	r2, #1
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8010adc:	f8d0 1900 	ldr.w	r1, [r0, #2304]	; 0x900
 8010ae0:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 8010ae4:	f8c0 1900 	str.w	r1, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8010ae8:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 8010aec:	40b2      	lsls	r2, r6
 8010aee:	430a      	orrs	r2, r1
 8010af0:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8010af4:	b662      	cpsie	i
 8010af6:	e7d3      	b.n	8010aa0 <otg_epin_handler.constprop.8+0x20>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8010af8:	b672      	cpsid	i
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8010afa:	f8d5 1834 	ldr.w	r1, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 8010afe:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8010b00:	480c      	ldr	r0, [pc, #48]	; (8010b34 <otg_epin_handler.constprop.8+0xb4>)
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8010b02:	ea21 0103 	bic.w	r1, r1, r3
 8010b06:	f8c5 1834 	str.w	r1, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 8010b0a:	4313      	orrs	r3, r2
 8010b0c:	2100      	movs	r1, #0
 8010b0e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010b10:	f7fc fe46 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8010b14:	b662      	cpsie	i
 8010b16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      usb_lld_start_in(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 8010b18:	893a      	ldrh	r2, [r7, #8]
 8010b1a:	f8d1 c008 	ldr.w	ip, [r1, #8]
 8010b1e:	2301      	movs	r3, #1
 8010b20:	40b3      	lsls	r3, r6
 8010b22:	ea22 0303 	bic.w	r3, r2, r3
 8010b26:	813b      	strh	r3, [r7, #8]
 8010b28:	4638      	mov	r0, r7
 8010b2a:	4631      	mov	r1, r6
 8010b2c:	47e0      	blx	ip
 8010b2e:	e7b7      	b.n	8010aa0 <otg_epin_handler.constprop.8+0x20>
 8010b30:	20001498 	.word	0x20001498
 8010b34:	200014f8 	.word	0x200014f8
	...

08010b40 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8010b40:	b570      	push	{r4, r5, r6, lr}
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8010b42:	4e38      	ldr	r6, [pc, #224]	; (8010c24 <Vector14C+0xe4>)
 8010b44:	6d35      	ldr	r5, [r6, #80]	; 0x50
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8010b46:	696b      	ldr	r3, [r5, #20]
  sts &= otgp->GINTMSK;
 8010b48:	69ac      	ldr	r4, [r5, #24]
 8010b4a:	401c      	ands	r4, r3
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8010b4c:	04e1      	lsls	r1, r4, #19
  stm32_otg_t *otgp = usbp->otg;
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;
 8010b4e:	616c      	str	r4, [r5, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8010b50:	d42d      	bmi.n	8010bae <Vector14C+0x6e>
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8010b52:	04a2      	lsls	r2, r4, #18
    (void)otgp->DSTS;
 8010b54:	bf48      	it	mi
 8010b56:	f8d5 3808 	ldrmi.w	r3, [r5, #2056]	; 0x808
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8010b5a:	0723      	lsls	r3, r4, #28
 8010b5c:	d504      	bpl.n	8010b68 <Vector14C+0x28>
    _usb_isr_invoke_sof_cb(usbp);
 8010b5e:	6873      	ldr	r3, [r6, #4]
 8010b60:	68db      	ldr	r3, [r3, #12]
 8010b62:	b10b      	cbz	r3, 8010b68 <Vector14C+0x28>
 8010b64:	482f      	ldr	r0, [pc, #188]	; (8010c24 <Vector14C+0xe4>)
 8010b66:	4798      	blx	r3
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8010b68:	06e6      	lsls	r6, r4, #27
 8010b6a:	d42b      	bmi.n	8010bc4 <Vector14C+0x84>
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
 8010b6c:	0360      	lsls	r0, r4, #13
    osalThreadResumeI(&usbp->wait, MSG_OK);
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8010b6e:	f8d5 5818 	ldr.w	r5, [r5, #2072]	; 0x818
  if (sts & GINTSTS_IEPINT) {
 8010b72:	d507      	bpl.n	8010b84 <Vector14C+0x44>
    if (src & (1 << 0))
 8010b74:	07e9      	lsls	r1, r5, #31
 8010b76:	d441      	bmi.n	8010bfc <Vector14C+0xbc>
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
 8010b78:	07aa      	lsls	r2, r5, #30
 8010b7a:	d444      	bmi.n	8010c06 <Vector14C+0xc6>
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
 8010b7c:	076b      	lsls	r3, r5, #29
 8010b7e:	d447      	bmi.n	8010c10 <Vector14C+0xd0>
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
 8010b80:	072e      	lsls	r6, r5, #28
 8010b82:	d44a      	bmi.n	8010c1a <Vector14C+0xda>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8010b84:	0324      	lsls	r4, r4, #12
 8010b86:	d507      	bpl.n	8010b98 <Vector14C+0x58>
    if (src & (1 << 16))
 8010b88:	03e8      	lsls	r0, r5, #15
 8010b8a:	d42c      	bmi.n	8010be6 <Vector14C+0xa6>
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
 8010b8c:	03a9      	lsls	r1, r5, #14
 8010b8e:	d42f      	bmi.n	8010bf0 <Vector14C+0xb0>
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
 8010b90:	036a      	lsls	r2, r5, #13
 8010b92:	d422      	bmi.n	8010bda <Vector14C+0x9a>
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
 8010b94:	032b      	lsls	r3, r5, #12
 8010b96:	d403      	bmi.n	8010ba0 <Vector14C+0x60>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 8010b98:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 8010b9c:	f7fd b8c8 	b.w	800dd30 <_port_irq_epilogue>
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
      otg_epout_handler(usbp, 3);
 8010ba0:	2003      	movs	r0, #3
 8010ba2:	f7ff fef5 	bl	8010990 <otg_epout_handler.constprop.7>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 8010ba6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 8010baa:	f7fd b8c1 	b.w	800dd30 <_port_irq_epilogue>
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
    _usb_reset(usbp);
 8010bae:	4630      	mov	r0, r6
 8010bb0:	f7fd fca6 	bl	800e500 <_usb_reset>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8010bb4:	6873      	ldr	r3, [r6, #4]
 8010bb6:	681b      	ldr	r3, [r3, #0]
 8010bb8:	2b00      	cmp	r3, #0
 8010bba:	d0ca      	beq.n	8010b52 <Vector14C+0x12>
 8010bbc:	4630      	mov	r0, r6
 8010bbe:	2100      	movs	r1, #0
 8010bc0:	4798      	blx	r3
 8010bc2:	e7c6      	b.n	8010b52 <Vector14C+0x12>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8010bc4:	b672      	cpsid	i
  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8010bc6:	69ab      	ldr	r3, [r5, #24]
 8010bc8:	4817      	ldr	r0, [pc, #92]	; (8010c28 <Vector14C+0xe8>)
 8010bca:	f023 0310 	bic.w	r3, r3, #16
 8010bce:	61ab      	str	r3, [r5, #24]
 8010bd0:	2100      	movs	r1, #0
 8010bd2:	f7fc fde5 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8010bd6:	b662      	cpsie	i
 8010bd8:	e7c8      	b.n	8010b6c <Vector14C+0x2c>
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
 8010bda:	2002      	movs	r0, #2
 8010bdc:	f7ff fed8 	bl	8010990 <otg_epout_handler.constprop.7>
    if (src & (1 << 19))
 8010be0:	032b      	lsls	r3, r5, #12
 8010be2:	d5d9      	bpl.n	8010b98 <Vector14C+0x58>
 8010be4:	e7dc      	b.n	8010ba0 <Vector14C+0x60>
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
 8010be6:	2000      	movs	r0, #0
 8010be8:	f7ff fed2 	bl	8010990 <otg_epout_handler.constprop.7>
    if (src & (1 << 17))
 8010bec:	03a9      	lsls	r1, r5, #14
 8010bee:	d5cf      	bpl.n	8010b90 <Vector14C+0x50>
      otg_epout_handler(usbp, 1);
 8010bf0:	2001      	movs	r0, #1
 8010bf2:	f7ff fecd 	bl	8010990 <otg_epout_handler.constprop.7>
    if (src & (1 << 18))
 8010bf6:	036a      	lsls	r2, r5, #13
 8010bf8:	d5cc      	bpl.n	8010b94 <Vector14C+0x54>
 8010bfa:	e7ee      	b.n	8010bda <Vector14C+0x9a>

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
 8010bfc:	2000      	movs	r0, #0
 8010bfe:	f7ff ff3f 	bl	8010a80 <otg_epin_handler.constprop.8>
    if (src & (1 << 1))
 8010c02:	07aa      	lsls	r2, r5, #30
 8010c04:	d5ba      	bpl.n	8010b7c <Vector14C+0x3c>
      otg_epin_handler(usbp, 1);
 8010c06:	2001      	movs	r0, #1
 8010c08:	f7ff ff3a 	bl	8010a80 <otg_epin_handler.constprop.8>
    if (src & (1 << 2))
 8010c0c:	076b      	lsls	r3, r5, #29
 8010c0e:	d5b7      	bpl.n	8010b80 <Vector14C+0x40>
      otg_epin_handler(usbp, 2);
 8010c10:	2002      	movs	r0, #2
 8010c12:	f7ff ff35 	bl	8010a80 <otg_epin_handler.constprop.8>
    if (src & (1 << 3))
 8010c16:	072e      	lsls	r6, r5, #28
 8010c18:	d5b4      	bpl.n	8010b84 <Vector14C+0x44>
      otg_epin_handler(usbp, 3);
 8010c1a:	2003      	movs	r0, #3
 8010c1c:	f7ff ff30 	bl	8010a80 <otg_epin_handler.constprop.8>
 8010c20:	e7b0      	b.n	8010b84 <Vector14C+0x44>
 8010c22:	bf00      	nop
 8010c24:	20001498 	.word	0x20001498
 8010c28:	200014f8 	.word	0x200014f8
 8010c2c:	00000000 	.word	0x00000000

08010c30 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8010c30:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8010c32:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 8010c36:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8010c3a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8010c3e:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 8010c42:	4770      	bx	lr
	...

08010c50 <usb_lld_start_in>:
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8010c50:	6d03      	ldr	r3, [r0, #80]	; 0x50
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8010c52:	b410      	push	{r4}
 8010c54:	eb03 1441 	add.w	r4, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8010c58:	2201      	movs	r2, #1
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8010c5a:	f8d4 0900 	ldr.w	r0, [r4, #2304]	; 0x900
 8010c5e:	f040 4004 	orr.w	r0, r0, #2214592512	; 0x84000000
 8010c62:	f8c4 0900 	str.w	r0, [r4, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8010c66:	f8d3 0834 	ldr.w	r0, [r3, #2100]	; 0x834
}
 8010c6a:	f85d 4b04 	ldr.w	r4, [sp], #4
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8010c6e:	408a      	lsls	r2, r1
 8010c70:	4302      	orrs	r2, r0
 8010c72:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 8010c76:	4770      	bx	lr
	...

08010c80 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8010c80:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8010c82:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8010c86:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8010c8a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8010c8e:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 8010c92:	4770      	bx	lr
	...

08010ca0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8010ca0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8010ca2:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8010ca6:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8010caa:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8010cae:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 8010cb2:	4770      	bx	lr
	...

08010cc0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8010cc0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8010cc2:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8010cc6:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8010cca:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8010cce:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 8010cd2:	4770      	bx	lr
	...

08010ce0 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8010ce0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8010ce2:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8010ce6:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8010cea:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8010cee:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 8010cf2:	4770      	bx	lr
	...

08010d00 <spi_lld_serve_tx_interrupt>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8010d00:	f011 0f0c 	tst.w	r1, #12
 8010d04:	d100      	bne.n	8010d08 <spi_lld_serve_tx_interrupt+0x8>
 8010d06:	4770      	bx	lr
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8010d08:	4801      	ldr	r0, [pc, #4]	; (8010d10 <spi_lld_serve_tx_interrupt+0x10>)
 8010d0a:	f7fc ba91 	b.w	800d230 <chSysHalt>
 8010d0e:	bf00      	nop
 8010d10:	08016770 	.word	0x08016770
	...

08010d20 <spi_lld_serve_rx_interrupt>:
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8010d20:	f011 0f0c 	tst.w	r1, #12
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8010d24:	b538      	push	{r3, r4, r5, lr}
 8010d26:	4604      	mov	r4, r0

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8010d28:	d130      	bne.n	8010d8c <spi_lld_serve_rx_interrupt+0x6c>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 8010d2a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8010d2c:	6802      	ldr	r2, [r0, #0]
 8010d2e:	6813      	ldr	r3, [r2, #0]
 8010d30:	f023 031f 	bic.w	r3, r3, #31
 8010d34:	6013      	str	r3, [r2, #0]
 8010d36:	6813      	ldr	r3, [r2, #0]
 8010d38:	07d9      	lsls	r1, r3, #31
 8010d3a:	d4fc      	bmi.n	8010d36 <spi_lld_serve_rx_interrupt+0x16>
 8010d3c:	7a05      	ldrb	r5, [r0, #8]
  dmaStreamDisable(spip->dmarx);
 8010d3e:	6a21      	ldr	r1, [r4, #32]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 8010d40:	6840      	ldr	r0, [r0, #4]
  dmaStreamDisable(spip->dmarx);
 8010d42:	680a      	ldr	r2, [r1, #0]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 8010d44:	233d      	movs	r3, #61	; 0x3d
 8010d46:	40ab      	lsls	r3, r5
 8010d48:	6003      	str	r3, [r0, #0]
  dmaStreamDisable(spip->dmarx);
 8010d4a:	6813      	ldr	r3, [r2, #0]
 8010d4c:	f023 031f 	bic.w	r3, r3, #31
 8010d50:	6013      	str	r3, [r2, #0]
 8010d52:	6813      	ldr	r3, [r2, #0]
 8010d54:	07db      	lsls	r3, r3, #31
 8010d56:	d4fc      	bmi.n	8010d52 <spi_lld_serve_rx_interrupt+0x32>

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8010d58:	6863      	ldr	r3, [r4, #4]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 8010d5a:	7a08      	ldrb	r0, [r1, #8]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8010d5c:	681a      	ldr	r2, [r3, #0]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 8010d5e:	6849      	ldr	r1, [r1, #4]
 8010d60:	233d      	movs	r3, #61	; 0x3d
 8010d62:	4083      	lsls	r3, r0
 8010d64:	600b      	str	r3, [r1, #0]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8010d66:	b172      	cbz	r2, 8010d86 <spi_lld_serve_rx_interrupt+0x66>
 8010d68:	2304      	movs	r3, #4
 8010d6a:	7023      	strb	r3, [r4, #0]
 8010d6c:	4620      	mov	r0, r4
 8010d6e:	4790      	blx	r2
 8010d70:	7823      	ldrb	r3, [r4, #0]
 8010d72:	2b04      	cmp	r3, #4
 8010d74:	d007      	beq.n	8010d86 <spi_lld_serve_rx_interrupt+0x66>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8010d76:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8010d78:	2100      	movs	r1, #0
 8010d7a:	f104 0008 	add.w	r0, r4, #8
 8010d7e:	f7fc fd0f 	bl	800d7a0 <chThdResumeI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8010d82:	b662      	cpsie	i
 8010d84:	bd38      	pop	{r3, r4, r5, pc}
 8010d86:	2302      	movs	r3, #2
 8010d88:	7023      	strb	r3, [r4, #0]
 8010d8a:	e7f4      	b.n	8010d76 <spi_lld_serve_rx_interrupt+0x56>
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8010d8c:	4801      	ldr	r0, [pc, #4]	; (8010d94 <spi_lld_serve_rx_interrupt+0x74>)
 8010d8e:	f7fc fa4f 	bl	800d230 <chSysHalt>
 8010d92:	e7ca      	b.n	8010d2a <spi_lld_serve_rx_interrupt+0xa>
 8010d94:	08016770 	.word	0x08016770
	...

08010da0 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 8010da0:	b510      	push	{r4, lr}
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 8010da2:	4c0a      	ldr	r4, [pc, #40]	; (8010dcc <spi_lld_init+0x2c>)
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 8010da4:	4b0a      	ldr	r3, [pc, #40]	; (8010dd0 <spi_lld_init+0x30>)
 8010da6:	f64f 72ff 	movw	r2, #65535	; 0xffff
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 8010daa:	4620      	mov	r0, r4
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 8010dac:	801a      	strh	r2, [r3, #0]
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 8010dae:	f7fd fab7 	bl	800e320 <spiObjectInit>
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 8010db2:	4b08      	ldr	r3, [pc, #32]	; (8010dd4 <spi_lld_init+0x34>)
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 8010db4:	4808      	ldr	r0, [pc, #32]	; (8010dd8 <spi_lld_init+0x38>)
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8010db6:	4909      	ldr	r1, [pc, #36]	; (8010ddc <spi_lld_init+0x3c>)
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8010db8:	4a09      	ldr	r2, [pc, #36]	; (8010de0 <spi_lld_init+0x40>)
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 8010dba:	61e0      	str	r0, [r4, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 8010dbc:	f103 000c 	add.w	r0, r3, #12
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 8010dc0:	6223      	str	r3, [r4, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 8010dc2:	6260      	str	r0, [r4, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8010dc4:	62a1      	str	r1, [r4, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8010dc6:	62e2      	str	r2, [r4, #44]	; 0x2c
 8010dc8:	bd10      	pop	{r4, pc}
 8010dca:	bf00      	nop
 8010dcc:	20001738 	.word	0x20001738
 8010dd0:	20001734 	.word	0x20001734
 8010dd4:	080166d4 	.word	0x080166d4
 8010dd8:	40003800 	.word	0x40003800
 8010ddc:	00010016 	.word	0x00010016
 8010de0:	00010046 	.word	0x00010046
	...

08010df0 <spi_lld_start>:
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 8010df0:	7803      	ldrb	r3, [r0, #0]
 8010df2:	2b01      	cmp	r3, #1
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 8010df4:	b510      	push	{r4, lr}
 8010df6:	4604      	mov	r4, r0

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 8010df8:	d01d      	beq.n	8010e36 <spi_lld_start+0x46>
 8010dfa:	69c3      	ldr	r3, [r0, #28]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 8010dfc:	6862      	ldr	r2, [r4, #4]
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8010dfe:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 8010e00:	8952      	ldrh	r2, [r2, #10]
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8010e02:	6ae1      	ldr	r1, [r4, #44]	; 0x2c

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8010e04:	f420 40f0 	bic.w	r0, r0, #30720	; 0x7800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8010e08:	f421 41f0 	bic.w	r1, r1, #30720	; 0x7800
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 8010e0c:	f412 6f00 	tst.w	r2, #2048	; 0x800
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8010e10:	bf1c      	itt	ne
 8010e12:	f440 5020 	orrne.w	r0, r0, #10240	; 0x2800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8010e16:	f441 5120 	orrne.w	r1, r1, #10240	; 0x2800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8010e1a:	62a0      	str	r0, [r4, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8010e1c:	62e1      	str	r1, [r4, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 8010e1e:	f442 7241 	orr.w	r2, r2, #772	; 0x304
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 8010e22:	2000      	movs	r0, #0
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = SPI_CR2_SSOE | SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 8010e24:	2107      	movs	r1, #7
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 8010e26:	6018      	str	r0, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 8010e28:	601a      	str	r2, [r3, #0]
                    SPI_CR1_SSI;
  spip->spi->CR2  = SPI_CR2_SSOE | SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 8010e2a:	6059      	str	r1, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 8010e2c:	681a      	ldr	r2, [r3, #0]
 8010e2e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8010e32:	601a      	str	r2, [r3, #0]
 8010e34:	bd10      	pop	{r4, pc}
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
 8010e36:	4b0f      	ldr	r3, [pc, #60]	; (8010e74 <spi_lld_start+0x84>)
 8010e38:	4298      	cmp	r0, r3
 8010e3a:	d009      	beq.n	8010e50 <spi_lld_start+0x60>
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8010e3c:	6a21      	ldr	r1, [r4, #32]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8010e3e:	6a62      	ldr	r2, [r4, #36]	; 0x24
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8010e40:	69e3      	ldr	r3, [r4, #28]
 8010e42:	6808      	ldr	r0, [r1, #0]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8010e44:	6811      	ldr	r1, [r2, #0]
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8010e46:	f103 020c 	add.w	r2, r3, #12
 8010e4a:	6082      	str	r2, [r0, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8010e4c:	608a      	str	r2, [r1, #8]
 8010e4e:	e7d5      	b.n	8010dfc <spi_lld_start+0xc>
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 8010e50:	4a09      	ldr	r2, [pc, #36]	; (8010e78 <spi_lld_start+0x88>)
 8010e52:	6a00      	ldr	r0, [r0, #32]
 8010e54:	210a      	movs	r1, #10
 8010e56:	4623      	mov	r3, r4
 8010e58:	f7fd ff7a 	bl	800ed50 <dmaStreamAllocate>
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 8010e5c:	4a07      	ldr	r2, [pc, #28]	; (8010e7c <spi_lld_start+0x8c>)
 8010e5e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8010e60:	4623      	mov	r3, r4
 8010e62:	210a      	movs	r1, #10
 8010e64:	f7fd ff74 	bl	800ed50 <dmaStreamAllocate>
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
 8010e68:	4a05      	ldr	r2, [pc, #20]	; (8010e80 <spi_lld_start+0x90>)
 8010e6a:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8010e6c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8010e70:	6413      	str	r3, [r2, #64]	; 0x40
 8010e72:	e7e3      	b.n	8010e3c <spi_lld_start+0x4c>
 8010e74:	20001738 	.word	0x20001738
 8010e78:	08010d21 	.word	0x08010d21
 8010e7c:	08010d01 	.word	0x08010d01
 8010e80:	40023800 	.word	0x40023800
	...

08010e90 <spi_lld_select>:
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {

  palClearPad(spip->config->ssport, spip->config->sspad);
 8010e90:	6843      	ldr	r3, [r0, #4]
 8010e92:	8919      	ldrh	r1, [r3, #8]
 8010e94:	685a      	ldr	r2, [r3, #4]
 8010e96:	2301      	movs	r3, #1
 8010e98:	408b      	lsls	r3, r1
 8010e9a:	b29b      	uxth	r3, r3
 8010e9c:	8353      	strh	r3, [r2, #26]
 8010e9e:	4770      	bx	lr

08010ea0 <spi_lld_unselect>:
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {

  palSetPad(spip->config->ssport, spip->config->sspad);
 8010ea0:	6843      	ldr	r3, [r0, #4]
 8010ea2:	8919      	ldrh	r1, [r3, #8]
 8010ea4:	685a      	ldr	r2, [r3, #4]
 8010ea6:	2301      	movs	r3, #1
 8010ea8:	408b      	lsls	r3, r1
 8010eaa:	b29b      	uxth	r3, r3
 8010eac:	8313      	strh	r3, [r2, #24]
 8010eae:	4770      	bx	lr

08010eb0 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 8010eb0:	b4f0      	push	{r4, r5, r6, r7}

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8010eb2:	6a04      	ldr	r4, [r0, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8010eb4:	6a47      	ldr	r7, [r0, #36]	; 0x24
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8010eb6:	6a86      	ldr	r6, [r0, #40]	; 0x28

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8010eb8:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8010eba:	6824      	ldr	r4, [r4, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8010ebc:	6838      	ldr	r0, [r7, #0]
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8010ebe:	60e3      	str	r3, [r4, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8010ec0:	f446 6680 	orr.w	r6, r6, #1024	; 0x400

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8010ec4:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8010ec8:	6061      	str	r1, [r4, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8010eca:	6026      	str	r6, [r4, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8010ecc:	60c2      	str	r2, [r0, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8010ece:	6041      	str	r1, [r0, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8010ed0:	6005      	str	r5, [r0, #0]

  dmaStreamEnable(spip->dmarx);
 8010ed2:	6823      	ldr	r3, [r4, #0]
 8010ed4:	f043 0301 	orr.w	r3, r3, #1
 8010ed8:	6023      	str	r3, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 8010eda:	6803      	ldr	r3, [r0, #0]
 8010edc:	f043 0301 	orr.w	r3, r3, #1
 8010ee0:	6003      	str	r3, [r0, #0]
}
 8010ee2:	bcf0      	pop	{r4, r5, r6, r7}
 8010ee4:	4770      	bx	lr
 8010ee6:	bf00      	nop
	...

08010ef0 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 8010ef0:	b470      	push	{r4, r5, r6}

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8010ef2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 8010ef4:	6a04      	ldr	r4, [r0, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8010ef6:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 8010ef8:	6824      	ldr	r4, [r4, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8010efa:	681b      	ldr	r3, [r3, #0]
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 8010efc:	6a80      	ldr	r0, [r0, #40]	; 0x28
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 8010efe:	4e09      	ldr	r6, [pc, #36]	; (8010f24 <spi_lld_send+0x34>)
 8010f00:	60e6      	str	r6, [r4, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8010f02:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8010f06:	6061      	str	r1, [r4, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 8010f08:	6020      	str	r0, [r4, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8010f0a:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8010f0c:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8010f0e:	601d      	str	r5, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 8010f10:	6822      	ldr	r2, [r4, #0]
 8010f12:	f042 0201 	orr.w	r2, r2, #1
 8010f16:	6022      	str	r2, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 8010f18:	681a      	ldr	r2, [r3, #0]
 8010f1a:	f042 0201 	orr.w	r2, r2, #1
 8010f1e:	601a      	str	r2, [r3, #0]
}
 8010f20:	bc70      	pop	{r4, r5, r6}
 8010f22:	4770      	bx	lr
 8010f24:	20001768 	.word	0x20001768
	...

08010f30 <spi_lld_receive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 8010f30:	b470      	push	{r4, r5, r6}

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8010f32:	6a43      	ldr	r3, [r0, #36]	; 0x24
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8010f34:	6a04      	ldr	r4, [r0, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8010f36:	6a85      	ldr	r5, [r0, #40]	; 0x28
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8010f38:	6824      	ldr	r4, [r4, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8010f3a:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 8010f3c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8010f3e:	4e09      	ldr	r6, [pc, #36]	; (8010f64 <spi_lld_receive+0x34>)
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8010f40:	60e2      	str	r2, [r4, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8010f42:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8010f46:	6061      	str	r1, [r4, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8010f48:	6025      	str	r5, [r4, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8010f4a:	60de      	str	r6, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8010f4c:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 8010f4e:	6018      	str	r0, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 8010f50:	6822      	ldr	r2, [r4, #0]
 8010f52:	f042 0201 	orr.w	r2, r2, #1
 8010f56:	6022      	str	r2, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 8010f58:	681a      	ldr	r2, [r3, #0]
 8010f5a:	f042 0201 	orr.w	r2, r2, #1
 8010f5e:	601a      	str	r2, [r3, #0]
}
 8010f60:	bc70      	pop	{r4, r5, r6}
 8010f62:	4770      	bx	lr
 8010f64:	20001734 	.word	0x20001734
	...

08010f70 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8010f70:	b538      	push	{r3, r4, r5, lr}
 * @param[in] pwmp      pointer to a @p PWMDriver object
 */
static void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8010f72:	4d17      	ldr	r5, [pc, #92]	; (8010fd0 <VectorB4+0x60>)
 8010f74:	69ab      	ldr	r3, [r5, #24]
 8010f76:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8010f78:	68dc      	ldr	r4, [r3, #12]
 8010f7a:	4014      	ands	r4, r2
 8010f7c:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 8010f7e:	43d2      	mvns	r2, r2
 8010f80:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8010f82:	07a3      	lsls	r3, r4, #30
 8010f84:	d504      	bpl.n	8010f90 <VectorB4+0x20>
      (pwmp->config->channels[0].callback != NULL))
 8010f86:	686b      	ldr	r3, [r5, #4]
 8010f88:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8010f8a:	b10b      	cbz	r3, 8010f90 <VectorB4+0x20>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 8010f8c:	4628      	mov	r0, r5
 8010f8e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8010f90:	0760      	lsls	r0, r4, #29
 8010f92:	d504      	bpl.n	8010f9e <VectorB4+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 8010f94:	686b      	ldr	r3, [r5, #4]
 8010f96:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8010f98:	b10b      	cbz	r3, 8010f9e <VectorB4+0x2e>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 8010f9a:	480d      	ldr	r0, [pc, #52]	; (8010fd0 <VectorB4+0x60>)
 8010f9c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8010f9e:	0721      	lsls	r1, r4, #28
 8010fa0:	d504      	bpl.n	8010fac <VectorB4+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 8010fa2:	686b      	ldr	r3, [r5, #4]
 8010fa4:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8010fa6:	b10b      	cbz	r3, 8010fac <VectorB4+0x3c>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8010fa8:	4809      	ldr	r0, [pc, #36]	; (8010fd0 <VectorB4+0x60>)
 8010faa:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8010fac:	06e2      	lsls	r2, r4, #27
 8010fae:	d504      	bpl.n	8010fba <VectorB4+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 8010fb0:	686b      	ldr	r3, [r5, #4]
 8010fb2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8010fb4:	b10b      	cbz	r3, 8010fba <VectorB4+0x4a>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 8010fb6:	4806      	ldr	r0, [pc, #24]	; (8010fd0 <VectorB4+0x60>)
 8010fb8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8010fba:	07e3      	lsls	r3, r4, #31
 8010fbc:	d504      	bpl.n	8010fc8 <VectorB4+0x58>
 8010fbe:	686b      	ldr	r3, [r5, #4]
 8010fc0:	689b      	ldr	r3, [r3, #8]
 8010fc2:	b10b      	cbz	r3, 8010fc8 <VectorB4+0x58>
    pwmp->config->callback(pwmp);
 8010fc4:	4802      	ldr	r0, [pc, #8]	; (8010fd0 <VectorB4+0x60>)
 8010fc6:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
}
 8010fc8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
 8010fcc:	f7fc beb0 	b.w	800dd30 <_port_irq_epilogue>
 8010fd0:	2000176c 	.word	0x2000176c
	...

08010fe0 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 8010fe0:	b510      	push	{r4, lr}
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8010fe2:	4c04      	ldr	r4, [pc, #16]	; (8010ff4 <pwm_lld_init+0x14>)
 8010fe4:	4620      	mov	r0, r4
 8010fe6:	f7fc ffeb 	bl	800dfc0 <pwmObjectInit>
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8010fea:	2204      	movs	r2, #4
  PWMD3.tim = STM32_TIM3;
 8010fec:	4b02      	ldr	r3, [pc, #8]	; (8010ff8 <pwm_lld_init+0x18>)
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8010fee:	7422      	strb	r2, [r4, #16]
  PWMD3.tim = STM32_TIM3;
 8010ff0:	61a3      	str	r3, [r4, #24]
 8010ff2:	bd10      	pop	{r4, pc}
 8010ff4:	2000176c 	.word	0x2000176c
 8010ff8:	40000400 	.word	0x40000400
 8010ffc:	00000000 	.word	0x00000000

08011000 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 8011000:	f7fd bf26 	b.w	800ee50 <stm32_clock_init>
	...

08011010 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 8011010:	4770      	bx	lr
 8011012:	bf00      	nop
	...

08011020 <_sbrk_r>:
}

/***************************************************************************/

caddr_t _sbrk_r(struct _reent *r, int incr)
{
 8011020:	b510      	push	{r4, lr}
 8011022:	4604      	mov	r4, r0
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr > 0);

  p = chCoreAlloc((size_t)incr);
 8011024:	4608      	mov	r0, r1
 8011026:	f7fc fe4b 	bl	800dcc0 <chCoreAlloc>
  if (p == NULL) {
 801102a:	b100      	cbz	r0, 801102e <_sbrk_r+0xe>
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 801102c:	bd10      	pop	{r4, pc}

  chDbgCheck(incr > 0);

  p = chCoreAlloc((size_t)incr);
  if (p == NULL) {
    __errno_r(r) = ENOMEM;
 801102e:	230c      	movs	r3, #12
 8011030:	6023      	str	r3, [r4, #0]
    return (caddr_t)-1;
 8011032:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 8011036:	bd10      	pop	{r4, pc}
	...

08011040 <halAssyInit>:
 * @param   none
 *
 * @return  none
 */
void halAssyInit(void)
{
 8011040:	b538      	push	{r3, r4, r5, lr}
	CC2520_GPIO0_DIR_OUT();
 8011042:	4c28      	ldr	r4, [pc, #160]	; (80110e4 <halAssyInit+0xa4>)
 *
 * @return      none
 */
static void halRadioSpiInit(void)
{
	palSetPad(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN);
 8011044:	4d28      	ldr	r5, [pc, #160]	; (80110e8 <halAssyInit+0xa8>)
 *
 * @return  none
 */
void halAssyInit(void)
{
	CC2520_GPIO0_DIR_OUT();
 8011046:	4620      	mov	r0, r4
 8011048:	f44f 7100 	mov.w	r1, #512	; 0x200
 801104c:	2200      	movs	r2, #0
 801104e:	f7fe fd9f 	bl	800fb90 <_pal_lld_setgroupmode>
	CC2520_GPIO1_DIR_OUT();
 8011052:	4620      	mov	r0, r4
 8011054:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8011058:	2200      	movs	r2, #0
 801105a:	f7fe fd99 	bl	800fb90 <_pal_lld_setgroupmode>
	CC2520_GPIO2_DIR_OUT();
 801105e:	4620      	mov	r0, r4
 8011060:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8011064:	2200      	movs	r2, #0
 8011066:	f7fe fd93 	bl	800fb90 <_pal_lld_setgroupmode>
	CC2520_GPIO3_DIR_OUT();
 801106a:	4620      	mov	r0, r4
 801106c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8011070:	2200      	movs	r2, #0
 8011072:	f7fe fd8d 	bl	800fb90 <_pal_lld_setgroupmode>
	CC2520_GPIO4_DIR_OUT();
 8011076:	4620      	mov	r0, r4
 8011078:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 801107c:	2200      	movs	r2, #0
 801107e:	f7fe fd87 	bl	800fb90 <_pal_lld_setgroupmode>
	CC2520_GPIO5_DIR_OUT();
 8011082:	4620      	mov	r0, r4
 8011084:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8011088:	2200      	movs	r2, #0
 801108a:	f7fe fd81 	bl	800fb90 <_pal_lld_setgroupmode>
 *
 * @return      none
 */
static void halRadioSpiInit(void)
{
	palSetPad(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN);
 801108e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8011092:	8329      	strh	r1, [r5, #24]
	palSetPadMode(CC2520_SPI_CSN_PORT, CC2520_SPI_CSN_PIN, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8011094:	4628      	mov	r0, r5
 8011096:	2219      	movs	r2, #25
 8011098:	f7fe fd7a 	bl	800fb90 <_pal_lld_setgroupmode>
	CC2520_ENABLE_SPI_FUNC();
 801109c:	4628      	mov	r0, r5
 801109e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80110a2:	f240 229a 	movw	r2, #666	; 0x29a
 80110a6:	f7fe fd73 	bl	800fb90 <_pal_lld_setgroupmode>
 80110aa:	4628      	mov	r0, r5
 80110ac:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80110b0:	f240 2282 	movw	r2, #642	; 0x282
 80110b4:	f7fe fd6c 	bl	800fb90 <_pal_lld_setgroupmode>
 80110b8:	4628      	mov	r0, r5
 80110ba:	f240 229a 	movw	r2, #666	; 0x29a
 80110be:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80110c2:	f7fe fd65 	bl	800fb90 <_pal_lld_setgroupmode>

	spiStart(&CC2520_SPI, &spicfg);
 80110c6:	4809      	ldr	r0, [pc, #36]	; (80110ec <halAssyInit+0xac>)
 80110c8:	4909      	ldr	r1, [pc, #36]	; (80110f0 <halAssyInit+0xb0>)
 80110ca:	f7fd f931 	bl	800e330 <spiStart>
 * @return  none
 */
static void halMcuRfInterfaceInit(void)
{
	// Initialize the CC2520 interface
	CC2520_RESET_OPIN(0);
 80110ce:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 80110d2:	61a3      	str	r3, [r4, #24]
	CC2520_BASIC_IO_DIR_INIT();
 80110d4:	4620      	mov	r0, r4
 80110d6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80110da:	2219      	movs	r2, #25
	halRadioSpiInit();
	halMcuRfInterfaceInit();
#ifndef MRFI_CC2520
	//halDigioConfig(&pinRadio_GPIO0);
#endif
}
 80110dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 */
static void halMcuRfInterfaceInit(void)
{
	// Initialize the CC2520 interface
	CC2520_RESET_OPIN(0);
	CC2520_BASIC_IO_DIR_INIT();
 80110e0:	f7fe bd56 	b.w	800fb90 <_pal_lld_setgroupmode>
 80110e4:	40020c00 	.word	0x40020c00
 80110e8:	40020400 	.word	0x40020400
 80110ec:	20001738 	.word	0x20001738
 80110f0:	080168d0 	.word	0x080168d0
	...

08011100 <halSpiExc>:
#ifndef MRFI_CC2520
	//halDigioConfig(&pinRadio_GPIO0);
#endif
}

unsigned char halSpiExc(unsigned char x) {
 8011100:	b500      	push	{lr}
 8011102:	b085      	sub	sp, #20
 8011104:	aa04      	add	r2, sp, #16
	unsigned char rx;
	spiExchange(&CC2520_SPI, 1, &x, &rx);
 8011106:	2101      	movs	r1, #1
#ifndef MRFI_CC2520
	//halDigioConfig(&pinRadio_GPIO0);
#endif
}

unsigned char halSpiExc(unsigned char x) {
 8011108:	f802 0d09 	strb.w	r0, [r2, #-9]!
	unsigned char rx;
	spiExchange(&CC2520_SPI, 1, &x, &rx);
 801110c:	f10d 030f 	add.w	r3, sp, #15
 8011110:	4803      	ldr	r0, [pc, #12]	; (8011120 <halSpiExc+0x20>)
 8011112:	f7fd f92d 	bl	800e370 <spiExchange>
	return rx;
}
 8011116:	f89d 000f 	ldrb.w	r0, [sp, #15]
 801111a:	b005      	add	sp, #20
 801111c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011120:	20001738 	.word	0x20001738
	...

08011130 <CC2520_INS_STROBE>:
 * @param   uint8 strobe - strobe command
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_INS_STROBE(uint8 strobe)
{
 8011130:	b538      	push	{r3, r4, r5, lr}
	uint8 s;
	CC2520_SPI_BEGIN();
 8011132:	4c07      	ldr	r4, [pc, #28]	; (8011150 <CC2520_INS_STROBE+0x20>)
 * @param   uint8 strobe - strobe command
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_INS_STROBE(uint8 strobe)
{
 8011134:	4605      	mov	r5, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 8011136:	4620      	mov	r0, r4
 8011138:	f7fd f90a 	bl	800e350 <spiSelect>
	s = CC2520_SPI_TXRX(strobe);
 801113c:	4628      	mov	r0, r5
 801113e:	f7ff ffdf 	bl	8011100 <halSpiExc>
 8011142:	4605      	mov	r5, r0
	CC2520_SPI_END();
 8011144:	4620      	mov	r0, r4
 8011146:	f7fd f90b 	bl	800e360 <spiUnselect>
	return s;
}
 801114a:	4628      	mov	r0, r5
 801114c:	bd38      	pop	{r3, r4, r5, pc}
 801114e:	bf00      	nop
 8011150:	20001738 	.word	0x20001738
	...

08011160 <CC2520_MEMRD8>:
 * @param   uint16 addr
 *
 * @return  uint8 - result
 */
uint8 CC2520_MEMRD8(uint16 addr)
{
 8011160:	b538      	push	{r3, r4, r5, lr}
	uint8 value;
	CC2520_SPI_BEGIN();
 8011162:	4c0b      	ldr	r4, [pc, #44]	; (8011190 <CC2520_MEMRD8+0x30>)
 * @param   uint16 addr
 *
 * @return  uint8 - result
 */
uint8 CC2520_MEMRD8(uint16 addr)
{
 8011164:	4605      	mov	r5, r0
	uint8 value;
	CC2520_SPI_BEGIN();
 8011166:	4620      	mov	r0, r4
 8011168:	f7fd f8f2 	bl	800e350 <spiSelect>
	CC2520_SPI_TXRX(CC2520_INS_MEMRD | HI_UINT16(addr));
 801116c:	0a28      	lsrs	r0, r5, #8
 801116e:	f040 0010 	orr.w	r0, r0, #16
 8011172:	f7ff ffc5 	bl	8011100 <halSpiExc>
	CC2520_SPI_TXRX(LO_UINT16(addr));
 8011176:	b2e8      	uxtb	r0, r5
 8011178:	f7ff ffc2 	bl	8011100 <halSpiExc>
	value = CC2520_SPI_TXRX(0x00);
 801117c:	2000      	movs	r0, #0
 801117e:	f7ff ffbf 	bl	8011100 <halSpiExc>
 8011182:	4605      	mov	r5, r0
	CC2520_SPI_END();
 8011184:	4620      	mov	r0, r4
 8011186:	f7fd f8eb 	bl	800e360 <spiUnselect>
	return value;
}
 801118a:	4628      	mov	r0, r5
 801118c:	bd38      	pop	{r3, r4, r5, pc}
 801118e:	bf00      	nop
 8011190:	20001738 	.word	0x20001738
	...

080111a0 <CC2520_MEMWR8>:
 *          uint8 value
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_MEMWR8(uint16 addr, uint8 value)
{
 80111a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8 s;
	CC2520_SPI_BEGIN();
 80111a2:	4c0b      	ldr	r4, [pc, #44]	; (80111d0 <CC2520_MEMWR8+0x30>)
 *          uint8 value
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_MEMWR8(uint16 addr, uint8 value)
{
 80111a4:	4605      	mov	r5, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 80111a6:	4620      	mov	r0, r4
 *          uint8 value
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_MEMWR8(uint16 addr, uint8 value)
{
 80111a8:	460f      	mov	r7, r1
	uint8 s;
	CC2520_SPI_BEGIN();
 80111aa:	f7fd f8d1 	bl	800e350 <spiSelect>
	s = CC2520_SPI_TXRX(CC2520_INS_MEMWR | HI_UINT16(addr));
 80111ae:	0a28      	lsrs	r0, r5, #8
 80111b0:	f040 0020 	orr.w	r0, r0, #32
 80111b4:	f7ff ffa4 	bl	8011100 <halSpiExc>
 80111b8:	4606      	mov	r6, r0
	CC2520_SPI_TXRX(LO_UINT16(addr));
 80111ba:	b2e8      	uxtb	r0, r5
 80111bc:	f7ff ffa0 	bl	8011100 <halSpiExc>
	CC2520_SPI_TXRX(value);
 80111c0:	4638      	mov	r0, r7
 80111c2:	f7ff ff9d 	bl	8011100 <halSpiExc>
	CC2520_SPI_END();
 80111c6:	4620      	mov	r0, r4
 80111c8:	f7fd f8ca 	bl	800e360 <spiUnselect>
	return s;
}
 80111cc:	4630      	mov	r0, r6
 80111ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80111d0:	20001738 	.word	0x20001738
	...

080111e0 <CC2520_MEMWR16>:
 *          uint16 value
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_MEMWR16(uint16 addr, uint16 value)
{
 80111e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8 s;
	CC2520_SPI_BEGIN();
 80111e2:	4c0d      	ldr	r4, [pc, #52]	; (8011218 <CC2520_MEMWR16+0x38>)
 *          uint16 value
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_MEMWR16(uint16 addr, uint16 value)
{
 80111e4:	4606      	mov	r6, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 80111e6:	4620      	mov	r0, r4
 *          uint16 value
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_MEMWR16(uint16 addr, uint16 value)
{
 80111e8:	460d      	mov	r5, r1
	uint8 s;
	CC2520_SPI_BEGIN();
 80111ea:	f7fd f8b1 	bl	800e350 <spiSelect>
	s = CC2520_SPI_TXRX(CC2520_INS_MEMWR | HI_UINT16(addr));
 80111ee:	0a30      	lsrs	r0, r6, #8
 80111f0:	f040 0020 	orr.w	r0, r0, #32
 80111f4:	f7ff ff84 	bl	8011100 <halSpiExc>
 80111f8:	4607      	mov	r7, r0
	CC2520_SPI_TXRX(LO_UINT16(addr));
 80111fa:	b2f0      	uxtb	r0, r6
 80111fc:	f7ff ff80 	bl	8011100 <halSpiExc>
	CC2520_SPI_TXRX(LO_UINT16(value));
 8011200:	b2e8      	uxtb	r0, r5
 8011202:	f7ff ff7d 	bl	8011100 <halSpiExc>
	CC2520_SPI_TXRX(HI_UINT16(value));
 8011206:	0a28      	lsrs	r0, r5, #8
 8011208:	f7ff ff7a 	bl	8011100 <halSpiExc>
	CC2520_SPI_END();
 801120c:	4620      	mov	r0, r4
 801120e:	f7fd f8a7 	bl	800e360 <spiUnselect>
	return s;
}
 8011212:	4638      	mov	r0, r7
 8011214:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8011216:	bf00      	nop
 8011218:	20001738 	.word	0x20001738
 801121c:	00000000 	.word	0x00000000

08011220 <CC2520_RXBUF>:
 *          uint8  *pData
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_RXBUF(uint8 count, uint8  *pData)
{
 8011220:	b570      	push	{r4, r5, r6, lr}
 8011222:	4604      	mov	r4, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 8011224:	4809      	ldr	r0, [pc, #36]	; (801124c <CC2520_RXBUF+0x2c>)
 *          uint8  *pData
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_RXBUF(uint8 count, uint8  *pData)
{
 8011226:	460e      	mov	r6, r1
	uint8 s;
	CC2520_SPI_BEGIN();
 8011228:	f7fd f892 	bl	800e350 <spiSelect>
	s = CC2520_SPI_TXRX(CC2520_INS_RXBUF);
 801122c:	2030      	movs	r0, #48	; 0x30
 801122e:	f7ff ff67 	bl	8011100 <halSpiExc>
 8011232:	4605      	mov	r5, r0
	CC2520_INS_RD_ARRAY(count, pData);
 8011234:	b124      	cbz	r4, 8011240 <CC2520_RXBUF+0x20>
 8011236:	4621      	mov	r1, r4
 8011238:	4632      	mov	r2, r6
 801123a:	4804      	ldr	r0, [pc, #16]	; (801124c <CC2520_RXBUF+0x2c>)
 801123c:	f7fd f8b8 	bl	800e3b0 <spiReceive>
	CC2520_SPI_END();
 8011240:	4802      	ldr	r0, [pc, #8]	; (801124c <CC2520_RXBUF+0x2c>)
 8011242:	f7fd f88d 	bl	800e360 <spiUnselect>
	return s;
}
 8011246:	4628      	mov	r0, r5
 8011248:	bd70      	pop	{r4, r5, r6, pc}
 801124a:	bf00      	nop
 801124c:	20001738 	.word	0x20001738

08011250 <CC2520_RXBUF8>:
 * @param   none
 *
 * @return  uint8 - result
 */
uint8 CC2520_RXBUF8(void)
{
 8011250:	b538      	push	{r3, r4, r5, lr}
	uint8 value;
	CC2520_SPI_BEGIN();
 8011252:	4c08      	ldr	r4, [pc, #32]	; (8011274 <CC2520_RXBUF8+0x24>)
 8011254:	4620      	mov	r0, r4
 8011256:	f7fd f87b 	bl	800e350 <spiSelect>
	CC2520_SPI_TXRX(CC2520_INS_RXBUF);
 801125a:	2030      	movs	r0, #48	; 0x30
 801125c:	f7ff ff50 	bl	8011100 <halSpiExc>
	value = CC2520_SPI_TXRX(0x00);
 8011260:	2000      	movs	r0, #0
 8011262:	f7ff ff4d 	bl	8011100 <halSpiExc>
 8011266:	4605      	mov	r5, r0
	CC2520_SPI_END();
 8011268:	4620      	mov	r0, r4
 801126a:	f7fd f879 	bl	800e360 <spiUnselect>
	return value;
}
 801126e:	4628      	mov	r0, r5
 8011270:	bd38      	pop	{r3, r4, r5, pc}
 8011272:	bf00      	nop
 8011274:	20001738 	.word	0x20001738
	...

08011280 <CC2520_TXBUF>:
 *          uint8  *pData - pointer to data buffer
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_TXBUF(uint8 count, uint8  *pData)
{
 8011280:	b570      	push	{r4, r5, r6, lr}
 8011282:	4604      	mov	r4, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 8011284:	4809      	ldr	r0, [pc, #36]	; (80112ac <CC2520_TXBUF+0x2c>)
 *          uint8  *pData - pointer to data buffer
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_TXBUF(uint8 count, uint8  *pData)
{
 8011286:	460e      	mov	r6, r1
	uint8 s;
	CC2520_SPI_BEGIN();
 8011288:	f7fd f862 	bl	800e350 <spiSelect>
	s = CC2520_SPI_TXRX(CC2520_INS_TXBUF);
 801128c:	203a      	movs	r0, #58	; 0x3a
 801128e:	f7ff ff37 	bl	8011100 <halSpiExc>
 8011292:	4605      	mov	r5, r0
	CC2520_INS_WR_ARRAY(count, pData);
 8011294:	b124      	cbz	r4, 80112a0 <CC2520_TXBUF+0x20>
 8011296:	4621      	mov	r1, r4
 8011298:	4632      	mov	r2, r6
 801129a:	4804      	ldr	r0, [pc, #16]	; (80112ac <CC2520_TXBUF+0x2c>)
 801129c:	f7fd f878 	bl	800e390 <spiSend>
	CC2520_SPI_END();
 80112a0:	4802      	ldr	r0, [pc, #8]	; (80112ac <CC2520_TXBUF+0x2c>)
 80112a2:	f7fd f85d 	bl	800e360 <spiUnselect>
	return s;
}
 80112a6:	4628      	mov	r0, r5
 80112a8:	bd70      	pop	{r4, r5, r6, pc}
 80112aa:	bf00      	nop
 80112ac:	20001738 	.word	0x20001738

080112b0 <CC2520_BCLR>:
 * @param  uint8 bitAddr - address
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_BCLR(uint8 bitAddr)
{
 80112b0:	b570      	push	{r4, r5, r6, lr}
	uint8 s;
	CC2520_SPI_BEGIN();
 80112b2:	4c08      	ldr	r4, [pc, #32]	; (80112d4 <CC2520_BCLR+0x24>)
 * @param  uint8 bitAddr - address
 *
 * @return  uint8 - status byte
 */
uint8 CC2520_BCLR(uint8 bitAddr)
{
 80112b4:	4606      	mov	r6, r0
	uint8 s;
	CC2520_SPI_BEGIN();
 80112b6:	4620      	mov	r0, r4
 80112b8:	f7fd f84a 	bl	800e350 <spiSelect>
	s = CC2520_SPI_TXRX(CC2520_INS_BCLR);
 80112bc:	2058      	movs	r0, #88	; 0x58
 80112be:	f7ff ff1f 	bl	8011100 <halSpiExc>
 80112c2:	4605      	mov	r5, r0
	CC2520_SPI_TXRX(bitAddr);
 80112c4:	4630      	mov	r0, r6
 80112c6:	f7ff ff1b 	bl	8011100 <halSpiExc>
	CC2520_SPI_END();
 80112ca:	4620      	mov	r0, r4
 80112cc:	f7fd f848 	bl	800e360 <spiUnselect>
	return s;
}
 80112d0:	4628      	mov	r0, r5
 80112d2:	bd70      	pop	{r4, r5, r6, pc}
 80112d4:	20001738 	.word	0x20001738
	...

080112e0 <CC2520_REGRD8>:
 * @param  uint8 addr - address
 *
 * @return  uint8 - result
 */
uint8 CC2520_REGRD8(uint8 addr)
{
 80112e0:	b538      	push	{r3, r4, r5, lr}
	uint8 value;
	CC2520_SPI_BEGIN();
 80112e2:	4c09      	ldr	r4, [pc, #36]	; (8011308 <CC2520_REGRD8+0x28>)
 * @param  uint8 addr - address
 *
 * @return  uint8 - result
 */
uint8 CC2520_REGRD8(uint8 addr)
{
 80112e4:	4605      	mov	r5, r0
	uint8 value;
	CC2520_SPI_BEGIN();
 80112e6:	4620      	mov	r0, r4
 80112e8:	f7fd f832 	bl	800e350 <spiSelect>
	CC2520_SPI_TXRX(CC2520_INS_REGRD | addr);
 80112ec:	f045 0080 	orr.w	r0, r5, #128	; 0x80
 80112f0:	f7ff ff06 	bl	8011100 <halSpiExc>
	value = CC2520_SPI_TXRX(0x00);
 80112f4:	2000      	movs	r0, #0
 80112f6:	f7ff ff03 	bl	8011100 <halSpiExc>
 80112fa:	4605      	mov	r5, r0
	CC2520_SPI_END();
 80112fc:	4620      	mov	r0, r4
 80112fe:	f7fd f82f 	bl	800e360 <spiUnselect>
	return value;
}
 8011302:	4628      	mov	r0, r5
 8011304:	bd38      	pop	{r3, r4, r5, pc}
 8011306:	bf00      	nop
 8011308:	20001738 	.word	0x20001738
 801130c:	00000000 	.word	0x00000000

08011310 <CC2520_REGWR8>:
 *         uint8 value
 *
 * @return  none
 */
void CC2520_REGWR8(uint8 addr, uint8 value)
{
 8011310:	b570      	push	{r4, r5, r6, lr}
	CC2520_SPI_BEGIN();
 8011312:	4c09      	ldr	r4, [pc, #36]	; (8011338 <CC2520_REGWR8+0x28>)
 *         uint8 value
 *
 * @return  none
 */
void CC2520_REGWR8(uint8 addr, uint8 value)
{
 8011314:	4606      	mov	r6, r0
	CC2520_SPI_BEGIN();
 8011316:	4620      	mov	r0, r4
 *         uint8 value
 *
 * @return  none
 */
void CC2520_REGWR8(uint8 addr, uint8 value)
{
 8011318:	460d      	mov	r5, r1
	CC2520_SPI_BEGIN();
 801131a:	f7fd f819 	bl	800e350 <spiSelect>
	CC2520_SPI_TXRX(CC2520_INS_REGWR | addr);
 801131e:	f046 00c0 	orr.w	r0, r6, #192	; 0xc0
 8011322:	f7ff feed 	bl	8011100 <halSpiExc>
	CC2520_SPI_TXRX(value);
 8011326:	4628      	mov	r0, r5
 8011328:	f7ff feea 	bl	8011100 <halSpiExc>
	CC2520_SPI_END();
 801132c:	4620      	mov	r0, r4
	return;
}
 801132e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void CC2520_REGWR8(uint8 addr, uint8 value)
{
	CC2520_SPI_BEGIN();
	CC2520_SPI_TXRX(CC2520_INS_REGWR | addr);
	CC2520_SPI_TXRX(value);
	CC2520_SPI_END();
 8011332:	f7fd b815 	b.w	800e360 <spiUnselect>
 8011336:	bf00      	nop
 8011338:	20001738 	.word	0x20001738
 801133c:	00000000 	.word	0x00000000

08011340 <isrThread>:
	chSysLockFromISR();
	chEvtSignalI(isr_tp, (eventmask_t) 1);
	chSysUnlockFromISR();
}

static THD_FUNCTION(isrThread, arg) {
 8011340:	b508      	push	{r3, lr}
 8011342:	4b07      	ldr	r3, [pc, #28]	; (8011360 <isrThread+0x20>)
	(void) arg;
	chRegSetThreadName("CC2520 EXTI");

	isr_tp = chThdGetSelfX();
 8011344:	4a07      	ldr	r2, [pc, #28]	; (8011364 <isrThread+0x24>)
 8011346:	699b      	ldr	r3, [r3, #24]
 8011348:	4907      	ldr	r1, [pc, #28]	; (8011368 <isrThread+0x28>)
 801134a:	4c08      	ldr	r4, [pc, #32]	; (801136c <isrThread+0x2c>)
 801134c:	6199      	str	r1, [r3, #24]
 801134e:	6013      	str	r3, [r2, #0]

	for (;;) {
		chEvtWaitAny((eventmask_t) 1);
 8011350:	2001      	movs	r0, #1
 8011352:	f7fc fb95 	bl	800da80 <chEvtWaitAny>

		if (gpio0_func) {
 8011356:	6823      	ldr	r3, [r4, #0]
 8011358:	2b00      	cmp	r3, #0
 801135a:	d0f9      	beq.n	8011350 <isrThread+0x10>
			gpio0_func();
 801135c:	4798      	blx	r3
 801135e:	e7f7      	b.n	8011350 <isrThread+0x10>
 8011360:	200010b8 	.word	0x200010b8
 8011364:	20001d20 	.word	0x20001d20
 8011368:	080168e0 	.word	0x080168e0
 801136c:	20001d24 	.word	0x20001d24

08011370 <halRfGetRssiOffset>:
 * @param   none
 *
 * @return  uint8 - RSSI offset
 */
uint8 halRfGetRssiOffset(void) {
	return rssiOffset;
 8011370:	4b01      	ldr	r3, [pc, #4]	; (8011378 <halRfGetRssiOffset+0x8>)
}
 8011372:	7818      	ldrb	r0, [r3, #0]
 8011374:	4770      	bx	lr
 8011376:	bf00      	nop
 8011378:	20000836 	.word	0x20000836
 801137c:	00000000 	.word	0x00000000

08011380 <halRfSetChannel>:
 * @param   channel - logical channel number
 *
 * @return  none
 */
void halRfSetChannel(uint8 channel) {
	CC2520_REGWR8(CC2520_FREQCTRL,
 8011380:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8011384:	f1a0 012c 	sub.w	r1, r0, #44	; 0x2c
 8011388:	b2c9      	uxtb	r1, r1
 801138a:	202e      	movs	r0, #46	; 0x2e
 801138c:	f7ff bfc0 	b.w	8011310 <CC2520_REGWR8>

08011390 <halRfSetShortAddr>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfSetShortAddr(uint16 shortAddr) {
 8011390:	4601      	mov	r1, r0
	CC2520_MEMWR16(CC2520_RAM_SHORTADDR, shortAddr);
 8011392:	f44f 707d 	mov.w	r0, #1012	; 0x3f4
 8011396:	f7ff bf23 	b.w	80111e0 <CC2520_MEMWR16>
 801139a:	bf00      	nop
 801139c:	0000      	movs	r0, r0
	...

080113a0 <halRfSetPanId>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfSetPanId(uint16 panId) {
 80113a0:	4601      	mov	r1, r0
	CC2520_MEMWR16(CC2520_RAM_PANID, panId);
 80113a2:	f240 30f2 	movw	r0, #1010	; 0x3f2
 80113a6:	f7ff bf1b 	b.w	80111e0 <CC2520_MEMWR16>
 80113aa:	bf00      	nop
 80113ac:	0000      	movs	r0, r0
	...

080113b0 <halRfWriteTxBuf>:
 * @param   uint8* data - buffer to write
 *          uint8 length - number of bytes
 *
 * @return  none
 */
void halRfWriteTxBuf(uint8* data, uint8 length) {
 80113b0:	4603      	mov	r3, r0
	// Copy packet to TX FIFO
	CC2520_TXBUF(length, data);
 80113b2:	4608      	mov	r0, r1
 80113b4:	4619      	mov	r1, r3
 80113b6:	f7ff bf63 	b.w	8011280 <CC2520_TXBUF>
 80113ba:	bf00      	nop
 80113bc:	0000      	movs	r0, r0
	...

080113c0 <halRfReadRxBuf>:
 * @param   uint8* pData - data buffer. This must be allocated by caller.
 *          uint8 length - number of bytes
 *
 * @return  none
 */
void halRfReadRxBuf(uint8* pData, uint8 length) {
 80113c0:	4603      	mov	r3, r0
	CC2520_RXBUF(length, pData);
 80113c2:	4608      	mov	r0, r1
 80113c4:	4619      	mov	r1, r3
 80113c6:	f7ff bf2b 	b.w	8011220 <CC2520_RXBUF>
 80113ca:	bf00      	nop
 80113cc:	0000      	movs	r0, r0
	...

080113d0 <halRfTransmit>:
 *
 * @param   none
 *
 * @return  uint8 - SUCCESS or FAILED
 */
uint8 halRfTransmit(void) {
 80113d0:	b538      	push	{r3, r4, r5, lr}
	uint8 status = 0;

	PA_RX();

	// Wait for RSSI to become valid
	while(!CC2520_RSSI_VALID_PIN){}
 80113d2:	4a1b      	ldr	r2, [pc, #108]	; (8011440 <halRfTransmit+0x70>)
 80113d4:	6913      	ldr	r3, [r2, #16]
 80113d6:	0519      	lsls	r1, r3, #20
 80113d8:	d5fc      	bpl.n	80113d4 <halRfTransmit+0x4>

	// Reuse GPIO2 for TX_FRM_DONE exception
	CC2520_CFG_GPIO_OUT(2, 1 + CC2520_EXC_TX_FRM_DONE);
 80113da:	2022      	movs	r0, #34	; 0x22
 80113dc:	2102      	movs	r1, #2
 80113de:	f7ff ff97 	bl	8011310 <CC2520_REGWR8>
 80113e2:	4817      	ldr	r0, [pc, #92]	; (8011440 <halRfTransmit+0x70>)
 80113e4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80113e8:	2200      	movs	r2, #0

	// Wait for the transmission to begin before exiting (makes sure that this function cannot be called
	// a second time, and thereby canceling the first transmission.
	while (--timeout > 0) {
		CC2520_INS_STROBE(CC2520_INS_STXONCCA);
		if (CC2520_SAMPLED_CCA_PIN) {
 80113ea:	4605      	mov	r5, r0

	// Wait for RSSI to become valid
	while(!CC2520_RSSI_VALID_PIN){}

	// Reuse GPIO2 for TX_FRM_DONE exception
	CC2520_CFG_GPIO_OUT(2, 1 + CC2520_EXC_TX_FRM_DONE);
 80113ec:	f240 14f3 	movw	r4, #499	; 0x1f3
 80113f0:	f7fe fbce 	bl	800fb90 <_pal_lld_setgroupmode>
 80113f4:	e004      	b.n	8011400 <halRfTransmit+0x30>

	// Wait for the transmission to begin before exiting (makes sure that this function cannot be called
	// a second time, and thereby canceling the first transmission.
	while (--timeout > 0) {
 80113f6:	3c01      	subs	r4, #1
 80113f8:	b2a4      	uxth	r4, r4
		if (CC2520_SAMPLED_CCA_PIN) {
			PA_TX();
			break;
		}

		chThdSleepMicroseconds(100);
 80113fa:	f7fc f981 	bl	800d700 <chThdSleep>
	// Reuse GPIO2 for TX_FRM_DONE exception
	CC2520_CFG_GPIO_OUT(2, 1 + CC2520_EXC_TX_FRM_DONE);

	// Wait for the transmission to begin before exiting (makes sure that this function cannot be called
	// a second time, and thereby canceling the first transmission.
	while (--timeout > 0) {
 80113fe:	b1cc      	cbz	r4, 8011434 <halRfTransmit+0x64>
		CC2520_INS_STROBE(CC2520_INS_STXONCCA);
 8011400:	2044      	movs	r0, #68	; 0x44
 8011402:	f7ff fe95 	bl	8011130 <CC2520_INS_STROBE>
		if (CC2520_SAMPLED_CCA_PIN) {
 8011406:	692b      	ldr	r3, [r5, #16]
 8011408:	055a      	lsls	r2, r3, #21
			PA_TX();
			break;
		}

		chThdSleepMicroseconds(100);
 801140a:	f04f 0001 	mov.w	r0, #1

	// Wait for the transmission to begin before exiting (makes sure that this function cannot be called
	// a second time, and thereby canceling the first transmission.
	while (--timeout > 0) {
		CC2520_INS_STROBE(CC2520_INS_STXONCCA);
		if (CC2520_SAMPLED_CCA_PIN) {
 801140e:	d5f2      	bpl.n	80113f6 <halRfTransmit+0x26>
		}

		chThdSleepMicroseconds(100);
	}

	if (timeout == 0) {
 8011410:	b184      	cbz	r4, 8011434 <halRfTransmit+0x64>
		status = FAILED;
		CC2520_INS_STROBE(CC2520_INS_SFLUSHTX);
	} else {
		status = SUCCESS;
		// Wait for TX_FRM_DONE exception
		while(!CC2520_TX_FRM_DONE_PIN){};
 8011412:	4a0b      	ldr	r2, [pc, #44]	; (8011440 <halRfTransmit+0x70>)
 8011414:	6913      	ldr	r3, [r2, #16]
 8011416:	051b      	lsls	r3, r3, #20
 8011418:	d5fc      	bpl.n	8011414 <halRfTransmit+0x44>

	if (timeout == 0) {
		status = FAILED;
		CC2520_INS_STROBE(CC2520_INS_SFLUSHTX);
	} else {
		status = SUCCESS;
 801141a:	2400      	movs	r4, #0
	}

	PA_RX();

	// Reconfigure GPIO2
	CC2520_CFG_GPIO_OUT(2, CC2520_GPIO_RSSI_VALID);
 801141c:	2022      	movs	r0, #34	; 0x22
 801141e:	212c      	movs	r1, #44	; 0x2c
 8011420:	f7ff ff76 	bl	8011310 <CC2520_REGWR8>
 8011424:	4806      	ldr	r0, [pc, #24]	; (8011440 <halRfTransmit+0x70>)
 8011426:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801142a:	2200      	movs	r2, #0
 801142c:	f7fe fbb0 	bl	800fb90 <_pal_lld_setgroupmode>

	return status;
}
 8011430:	4620      	mov	r0, r4
 8011432:	bd38      	pop	{r3, r4, r5, pc}
		chThdSleepMicroseconds(100);
	}

	if (timeout == 0) {
		status = FAILED;
		CC2520_INS_STROBE(CC2520_INS_SFLUSHTX);
 8011434:	2048      	movs	r0, #72	; 0x48
 8011436:	f7ff fe7b 	bl	8011130 <CC2520_INS_STROBE>

		chThdSleepMicroseconds(100);
	}

	if (timeout == 0) {
		status = FAILED;
 801143a:	2401      	movs	r4, #1
 801143c:	e7ee      	b.n	801141c <halRfTransmit+0x4c>
 801143e:	bf00      	nop
 8011440:	40020c00 	.word	0x40020c00
	...

08011450 <halRfRxInterruptConfig>:
	HAL_INT_OFF();
}

void halRfRxInterruptConfig(void (*func)(void)) {
	// Set function pointer
	gpio0_func = func;
 8011450:	4b02      	ldr	r3, [pc, #8]	; (801145c <halRfRxInterruptConfig+0xc>)
 8011452:	6018      	str	r0, [r3, #0]

	CLEAR_EXC_RX_FRM_DONE();
 8011454:	2088      	movs	r0, #136	; 0x88
 8011456:	f7ff bf2b 	b.w	80112b0 <CC2520_BCLR>
 801145a:	bf00      	nop
 801145c:	20001d24 	.word	0x20001d24

08011460 <halRfDisableRxInterrupt>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfDisableRxInterrupt(void) {
 8011460:	b508      	push	{r3, lr}
	CLEAR_EXC_RX_FRM_DONE();
 8011462:	2088      	movs	r0, #136	; 0x88
 8011464:	f7ff ff24 	bl	80112b0 <CC2520_BCLR>
	extChannelDisable(&EXTD1, 9);
 8011468:	4802      	ldr	r0, [pc, #8]	; (8011474 <halRfDisableRxInterrupt+0x14>)
 801146a:	2109      	movs	r1, #9
}
 801146c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 *
 * @return  none
 */
void halRfDisableRxInterrupt(void) {
	CLEAR_EXC_RX_FRM_DONE();
	extChannelDisable(&EXTD1, 9);
 8011470:	f7fc bd46 	b.w	800df00 <extChannelDisable>
 8011474:	200013f0 	.word	0x200013f0
	...

08011480 <halRfInit>:
 *
 * @param   none
 *
 * @return  SUCCESS if the radio has started, FAILURE otherwise
 */
uint8 halRfInit(void) {
 8011480:	b570      	push	{r4, r5, r6, lr}
	regVal_t* p;
	uint8 val;

#ifdef INCLUDE_PA
	PA_HGM_OUT();
 8011482:	4e2b      	ldr	r6, [pc, #172]	; (8011530 <halRfInit+0xb0>)

	// Avoid GPIO0 interrupts during reset
	halRfDisableRxInterrupt();

	// Make sure to pull the CC2520 RESETn pin low
	CC2520_RESET_OPIN(0);
 8011484:	4d2b      	ldr	r5, [pc, #172]	; (8011534 <halRfInit+0xb4>)
	CC2520_SPI_END();
	chThdSleepMilliseconds(2);

	// Make sure MISO is configured as output.
	CC2520_MISO_DIR_OUT();
 8011486:	4c2c      	ldr	r4, [pc, #176]	; (8011538 <halRfInit+0xb8>)
 *
 * @param   none
 *
 * @return  SUCCESS if the radio has started, FAILURE otherwise
 */
uint8 halRfInit(void) {
 8011488:	b082      	sub	sp, #8
	regVal_t* p;
	uint8 val;

#ifdef INCLUDE_PA
	PA_HGM_OUT();
 801148a:	2140      	movs	r1, #64	; 0x40
 801148c:	2219      	movs	r2, #25
 801148e:	4630      	mov	r0, r6
 8011490:	f7fe fb7e 	bl	800fb90 <_pal_lld_setgroupmode>
	PA_OFF();
#endif
#endif

	// High gain mode by default
	HAL_PA_LNA_RX_HGM();
 8011494:	2340      	movs	r3, #64	; 0x40
 8011496:	61b3      	str	r3, [r6, #24]

	// Avoid GPIO0 interrupts during reset
	halRfDisableRxInterrupt();
 8011498:	f7ff ffe2 	bl	8011460 <halRfDisableRxInterrupt>

	// Make sure to pull the CC2520 RESETn pin low
	CC2520_RESET_OPIN(0);
 801149c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 80114a0:	61ab      	str	r3, [r5, #24]
	CC2520_SPI_END();
 80114a2:	4826      	ldr	r0, [pc, #152]	; (801153c <halRfInit+0xbc>)
 80114a4:	f7fc ff5c 	bl	800e360 <spiUnselect>
	chThdSleepMilliseconds(2);
 80114a8:	2014      	movs	r0, #20
 80114aa:	f7fc f929 	bl	800d700 <chThdSleep>

	// Make sure MISO is configured as output.
	CC2520_MISO_DIR_OUT();
 80114ae:	4620      	mov	r0, r4
 80114b0:	f240 2282 	movw	r2, #642	; 0x282
 80114b4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80114b8:	f7fe fb6a 	bl	800fb90 <_pal_lld_setgroupmode>

	// Release reset
	CC2520_RESET_OPIN(1);
 80114bc:	f44f 4200 	mov.w	r2, #32768	; 0x8000
static uint8 halRfWaitRadioReady(void) {
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
 80114c0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000

	// Make sure MISO is configured as output.
	CC2520_MISO_DIR_OUT();

	// Release reset
	CC2520_RESET_OPIN(1);
 80114c4:	61aa      	str	r2, [r5, #24]
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
 80114c6:	4626      	mov	r6, r4
static uint8 halRfWaitRadioReady(void) {
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
 80114c8:	61a3      	str	r3, [r4, #24]
 80114ca:	2432      	movs	r4, #50	; 0x32
 80114cc:	e005      	b.n	80114da <halRfInit+0x5a>
	while (i > 0 && !CC2520_MISO_IPIN) {
		chThdSleepMicroseconds(100);
 80114ce:	f7fc f917 	bl	800d700 <chThdSleep>
 80114d2:	1e63      	subs	r3, r4, #1
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
 80114d4:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 80114d8:	d023      	beq.n	8011522 <halRfInit+0xa2>
 80114da:	6933      	ldr	r3, [r6, #16]
 80114dc:	4d16      	ldr	r5, [pc, #88]	; (8011538 <halRfInit+0xb8>)
 80114de:	045b      	lsls	r3, r3, #17
		chThdSleepMicroseconds(100);
 80114e0:	f04f 0001 	mov.w	r0, #1
	uint8 i;

	// Wait for XOSC stable to be announced on the MISO pin
	i= 50;
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
 80114e4:	d5f3      	bpl.n	80114ce <halRfInit+0x4e>
		chThdSleepMicroseconds(100);
		--i;
	}
	CC2520_CSN_OPIN(1);
 80114e6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
		return FAILED;
	}

	// Write non-default register values
	p = regval;
	while (p->reg != 0) {
 80114ea:	4c15      	ldr	r4, [pc, #84]	; (8011540 <halRfInit+0xc0>)
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
		chThdSleepMicroseconds(100);
		--i;
	}
	CC2520_CSN_OPIN(1);
 80114ec:	61ab      	str	r3, [r5, #24]
		return FAILED;
	}

	// Write non-default register values
	p = regval;
	while (p->reg != 0) {
 80114ee:	7820      	ldrb	r0, [r4, #0]
 80114f0:	b130      	cbz	r0, 8011500 <halRfInit+0x80>
		CC2520_MEMWR8(p->reg, p->val);
 80114f2:	7861      	ldrb	r1, [r4, #1]
 80114f4:	f7ff fe54 	bl	80111a0 <CC2520_MEMWR8>
		return FAILED;
	}

	// Write non-default register values
	p = regval;
	while (p->reg != 0) {
 80114f8:	f814 0f02 	ldrb.w	r0, [r4, #2]!
 80114fc:	2800      	cmp	r0, #0
 80114fe:	d1f8      	bne.n	80114f2 <halRfInit+0x72>
		CC2520_MEMWR8(p->reg, p->val);
		p++;
	}

	// ISR Thread
	chThdCreateStatic(waIsrTx, sizeof(waIsrTx), NORMALPRIO + 2, isrThread, NULL);
 8011500:	2300      	movs	r3, #0
 8011502:	9300      	str	r3, [sp, #0]
 8011504:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 8011508:	4b0e      	ldr	r3, [pc, #56]	; (8011544 <halRfInit+0xc4>)
 801150a:	480f      	ldr	r0, [pc, #60]	; (8011548 <halRfInit+0xc8>)
 801150c:	2242      	movs	r2, #66	; 0x42
 801150e:	f7fc f8b7 	bl	800d680 <chThdCreateStatic>

	// Verify a register
	val = CC2520_MEMRD8(CC2520_MDMCTRL0);
 8011512:	2046      	movs	r0, #70	; 0x46
 8011514:	f7ff fe24 	bl	8011160 <CC2520_MEMRD8>
	return val == 0x85 ? SUCCESS : FAILED;
 8011518:	3885      	subs	r0, #133	; 0x85
 801151a:	bf18      	it	ne
 801151c:	2001      	movne	r0, #1
}
 801151e:	b002      	add	sp, #8
 8011520:	bd70      	pop	{r4, r5, r6, pc}
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
		chThdSleepMicroseconds(100);
		--i;
	}
	CC2520_CSN_OPIN(1);
 8011522:	f44f 5380 	mov.w	r3, #4096	; 0x1000
	// Release reset
	CC2520_RESET_OPIN(1);

	// Wait for XOSC stable to be announced on the MISO pin
	if (halRfWaitRadioReady() == FAILED) {
		return FAILED;
 8011526:	2001      	movs	r0, #1
	CC2520_CSN_OPIN(0);
	while (i > 0 && !CC2520_MISO_IPIN) {
		chThdSleepMicroseconds(100);
		--i;
	}
	CC2520_CSN_OPIN(1);
 8011528:	61ab      	str	r3, [r5, #24]
	chThdCreateStatic(waIsrTx, sizeof(waIsrTx), NORMALPRIO + 2, isrThread, NULL);

	// Verify a register
	val = CC2520_MEMRD8(CC2520_MDMCTRL0);
	return val == 0x85 ? SUCCESS : FAILED;
}
 801152a:	b002      	add	sp, #8
 801152c:	bd70      	pop	{r4, r5, r6, pc}
 801152e:	bf00      	nop
 8011530:	40020800 	.word	0x40020800
 8011534:	40020c00 	.word	0x40020c00
 8011538:	40020400 	.word	0x40020400
 801153c:	20001738 	.word	0x20001738
 8011540:	20000808 	.word	0x20000808
 8011544:	08011341 	.word	0x08011341
 8011548:	20001788 	.word	0x20001788
 801154c:	00000000 	.word	0x00000000

08011550 <halRfReceiveOn>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfReceiveOn(void) {
 8011550:	b510      	push	{r4, lr}
	PA_RX();

	/* Flush RX FIFO if needed.
	 * See bug #1 in http://www.ti.com/lit/er/swrz024/swrz024.pdf */
	halRfDisableRxInterrupt();
 8011552:	f7ff ff85 	bl	8011460 <halRfDisableRxInterrupt>
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 8011556:	2047      	movs	r0, #71	; 0x47
 8011558:	f7ff fdea 	bl	8011130 <CC2520_INS_STROBE>
	uint8_t rx_fifo_cnt = CC2520_REGRD8(CC2520_RXFIFOCNT);
 801155c:	203e      	movs	r0, #62	; 0x3e
 801155e:	f7ff febf 	bl	80112e0 <CC2520_REGRD8>
 8011562:	4604      	mov	r4, r0

	CC2520_INS_STROBE(CC2520_INS_SRXON);
 8011564:	2042      	movs	r0, #66	; 0x42
 8011566:	f7ff fde3 	bl	8011130 <CC2520_INS_STROBE>

	if (rx_fifo_cnt != CC2520_REGRD8(CC2520_RXFIFOCNT)) {
 801156a:	203e      	movs	r0, #62	; 0x3e
 801156c:	f7ff feb8 	bl	80112e0 <CC2520_REGRD8>
 8011570:	42a0      	cmp	r0, r4
 8011572:	d002      	beq.n	801157a <halRfReceiveOn+0x2a>
		CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 8011574:	2047      	movs	r0, #71	; 0x47
 8011576:	f7ff fddb 	bl	8011130 <CC2520_INS_STROBE>
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 9);
 801157a:	4803      	ldr	r0, [pc, #12]	; (8011588 <halRfReceiveOn+0x38>)
 801157c:	2109      	movs	r1, #9

	if (rx_fifo_cnt != CC2520_REGRD8(CC2520_RXFIFOCNT)) {
		CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
	}
	halRfEnableRxInterrupt();
}
 801157e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 9);
 8011582:	f7fc bcb5 	b.w	800def0 <extChannelEnable>
 8011586:	bf00      	nop
 8011588:	200013f0 	.word	0x200013f0
 801158c:	00000000 	.word	0x00000000

08011590 <halRfReceiveOff>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfReceiveOff(void) {
 8011590:	b510      	push	{r4, lr}
	PA_OFF();

	/* Flush RX FIFO if needed.
	 * See bug #1 in http://www.ti.com/lit/er/swrz024/swrz024.pdf */
	halRfDisableRxInterrupt();
 8011592:	f7ff ff65 	bl	8011460 <halRfDisableRxInterrupt>
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 8011596:	2047      	movs	r0, #71	; 0x47
 8011598:	f7ff fdca 	bl	8011130 <CC2520_INS_STROBE>
	uint8_t rx_fifo_cnt = CC2520_REGRD8(CC2520_RXFIFOCNT);
 801159c:	203e      	movs	r0, #62	; 0x3e
 801159e:	f7ff fe9f 	bl	80112e0 <CC2520_REGRD8>
 80115a2:	4604      	mov	r4, r0

	CC2520_INS_STROBE(CC2520_INS_SRFOFF);
 80115a4:	2045      	movs	r0, #69	; 0x45
 80115a6:	f7ff fdc3 	bl	8011130 <CC2520_INS_STROBE>

	if (rx_fifo_cnt != CC2520_REGRD8(CC2520_RXFIFOCNT)) {
 80115aa:	203e      	movs	r0, #62	; 0x3e
 80115ac:	f7ff fe98 	bl	80112e0 <CC2520_REGRD8>
 80115b0:	42a0      	cmp	r0, r4
 80115b2:	d002      	beq.n	80115ba <halRfReceiveOff+0x2a>
		CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 80115b4:	2047      	movs	r0, #71	; 0x47
 80115b6:	f7ff fdbb 	bl	8011130 <CC2520_INS_STROBE>
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 9);
 80115ba:	4803      	ldr	r0, [pc, #12]	; (80115c8 <halRfReceiveOff+0x38>)
 80115bc:	2109      	movs	r1, #9
		CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
		// Software clean-up
		// Reset software for frame reception...
	}
	halRfEnableRxInterrupt();
}
 80115be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 9);
 80115c2:	f7fc bc95 	b.w	800def0 <extChannelEnable>
 80115c6:	bf00      	nop
 80115c8:	200013f0 	.word	0x200013f0
 80115cc:	00000000 	.word	0x00000000

080115d0 <halRfFlushRx>:
		// Reset software for frame reception...
	}
	halRfEnableRxInterrupt();
}

void halRfFlushRx(void) {
 80115d0:	b508      	push	{r3, lr}
	/* Flush RX FIFO twice instead of once. See bug #1 in
	 * http://www.ti.com/lit/er/swrz024/swrz024.pdf */
	halRfDisableRxInterrupt();
 80115d2:	f7ff ff45 	bl	8011460 <halRfDisableRxInterrupt>
	CC2520_RXBUF8();
 80115d6:	f7ff fe3b 	bl	8011250 <CC2520_RXBUF8>
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 80115da:	2047      	movs	r0, #71	; 0x47
 80115dc:	f7ff fda8 	bl	8011130 <CC2520_INS_STROBE>
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
 80115e0:	2047      	movs	r0, #71	; 0x47
 80115e2:	f7ff fda5 	bl	8011130 <CC2520_INS_STROBE>
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 9);
 80115e6:	4803      	ldr	r0, [pc, #12]	; (80115f4 <halRfFlushRx+0x24>)
 80115e8:	2109      	movs	r1, #9
	halRfDisableRxInterrupt();
	CC2520_RXBUF8();
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
	CC2520_INS_STROBE(CC2520_INS_SFLUSHRX);
	halRfEnableRxInterrupt();
}
 80115ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 * @param   none
 *
 * @return  none
 */
void halRfEnableRxInterrupt(void) {
	extChannelEnable(&EXTD1, 9);
 80115ee:	f7fc bc7f 	b.w	800def0 <extChannelEnable>
 80115f2:	bf00      	nop
 80115f4:	200013f0 	.word	0x200013f0
	...

08011600 <halRfExtCb>:

/**
 * External interrupt handler for lines 9 to 5
 */

void halRfExtCb(EXTDriver *extp, expchannel_t channel) {
 8011600:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8011602:	b672      	cpsid	i
	(void)extp;
	(void)channel;

	chSysLockFromISR();
	chEvtSignalI(isr_tp, (eventmask_t) 1);
 8011604:	4b03      	ldr	r3, [pc, #12]	; (8011614 <halRfExtCb+0x14>)
 8011606:	2101      	movs	r1, #1
 8011608:	6818      	ldr	r0, [r3, #0]
 801160a:	f7fc fa01 	bl	800da10 <chEvtSignalI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 801160e:	b662      	cpsie	i
 8011610:	bd08      	pop	{r3, pc}
 8011612:	bf00      	nop
 8011614:	20001d20 	.word	0x20001d20
	...

08011620 <halRfWaitTransceiverReady>:
 *
 * @param   none
 *
 * @return  none
 */
void halRfWaitTransceiverReady(void) {
 8011620:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8011622:	b672      	cpsid	i
#if defined(INCLUDE_PA) && !defined(PA_CTRL_FROM_MCU)
	// GPIO3 is not conncted to combo board; use SFD at GPIO2 instead
	HAL_INT_OFF();
	// GPIO2 = SFD
	CC2520_CFG_GPIO_OUT(2,CC2520_GPIO_SFD);
 8011624:	4c0f      	ldr	r4, [pc, #60]	; (8011664 <halRfWaitTransceiverReady+0x44>)
 8011626:	2022      	movs	r0, #34	; 0x22
 8011628:	212a      	movs	r1, #42	; 0x2a
 801162a:	f7ff fe71 	bl	8011310 <CC2520_REGWR8>
 801162e:	2200      	movs	r2, #0
 8011630:	4620      	mov	r0, r4
 8011632:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8011636:	f7fe faab 	bl	800fb90 <_pal_lld_setgroupmode>
	while (CC2520_GPIO2_IPIN) {
 801163a:	6923      	ldr	r3, [r4, #16]
 801163c:	051a      	lsls	r2, r3, #20
 801163e:	d505      	bpl.n	801164c <halRfWaitTransceiverReady+0x2c>
		chThdSleep(1);
 8011640:	2001      	movs	r0, #1
 8011642:	f7fc f85d 	bl	800d700 <chThdSleep>
#if defined(INCLUDE_PA) && !defined(PA_CTRL_FROM_MCU)
	// GPIO3 is not conncted to combo board; use SFD at GPIO2 instead
	HAL_INT_OFF();
	// GPIO2 = SFD
	CC2520_CFG_GPIO_OUT(2,CC2520_GPIO_SFD);
	while (CC2520_GPIO2_IPIN) {
 8011646:	6923      	ldr	r3, [r4, #16]
 8011648:	051b      	lsls	r3, r3, #20
 801164a:	d4f9      	bmi.n	8011640 <halRfWaitTransceiverReady+0x20>
		chThdSleep(1);
	};
	// GPIO2 = default (RSSI_VALID)
	CC2520_CFG_GPIO_OUT(2,CC2520_GPIO_RSSI_VALID);
 801164c:	2022      	movs	r0, #34	; 0x22
 801164e:	212c      	movs	r1, #44	; 0x2c
 8011650:	f7ff fe5e 	bl	8011310 <CC2520_REGWR8>
 8011654:	4803      	ldr	r0, [pc, #12]	; (8011664 <halRfWaitTransceiverReady+0x44>)
 8011656:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801165a:	2200      	movs	r2, #0
 801165c:	f7fe fa98 	bl	800fb90 <_pal_lld_setgroupmode>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8011660:	b662      	cpsie	i
 8011662:	bd10      	pop	{r4, pc}
 8011664:	40020c00 	.word	0x40020c00
	...

08011670 <min>:
uint8 min(uint8 v1, uint8 v2)
{
	if(v1 < v2)
		return v1;
	else return v2;
}
 8011670:	4288      	cmp	r0, r1
 8011672:	bf28      	it	cs
 8011674:	4608      	movcs	r0, r1
 8011676:	4770      	bx	lr
	...

08011680 <basicRf_thread>:
/**
 * This thread only checks if the CC2520 has gotten the RX_OVERFLOW exception and
 * flushes the rx buffer in that case. This is because it will stop receiving
 * packets otherwise.
 */
static THD_FUNCTION(basicRf_thread, arg) {
 8011680:	b508      	push	{r3, lr}
 8011682:	4b0c      	ldr	r3, [pc, #48]	; (80116b4 <basicRf_thread+0x34>)
 8011684:	4a0c      	ldr	r2, [pc, #48]	; (80116b8 <basicRf_thread+0x38>)
 8011686:	699b      	ldr	r3, [r3, #24]
	(void)arg;

	chRegSetThreadName("CC2520 EXC");

	for(;;) {
		if (CC2520_RX_OVERFLOW_PIN) {
 8011688:	4c0c      	ldr	r4, [pc, #48]	; (80116bc <basicRf_thread+0x3c>)
 801168a:	619a      	str	r2, [r3, #24]
 801168c:	e002      	b.n	8011694 <basicRf_thread+0x14>
			halRfFlushRx();
			CC2520_CLEAR_EXC(CC2520_EXC_RX_OVERFLOW);
			chMtxUnlock(&rf_mutex);
		}

		chThdSleepMilliseconds(1);
 801168e:	200a      	movs	r0, #10
 8011690:	f7fc f836 	bl	800d700 <chThdSleep>
	(void)arg;

	chRegSetThreadName("CC2520 EXC");

	for(;;) {
		if (CC2520_RX_OVERFLOW_PIN) {
 8011694:	6923      	ldr	r3, [r4, #16]
 8011696:	04db      	lsls	r3, r3, #19
 8011698:	d5f9      	bpl.n	801168e <basicRf_thread+0xe>
			chMtxLock(&rf_mutex);
 801169a:	4809      	ldr	r0, [pc, #36]	; (80116c0 <basicRf_thread+0x40>)
 801169c:	f7fc f980 	bl	800d9a0 <chMtxLock>
			halRfFlushRx();
 80116a0:	f7ff ff96 	bl	80115d0 <halRfFlushRx>
			CC2520_CLEAR_EXC(CC2520_EXC_RX_OVERFLOW);
 80116a4:	2086      	movs	r0, #134	; 0x86
 80116a6:	f7ff fe03 	bl	80112b0 <CC2520_BCLR>
			chMtxUnlock(&rf_mutex);
 80116aa:	4805      	ldr	r0, [pc, #20]	; (80116c0 <basicRf_thread+0x40>)
 80116ac:	f7fc f980 	bl	800d9b0 <chMtxUnlock>
 80116b0:	e7ed      	b.n	801168e <basicRf_thread+0xe>
 80116b2:	bf00      	nop
 80116b4:	200010b8 	.word	0x200010b8
 80116b8:	08016920 	.word	0x08016920
 80116bc:	40020c00 	.word	0x40020c00
 80116c0:	20002068 	.word	0x20002068
	...

080116d0 <basicRfRxFrmDoneIsr>:
 *                    frame
 *              txState - file scope variable that keeps tx state info
 *
 * @return      none
 */
static void basicRfRxFrmDoneIsr(void) {
 80116d0:	b538      	push	{r3, r4, r5, lr}
	uint8 *pStatusWord;
#ifdef SECURITY_CCM
	uint8 authStatus=0;
#endif

	chMtxLock(&rf_mutex);
 80116d2:	4828      	ldr	r0, [pc, #160]	; (8011774 <basicRfRxFrmDoneIsr+0xa4>)

	// Clear interrupt
	CLEAR_EXC_RX_FRM_DONE();

	// Read payload length.
	halRfReadRxBuf(&pHdr->packetLength,1);
 80116d4:	4c28      	ldr	r4, [pc, #160]	; (8011778 <basicRfRxFrmDoneIsr+0xa8>)
	uint8 *pStatusWord;
#ifdef SECURITY_CCM
	uint8 authStatus=0;
#endif

	chMtxLock(&rf_mutex);
 80116d6:	f7fc f963 	bl	800d9a0 <chMtxLock>

	// Map header to packet buffer
	pHdr= (basicRfPktHdr_t*)rxMpdu;

	// Clear interrupt
	CLEAR_EXC_RX_FRM_DONE();
 80116da:	2088      	movs	r0, #136	; 0x88
 80116dc:	f7ff fde8 	bl	80112b0 <CC2520_BCLR>

	// Read payload length.
	halRfReadRxBuf(&pHdr->packetLength,1);
 80116e0:	2101      	movs	r1, #1
 80116e2:	4620      	mov	r0, r4
 80116e4:	f7ff fe6c 	bl	80113c0 <halRfReadRxBuf>
	pHdr->packetLength &= BASIC_RF_PLD_LEN_MASK; // Ignore MSB
 80116e8:	7821      	ldrb	r1, [r4, #0]
 80116ea:	f001 017f 	and.w	r1, r1, #127	; 0x7f

	// Is this an acknowledgment packet?
	// Only ack packets may be 5 bytes in total.
	if (pHdr->packetLength == BASIC_RF_ACK_PACKET_SIZE) {
 80116ee:	2905      	cmp	r1, #5
	// Clear interrupt
	CLEAR_EXC_RX_FRM_DONE();

	// Read payload length.
	halRfReadRxBuf(&pHdr->packetLength,1);
	pHdr->packetLength &= BASIC_RF_PLD_LEN_MASK; // Ignore MSB
 80116f0:	7021      	strb	r1, [r4, #0]

	// Is this an acknowledgment packet?
	// Only ack packets may be 5 bytes in total.
	if (pHdr->packetLength == BASIC_RF_ACK_PACKET_SIZE) {
 80116f2:	d021      	beq.n	8011738 <basicRfRxFrmDoneIsr+0x68>
	} else {

		// It is assumed that the radio rejects packets with invalid length.
		// Subtract the number of bytes in the frame overhead to get actual payload.

		rxi.length = pHdr->packetLength - BASIC_RF_PACKET_OVERHEAD_SIZE;
 80116f4:	4d21      	ldr	r5, [pc, #132]	; (801177c <basicRfRxFrmDoneIsr+0xac>)
 80116f6:	f1a1 030b 	sub.w	r3, r1, #11
 80116fa:	b2db      	uxtb	r3, r3
#ifdef SECURITY_CCM
		rxi.length -= (BASIC_RF_AUX_HDR_LENGTH + BASIC_RF_LEN_MIC);
		authStatus = halRfReadRxBufSecure(&rxMpdu[1], pHdr->packetLength, rxi.length,
				BASIC_RF_LEN_AUTH, BASIC_RF_SECURITY_M);
#else
		halRfReadRxBuf(&rxMpdu[1], pHdr->packetLength);
 80116fc:	1c60      	adds	r0, r4, #1
	} else {

		// It is assumed that the radio rejects packets with invalid length.
		// Subtract the number of bytes in the frame overhead to get actual payload.

		rxi.length = pHdr->packetLength - BASIC_RF_PACKET_OVERHEAD_SIZE;
 80116fe:	71ab      	strb	r3, [r5, #6]
#ifdef SECURITY_CCM
		rxi.length -= (BASIC_RF_AUX_HDR_LENGTH + BASIC_RF_LEN_MIC);
		authStatus = halRfReadRxBufSecure(&rxMpdu[1], pHdr->packetLength, rxi.length,
				BASIC_RF_LEN_AUTH, BASIC_RF_SECURITY_M);
#else
		halRfReadRxBuf(&rxMpdu[1], pHdr->packetLength);
 8011700:	f7ff fe5e 	bl	80113c0 <halRfReadRxBuf>
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 8011704:	7861      	ldrb	r1, [r4, #1]

		// Read the source address
		rxi.srcAddr= pHdr->srcAddr;
 8011706:	8922      	ldrh	r2, [r4, #8]
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 8011708:	f3c1 1040 	ubfx	r0, r1, #5, #1

		// Read the source address
		rxi.srcAddr= pHdr->srcAddr;

		// Read the packet payload
		rxi.pPayload = rxMpdu + BASIC_RF_HDR_SIZE;
 801170c:	f104 030a 	add.w	r3, r4, #10
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 8011710:	7328      	strb	r0, [r5, #12]

		// Read the source address
		rxi.srcAddr= pHdr->srcAddr;
 8011712:	806a      	strh	r2, [r5, #2]

		// Read the packet payload
		rxi.pPayload = rxMpdu + BASIC_RF_HDR_SIZE;
 8011714:	60ab      	str	r3, [r5, #8]

		// Read the FCS to get the RSSI and CRC
		pStatusWord= rxi.pPayload+rxi.length;
 8011716:	68aa      	ldr	r2, [r5, #8]
 8011718:	79ab      	ldrb	r3, [r5, #6]
 801171a:	b25b      	sxtb	r3, r3
 801171c:	18d0      	adds	r0, r2, r3
#ifdef SECURITY_CCM
		pStatusWord+= BASIC_RF_LEN_MIC;
#endif
		rxi.rssi = pStatusWord[0];
 801171e:	5cd3      	ldrb	r3, [r2, r3]
 8011720:	736b      	strb	r3, [r5, #13]

		// Notify the application about the received data packet if the CRC is OK
		// Throw packet if the previous packet had the same sequence number
		if( (pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (rxi.seqNumber != pHdr->seqNumber) ) {
 8011722:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8011726:	2b00      	cmp	r3, #0
 8011728:	78e3      	ldrb	r3, [r4, #3]
 801172a:	db19      	blt.n	8011760 <basicRfRxFrmDoneIsr+0x90>
			if ( ((pHdr->fcf0 & (BASIC_RF_FCF_BM_L)) == BASIC_RF_FCF_NOACK_L) ) {
				rxi.isReady = TRUE;
			}
#endif
		}
		rxi.seqNumber = pHdr->seqNumber;
 801172c:	702b      	strb	r3, [r5, #0]
	}

	chMtxUnlock(&rf_mutex);
 801172e:	4811      	ldr	r0, [pc, #68]	; (8011774 <basicRfRxFrmDoneIsr+0xa4>)
}
 8011730:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
		}
		rxi.seqNumber = pHdr->seqNumber;
	}

	chMtxUnlock(&rf_mutex);
 8011734:	f7fc b93c 	b.w	800d9b0 <chMtxUnlock>
	// Is this an acknowledgment packet?
	// Only ack packets may be 5 bytes in total.
	if (pHdr->packetLength == BASIC_RF_ACK_PACKET_SIZE) {

		// Read the packet
		halRfReadRxBuf(&rxMpdu[1], pHdr->packetLength);
 8011738:	1c60      	adds	r0, r4, #1
 801173a:	f7ff fe41 	bl	80113c0 <halRfReadRxBuf>
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 801173e:	7863      	ldrb	r3, [r4, #1]

		// Read the status word and check for CRC OK
		pStatusWord= rxMpdu + 4;

		// Indicate the successful ACK reception if CRC and sequence number OK
		if ((pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (pHdr->seqNumber == txState.txSeqNumber)) {
 8011740:	f994 2005 	ldrsb.w	r2, [r4, #5]
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 8011744:	490d      	ldr	r1, [pc, #52]	; (801177c <basicRfRxFrmDoneIsr+0xac>)
 8011746:	f3c3 1340 	ubfx	r3, r3, #5, #1

		// Read the status word and check for CRC OK
		pStatusWord= rxMpdu + 4;

		// Indicate the successful ACK reception if CRC and sequence number OK
		if ((pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (pHdr->seqNumber == txState.txSeqNumber)) {
 801174a:	2a00      	cmp	r2, #0
		UINT16_NTOH(pHdr->srcAddr);
#ifdef SECURITY_CCM
		UINT32_NTOH(pHdr->frameCounter);
#endif

		rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
 801174c:	730b      	strb	r3, [r1, #12]

		// Read the status word and check for CRC OK
		pStatusWord= rxMpdu + 4;

		// Indicate the successful ACK reception if CRC and sequence number OK
		if ((pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (pHdr->seqNumber == txState.txSeqNumber)) {
 801174e:	daee      	bge.n	801172e <basicRfRxFrmDoneIsr+0x5e>
 8011750:	4b0b      	ldr	r3, [pc, #44]	; (8011780 <basicRfRxFrmDoneIsr+0xb0>)
 8011752:	78e1      	ldrb	r1, [r4, #3]
 8011754:	781a      	ldrb	r2, [r3, #0]
 8011756:	4291      	cmp	r1, r2
 8011758:	d1e9      	bne.n	801172e <basicRfRxFrmDoneIsr+0x5e>
			txState.ackReceived = TRUE;
 801175a:	2201      	movs	r2, #1
 801175c:	705a      	strb	r2, [r3, #1]
 801175e:	e7e6      	b.n	801172e <basicRfRxFrmDoneIsr+0x5e>
#endif
		rxi.rssi = pStatusWord[0];

		// Notify the application about the received data packet if the CRC is OK
		// Throw packet if the previous packet had the same sequence number
		if( (pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (rxi.seqNumber != pHdr->seqNumber) ) {
 8011760:	782a      	ldrb	r2, [r5, #0]
 8011762:	429a      	cmp	r2, r3
 8011764:	d0e2      	beq.n	801172c <basicRfRxFrmDoneIsr+0x5c>
						(BASIC_RF_FCF_NOACK_L | BASIC_RF_SEC_ENABLED_FCF_BM_L)) {
					rxi.isReady = TRUE;
				}
			}
#else
			if ( ((pHdr->fcf0 & (BASIC_RF_FCF_BM_L)) == BASIC_RF_FCF_NOACK_L) ) {
 8011766:	f001 01df 	and.w	r1, r1, #223	; 0xdf
 801176a:	2941      	cmp	r1, #65	; 0x41
				rxi.isReady = TRUE;
 801176c:	bf04      	itt	eq
 801176e:	2201      	moveq	r2, #1
 8011770:	73aa      	strbeq	r2, [r5, #14]
 8011772:	e7db      	b.n	801172c <basicRfRxFrmDoneIsr+0x5c>
 8011774:	20002068 	.word	0x20002068
 8011778:	20001d38 	.word	0x20001d38
 801177c:	20001d28 	.word	0x20001d28
 8011780:	20002060 	.word	0x20002060
	...

08011790 <basicRfInit>:
 *              rxi - file scope variable info extracted from the last incoming
 *                    frame
 *
 * @return      none
 */
uint8 basicRfInit(basicRfCfg_t* pRfConfig) {
 8011790:	b570      	push	{r4, r5, r6, lr}
 8011792:	b082      	sub	sp, #8
 8011794:	4606      	mov	r6, r0
	if (halRfInit() == FAILED) {
 8011796:	f7ff fe73 	bl	8011480 <halRfInit>
 801179a:	2801      	cmp	r0, #1
 801179c:	d027      	beq.n	80117ee <basicRfInit+0x5e>
		return FAILED;
	}

	chMtxObjectInit(&rf_mutex);
 801179e:	4815      	ldr	r0, [pc, #84]	; (80117f4 <basicRfInit+0x64>)
	chMtxObjectInit(&rf_send_mutex);

	// Set the protocol configuration
	pConfig = pRfConfig;
 80117a0:	4d15      	ldr	r5, [pc, #84]	; (80117f8 <basicRfInit+0x68>)
uint8 basicRfInit(basicRfCfg_t* pRfConfig) {
	if (halRfInit() == FAILED) {
		return FAILED;
	}

	chMtxObjectInit(&rf_mutex);
 80117a2:	f7fc f88d 	bl	800d8c0 <chMtxObjectInit>
	chMtxObjectInit(&rf_send_mutex);
 80117a6:	4815      	ldr	r0, [pc, #84]	; (80117fc <basicRfInit+0x6c>)
 80117a8:	f7fc f88a 	bl	800d8c0 <chMtxObjectInit>

	// Set the protocol configuration
	pConfig = pRfConfig;
	rxi.pPayload   = NULL;
 80117ac:	4914      	ldr	r1, [pc, #80]	; (8011800 <basicRfInit+0x70>)

	txState.receiveOn = TRUE;
 80117ae:	4b15      	ldr	r3, [pc, #84]	; (8011804 <basicRfInit+0x74>)

	chMtxObjectInit(&rf_mutex);
	chMtxObjectInit(&rf_send_mutex);

	// Set the protocol configuration
	pConfig = pRfConfig;
 80117b0:	602e      	str	r6, [r5, #0]
	rxi.pPayload   = NULL;

	txState.receiveOn = TRUE;
 80117b2:	2201      	movs	r2, #1
	chMtxObjectInit(&rf_mutex);
	chMtxObjectInit(&rf_send_mutex);

	// Set the protocol configuration
	pConfig = pRfConfig;
	rxi.pPayload   = NULL;
 80117b4:	2400      	movs	r4, #0
 80117b6:	608c      	str	r4, [r1, #8]

	txState.receiveOn = TRUE;
 80117b8:	709a      	strb	r2, [r3, #2]
	txState.frameCounter = 0;
 80117ba:	605c      	str	r4, [r3, #4]

	// Set channel
	halRfSetChannel(pConfig->channel);
 80117bc:	7930      	ldrb	r0, [r6, #4]
 80117be:	f7ff fddf 	bl	8011380 <halRfSetChannel>

	// Write the short address and the PAN ID to the CC2520 RAM
	halRfSetShortAddr(pConfig->myAddr);
 80117c2:	682b      	ldr	r3, [r5, #0]
 80117c4:	8818      	ldrh	r0, [r3, #0]
 80117c6:	b280      	uxth	r0, r0
 80117c8:	f7ff fde2 	bl	8011390 <halRfSetShortAddr>
	halRfSetPanId(pConfig->panId);
 80117cc:	682b      	ldr	r3, [r5, #0]
 80117ce:	8858      	ldrh	r0, [r3, #2]
 80117d0:	b280      	uxth	r0, r0
 80117d2:	f7ff fde5 	bl	80113a0 <halRfSetPanId>
#ifdef SECURITY_CCM
	basicRfSecurityInit((basicRfCfg_t*)pConfig);
#endif

	// Set up receive interrupt (received data or acknowlegment)
	halRfRxInterruptConfig(basicRfRxFrmDoneIsr);
 80117d6:	480c      	ldr	r0, [pc, #48]	; (8011808 <basicRfInit+0x78>)
 80117d8:	f7ff fe3a 	bl	8011450 <halRfRxInterruptConfig>

	chThdCreateStatic(basicRf_thread_wa, sizeof(basicRf_thread_wa), NORMALPRIO, basicRf_thread, NULL);
 80117dc:	9400      	str	r4, [sp, #0]
 80117de:	480b      	ldr	r0, [pc, #44]	; (801180c <basicRfInit+0x7c>)
 80117e0:	4b0b      	ldr	r3, [pc, #44]	; (8011810 <basicRfInit+0x80>)
 80117e2:	f44f 7126 	mov.w	r1, #664	; 0x298
 80117e6:	2240      	movs	r2, #64	; 0x40
 80117e8:	f7fb ff4a 	bl	800d680 <chThdCreateStatic>

	return SUCCESS;
 80117ec:	4620      	mov	r0, r4
}
 80117ee:	b002      	add	sp, #8
 80117f0:	bd70      	pop	{r4, r5, r6, pc}
 80117f2:	bf00      	nop
 80117f4:	20002068 	.word	0x20002068
 80117f8:	20002078 	.word	0x20002078
 80117fc:	20002050 	.word	0x20002050
 8011800:	20001d28 	.word	0x20001d28
 8011804:	20002060 	.word	0x20002060
 8011808:	080116d1 	.word	0x080116d1
 801180c:	20001db8 	.word	0x20001db8
 8011810:	08011681 	.word	0x08011681
	...

08011820 <basicRfPacketIsReady>:
 * @param       none
 *
 * @return      uint8 - TRUE if a packet is ready to be read by higher layer
 */
uint8 basicRfPacketIsReady(void) {
	return rxi.isReady;
 8011820:	4b01      	ldr	r3, [pc, #4]	; (8011828 <basicRfPacketIsReady+0x8>)
 8011822:	7b98      	ldrb	r0, [r3, #14]
}
 8011824:	4770      	bx	lr
 8011826:	bf00      	nop
 8011828:	20001d28 	.word	0x20001d28
 801182c:	00000000 	.word	0x00000000

08011830 <basicRfReceive>:
 *                    incoming packet
 *
 * @return      uint8 - number of bytes actually copied into buffer
 */
uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)
{
 8011830:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// Accessing shared variables -> this is a critical region
	// Critical region start
	chMtxLock(&rf_mutex);

	memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
 8011834:	4d11      	ldr	r5, [pc, #68]	; (801187c <basicRfReceive+0x4c>)
 *                    incoming packet
 *
 * @return      uint8 - number of bytes actually copied into buffer
 */
uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)
{
 8011836:	4680      	mov	r8, r0
 8011838:	460e      	mov	r6, r1
	// Accessing shared variables -> this is a critical region
	// Critical region start
	chMtxLock(&rf_mutex);
 801183a:	4811      	ldr	r0, [pc, #68]	; (8011880 <basicRfReceive+0x50>)
 *                    incoming packet
 *
 * @return      uint8 - number of bytes actually copied into buffer
 */
uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)
{
 801183c:	4617      	mov	r7, r2
	// Accessing shared variables -> this is a critical region
	// Critical region start
	chMtxLock(&rf_mutex);
 801183e:	f7fc f8af 	bl	800d9a0 <chMtxLock>

	memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
 8011842:	68ac      	ldr	r4, [r5, #8]
 8011844:	79a8      	ldrb	r0, [r5, #6]
 8011846:	4631      	mov	r1, r6
 8011848:	f7ff ff12 	bl	8011670 <min>
 801184c:	4621      	mov	r1, r4
 801184e:	4602      	mov	r2, r0
 8011850:	4640      	mov	r0, r8
 8011852:	f7fb f875 	bl	800c940 <memcpy>
	if(pRssi != NULL) {
 8011856:	b137      	cbz	r7, 8011866 <basicRfReceive+0x36>
 * @param       none

 * @return      int8 - RSSI value
 */
int8 basicRfGetRssi(void) {
	return rxi.rssi - halRfGetRssiOffset();
 8011858:	7b6c      	ldrb	r4, [r5, #13]
 801185a:	f7ff fd89 	bl	8011370 <halRfGetRssiOffset>
 801185e:	b2e4      	uxtb	r4, r4
 8011860:	1a20      	subs	r0, r4, r0
	// Critical region start
	chMtxLock(&rf_mutex);

	memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
	if(pRssi != NULL) {
		*pRssi = basicRfGetRssi();
 8011862:	b240      	sxtb	r0, r0
 8011864:	8038      	strh	r0, [r7, #0]
	}
	rxi.isReady = FALSE;
 8011866:	2300      	movs	r3, #0

	// Critical region end
	chMtxUnlock(&rf_mutex);
 8011868:	4805      	ldr	r0, [pc, #20]	; (8011880 <basicRfReceive+0x50>)

	memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
	if(pRssi != NULL) {
		*pRssi = basicRfGetRssi();
	}
	rxi.isReady = FALSE;
 801186a:	73ab      	strb	r3, [r5, #14]

	// Critical region end
	chMtxUnlock(&rf_mutex);
 801186c:	f7fc f8a0 	bl	800d9b0 <chMtxUnlock>

	return min(rxi.length, len);
 8011870:	79a8      	ldrb	r0, [r5, #6]
 8011872:	4631      	mov	r1, r6
}
 8011874:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	rxi.isReady = FALSE;

	// Critical region end
	chMtxUnlock(&rf_mutex);

	return min(rxi.length, len);
 8011878:	f7ff befa 	b.w	8011670 <min>
 801187c:	20001d28 	.word	0x20001d28
 8011880:	20002068 	.word	0x20002068
	...

08011890 <basicRfReceiveOn>:
 *
 * @param       txState - file scope variable
 *
 * @return      none
 */
void basicRfReceiveOn(void) {
 8011890:	b510      	push	{r4, lr}
	chMtxLock(&rf_mutex);
 8011892:	4c07      	ldr	r4, [pc, #28]	; (80118b0 <basicRfReceiveOn+0x20>)
 8011894:	4620      	mov	r0, r4
 8011896:	f7fc f883 	bl	800d9a0 <chMtxLock>
	txState.receiveOn = TRUE;
 801189a:	4b06      	ldr	r3, [pc, #24]	; (80118b4 <basicRfReceiveOn+0x24>)
 801189c:	2201      	movs	r2, #1
 801189e:	709a      	strb	r2, [r3, #2]
	halRfReceiveOn();
 80118a0:	f7ff fe56 	bl	8011550 <halRfReceiveOn>
	chMtxUnlock(&rf_mutex);
 80118a4:	4620      	mov	r0, r4
}
 80118a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 */
void basicRfReceiveOn(void) {
	chMtxLock(&rf_mutex);
	txState.receiveOn = TRUE;
	halRfReceiveOn();
	chMtxUnlock(&rf_mutex);
 80118aa:	f7fc b881 	b.w	800d9b0 <chMtxUnlock>
 80118ae:	bf00      	nop
 80118b0:	20002068 	.word	0x20002068
 80118b4:	20002060 	.word	0x20002060
	...

080118c0 <basicRfReceiveOff>:
 *
 * @param       txState - file scope variable
 *
 * @return      none
 */
void basicRfReceiveOff(void) {
 80118c0:	b510      	push	{r4, lr}
	chMtxLock(&rf_mutex);
 80118c2:	4c07      	ldr	r4, [pc, #28]	; (80118e0 <basicRfReceiveOff+0x20>)
 80118c4:	4620      	mov	r0, r4
 80118c6:	f7fc f86b 	bl	800d9a0 <chMtxLock>
	txState.receiveOn = FALSE;
 80118ca:	4b06      	ldr	r3, [pc, #24]	; (80118e4 <basicRfReceiveOff+0x24>)
 80118cc:	2200      	movs	r2, #0
 80118ce:	709a      	strb	r2, [r3, #2]
	halRfReceiveOff();
 80118d0:	f7ff fe5e 	bl	8011590 <halRfReceiveOff>
	chMtxUnlock(&rf_mutex);
 80118d4:	4620      	mov	r0, r4
}
 80118d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 */
void basicRfReceiveOff(void) {
	chMtxLock(&rf_mutex);
	txState.receiveOn = FALSE;
	halRfReceiveOff();
	chMtxUnlock(&rf_mutex);
 80118da:	f7fc b869 	b.w	800d9b0 <chMtxUnlock>
 80118de:	bf00      	nop
 80118e0:	20002068 	.word	0x20002068
 80118e4:	20002060 	.word	0x20002060
	...

080118f0 <basicRfSendPacket>:
 *              txState - file scope variable that keeps tx state info
 *              mpdu - file scope variable. Buffer for the frame to send
 *
 * @return      basicRFStatus_t - SUCCESS or FAILED
 */
uint8 basicRfSendPacket(uint16 destAddr, uint8* pPayload, uint8 length) {
 80118f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8 status = SUCCESS;

	chMtxLock(&rf_send_mutex);

	// Turn on receiver if its not on
	if(!txState.receiveOn) {
 80118f4:	4d36      	ldr	r5, [pc, #216]	; (80119d0 <basicRfSendPacket+0xe0>)
 *              txState - file scope variable that keeps tx state info
 *              mpdu - file scope variable. Buffer for the frame to send
 *
 * @return      basicRFStatus_t - SUCCESS or FAILED
 */
uint8 basicRfSendPacket(uint16 destAddr, uint8* pPayload, uint8 length) {
 80118f6:	4680      	mov	r8, r0
	uint8 mpduLength;
	uint8 status = SUCCESS;

	chMtxLock(&rf_send_mutex);
 80118f8:	4836      	ldr	r0, [pc, #216]	; (80119d4 <basicRfSendPacket+0xe4>)
 *              txState - file scope variable that keeps tx state info
 *              mpdu - file scope variable. Buffer for the frame to send
 *
 * @return      basicRFStatus_t - SUCCESS or FAILED
 */
uint8 basicRfSendPacket(uint16 destAddr, uint8* pPayload, uint8 length) {
 80118fa:	460c      	mov	r4, r1
 80118fc:	4617      	mov	r7, r2
	uint8 mpduLength;
	uint8 status = SUCCESS;

	chMtxLock(&rf_send_mutex);
 80118fe:	f7fc f84f 	bl	800d9a0 <chMtxLock>

	// Turn on receiver if its not on
	if(!txState.receiveOn) {
 8011902:	78ab      	ldrb	r3, [r5, #2]
 8011904:	2b00      	cmp	r3, #0
 8011906:	d05f      	beq.n	80119c8 <basicRfSendPacket+0xd8>
		basicRfReceiveOn();
	}

	// Check packet length
	length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
 8011908:	4638      	mov	r0, r7
 801190a:	2167      	movs	r1, #103	; 0x67
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 801190c:	4e32      	ldr	r6, [pc, #200]	; (80119d8 <basicRfSendPacket+0xe8>)
	if(!txState.receiveOn) {
		basicRfReceiveOn();
	}

	// Check packet length
	length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
 801190e:	f7ff feaf 	bl	8011670 <min>
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 8011912:	6832      	ldr	r2, [r6, #0]
	uint16 fcf;

	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
 8011914:	4b31      	ldr	r3, [pc, #196]	; (80119dc <basicRfSendPacket+0xec>)
	if(!txState.receiveOn) {
		basicRfReceiveOn();
	}

	// Check packet length
	length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
 8011916:	4607      	mov	r7, r0
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 8011918:	7950      	ldrb	r0, [r2, #5]
	pHdr->fcf0 = LO_UINT16(fcf);
	pHdr->fcf1 = HI_UINT16(fcf);
	pHdr->seqNumber= txState.txSeqNumber;
 801191a:	7829      	ldrb	r1, [r5, #0]
 801191c:	70d9      	strb	r1, [r3, #3]
	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	pHdr->fcf0 = LO_UINT16(fcf);
	pHdr->fcf1 = HI_UINT16(fcf);
 801191e:	2188      	movs	r1, #136	; 0x88
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 8011920:	2800      	cmp	r0, #0
	pHdr->fcf0 = LO_UINT16(fcf);
	pHdr->fcf1 = HI_UINT16(fcf);
 8011922:	7099      	strb	r1, [r3, #2]
	pHdr->seqNumber= txState.txSeqNumber;
	pHdr->panId= pConfig->panId;
 8011924:	8851      	ldrh	r1, [r2, #2]
 8011926:	8099      	strh	r1, [r3, #4]
	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
 8011928:	bf14      	ite	ne
 801192a:	f04f 0e61 	movne.w	lr, #97	; 0x61
 801192e:	f04f 0e41 	moveq.w	lr, #65	; 0x41
	uint16 fcf;

	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
 8011932:	f107 000b 	add.w	r0, r7, #11
	//pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	pHdr->fcf0 = LO_UINT16(fcf);
 8011936:	f883 e001 	strb.w	lr, [r3, #1]
	uint16 fcf;

	pHdr= (basicRfPktHdr_t*)buffer;

	// Populate packet header
	pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
 801193a:	7018      	strb	r0, [r3, #0]
	fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
	pHdr->fcf0 = LO_UINT16(fcf);
	pHdr->fcf1 = HI_UINT16(fcf);
	pHdr->seqNumber= txState.txSeqNumber;
	pHdr->panId= pConfig->panId;
	pHdr->destAddr= destAddr;
 801193c:	f8a3 8006 	strh.w	r8, [r3, #6]
	pHdr->srcAddr= pConfig->myAddr;
 8011940:	8812      	ldrh	r2, [r2, #0]
 8011942:	811a      	strh	r2, [r3, #8]
static uint8 basicRfBuildMpdu(uint16 destAddr, uint8* pPayload, uint8 payloadLength) {
	uint8 hdrLength, n;

	hdrLength = basicRfBuildHeader(txMpdu, destAddr, payloadLength);

	for(n=0;n<payloadLength;n++) {
 8011944:	b15f      	cbz	r7, 801195e <basicRfSendPacket+0x6e>
 8011946:	1e78      	subs	r0, r7, #1
 8011948:	b2c0      	uxtb	r0, r0
 801194a:	300a      	adds	r0, #10
 801194c:	4418      	add	r0, r3
 801194e:	1e62      	subs	r2, r4, #1
 8011950:	3309      	adds	r3, #9
		txMpdu[hdrLength+n] = pPayload[n];
 8011952:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8011956:	f803 1f01 	strb.w	r1, [r3, #1]!
static uint8 basicRfBuildMpdu(uint16 destAddr, uint8* pPayload, uint8 payloadLength) {
	uint8 hdrLength, n;

	hdrLength = basicRfBuildHeader(txMpdu, destAddr, payloadLength);

	for(n=0;n<payloadLength;n++) {
 801195a:	4283      	cmp	r3, r0
 801195c:	d1f9      	bne.n	8011952 <basicRfSendPacket+0x62>
	// Check packet length
	length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
	mpduLength = basicRfBuildMpdu(destAddr, pPayload, length);

	// Wait until the transceiver is idle
	chMtxLock(&rf_mutex);
 801195e:	4820      	ldr	r0, [pc, #128]	; (80119e0 <basicRfSendPacket+0xf0>)
 8011960:	f7fc f81e 	bl	800d9a0 <chMtxLock>
	halRfWaitTransceiverReady();
 8011964:	f7ff fe5c 	bl	8011620 <halRfWaitTransceiverReady>

	for(n=0;n<payloadLength;n++) {
		txMpdu[hdrLength+n] = pPayload[n];
	}

	return hdrLength + payloadLength; // total mpdu length
 8011968:	f107 010a 	add.w	r1, r7, #10

#ifdef SECURITY_CCM
	halRfWriteTxBufSecure(txMpdu, mpduLength, length, BASIC_RF_LEN_AUTH, BASIC_RF_SECURITY_M);
	txState.frameCounter++;     // Increment frame counter field
#else
	halRfWriteTxBuf(txMpdu, mpduLength);
 801196c:	b2c9      	uxtb	r1, r1
 801196e:	481b      	ldr	r0, [pc, #108]	; (80119dc <basicRfSendPacket+0xec>)
 8011970:	f7ff fd1e 	bl	80113b0 <halRfWriteTxBuf>
#endif

	// Send frame with CCA. return FAILED if not successful
	if(halRfTransmit() != SUCCESS) {
 8011974:	f7ff fd2c 	bl	80113d0 <halRfTransmit>
 8011978:	4607      	mov	r7, r0
 801197a:	b198      	cbz	r0, 80119a4 <basicRfSendPacket+0xb4>
		status = FAILED;
	}

	chMtxUnlock(&rf_mutex);
 801197c:	4818      	ldr	r0, [pc, #96]	; (80119e0 <basicRfSendPacket+0xf0>)
 801197e:	f7fc f817 	bl	800d9b0 <chMtxUnlock>

	// Wait for the acknowledge to be received, if any
	if (pConfig->ackRequest && status == SUCCESS) {
 8011982:	6833      	ldr	r3, [r6, #0]
 8011984:	795b      	ldrb	r3, [r3, #5]
	halRfWriteTxBuf(txMpdu, mpduLength);
#endif

	// Send frame with CCA. return FAILED if not successful
	if(halRfTransmit() != SUCCESS) {
		status = FAILED;
 8011986:	2401      	movs	r4, #1
		// If an acknowledgment has been received (by RxFrmDoneIsr), the ackReceived flag should be set
		status = txState.ackReceived ? SUCCESS : FAILED;
	}

	// Turn off the receiver if it should not continue to be enabled
	if (!txState.receiveOn) {
 8011988:	78ab      	ldrb	r3, [r5, #2]
 801198a:	b90b      	cbnz	r3, 8011990 <basicRfSendPacket+0xa0>
		basicRfReceiveOff();
 801198c:	f7ff ff98 	bl	80118c0 <basicRfReceiveOff>
	}

	txState.txSeqNumber++;
 8011990:	782b      	ldrb	r3, [r5, #0]
	chMtxLock(&rf_mutex);
	halRfIncNonceTx();          // Increment nonce value
	chMtxUnlock();
#endif

	chMtxUnlock(&rf_send_mutex);
 8011992:	4810      	ldr	r0, [pc, #64]	; (80119d4 <basicRfSendPacket+0xe4>)
	// Turn off the receiver if it should not continue to be enabled
	if (!txState.receiveOn) {
		basicRfReceiveOff();
	}

	txState.txSeqNumber++;
 8011994:	3301      	adds	r3, #1
 8011996:	b2db      	uxtb	r3, r3
 8011998:	702b      	strb	r3, [r5, #0]
	chMtxLock(&rf_mutex);
	halRfIncNonceTx();          // Increment nonce value
	chMtxUnlock();
#endif

	chMtxUnlock(&rf_send_mutex);
 801199a:	f7fc f809 	bl	800d9b0 <chMtxUnlock>

	return status;
}
 801199e:	4620      	mov	r0, r4
 80119a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	// Send frame with CCA. return FAILED if not successful
	if(halRfTransmit() != SUCCESS) {
		status = FAILED;
	}

	chMtxUnlock(&rf_mutex);
 80119a4:	480e      	ldr	r0, [pc, #56]	; (80119e0 <basicRfSendPacket+0xf0>)
 80119a6:	f7fc f803 	bl	800d9b0 <chMtxUnlock>

	// Wait for the acknowledge to be received, if any
	if (pConfig->ackRequest && status == SUCCESS) {
 80119aa:	6833      	ldr	r3, [r6, #0]
 80119ac:	795b      	ldrb	r3, [r3, #5]
 80119ae:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 80119b2:	2b00      	cmp	r3, #0
 80119b4:	d0e8      	beq.n	8011988 <basicRfSendPacket+0x98>

		// We'll enter RX automatically, so just wait until we can be sure that the ack reception should have finished
		// The timeout consists of a 12-symbol turnaround time, the ack packet duration, and a small margin
		// TODO: Sleep may be to un-accurate?
		//		halMcuWaitUs((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
		chThdSleepMicroseconds((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
 80119b6:	2006      	movs	r0, #6

	chMtxUnlock(&rf_mutex);

	// Wait for the acknowledge to be received, if any
	if (pConfig->ackRequest && status == SUCCESS) {
		txState.ackReceived = FALSE;
 80119b8:	706f      	strb	r7, [r5, #1]

		// We'll enter RX automatically, so just wait until we can be sure that the ack reception should have finished
		// The timeout consists of a 12-symbol turnaround time, the ack packet duration, and a small margin
		// TODO: Sleep may be to un-accurate?
		//		halMcuWaitUs((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
		chThdSleepMicroseconds((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
 80119ba:	f7fb fea1 	bl	800d700 <chThdSleep>

		// If an acknowledgment has been received (by RxFrmDoneIsr), the ackReceived flag should be set
		status = txState.ackReceived ? SUCCESS : FAILED;
 80119be:	786c      	ldrb	r4, [r5, #1]
 80119c0:	fab4 f484 	clz	r4, r4
 80119c4:	0964      	lsrs	r4, r4, #5
 80119c6:	e7df      	b.n	8011988 <basicRfSendPacket+0x98>

	chMtxLock(&rf_send_mutex);

	// Turn on receiver if its not on
	if(!txState.receiveOn) {
		basicRfReceiveOn();
 80119c8:	f7ff ff62 	bl	8011890 <basicRfReceiveOn>
 80119cc:	e79c      	b.n	8011908 <basicRfSendPacket+0x18>
 80119ce:	bf00      	nop
 80119d0:	20002060 	.word	0x20002060
 80119d4:	20002050 	.word	0x20002050
 80119d8:	20002078 	.word	0x20002078
 80119dc:	2000207c 	.word	0x2000207c
 80119e0:	20002068 	.word	0x20002068
	...

080119f0 <main>:
 *
 */

#include "hal_cc2520.h"

int main(void) {
 80119f0:	b508      	push	{r3, lr}
	halInit();
 80119f2:	f7fc f9cd 	bl	800dd90 <halInit>
	chSysInit();
 80119f6:	f7fb fbcb 	bl	800d190 <chSysInit>

	conf_general_init();
 80119fa:	f001 f809 	bl	8012a10 <conf_general_init>
	led_init();
 80119fe:	f000 fd4f 	bl	80124a0 <led_init>
	adconv_init();
 8011a02:	f000 fdbd 	bl	8012580 <adconv_init>
	comm_usb_init();
 8011a06:	f000 fe9b 	bl	8012740 <comm_usb_init>
	ext_cb_init();
 8011a0a:	f000 fd99 	bl	8012540 <ext_cb_init>
	mpu9150_init();
 8011a0e:	f000 fc9f 	bl	8012350 <mpu9150_init>
	comm_cc2520_init();
 8011a12:	f000 f93d 	bl	8011c90 <comm_cc2520_init>
	commands_set_send_func(comm_cc2520_send_buffer);
 8011a16:	480b      	ldr	r0, [pc, #44]	; (8011a44 <main+0x54>)
 8011a18:	f000 ffc2 	bl	80129a0 <commands_set_send_func>

	chThdSleepMilliseconds(1000);
 8011a1c:	f242 7010 	movw	r0, #10000	; 0x2710
 8011a20:	f7fb fe6e 	bl	800d700 <chThdSleep>
	led_write(LED_RED, 1);
 8011a24:	2101      	movs	r1, #1
 8011a26:	2000      	movs	r0, #0
 8011a28:	f000 fd52 	bl	80124d0 <led_write>
	mpu9150_sample_gyro_offsets(100);
 8011a2c:	2064      	movs	r0, #100	; 0x64
 8011a2e:	f000 fcf7 	bl	8012420 <mpu9150_sample_gyro_offsets>
	led_write(LED_RED, 0);
 8011a32:	2000      	movs	r0, #0
 8011a34:	4601      	mov	r1, r0
 8011a36:	f000 fd4b 	bl	80124d0 <led_write>

	for(;;) {
		commands_printf("Hello World");
 8011a3a:	4803      	ldr	r0, [pc, #12]	; (8011a48 <main+0x58>)
 8011a3c:	f000 ffc0 	bl	80129c0 <commands_printf>
	}
 8011a40:	e7fb      	b.n	8011a3a <main+0x4a>
 8011a42:	bf00      	nop
 8011a44:	08011d71 	.word	0x08011d71
 8011a48:	08016930 	.word	0x08016930
 8011a4c:	00000000 	.word	0x00000000

08011a50 <get_descriptor>:
		uint8_t dindex,
		uint16_t lang) {

	(void)usbp;
	(void)lang;
	switch (dtype) {
 8011a50:	2902      	cmp	r1, #2
 8011a52:	d006      	beq.n	8011a62 <get_descriptor+0x12>
 8011a54:	2903      	cmp	r1, #3
 8011a56:	d006      	beq.n	8011a66 <get_descriptor+0x16>
 8011a58:	2901      	cmp	r1, #1
		return &vcom_configuration_descriptor;
	case USB_DESCRIPTOR_STRING:
		if (dindex < 4)
			return &vcom_strings[dindex];
	}
	return NULL;
 8011a5a:	4806      	ldr	r0, [pc, #24]	; (8011a74 <get_descriptor+0x24>)
 8011a5c:	bf18      	it	ne
 8011a5e:	2000      	movne	r0, #0
 8011a60:	4770      	bx	lr
	(void)lang;
	switch (dtype) {
	case USB_DESCRIPTOR_DEVICE:
		return &vcom_device_descriptor;
	case USB_DESCRIPTOR_CONFIGURATION:
		return &vcom_configuration_descriptor;
 8011a62:	4805      	ldr	r0, [pc, #20]	; (8011a78 <get_descriptor+0x28>)
 8011a64:	4770      	bx	lr
	case USB_DESCRIPTOR_STRING:
		if (dindex < 4)
 8011a66:	2a03      	cmp	r2, #3
			return &vcom_strings[dindex];
 8011a68:	bf9a      	itte	ls
 8011a6a:	4b04      	ldrls	r3, [pc, #16]	; (8011a7c <get_descriptor+0x2c>)
 8011a6c:	eb03 00c2 	addls.w	r0, r3, r2, lsl #3
	}
	return NULL;
 8011a70:	2000      	movhi	r0, #0
}
 8011a72:	4770      	bx	lr
 8011a74:	08016af0 	.word	0x08016af0
 8011a78:	08016970 	.word	0x08016970
 8011a7c:	08016ac0 	.word	0x08016ac0

08011a80 <usb_event>:
/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {

	switch (event) {
 8011a80:	2902      	cmp	r1, #2
 8011a82:	d111      	bne.n	8011aa8 <usb_event+0x28>
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8011a84:	b538      	push	{r3, r4, r5, lr}
 8011a86:	4605      	mov	r5, r0
 8011a88:	460c      	mov	r4, r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8011a8a:	b672      	cpsid	i
		chSysLockFromISR();

		/* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
		usbInitEndpointI(usbp, USBD2_DATA_REQUEST_EP, &ep1config);
 8011a8c:	2101      	movs	r1, #1
 8011a8e:	4a07      	ldr	r2, [pc, #28]	; (8011aac <usb_event+0x2c>)
 8011a90:	f7fc fcc6 	bl	800e420 <usbInitEndpointI>
		usbInitEndpointI(usbp, USBD2_INTERRUPT_REQUEST_EP, &ep2config);
 8011a94:	4628      	mov	r0, r5
 8011a96:	4621      	mov	r1, r4
 8011a98:	4a05      	ldr	r2, [pc, #20]	; (8011ab0 <usb_event+0x30>)
 8011a9a:	f7fc fcc1 	bl	800e420 <usbInitEndpointI>

		/* Resetting the state of the CDC subsystem.*/
		sduConfigureHookI(&SDU1);
 8011a9e:	4805      	ldr	r0, [pc, #20]	; (8011ab4 <usb_event+0x34>)
 8011aa0:	f7fc fb86 	bl	800e1b0 <sduConfigureHookI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8011aa4:	b662      	cpsie	i
 8011aa6:	bd38      	pop	{r3, r4, r5, pc}
 8011aa8:	4770      	bx	lr
 8011aaa:	bf00      	nop
 8011aac:	08016940 	.word	0x08016940
 8011ab0:	08016980 	.word	0x08016980
 8011ab4:	20002104 	.word	0x20002104
	...

08011ac0 <comm_usb_serial_init>:
		USBD2_DATA_REQUEST_EP,
		USBD2_DATA_AVAILABLE_EP,
		USBD2_INTERRUPT_REQUEST_EP
};

void comm_usb_serial_init(void) {
 8011ac0:	b538      	push	{r3, r4, r5, lr}
	sduObjectInit(&SDU1);
 8011ac2:	4d0e      	ldr	r5, [pc, #56]	; (8011afc <comm_usb_serial_init+0x3c>)
	/*
	 * Activates the USB driver and then the USB bus pull-up on D+.
	 * Note, a delay is inserted in order to not have to disconnect the cable
	 * after a reset.
	 */
	usbDisconnectBus(serusbcfg.usbp);
 8011ac4:	4c0e      	ldr	r4, [pc, #56]	; (8011b00 <comm_usb_serial_init+0x40>)
		USBD2_DATA_AVAILABLE_EP,
		USBD2_INTERRUPT_REQUEST_EP
};

void comm_usb_serial_init(void) {
	sduObjectInit(&SDU1);
 8011ac6:	4628      	mov	r0, r5
 8011ac8:	f7fc fb32 	bl	800e130 <sduObjectInit>
	sduStart(&SDU1, &serusbcfg);
 8011acc:	490d      	ldr	r1, [pc, #52]	; (8011b04 <comm_usb_serial_init+0x44>)
 8011ace:	4628      	mov	r0, r5
 8011ad0:	f7fc fb56 	bl	800e180 <sduStart>
	/*
	 * Activates the USB driver and then the USB bus pull-up on D+.
	 * Note, a delay is inserted in order to not have to disconnect the cable
	 * after a reset.
	 */
	usbDisconnectBus(serusbcfg.usbp);
 8011ad4:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8011ad6:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8011ad8:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8011adc:	6393      	str	r3, [r2, #56]	; 0x38
	chThdSleepMilliseconds(1500);
 8011ade:	f643 2098 	movw	r0, #15000	; 0x3a98
 8011ae2:	f7fb fe0d 	bl	800d700 <chThdSleep>
	usbStart(serusbcfg.usbp, &usbcfg);
 8011ae6:	4620      	mov	r0, r4
 8011ae8:	4907      	ldr	r1, [pc, #28]	; (8011b08 <comm_usb_serial_init+0x48>)
 8011aea:	f7fc fc89 	bl	800e400 <usbStart>
	usbConnectBus(serusbcfg.usbp);
 8011aee:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8011af0:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8011af2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8011af6:	6393      	str	r3, [r2, #56]	; 0x38
 8011af8:	bd38      	pop	{r3, r4, r5, pc}
 8011afa:	bf00      	nop
 8011afc:	20002104 	.word	0x20002104
 8011b00:	20001498 	.word	0x20001498
 8011b04:	08016ae0 	.word	0x08016ae0
 8011b08:	080169b0 	.word	0x080169b0
 8011b0c:	00000000 	.word	0x00000000

08011b10 <tx_thread>:
 8011b10:	4b14      	ldr	r3, [pc, #80]	; (8011b64 <tx_thread+0x54>)
static THD_FUNCTION(tx_thread, arg) {
	(void)arg;

	chRegSetThreadName("CC2520 Tx");

	tx_tp = chThdGetSelfX();
 8011b12:	4a15      	ldr	r2, [pc, #84]	; (8011b68 <tx_thread+0x58>)
 8011b14:	699b      	ldr	r3, [r3, #24]
 8011b16:	4c15      	ldr	r4, [pc, #84]	; (8011b6c <tx_thread+0x5c>)
 8011b18:	4915      	ldr	r1, [pc, #84]	; (8011b70 <tx_thread+0x60>)
 8011b1a:	4d16      	ldr	r5, [pc, #88]	; (8011b74 <tx_thread+0x64>)
 8011b1c:	4e16      	ldr	r6, [pc, #88]	; (8011b78 <tx_thread+0x68>)
 8011b1e:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8011b7c <tx_thread+0x6c>

		chThdSleepMicroseconds(100);
	}
}

static THD_FUNCTION(tx_thread, arg) {
 8011b22:	b580      	push	{r7, lr}
 8011b24:	6199      	str	r1, [r3, #24]
	(void)arg;

	chRegSetThreadName("CC2520 Tx");

	tx_tp = chThdGetSelfX();
 8011b26:	6013      	str	r3, [r2, #0]

		while(tx_slot_read != tx_slot_write) {
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
			led_toggle(LED_GREEN);

			tx_slot_read++;
 8011b28:	4627      	mov	r7, r4
	chRegSetThreadName("CC2520 Tx");

	tx_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);
 8011b2a:	2001      	movs	r0, #1
 8011b2c:	f7fb ffa8 	bl	800da80 <chEvtWaitAny>
 8011b30:	6823      	ldr	r3, [r4, #0]

		while(tx_slot_read != tx_slot_write) {
 8011b32:	f8d8 2000 	ldr.w	r2, [r8]
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
 8011b36:	eb03 1183 	add.w	r1, r3, r3, lsl #6
	tx_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while(tx_slot_read != tx_slot_write) {
 8011b3a:	429a      	cmp	r2, r3
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
 8011b3c:	eb05 0141 	add.w	r1, r5, r1, lsl #1
 8011b40:	f64f 70ff 	movw	r0, #65535	; 0xffff
	tx_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while(tx_slot_read != tx_slot_write) {
 8011b44:	d0f1      	beq.n	8011b2a <tx_thread+0x1a>
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
 8011b46:	5cf2      	ldrb	r2, [r6, r3]
 8011b48:	f7ff fed2 	bl	80118f0 <basicRfSendPacket>
			led_toggle(LED_GREEN);
 8011b4c:	2001      	movs	r0, #1
 8011b4e:	f000 fcdf 	bl	8012510 <led_toggle>

			tx_slot_read++;
 8011b52:	6823      	ldr	r3, [r4, #0]
 8011b54:	3301      	adds	r3, #1
			if (tx_slot_read >= TX_BUFFER_SLOTS) {
 8011b56:	2b09      	cmp	r3, #9

		while(tx_slot_read != tx_slot_write) {
			basicRfSendPacket(CC2520_DEST_ADDRESS, tx_buffer[tx_slot_read], tx_slot_len[tx_slot_read]);
			led_toggle(LED_GREEN);

			tx_slot_read++;
 8011b58:	6023      	str	r3, [r4, #0]
			if (tx_slot_read >= TX_BUFFER_SLOTS) {
 8011b5a:	ddea      	ble.n	8011b32 <tx_thread+0x22>
				tx_slot_read = 0;
 8011b5c:	2300      	movs	r3, #0
 8011b5e:	603b      	str	r3, [r7, #0]
 8011b60:	e7e6      	b.n	8011b30 <tx_thread+0x20>
 8011b62:	bf00      	nop
 8011b64:	200010b8 	.word	0x200010b8
 8011b68:	20002c98 	.word	0x20002c98
 8011b6c:	200036e8 	.word	0x200036e8
 8011b70:	08016b00 	.word	0x08016b00
 8011b74:	20002384 	.word	0x20002384
 8011b78:	20002ca0 	.word	0x20002ca0
 8011b7c:	20002c9c 	.word	0x20002c9c

08011b80 <rx_thread>:
		chVTSetI(&vt, US2ST(TX_DELAY_US), wakeup_tx, NULL);
	}
	chSysUnlock();
}

static THD_FUNCTION(rx_thread, arg) {
 8011b80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8011b84:	4b2e      	ldr	r3, [pc, #184]	; (8011c40 <rx_thread+0xc0>)
 8011b86:	4d2f      	ldr	r5, [pc, #188]	; (8011c44 <rx_thread+0xc4>)
 8011b88:	699b      	ldr	r3, [r3, #24]
 8011b8a:	4a2f      	ldr	r2, [pc, #188]	; (8011c48 <rx_thread+0xc8>)
 8011b8c:	4f2f      	ldr	r7, [pc, #188]	; (8011c4c <rx_thread+0xcc>)
 8011b8e:	619a      	str	r2, [r3, #24]
		if (basicRfPacketIsReady()) {
			static uint8_t buf[130];
			unsigned int len = 0;
			unsigned int ind = 0;

			len = basicRfReceive(buf, 130, NULL);
 8011b90:	46a8      	mov	r8, r5
 8011b92:	e002      	b.n	8011b9a <rx_thread+0x1a>
			default:
				break;
			}
		}

		chThdSleepMicroseconds(100);
 8011b94:	2001      	movs	r0, #1
 8011b96:	f7fb fdb3 	bl	800d700 <chThdSleep>
	(void)arg;

	chRegSetThreadName("CC2520 RX");

	for(;;) {
		if (basicRfPacketIsReady()) {
 8011b9a:	f7ff fe41 	bl	8011820 <basicRfPacketIsReady>
 8011b9e:	2800      	cmp	r0, #0
 8011ba0:	d0f8      	beq.n	8011b94 <rx_thread+0x14>
			static uint8_t buf[130];
			unsigned int len = 0;
			unsigned int ind = 0;

			len = basicRfReceive(buf, 130, NULL);
 8011ba2:	4828      	ldr	r0, [pc, #160]	; (8011c44 <rx_thread+0xc4>)
 8011ba4:	2182      	movs	r1, #130	; 0x82
 8011ba6:	2200      	movs	r2, #0
 8011ba8:	f7ff fe42 	bl	8011830 <basicRfReceive>
			MOTE_PACKET packet = buf[0];
 8011bac:	782c      	ldrb	r4, [r5, #0]
		if (basicRfPacketIsReady()) {
			static uint8_t buf[130];
			unsigned int len = 0;
			unsigned int ind = 0;

			len = basicRfReceive(buf, 130, NULL);
 8011bae:	4606      	mov	r6, r0
			MOTE_PACKET packet = buf[0];

			led_toggle(LED_RED);
 8011bb0:	2000      	movs	r0, #0
 8011bb2:	f000 fcad 	bl	8012510 <led_toggle>

			switch (packet) {
 8011bb6:	2c03      	cmp	r4, #3
 8011bb8:	d8ec      	bhi.n	8011b94 <rx_thread+0x14>
 8011bba:	e8df f004 	tbb	[pc, r4]
 8011bbe:	2c39      	.short	0x2c39
 8011bc0:	020a      	.short	0x020a
				}
			}
			break;

			case MOTE_PACKET_PROCESS_SHORT_BUFFER:
				commands_set_send_func(comm_cc2520_send_buffer);
 8011bc2:	4823      	ldr	r0, [pc, #140]	; (8011c50 <rx_thread+0xd0>)
 8011bc4:	f000 feec 	bl	80129a0 <commands_set_send_func>
				commands_process_packet(buf + 1, len - 1);
 8011bc8:	1e71      	subs	r1, r6, #1
 8011bca:	4822      	ldr	r0, [pc, #136]	; (8011c54 <rx_thread+0xd4>)
 8011bcc:	f000 fef0 	bl	80129b0 <commands_process_packet>
				break;
 8011bd0:	e7e0      	b.n	8011b94 <rx_thread+0x14>
			}
			break;

			case MOTE_PACKET_PROCESS_RX_BUFFER: {
				ind = 1;
				int rxbuf_len = (unsigned int)buf[ind++] << 8;
 8011bd2:	786c      	ldrb	r4, [r5, #1]
				rxbuf_len |= (unsigned int)buf[ind++];
 8011bd4:	78ab      	ldrb	r3, [r5, #2]
 8011bd6:	ea43 2404 	orr.w	r4, r3, r4, lsl #8

				if (rxbuf_len > RX_BUFFER_SIZE) {
 8011bda:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 8011bde:	d8d9      	bhi.n	8011b94 <rx_thread+0x14>
 8011be0:	1d60      	adds	r0, r4, #5
				}

				uint8_t crc_high = buf[ind++];
				uint8_t crc_low = buf[ind++];

				memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);
 8011be2:	1b80      	subs	r0, r0, r6
 8011be4:	1f72      	subs	r2, r6, #5
 8011be6:	491c      	ldr	r1, [pc, #112]	; (8011c58 <rx_thread+0xd8>)

				if (rxbuf_len > RX_BUFFER_SIZE) {
					break;
				}

				uint8_t crc_high = buf[ind++];
 8011be8:	f898 9003 	ldrb.w	r9, [r8, #3]
				uint8_t crc_low = buf[ind++];
 8011bec:	f898 6004 	ldrb.w	r6, [r8, #4]

				memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);
 8011bf0:	4438      	add	r0, r7
 8011bf2:	f7fa fea5 	bl	800c940 <memcpy>

				if (crc16(rx_buffer, rxbuf_len)
 8011bf6:	4815      	ldr	r0, [pc, #84]	; (8011c4c <rx_thread+0xcc>)
 8011bf8:	4621      	mov	r1, r4
 8011bfa:	f000 fca9 	bl	8012550 <crc16>
						== ((unsigned short) crc_high << 8
								| (unsigned short) crc_low)) {
 8011bfe:	ea46 2609 	orr.w	r6, r6, r9, lsl #8
				uint8_t crc_high = buf[ind++];
				uint8_t crc_low = buf[ind++];

				memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);

				if (crc16(rx_buffer, rxbuf_len)
 8011c02:	42b0      	cmp	r0, r6
 8011c04:	d1c6      	bne.n	8011b94 <rx_thread+0x14>
						== ((unsigned short) crc_high << 8
								| (unsigned short) crc_low)) {

					commands_set_send_func(comm_cc2520_send_buffer);
 8011c06:	4812      	ldr	r0, [pc, #72]	; (8011c50 <rx_thread+0xd0>)
 8011c08:	f000 feca 	bl	80129a0 <commands_set_send_func>
					commands_process_packet(rx_buffer, rxbuf_len);
 8011c0c:	4621      	mov	r1, r4
 8011c0e:	480f      	ldr	r0, [pc, #60]	; (8011c4c <rx_thread+0xcc>)
 8011c10:	f000 fece 	bl	80129b0 <commands_process_packet>
 8011c14:	e7be      	b.n	8011b94 <rx_thread+0x14>
			case MOTE_PACKET_FILL_RX_BUFFER:
				memcpy(rx_buffer + buf[1], buf + 2, len - 2);
				break;

			case MOTE_PACKET_FILL_RX_BUFFER_LONG: {
				int rxbuf_ind = (unsigned int)buf[1] << 8;
 8011c16:	7868      	ldrb	r0, [r5, #1]
				rxbuf_ind |= buf[2];
 8011c18:	78ab      	ldrb	r3, [r5, #2]
 8011c1a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
				if (rxbuf_ind < RX_BUFFER_SIZE) {
 8011c1e:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8011c22:	dab7      	bge.n	8011b94 <rx_thread+0x14>
					memcpy(rx_buffer + rxbuf_ind, buf + 3, len - 3);
 8011c24:	4438      	add	r0, r7
 8011c26:	1ef2      	subs	r2, r6, #3
 8011c28:	490c      	ldr	r1, [pc, #48]	; (8011c5c <rx_thread+0xdc>)
 8011c2a:	f7fa fe89 	bl	800c940 <memcpy>
 8011c2e:	e7b1      	b.n	8011b94 <rx_thread+0x14>

			led_toggle(LED_RED);

			switch (packet) {
			case MOTE_PACKET_FILL_RX_BUFFER:
				memcpy(rx_buffer + buf[1], buf + 2, len - 2);
 8011c30:	7868      	ldrb	r0, [r5, #1]
 8011c32:	490b      	ldr	r1, [pc, #44]	; (8011c60 <rx_thread+0xe0>)
 8011c34:	1eb2      	subs	r2, r6, #2
 8011c36:	4438      	add	r0, r7
 8011c38:	f7fa fe82 	bl	800c940 <memcpy>
				break;
 8011c3c:	e7aa      	b.n	8011b94 <rx_thread+0x14>
 8011c3e:	bf00      	nop
 8011c40:	200010b8 	.word	0x200010b8
 8011c44:	20002cac 	.word	0x20002cac
 8011c48:	08016b0c 	.word	0x08016b0c
 8011c4c:	20002898 	.word	0x20002898
 8011c50:	08011d71 	.word	0x08011d71
 8011c54:	20002cad 	.word	0x20002cad
 8011c58:	20002cb1 	.word	0x20002cb1
 8011c5c:	20002caf 	.word	0x20002caf
 8011c60:	20002cae 	.word	0x20002cae
	...

08011c70 <wakeup_tx>:
			}
		}
	}
}

static void wakeup_tx(void *p) {
 8011c70:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8011c72:	b672      	cpsid	i
	(void)p;

	chSysLockFromISR();
	chEvtSignalI(tx_tp, (eventmask_t) 1);
 8011c74:	4b03      	ldr	r3, [pc, #12]	; (8011c84 <wakeup_tx+0x14>)
 8011c76:	2101      	movs	r1, #1
 8011c78:	6818      	ldr	r0, [r3, #0]
 8011c7a:	f7fb fec9 	bl	800da10 <chEvtSignalI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8011c7e:	b662      	cpsie	i
 8011c80:	bd08      	pop	{r3, pc}
 8011c82:	bf00      	nop
 8011c84:	20002c98 	.word	0x20002c98
	...

08011c90 <comm_cc2520_init>:
static THD_FUNCTION(tx_thread, arg);
static void wakeup_tx(void *p);

#include "led.h"

void comm_cc2520_init(void) {
 8011c90:	b530      	push	{r4, r5, lr}
	tx_slot_read = 0;
 8011c92:	4a15      	ldr	r2, [pc, #84]	; (8011ce8 <comm_cc2520_init+0x58>)
	tx_slot_write = 0;
 8011c94:	4b15      	ldr	r3, [pc, #84]	; (8011cec <comm_cc2520_init+0x5c>)
static void wakeup_tx(void *p);

#include "led.h"

void comm_cc2520_init(void) {
	tx_slot_read = 0;
 8011c96:	2400      	movs	r4, #0
static THD_FUNCTION(tx_thread, arg);
static void wakeup_tx(void *p);

#include "led.h"

void comm_cc2520_init(void) {
 8011c98:	b083      	sub	sp, #12
	tx_slot_read = 0;
 8011c9a:	6014      	str	r4, [r2, #0]
	tx_slot_write = 0;
 8011c9c:	601c      	str	r4, [r3, #0]

	// rf
	halAssyInit();
 8011c9e:	f7ff f9cf 	bl	8011040 <halAssyInit>
	basicRfConfig.panId = CC2520_PAN_ID;
 8011ca2:	4b13      	ldr	r3, [pc, #76]	; (8011cf0 <comm_cc2520_init+0x60>)
	basicRfConfig.channel = CC2520_RF_CHANNEL;
 8011ca4:	210c      	movs	r1, #12
	basicRfConfig.ackRequest = FALSE;
	basicRfConfig.myAddr = CC2520_NODE_ADDRESS;
 8011ca6:	2201      	movs	r2, #1
	tx_slot_read = 0;
	tx_slot_write = 0;

	// rf
	halAssyInit();
	basicRfConfig.panId = CC2520_PAN_ID;
 8011ca8:	f64f 2511 	movw	r5, #64017	; 0xfa11
	basicRfConfig.myAddr = CC2520_NODE_ADDRESS;
#ifdef SECURITY_CCM
	basicRfConfig.securityKey = rf_security_key;
#endif

	if(basicRfInit(&basicRfConfig) == FAILED) {
 8011cac:	4618      	mov	r0, r3

	// rf
	halAssyInit();
	basicRfConfig.panId = CC2520_PAN_ID;
	basicRfConfig.channel = CC2520_RF_CHANNEL;
	basicRfConfig.ackRequest = FALSE;
 8011cae:	715c      	strb	r4, [r3, #5]
	tx_slot_read = 0;
	tx_slot_write = 0;

	// rf
	halAssyInit();
	basicRfConfig.panId = CC2520_PAN_ID;
 8011cb0:	805d      	strh	r5, [r3, #2]
	basicRfConfig.channel = CC2520_RF_CHANNEL;
 8011cb2:	7119      	strb	r1, [r3, #4]
	basicRfConfig.ackRequest = FALSE;
	basicRfConfig.myAddr = CC2520_NODE_ADDRESS;
 8011cb4:	801a      	strh	r2, [r3, #0]
#ifdef SECURITY_CCM
	basicRfConfig.securityKey = rf_security_key;
#endif

	if(basicRfInit(&basicRfConfig) == FAILED) {
 8011cb6:	f7ff fd6b 	bl	8011790 <basicRfInit>
 8011cba:	2801      	cmp	r0, #1
 8011cbc:	d100      	bne.n	8011cc0 <comm_cc2520_init+0x30>
		for(;;) {}
 8011cbe:	e7fe      	b.n	8011cbe <comm_cc2520_init+0x2e>
	}

	basicRfReceiveOn();
 8011cc0:	f7ff fde6 	bl	8011890 <basicRfReceiveOn>

	chThdCreateStatic(rx_thread_wa, sizeof(rx_thread_wa),
 8011cc4:	9400      	str	r4, [sp, #0]
 8011cc6:	4b0b      	ldr	r3, [pc, #44]	; (8011cf4 <comm_cc2520_init+0x64>)
 8011cc8:	480b      	ldr	r0, [pc, #44]	; (8011cf8 <comm_cc2520_init+0x68>)
 8011cca:	f640 1198 	movw	r1, #2456	; 0x998
 8011cce:	2240      	movs	r2, #64	; 0x40
 8011cd0:	f7fb fcd6 	bl	800d680 <chThdCreateStatic>
			NORMALPRIO, rx_thread, NULL);
	chThdCreateStatic(tx_thread_wa, sizeof(tx_thread_wa),
 8011cd4:	9400      	str	r4, [sp, #0]
 8011cd6:	4b09      	ldr	r3, [pc, #36]	; (8011cfc <comm_cc2520_init+0x6c>)
 8011cd8:	4809      	ldr	r0, [pc, #36]	; (8011d00 <comm_cc2520_init+0x70>)
 8011cda:	f44f 7166 	mov.w	r1, #920	; 0x398
 8011cde:	2240      	movs	r2, #64	; 0x40
 8011ce0:	f7fb fcce 	bl	800d680 <chThdCreateStatic>
			NORMALPRIO, tx_thread, NULL);
}
 8011ce4:	b003      	add	sp, #12
 8011ce6:	bd30      	pop	{r4, r5, pc}
 8011ce8:	200036e8 	.word	0x200036e8
 8011cec:	20002c9c 	.word	0x20002c9c
 8011cf0:	200036e0 	.word	0x200036e0
 8011cf4:	08011b81 	.word	0x08011b81
 8011cf8:	20002d48 	.word	0x20002d48
 8011cfc:	08011b11 	.word	0x08011b11
 8011d00:	200036f0 	.word	0x200036f0
	...

08011d10 <comm_cc2520_send_packet>:
 * Note that this packet is stored and sent in another thread after a delay. The delay is done
 * in case that this packet is a request from the (Qt) client, which means that more requests
 * can come within a short time. We want to give the additional requests a chance to arrive
 * before blocking the RF channel by sending the response.
 */
void comm_cc2520_send_packet(uint8_t *data, uint8_t len) {
 8011d10:	b570      	push	{r4, r5, r6, lr}
	memcpy(tx_buffer[tx_slot_write], data, len);
 8011d12:	4d0f      	ldr	r5, [pc, #60]	; (8011d50 <comm_cc2520_send_packet+0x40>)
 8011d14:	4b0f      	ldr	r3, [pc, #60]	; (8011d54 <comm_cc2520_send_packet+0x44>)
 8011d16:	682c      	ldr	r4, [r5, #0]
 * Note that this packet is stored and sent in another thread after a delay. The delay is done
 * in case that this packet is a request from the (Qt) client, which means that more requests
 * can come within a short time. We want to give the additional requests a chance to arrive
 * before blocking the RF channel by sending the response.
 */
void comm_cc2520_send_packet(uint8_t *data, uint8_t len) {
 8011d18:	460e      	mov	r6, r1
	memcpy(tx_buffer[tx_slot_write], data, len);
 8011d1a:	eb04 1284 	add.w	r2, r4, r4, lsl #6
 8011d1e:	4601      	mov	r1, r0
 8011d20:	eb03 0042 	add.w	r0, r3, r2, lsl #1
 8011d24:	4632      	mov	r2, r6
 8011d26:	f7fa fe0b 	bl	800c940 <memcpy>
	tx_slot_len[tx_slot_write] = len;

	tx_slot_write++;
 8011d2a:	1c63      	adds	r3, r4, #1
 * can come within a short time. We want to give the additional requests a chance to arrive
 * before blocking the RF channel by sending the response.
 */
void comm_cc2520_send_packet(uint8_t *data, uint8_t len) {
	memcpy(tx_buffer[tx_slot_write], data, len);
	tx_slot_len[tx_slot_write] = len;
 8011d2c:	4a0a      	ldr	r2, [pc, #40]	; (8011d58 <comm_cc2520_send_packet+0x48>)

	tx_slot_write++;
	if (tx_slot_write >= TX_BUFFER_SLOTS) {
 8011d2e:	2b09      	cmp	r3, #9
		tx_slot_write = 0;
 8011d30:	bfc8      	it	gt
 8011d32:	2300      	movgt	r3, #0
 * can come within a short time. We want to give the additional requests a chance to arrive
 * before blocking the RF channel by sending the response.
 */
void comm_cc2520_send_packet(uint8_t *data, uint8_t len) {
	memcpy(tx_buffer[tx_slot_write], data, len);
	tx_slot_len[tx_slot_write] = len;
 8011d34:	5516      	strb	r6, [r2, r4]

	tx_slot_write++;
	if (tx_slot_write >= TX_BUFFER_SLOTS) {
		tx_slot_write = 0;
 8011d36:	602b      	str	r3, [r5, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8011d38:	b672      	cpsid	i
 8011d3a:	4808      	ldr	r0, [pc, #32]	; (8011d5c <comm_cc2520_send_packet+0x4c>)
	}

	chSysLock();
	if (!chVTIsArmedI(&vt)) {
 8011d3c:	68c3      	ldr	r3, [r0, #12]
 8011d3e:	b10b      	cbz	r3, 8011d44 <comm_cc2520_send_packet+0x34>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8011d40:	b662      	cpsie	i
 8011d42:	bd70      	pop	{r4, r5, r6, pc}
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8011d44:	2132      	movs	r1, #50	; 0x32
 8011d46:	4a06      	ldr	r2, [pc, #24]	; (8011d60 <comm_cc2520_send_packet+0x50>)
 8011d48:	f7fb fac2 	bl	800d2d0 <chVTDoSetI>
 8011d4c:	b662      	cpsie	i
 8011d4e:	bd70      	pop	{r4, r5, r6, pc}
 8011d50:	20002c9c 	.word	0x20002c9c
 8011d54:	20002384 	.word	0x20002384
 8011d58:	20002ca0 	.word	0x20002ca0
 8011d5c:	20002d30 	.word	0x20002d30
 8011d60:	08011c71 	.word	0x08011c71
	...

08011d70 <comm_cc2520_send_buffer>:
			NORMALPRIO, rx_thread, NULL);
	chThdCreateStatic(tx_thread_wa, sizeof(tx_thread_wa),
			NORMALPRIO, tx_thread, NULL);
}

void comm_cc2520_send_buffer(uint8_t *data, unsigned int len) {
 8011d70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t send_buffer[MAX_PL_LEN];

	if (len <= (MAX_PL_LEN - 1)) {
 8011d74:	296d      	cmp	r1, #109	; 0x6d
			NORMALPRIO, rx_thread, NULL);
	chThdCreateStatic(tx_thread_wa, sizeof(tx_thread_wa),
			NORMALPRIO, tx_thread, NULL);
}

void comm_cc2520_send_buffer(uint8_t *data, unsigned int len) {
 8011d76:	b09d      	sub	sp, #116	; 0x74
 8011d78:	4689      	mov	r9, r1
 8011d7a:	4682      	mov	sl, r0
	uint8_t send_buffer[MAX_PL_LEN];

	if (len <= (MAX_PL_LEN - 1)) {
 8011d7c:	d970      	bls.n	8011e60 <comm_cc2520_send_buffer+0xf0>
		memcpy(send_buffer + ind, data, len);
		ind += len;
		comm_cc2520_send_packet(send_buffer, ind);
	} else {
		unsigned int end_a = 0;
		unsigned int len2 = len - (MAX_PL_LEN - 5);
 8011d7e:	f1a1 0769 	sub.w	r7, r1, #105	; 0x69
 8011d82:	b2fd      	uxtb	r5, r7
 8011d84:	1cae      	adds	r6, r5, #2
		send_buffer[ind++] = MOTE_PACKET_PROCESS_SHORT_BUFFER;
		memcpy(send_buffer + ind, data, len);
		ind += len;
		comm_cc2520_send_packet(send_buffer, ind);
	} else {
		unsigned int end_a = 0;
 8011d86:	2400      	movs	r4, #0
 8011d88:	b2f6      	uxtb	r6, r6
			}

			end_a = i + (MAX_PL_LEN - 2);

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
 8011d8a:	46a3      	mov	fp, r4
 8011d8c:	4680      	mov	r8, r0
		for (unsigned int i = 0;i < len2;i += (MAX_PL_LEN - 2)) {
			if (i > 255) {
				break;
			}

			end_a = i + (MAX_PL_LEN - 2);
 8011d8e:	346c      	adds	r4, #108	; 0x6c
 8011d90:	f1a4 036c 	sub.w	r3, r4, #108	; 0x6c

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
			send_buffer[1] = i;

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
 8011d94:	42a7      	cmp	r7, r4
			}

			end_a = i + (MAX_PL_LEN - 2);

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
 8011d96:	f88d b000 	strb.w	fp, [sp]
			send_buffer[1] = i;
 8011d9a:	f88d 3001 	strb.w	r3, [sp, #1]

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
				memcpy(send_buffer + 2, data + i, send_len);
 8011d9e:	f10d 0002 	add.w	r0, sp, #2
 8011da2:	4641      	mov	r1, r8
 8011da4:	f04f 026c 	mov.w	r2, #108	; 0x6c

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
			send_buffer[1] = i;

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
 8011da8:	d36d      	bcc.n	8011e86 <comm_cc2520_send_buffer+0x116>
				memcpy(send_buffer + 2, data + i, send_len);
 8011daa:	f7fa fdc9 	bl	800c940 <memcpy>
 8011dae:	216e      	movs	r1, #110	; 0x6e
			} else {
				send_len = len2 - i;
				memcpy(send_buffer + 2, data + i, send_len);
			}

			comm_cc2520_send_packet(send_buffer, send_len + 2);
 8011db0:	4668      	mov	r0, sp
 8011db2:	f7ff ffad 	bl	8011d10 <comm_cc2520_send_packet>
 8011db6:	3e6c      	subs	r6, #108	; 0x6c
		comm_cc2520_send_packet(send_buffer, ind);
	} else {
		unsigned int end_a = 0;
		unsigned int len2 = len - (MAX_PL_LEN - 5);

		for (unsigned int i = 0;i < len2;i += (MAX_PL_LEN - 2)) {
 8011db8:	42a7      	cmp	r7, r4
 8011dba:	b2f6      	uxtb	r6, r6
 8011dbc:	f108 086c 	add.w	r8, r8, #108	; 0x6c
 8011dc0:	d92d      	bls.n	8011e1e <comm_cc2520_send_buffer+0xae>
			if (i > 255) {
 8011dc2:	f5b4 7fa2 	cmp.w	r4, #324	; 0x144
 8011dc6:	d1e2      	bne.n	8011d8e <comm_cc2520_send_buffer+0x1e>
 8011dc8:	3d41      	subs	r5, #65	; 0x41
 8011dca:	b2ed      	uxtb	r5, r5
 8011dcc:	f50a 76a2 	add.w	r6, sl, #324	; 0x144
			comm_cc2520_send_packet(send_buffer, send_len + 2);
		}

		for (unsigned int i = end_a;i < len2;i += (MAX_PL_LEN - 3)) {
			uint8_t send_len = (MAX_PL_LEN - 3);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
 8011dd0:	f04f 0801 	mov.w	r8, #1
 8011dd4:	e00b      	b.n	8011dee <comm_cc2520_send_buffer+0x7e>
			send_buffer[1] = i >> 8;
			send_buffer[2] = i & 0xFF;

			if ((i + (MAX_PL_LEN - 3)) <= len2) {
				memcpy(send_buffer + 3, data + i, send_len);
 8011dd6:	f7fa fdb3 	bl	800c940 <memcpy>
 8011dda:	216e      	movs	r1, #110	; 0x6e
			} else {
				send_len = len2 - i;
				memcpy(send_buffer + 3, data + i, send_len);
			}

			comm_cc2520_send_packet(send_buffer, send_len + 3);
 8011ddc:	4668      	mov	r0, sp
 8011dde:	f7ff ff97 	bl	8011d10 <comm_cc2520_send_packet>
 8011de2:	3d6b      	subs	r5, #107	; 0x6b
			}

			comm_cc2520_send_packet(send_buffer, send_len + 2);
		}

		for (unsigned int i = end_a;i < len2;i += (MAX_PL_LEN - 3)) {
 8011de4:	42a7      	cmp	r7, r4
 8011de6:	f106 066b 	add.w	r6, r6, #107	; 0x6b
 8011dea:	b2ed      	uxtb	r5, r5
 8011dec:	d917      	bls.n	8011e1e <comm_cc2520_send_buffer+0xae>
			uint8_t send_len = (MAX_PL_LEN - 3);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
			send_buffer[1] = i >> 8;
 8011dee:	0a23      	lsrs	r3, r4, #8
			send_buffer[2] = i & 0xFF;
 8011df0:	f88d 4002 	strb.w	r4, [sp, #2]

			if ((i + (MAX_PL_LEN - 3)) <= len2) {
 8011df4:	346b      	adds	r4, #107	; 0x6b
 8011df6:	42a7      	cmp	r7, r4
			comm_cc2520_send_packet(send_buffer, send_len + 2);
		}

		for (unsigned int i = end_a;i < len2;i += (MAX_PL_LEN - 3)) {
			uint8_t send_len = (MAX_PL_LEN - 3);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
 8011df8:	f88d 8000 	strb.w	r8, [sp]
			send_buffer[1] = i >> 8;
 8011dfc:	f88d 3001 	strb.w	r3, [sp, #1]
			send_buffer[2] = i & 0xFF;

			if ((i + (MAX_PL_LEN - 3)) <= len2) {
				memcpy(send_buffer + 3, data + i, send_len);
 8011e00:	f10d 0003 	add.w	r0, sp, #3
 8011e04:	4631      	mov	r1, r6
 8011e06:	f04f 026b 	mov.w	r2, #107	; 0x6b
			uint8_t send_len = (MAX_PL_LEN - 3);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
			send_buffer[1] = i >> 8;
			send_buffer[2] = i & 0xFF;

			if ((i + (MAX_PL_LEN - 3)) <= len2) {
 8011e0a:	d2e4      	bcs.n	8011dd6 <comm_cc2520_send_buffer+0x66>
 8011e0c:	1eea      	subs	r2, r5, #3
				memcpy(send_buffer + 3, data + i, send_len);
			} else {
				send_len = len2 - i;
				memcpy(send_buffer + 3, data + i, send_len);
 8011e0e:	4631      	mov	r1, r6
 8011e10:	b2d2      	uxtb	r2, r2
 8011e12:	f10d 0003 	add.w	r0, sp, #3
 8011e16:	f7fa fd93 	bl	800c940 <memcpy>
 8011e1a:	4629      	mov	r1, r5
 8011e1c:	e7de      	b.n	8011ddc <comm_cc2520_send_buffer+0x6c>
			comm_cc2520_send_packet(send_buffer, send_len + 3);
		}

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
		send_buffer[ind++] = len >> 8;
 8011e1e:	ea4f 2319 	mov.w	r3, r9, lsr #8

			comm_cc2520_send_packet(send_buffer, send_len + 3);
		}

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
 8011e22:	2202      	movs	r2, #2
		send_buffer[ind++] = len >> 8;
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
 8011e24:	4649      	mov	r1, r9
 8011e26:	4650      	mov	r0, sl

			comm_cc2520_send_packet(send_buffer, send_len + 3);
		}

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
 8011e28:	f88d 2000 	strb.w	r2, [sp]
		send_buffer[ind++] = len >> 8;
 8011e2c:	f88d 3001 	strb.w	r3, [sp, #1]
		send_buffer[ind++] = len & 0xFF;
 8011e30:	f88d 9002 	strb.w	r9, [sp, #2]
		unsigned short crc = crc16(data, len);
 8011e34:	f000 fb8c 	bl	8012550 <crc16>
		send_buffer[ind++] = (uint8_t)(crc >> 8);
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
		memcpy(send_buffer + 5, data + len2, len - len2);
 8011e38:	eb0a 0107 	add.w	r1, sl, r7

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
		send_buffer[ind++] = len >> 8;
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
 8011e3c:	4603      	mov	r3, r0
		send_buffer[ind++] = (uint8_t)(crc >> 8);
 8011e3e:	0a04      	lsrs	r4, r0, #8
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
		memcpy(send_buffer + 5, data + len2, len - len2);
 8011e40:	2269      	movs	r2, #105	; 0x69
 8011e42:	f10d 0005 	add.w	r0, sp, #5
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
		send_buffer[ind++] = len >> 8;
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
		send_buffer[ind++] = (uint8_t)(crc >> 8);
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
 8011e46:	f88d 3004 	strb.w	r3, [sp, #4]
		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
		send_buffer[ind++] = len >> 8;
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
		send_buffer[ind++] = (uint8_t)(crc >> 8);
 8011e4a:	f88d 4003 	strb.w	r4, [sp, #3]
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
		memcpy(send_buffer + 5, data + len2, len - len2);
 8011e4e:	f7fa fd77 	bl	800c940 <memcpy>
		ind += len - len2;

		comm_cc2520_send_packet(send_buffer, ind);
 8011e52:	4668      	mov	r0, sp
 8011e54:	216e      	movs	r1, #110	; 0x6e
 8011e56:	f7ff ff5b 	bl	8011d10 <comm_cc2520_send_packet>
	}
}
 8011e5a:	b01d      	add	sp, #116	; 0x74
 8011e5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
void comm_cc2520_send_buffer(uint8_t *data, unsigned int len) {
	uint8_t send_buffer[MAX_PL_LEN];

	if (len <= (MAX_PL_LEN - 1)) {
		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_SHORT_BUFFER;
 8011e60:	ac1c      	add	r4, sp, #112	; 0x70
 8011e62:	2303      	movs	r3, #3
 8011e64:	f804 3d70 	strb.w	r3, [r4, #-112]!
		memcpy(send_buffer + ind, data, len);
 8011e68:	4601      	mov	r1, r0
 8011e6a:	464a      	mov	r2, r9
 8011e6c:	f10d 0001 	add.w	r0, sp, #1
 8011e70:	f7fa fd66 	bl	800c940 <memcpy>
		ind += len;
 8011e74:	f109 0101 	add.w	r1, r9, #1
		comm_cc2520_send_packet(send_buffer, ind);
 8011e78:	4620      	mov	r0, r4
 8011e7a:	b2c9      	uxtb	r1, r1
 8011e7c:	f7ff ff48 	bl	8011d10 <comm_cc2520_send_packet>
		memcpy(send_buffer + 5, data + len2, len - len2);
		ind += len - len2;

		comm_cc2520_send_packet(send_buffer, ind);
	}
}
 8011e80:	b01d      	add	sp, #116	; 0x74
 8011e82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011e86:	1eb2      	subs	r2, r6, #2

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
				memcpy(send_buffer + 2, data + i, send_len);
			} else {
				send_len = len2 - i;
				memcpy(send_buffer + 2, data + i, send_len);
 8011e88:	4641      	mov	r1, r8
 8011e8a:	b2d2      	uxtb	r2, r2
 8011e8c:	f10d 0002 	add.w	r0, sp, #2
 8011e90:	f7fa fd56 	bl	800c940 <memcpy>
 8011e94:	4631      	mov	r1, r6
 8011e96:	e78b      	b.n	8011db0 <comm_cc2520_send_buffer+0x40>
	...

08011ea0 <reset_init_mpu>:
			iteration_timer = chVTGetSystemTime();
		}
	}
}

static int reset_init_mpu(void) {
 8011ea0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	msg_t res = MSG_OK;

	palSetPadMode(SCL_GPIO, SCL_PAD,
 8011ea4:	4870      	ldr	r0, [pc, #448]	; (8012068 <reset_init_mpu+0x1c8>)
 8011ea6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8011eaa:	220c      	movs	r2, #12
			iteration_timer = chVTGetSystemTime();
		}
	}
}

static int reset_init_mpu(void) {
 8011eac:	b086      	sub	sp, #24
	msg_t res = MSG_OK;

	palSetPadMode(SCL_GPIO, SCL_PAD,
 8011eae:	f7fd fe6f 	bl	800fb90 <_pal_lld_setgroupmode>
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);

	for(int i = 0;i < 16;i++) {
		palClearPad(SCL_GPIO, SCL_PAD);
 8011eb2:	486d      	ldr	r0, [pc, #436]	; (8012068 <reset_init_mpu+0x1c8>)
}

static int reset_init_mpu(void) {
	msg_t res = MSG_OK;

	palSetPadMode(SCL_GPIO, SCL_PAD,
 8011eb4:	2410      	movs	r4, #16
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);

	for(int i = 0;i < 16;i++) {
		palClearPad(SCL_GPIO, SCL_PAD);
 8011eb6:	f44f 6180 	mov.w	r1, #1024	; 0x400
	return 1;
}
#endif

static void delay_short(void) {
	for (volatile int i = 0;i < 100;i++) {
 8011eba:	2200      	movs	r2, #0
	palSetPadMode(SCL_GPIO, SCL_PAD,
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);

	for(int i = 0;i < 16;i++) {
		palClearPad(SCL_GPIO, SCL_PAD);
 8011ebc:	8341      	strh	r1, [r0, #26]
	return 1;
}
#endif

static void delay_short(void) {
	for (volatile int i = 0;i < 100;i++) {
 8011ebe:	9204      	str	r2, [sp, #16]
 8011ec0:	9b04      	ldr	r3, [sp, #16]
 8011ec2:	2b63      	cmp	r3, #99	; 0x63
 8011ec4:	dc06      	bgt.n	8011ed4 <reset_init_mpu+0x34>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8011ec6:	bf00      	nop
 8011ec8:	9b04      	ldr	r3, [sp, #16]
 8011eca:	3301      	adds	r3, #1
 8011ecc:	9304      	str	r3, [sp, #16]
 8011ece:	9b04      	ldr	r3, [sp, #16]
 8011ed0:	2b63      	cmp	r3, #99	; 0x63
 8011ed2:	ddf8      	ble.n	8011ec6 <reset_init_mpu+0x26>
			PAL_STM32_OSPEED_MID1);

	for(int i = 0;i < 16;i++) {
		palClearPad(SCL_GPIO, SCL_PAD);
		delay_short();
		palSetPad(SCL_GPIO, SCL_PAD);
 8011ed4:	8301      	strh	r1, [r0, #24]
	return 1;
}
#endif

static void delay_short(void) {
	for (volatile int i = 0;i < 100;i++) {
 8011ed6:	9205      	str	r2, [sp, #20]
 8011ed8:	9b05      	ldr	r3, [sp, #20]
 8011eda:	2b63      	cmp	r3, #99	; 0x63
 8011edc:	dc06      	bgt.n	8011eec <reset_init_mpu+0x4c>
 8011ede:	bf00      	nop
 8011ee0:	9b05      	ldr	r3, [sp, #20]
 8011ee2:	3301      	adds	r3, #1
 8011ee4:	9305      	str	r3, [sp, #20]
 8011ee6:	9b05      	ldr	r3, [sp, #20]
 8011ee8:	2b63      	cmp	r3, #99	; 0x63
 8011eea:	ddf8      	ble.n	8011ede <reset_init_mpu+0x3e>

	palSetPadMode(SCL_GPIO, SCL_PAD,
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);

	for(int i = 0;i < 16;i++) {
 8011eec:	3c01      	subs	r4, #1
 8011eee:	d1e5      	bne.n	8011ebc <reset_init_mpu+0x1c>
	palSetPadMode(SCL_GPIO, SCL_PAD,
			PAL_MODE_ALTERNATE(GPIO_AF_I2C1) |
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);

	I2C_DEV.state = I2C_STOP;
 8011ef0:	4e5e      	ldr	r6, [pc, #376]	; (801206c <reset_init_mpu+0x1cc>)
		delay_short();
		palSetPad(SCL_GPIO, SCL_PAD);
		delay_short();
	}

	palSetPadMode(SCL_GPIO, SCL_PAD,
 8011ef2:	485d      	ldr	r0, [pc, #372]	; (8012068 <reset_init_mpu+0x1c8>)

	// Set clock source to gyro x
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_PWR_MGMT_1;
	tx_buf[1] = 0x01;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011ef4:	4f5e      	ldr	r7, [pc, #376]	; (8012070 <reset_init_mpu+0x1d0>)
	i2cStart(&I2C_DEV, &i2cfg);
	chThdSleepMicroseconds(1000);

	// Set clock source to gyro x
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_PWR_MGMT_1;
 8011ef6:	4d5f      	ldr	r5, [pc, #380]	; (8012074 <reset_init_mpu+0x1d4>)
	tx_buf[1] = 0x01;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011ef8:	f8df 8180 	ldr.w	r8, [pc, #384]	; 801207c <reset_init_mpu+0x1dc>
		delay_short();
		palSetPad(SCL_GPIO, SCL_PAD);
		delay_short();
	}

	palSetPadMode(SCL_GPIO, SCL_PAD,
 8011efc:	f240 220e 	movw	r2, #526	; 0x20e
 8011f00:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8011f04:	f7fd fe44 	bl	800fb90 <_pal_lld_setgroupmode>
			PAL_MODE_ALTERNATE(GPIO_AF_I2C1) |
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);

	I2C_DEV.state = I2C_STOP;
 8011f08:	f04f 0901 	mov.w	r9, #1
	i2cStart(&I2C_DEV, &i2cfg);
 8011f0c:	495a      	ldr	r1, [pc, #360]	; (8012078 <reset_init_mpu+0x1d8>)
	palSetPadMode(SCL_GPIO, SCL_PAD,
			PAL_MODE_ALTERNATE(GPIO_AF_I2C1) |
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);

	I2C_DEV.state = I2C_STOP;
 8011f0e:	f886 9000 	strb.w	r9, [r6]
	i2cStart(&I2C_DEV, &i2cfg);
 8011f12:	4630      	mov	r0, r6
 8011f14:	f7fc f80c 	bl	800df30 <i2cStart>
	chThdSleepMicroseconds(1000);
 8011f18:	200a      	movs	r0, #10
 8011f1a:	f7fb fbf1 	bl	800d700 <chThdSleep>

	// Set clock source to gyro x
	i2cAcquireBus(&I2C_DEV);
 8011f1e:	4630      	mov	r0, r6
 8011f20:	f7fc f836 	bl	800df90 <i2cAcquireBus>
	tx_buf[0] = MPU9150_PWR_MGMT_1;
	tx_buf[1] = 0x01;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f24:	8839      	ldrh	r1, [r7, #0]
 8011f26:	9401      	str	r4, [sp, #4]
 8011f28:	230a      	movs	r3, #10
	i2cStart(&I2C_DEV, &i2cfg);
	chThdSleepMicroseconds(1000);

	// Set clock source to gyro x
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_PWR_MGMT_1;
 8011f2a:	246b      	movs	r4, #107	; 0x6b
	tx_buf[1] = 0x01;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f2c:	9302      	str	r3, [sp, #8]
 8011f2e:	f8cd 8000 	str.w	r8, [sp]
 8011f32:	b289      	uxth	r1, r1
	i2cStart(&I2C_DEV, &i2cfg);
	chThdSleepMicroseconds(1000);

	// Set clock source to gyro x
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_PWR_MGMT_1;
 8011f34:	702c      	strb	r4, [r5, #0]
	tx_buf[1] = 0x01;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f36:	4630      	mov	r0, r6
 8011f38:	462a      	mov	r2, r5
 8011f3a:	2302      	movs	r3, #2
	chThdSleepMicroseconds(1000);

	// Set clock source to gyro x
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_PWR_MGMT_1;
	tx_buf[1] = 0x01;
 8011f3c:	f885 9001 	strb.w	r9, [r5, #1]
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f40:	f7fc f806 	bl	800df50 <i2cMasterTransmitTimeout>
 8011f44:	4604      	mov	r4, r0
	i2cReleaseBus(&I2C_DEV);
 8011f46:	4630      	mov	r0, r6
 8011f48:	f7fc f82a 	bl	800dfa0 <i2cReleaseBus>

	// Try the other address
	if (res != MSG_OK) {
 8011f4c:	b1fc      	cbz	r4, 8011f8e <reset_init_mpu+0xee>
		if (mpu_addr == MPU_ADDR1) {
 8011f4e:	883b      	ldrh	r3, [r7, #0]
		} else {
			mpu_addr = MPU_ADDR1;
		}

		// Set clock source to gyro x
		i2cAcquireBus(&I2C_DEV);
 8011f50:	4846      	ldr	r0, [pc, #280]	; (801206c <reset_init_mpu+0x1cc>)
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
	i2cReleaseBus(&I2C_DEV);

	// Try the other address
	if (res != MSG_OK) {
		if (mpu_addr == MPU_ADDR1) {
 8011f52:	b29b      	uxth	r3, r3
 8011f54:	2b68      	cmp	r3, #104	; 0x68
			mpu_addr = MPU_ADDR2;
 8011f56:	bf0c      	ite	eq
 8011f58:	2369      	moveq	r3, #105	; 0x69
		} else {
			mpu_addr = MPU_ADDR1;
 8011f5a:	2368      	movne	r3, #104	; 0x68
 8011f5c:	803b      	strh	r3, [r7, #0]
		}

		// Set clock source to gyro x
		i2cAcquireBus(&I2C_DEV);
 8011f5e:	f7fc f817 	bl	800df90 <i2cAcquireBus>
		tx_buf[0] = MPU9150_PWR_MGMT_1;
		tx_buf[1] = 0x01;
		res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f62:	8839      	ldrh	r1, [r7, #0]
 8011f64:	4841      	ldr	r0, [pc, #260]	; (801206c <reset_init_mpu+0x1cc>)
 8011f66:	f8cd 8000 	str.w	r8, [sp]
 8011f6a:	230a      	movs	r3, #10
 8011f6c:	9302      	str	r3, [sp, #8]
 8011f6e:	2200      	movs	r2, #0
			mpu_addr = MPU_ADDR1;
		}

		// Set clock source to gyro x
		i2cAcquireBus(&I2C_DEV);
		tx_buf[0] = MPU9150_PWR_MGMT_1;
 8011f70:	236b      	movs	r3, #107	; 0x6b
		tx_buf[1] = 0x01;
 8011f72:	2401      	movs	r4, #1
		res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f74:	9201      	str	r2, [sp, #4]
 8011f76:	b289      	uxth	r1, r1
			mpu_addr = MPU_ADDR1;
		}

		// Set clock source to gyro x
		i2cAcquireBus(&I2C_DEV);
		tx_buf[0] = MPU9150_PWR_MGMT_1;
 8011f78:	702b      	strb	r3, [r5, #0]
		tx_buf[1] = 0x01;
 8011f7a:	706c      	strb	r4, [r5, #1]
		res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f7c:	4a3d      	ldr	r2, [pc, #244]	; (8012074 <reset_init_mpu+0x1d4>)
 8011f7e:	2302      	movs	r3, #2
 8011f80:	f7fb ffe6 	bl	800df50 <i2cMasterTransmitTimeout>
 8011f84:	4604      	mov	r4, r0
		i2cReleaseBus(&I2C_DEV);
 8011f86:	4839      	ldr	r0, [pc, #228]	; (801206c <reset_init_mpu+0x1cc>)
 8011f88:	f7fc f80a 	bl	800dfa0 <i2cReleaseBus>

		if (res != MSG_OK) {
 8011f8c:	b9ec      	cbnz	r4, 8011fca <reset_init_mpu+0x12a>
			return 0;
		}
	}

	// Set accelerometer full-scale range to +/- 16g
	i2cAcquireBus(&I2C_DEV);
 8011f8e:	4837      	ldr	r0, [pc, #220]	; (801206c <reset_init_mpu+0x1cc>)
	tx_buf[0] = MPU9150_ACCEL_CONFIG;
 8011f90:	4c38      	ldr	r4, [pc, #224]	; (8012074 <reset_init_mpu+0x1d4>)
	tx_buf[1] = MPU9150_ACCEL_FS_16 << MPU9150_ACONFIG_AFS_SEL_BIT;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f92:	f8df a0dc 	ldr.w	sl, [pc, #220]	; 8012070 <reset_init_mpu+0x1d0>
 8011f96:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 801207c <reset_init_mpu+0x1dc>
			return 0;
		}
	}

	// Set accelerometer full-scale range to +/- 16g
	i2cAcquireBus(&I2C_DEV);
 8011f9a:	f7fb fff9 	bl	800df90 <i2cAcquireBus>
	tx_buf[0] = MPU9150_ACCEL_CONFIG;
	tx_buf[1] = MPU9150_ACCEL_FS_16 << MPU9150_ACONFIG_AFS_SEL_BIT;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011f9e:	8839      	ldrh	r1, [r7, #0]
 8011fa0:	4832      	ldr	r0, [pc, #200]	; (801206c <reset_init_mpu+0x1cc>)
 8011fa2:	f8cd 8000 	str.w	r8, [sp]
 8011fa6:	2300      	movs	r3, #0
 8011fa8:	9301      	str	r3, [sp, #4]
 8011faa:	260a      	movs	r6, #10
		}
	}

	// Set accelerometer full-scale range to +/- 16g
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_ACCEL_CONFIG;
 8011fac:	231c      	movs	r3, #28
	tx_buf[1] = MPU9150_ACCEL_FS_16 << MPU9150_ACONFIG_AFS_SEL_BIT;
 8011fae:	2718      	movs	r7, #24
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011fb0:	9602      	str	r6, [sp, #8]
 8011fb2:	b289      	uxth	r1, r1
		}
	}

	// Set accelerometer full-scale range to +/- 16g
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_ACCEL_CONFIG;
 8011fb4:	702b      	strb	r3, [r5, #0]
	tx_buf[1] = MPU9150_ACCEL_FS_16 << MPU9150_ACONFIG_AFS_SEL_BIT;
 8011fb6:	706f      	strb	r7, [r5, #1]
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011fb8:	4622      	mov	r2, r4
 8011fba:	2302      	movs	r3, #2
 8011fbc:	f7fb ffc8 	bl	800df50 <i2cMasterTransmitTimeout>
 8011fc0:	4605      	mov	r5, r0
	i2cReleaseBus(&I2C_DEV);
 8011fc2:	482a      	ldr	r0, [pc, #168]	; (801206c <reset_init_mpu+0x1cc>)
 8011fc4:	f7fb ffec 	bl	800dfa0 <i2cReleaseBus>

	if (res != MSG_OK) {
 8011fc8:	b11d      	cbz	r5, 8011fd2 <reset_init_mpu+0x132>
		tx_buf[1] = 0x01;
		res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
		i2cReleaseBus(&I2C_DEV);

		if (res != MSG_OK) {
			return 0;
 8011fca:	2000      	movs	r0, #0
		return 0;
	}
#endif

	return 1;
}
 8011fcc:	b006      	add	sp, #24
 8011fce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (res != MSG_OK) {
		return 0;
	}

	// Set gyroscope full-scale range to +/- 2000 deg/s
	i2cAcquireBus(&I2C_DEV);
 8011fd2:	4826      	ldr	r0, [pc, #152]	; (801206c <reset_init_mpu+0x1cc>)
 8011fd4:	f7fb ffdc 	bl	800df90 <i2cAcquireBus>
	tx_buf[0] = MPU9150_GYRO_CONFIG;
	tx_buf[1] = MPU9150_GYRO_FS_2000 << MPU9150_GCONFIG_FS_SEL_BIT;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011fd8:	f8ba 1000 	ldrh.w	r1, [sl]
 8011fdc:	9501      	str	r5, [sp, #4]
		return 0;
	}

	// Set gyroscope full-scale range to +/- 2000 deg/s
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_GYRO_CONFIG;
 8011fde:	251b      	movs	r5, #27
	tx_buf[1] = MPU9150_GYRO_FS_2000 << MPU9150_GCONFIG_FS_SEL_BIT;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011fe0:	f8cd 9000 	str.w	r9, [sp]
 8011fe4:	9602      	str	r6, [sp, #8]
 8011fe6:	b289      	uxth	r1, r1
		return 0;
	}

	// Set gyroscope full-scale range to +/- 2000 deg/s
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_GYRO_CONFIG;
 8011fe8:	7025      	strb	r5, [r4, #0]
	tx_buf[1] = MPU9150_GYRO_FS_2000 << MPU9150_GCONFIG_FS_SEL_BIT;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011fea:	4820      	ldr	r0, [pc, #128]	; (801206c <reset_init_mpu+0x1cc>)
	}

	// Set gyroscope full-scale range to +/- 2000 deg/s
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_GYRO_CONFIG;
	tx_buf[1] = MPU9150_GYRO_FS_2000 << MPU9150_GCONFIG_FS_SEL_BIT;
 8011fec:	7067      	strb	r7, [r4, #1]
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8011fee:	4622      	mov	r2, r4
 8011ff0:	2302      	movs	r3, #2
 8011ff2:	f7fb ffad 	bl	800df50 <i2cMasterTransmitTimeout>
 8011ff6:	4605      	mov	r5, r0
	i2cReleaseBus(&I2C_DEV);
 8011ff8:	481c      	ldr	r0, [pc, #112]	; (801206c <reset_init_mpu+0x1cc>)
 8011ffa:	f7fb ffd1 	bl	800dfa0 <i2cReleaseBus>

	if (res != MSG_OK) {
 8011ffe:	2d00      	cmp	r5, #0
 8012000:	d1e3      	bne.n	8011fca <reset_init_mpu+0x12a>
		return 0;
	}

	// Set low pass filter to 256Hz (1ms delay)
	i2cAcquireBus(&I2C_DEV);
 8012002:	481a      	ldr	r0, [pc, #104]	; (801206c <reset_init_mpu+0x1cc>)
 8012004:	f7fb ffc4 	bl	800df90 <i2cAcquireBus>
	tx_buf[0] = MPU9150_CONFIG;
	tx_buf[1] = MPU9150_DLPF_BW_256;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8012008:	f8ba 1000 	ldrh.w	r1, [sl]
 801200c:	f8cd 9000 	str.w	r9, [sp]
		return 0;
	}

	// Set low pass filter to 256Hz (1ms delay)
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_CONFIG;
 8012010:	271a      	movs	r7, #26
	tx_buf[1] = MPU9150_DLPF_BW_256;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8012012:	9501      	str	r5, [sp, #4]
 8012014:	9602      	str	r6, [sp, #8]
 8012016:	b289      	uxth	r1, r1
		return 0;
	}

	// Set low pass filter to 256Hz (1ms delay)
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_CONFIG;
 8012018:	7027      	strb	r7, [r4, #0]
	tx_buf[1] = MPU9150_DLPF_BW_256;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 801201a:	4814      	ldr	r0, [pc, #80]	; (801206c <reset_init_mpu+0x1cc>)
	}

	// Set low pass filter to 256Hz (1ms delay)
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_CONFIG;
	tx_buf[1] = MPU9150_DLPF_BW_256;
 801201c:	7065      	strb	r5, [r4, #1]
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 801201e:	4622      	mov	r2, r4
 8012020:	2302      	movs	r3, #2
 8012022:	f7fb ff95 	bl	800df50 <i2cMasterTransmitTimeout>
 8012026:	4607      	mov	r7, r0
	i2cReleaseBus(&I2C_DEV);
 8012028:	4810      	ldr	r0, [pc, #64]	; (801206c <reset_init_mpu+0x1cc>)
 801202a:	f7fb ffb9 	bl	800dfa0 <i2cReleaseBus>

	if (res != MSG_OK) {
 801202e:	2f00      	cmp	r7, #0
 8012030:	d1cb      	bne.n	8011fca <reset_init_mpu+0x12a>
		return 0;
	}

#if USE_MAGNETOMETER
	// Set the i2c bypass enable pin to true to access the magnetometer
	i2cAcquireBus(&I2C_DEV);
 8012032:	480e      	ldr	r0, [pc, #56]	; (801206c <reset_init_mpu+0x1cc>)
 8012034:	f7fb ffac 	bl	800df90 <i2cAcquireBus>
	tx_buf[0] = MPU9150_INT_PIN_CFG;
	tx_buf[1] = 0x02;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8012038:	f8ba 1000 	ldrh.w	r1, [sl]
 801203c:	9602      	str	r6, [sp, #8]

#if USE_MAGNETOMETER
	// Set the i2c bypass enable pin to true to access the magnetometer
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_INT_PIN_CFG;
	tx_buf[1] = 0x02;
 801203e:	2502      	movs	r5, #2
	}

#if USE_MAGNETOMETER
	// Set the i2c bypass enable pin to true to access the magnetometer
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_INT_PIN_CFG;
 8012040:	2637      	movs	r6, #55	; 0x37
	tx_buf[1] = 0x02;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8012042:	f8cd 9000 	str.w	r9, [sp]
 8012046:	9701      	str	r7, [sp, #4]
 8012048:	4622      	mov	r2, r4
 801204a:	b289      	uxth	r1, r1
 801204c:	462b      	mov	r3, r5

#if USE_MAGNETOMETER
	// Set the i2c bypass enable pin to true to access the magnetometer
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_INT_PIN_CFG;
	tx_buf[1] = 0x02;
 801204e:	7065      	strb	r5, [r4, #1]
	}

#if USE_MAGNETOMETER
	// Set the i2c bypass enable pin to true to access the magnetometer
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_INT_PIN_CFG;
 8012050:	7026      	strb	r6, [r4, #0]
	tx_buf[1] = 0x02;
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 8012052:	4806      	ldr	r0, [pc, #24]	; (801206c <reset_init_mpu+0x1cc>)
 8012054:	f7fb ff7c 	bl	800df50 <i2cMasterTransmitTimeout>
 8012058:	4604      	mov	r4, r0
	i2cReleaseBus(&I2C_DEV);
 801205a:	4804      	ldr	r0, [pc, #16]	; (801206c <reset_init_mpu+0x1cc>)
 801205c:	f7fb ffa0 	bl	800dfa0 <i2cReleaseBus>

	if (res != MSG_OK) {
 8012060:	fab4 f084 	clz	r0, r4
 8012064:	0940      	lsrs	r0, r0, #5
 8012066:	e7b1      	b.n	8011fcc <reset_init_mpu+0x12c>
 8012068:	40020400 	.word	0x40020400
 801206c:	20001460 	.word	0x20001460
 8012070:	20004550 	.word	0x20004550
 8012074:	20003ab4 	.word	0x20003ab4
 8012078:	08016c60 	.word	0x08016c60
 801207c:	200044ec 	.word	0x200044ec

08012080 <mpu_thread>:
	mag[1] = 0.0;
	mag[2] = 0.0;
#endif
}

static THD_FUNCTION(mpu_thread, arg) {
 8012080:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012084:	f8df b2b0 	ldr.w	fp, [pc, #688]	; 8012338 <mpu_thread+0x2b8>
 8012088:	4a9d      	ldr	r2, [pc, #628]	; (8012300 <mpu_thread+0x280>)
 801208a:	f8db 3018 	ldr.w	r3, [fp, #24]
 801208e:	b08d      	sub	sp, #52	; 0x34
 8012090:	619a      	str	r2, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8012092:	b672      	cpsid	i
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8012094:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8012098:	b662      	cpsie	i
	static int mag_cnt = MAG_DIV;
#endif
	static systime_t iteration_timer = 0;
	static int identical_reads = 0;

	iteration_timer = chVTGetSystemTime();
 801209a:	f8df 9298 	ldr.w	r9, [pc, #664]	; 8012334 <mpu_thread+0x2b4>
 801209e:	f8df a278 	ldr.w	sl, [pc, #632]	; 8012318 <mpu_thread+0x298>
 80120a2:	f8df 82a0 	ldr.w	r8, [pc, #672]	; 8012344 <mpu_thread+0x2c4>
 80120a6:	f8c9 3000 	str.w	r3, [r9]
}

static int get_raw_accel_gyro(int16_t* accel_gyro) {
	msg_t res = MSG_OK;

	tx_buf[0] = MPU9150_ACCEL_XOUT_H;
 80120aa:	4a96      	ldr	r2, [pc, #600]	; (8012304 <mpu_thread+0x284>)
	i2cAcquireBus(&I2C_DEV);
 80120ac:	4896      	ldr	r0, [pc, #600]	; (8012308 <mpu_thread+0x288>)
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 1, rx_buf, 14, MPU_I2C_TIMEOUT);
 80120ae:	4d97      	ldr	r5, [pc, #604]	; (801230c <mpu_thread+0x28c>)
}

static int get_raw_accel_gyro(int16_t* accel_gyro) {
	msg_t res = MSG_OK;

	tx_buf[0] = MPU9150_ACCEL_XOUT_H;
 80120b0:	233b      	movs	r3, #59	; 0x3b
 80120b2:	7013      	strb	r3, [r2, #0]
	i2cAcquireBus(&I2C_DEV);
 80120b4:	f7fb ff6c 	bl	800df90 <i2cAcquireBus>
	res = i2cMasterTransmitTimeout(&I2C_DEV, mpu_addr, tx_buf, 1, rx_buf, 14, MPU_I2C_TIMEOUT);
 80120b8:	4b95      	ldr	r3, [pc, #596]	; (8012310 <mpu_thread+0x290>)
 80120ba:	4893      	ldr	r0, [pc, #588]	; (8012308 <mpu_thread+0x288>)
 80120bc:	8819      	ldrh	r1, [r3, #0]
 80120be:	4b93      	ldr	r3, [pc, #588]	; (801230c <mpu_thread+0x28c>)
 80120c0:	9300      	str	r3, [sp, #0]
 80120c2:	260a      	movs	r6, #10
 80120c4:	230e      	movs	r3, #14
 80120c6:	9301      	str	r3, [sp, #4]
 80120c8:	b289      	uxth	r1, r1
 80120ca:	9602      	str	r6, [sp, #8]
 80120cc:	4a8d      	ldr	r2, [pc, #564]	; (8012304 <mpu_thread+0x284>)
 80120ce:	2301      	movs	r3, #1
 80120d0:	f7fb ff3e 	bl	800df50 <i2cMasterTransmitTimeout>
 80120d4:	4604      	mov	r4, r0
	i2cReleaseBus(&I2C_DEV);
 80120d6:	488c      	ldr	r0, [pc, #560]	; (8012308 <mpu_thread+0x288>)
 80120d8:	f7fb ff62 	bl	800dfa0 <i2cReleaseBus>

	if (res != MSG_OK) {
 80120dc:	2c00      	cmp	r4, #0
 80120de:	f040 809d 	bne.w	801221c <mpu_thread+0x19c>
		return 0;
	}

	// Acceleration
	for (int i = 0;i < 3; i++) {
		accel_gyro[i] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 80120e2:	f895 e000 	ldrb.w	lr, [r5]
				+ rx_buf[2 * i + 1]);
	}

	// Angular rate
	for (int i = 4;i < 7; i++) {
		accel_gyro[i - 1] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 80120e6:	7a69      	ldrb	r1, [r5, #9]
 80120e8:	7ae8      	ldrb	r0, [r5, #11]
 80120ea:	7b6a      	ldrb	r2, [r5, #13]
		return 0;
	}

	// Acceleration
	for (int i = 0;i < 3; i++) {
		accel_gyro[i] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 80120ec:	786b      	ldrb	r3, [r5, #1]
				+ rx_buf[2 * i + 1]);
	}

	// Angular rate
	for (int i = 4;i < 7; i++) {
		accel_gyro[i - 1] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 80120ee:	f895 c008 	ldrb.w	ip, [r5, #8]
 80120f2:	7aae      	ldrb	r6, [r5, #10]
 80120f4:	7b2f      	ldrb	r7, [r5, #12]
		return 0;
	}

	// Acceleration
	for (int i = 0;i < 3; i++) {
		accel_gyro[i] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 80120f6:	eb03 230e 	add.w	r3, r3, lr, lsl #8
				+ rx_buf[2 * i + 1]);
	}

	// Angular rate
	for (int i = 4;i < 7; i++) {
		accel_gyro[i - 1] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 80120fa:	eb01 2c0c 	add.w	ip, r1, ip, lsl #8
		return 0;
	}

	// Acceleration
	for (int i = 0;i < 3; i++) {
		accel_gyro[i] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 80120fe:	f895 e002 	ldrb.w	lr, [r5, #2]
 8012102:	78e9      	ldrb	r1, [r5, #3]
				+ rx_buf[2 * i + 1]);
	}

	// Angular rate
	for (int i = 4;i < 7; i++) {
		accel_gyro[i - 1] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 8012104:	eb00 2606 	add.w	r6, r0, r6, lsl #8
 8012108:	eb02 2707 	add.w	r7, r2, r7, lsl #8
		return 0;
	}

	// Acceleration
	for (int i = 0;i < 3; i++) {
		accel_gyro[i] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 801210c:	7928      	ldrb	r0, [r5, #4]
 801210e:	796a      	ldrb	r2, [r5, #5]
 8012110:	eb01 210e 	add.w	r1, r1, lr, lsl #8
 8012114:	eb02 2200 	add.w	r2, r2, r0, lsl #8
 8012118:	b29b      	uxth	r3, r3
				+ rx_buf[2 * i + 1]);
	}

	// Angular rate
	for (int i = 4;i < 7; i++) {
		accel_gyro[i - 1] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 801211a:	fa1f f58c 	uxth.w	r5, ip
 801211e:	b2b6      	uxth	r6, r6
 8012120:	b2bf      	uxth	r7, r7
		return 0;
	}

	// Acceleration
	for (int i = 0;i < 3; i++) {
		accel_gyro[i] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 8012122:	f8aa 1002 	strh.w	r1, [sl, #2]
 8012126:	f8aa 3000 	strh.w	r3, [sl]
				+ rx_buf[2 * i + 1]);
	}

	// Angular rate
	for (int i = 4;i < 7; i++) {
		accel_gyro[i - 1] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 801212a:	f8aa 5006 	strh.w	r5, [sl, #6]
 801212e:	f8aa 6008 	strh.w	r6, [sl, #8]
 8012132:	f8aa 700a 	strh.w	r7, [sl, #10]
		return 0;
	}

	// Acceleration
	for (int i = 0;i < 3; i++) {
		accel_gyro[i] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 8012136:	f8aa 2004 	strh.w	r2, [sl, #4]
 801213a:	f8df a1dc 	ldr.w	sl, [pc, #476]	; 8012318 <mpu_thread+0x298>
				+ rx_buf[2 * i + 1]);
	}

	// Angular rate
	for (int i = 4;i < 7; i++) {
		accel_gyro[i - 1] = ((int16_t) ((uint16_t) rx_buf[2 * i] << 8)
 801213e:	4620      	mov	r0, r4
 8012140:	4651      	mov	r1, sl

	for(;;) {
		if (get_raw_accel_gyro(raw_accel_gyro_mag_tmp)) {
			int is_identical = 1;
			for (int i = 0;i < 6;i++) {
				if (raw_accel_gyro_mag_tmp[i] != raw_accel_gyro_mag_no_offset[i]) {
 8012142:	f838 2010 	ldrh.w	r2, [r8, r0, lsl #1]
 8012146:	b21b      	sxth	r3, r3
 8012148:	b212      	sxth	r2, r2
 801214a:	429a      	cmp	r2, r3
	iteration_timer = chVTGetSystemTime();

	for(;;) {
		if (get_raw_accel_gyro(raw_accel_gyro_mag_tmp)) {
			int is_identical = 1;
			for (int i = 0;i < 6;i++) {
 801214c:	f100 0001 	add.w	r0, r0, #1
				if (raw_accel_gyro_mag_tmp[i] != raw_accel_gyro_mag_no_offset[i]) {
 8012150:	d178      	bne.n	8012244 <mpu_thread+0x1c4>
	iteration_timer = chVTGetSystemTime();

	for(;;) {
		if (get_raw_accel_gyro(raw_accel_gyro_mag_tmp)) {
			int is_identical = 1;
			for (int i = 0;i < 6;i++) {
 8012152:	2806      	cmp	r0, #6
 8012154:	d002      	beq.n	801215c <mpu_thread+0xdc>
 8012156:	f831 3f02 	ldrh.w	r3, [r1, #2]!
 801215a:	e7f2      	b.n	8012142 <mpu_thread+0xc2>
					break;
				}
			}

			if (is_identical) {
				identical_reads++;
 801215c:	4b6d      	ldr	r3, [pc, #436]	; (8012314 <mpu_thread+0x294>)
 801215e:	4a6d      	ldr	r2, [pc, #436]	; (8012314 <mpu_thread+0x294>)
 8012160:	681b      	ldr	r3, [r3, #0]
 8012162:	3301      	adds	r3, #1
			} else {
				identical_reads = 0;
			}

			if (identical_reads >= MAX_IDENTICAL_READS) {
 8012164:	2b04      	cmp	r3, #4
					break;
				}
			}

			if (is_identical) {
				identical_reads++;
 8012166:	6013      	str	r3, [r2, #0]
			} else {
				identical_reads = 0;
			}

			if (identical_reads >= MAX_IDENTICAL_READS) {
 8012168:	dc67      	bgt.n	801223a <mpu_thread+0x1ba>
				failed_reads++;
				chThdSleepMicroseconds(FAIL_DELAY_US);
				reset_init_mpu();
				iteration_timer = chVTGetSystemTime();
			} else {
				memcpy((uint16_t*)raw_accel_gyro_mag_no_offset, raw_accel_gyro_mag_tmp, sizeof(raw_accel_gyro_mag));
 801216a:	4c6b      	ldr	r4, [pc, #428]	; (8012318 <mpu_thread+0x298>)
 801216c:	f8df c1d4 	ldr.w	ip, [pc, #468]	; 8012344 <mpu_thread+0x2c4>
				raw_accel_gyro_mag_tmp[3] -= mpu9150_gyro_offsets[0];
				raw_accel_gyro_mag_tmp[4] -= mpu9150_gyro_offsets[1];
				raw_accel_gyro_mag_tmp[5] -= mpu9150_gyro_offsets[2];
				memcpy((uint16_t*)raw_accel_gyro_mag, raw_accel_gyro_mag_tmp, sizeof(raw_accel_gyro_mag));
 8012170:	f8df e1d4 	ldr.w	lr, [pc, #468]	; 8012348 <mpu_thread+0x2c8>
				failed_reads++;
				chThdSleepMicroseconds(FAIL_DELAY_US);
				reset_init_mpu();
				iteration_timer = chVTGetSystemTime();
			} else {
				memcpy((uint16_t*)raw_accel_gyro_mag_no_offset, raw_accel_gyro_mag_tmp, sizeof(raw_accel_gyro_mag));
 8012174:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8012176:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801217a:	46a2      	mov	sl, r4
 801217c:	f85a 3910 	ldr.w	r3, [sl], #-16
 8012180:	f8ac 3000 	strh.w	r3, [ip]
				raw_accel_gyro_mag_tmp[3] -= mpu9150_gyro_offsets[0];
 8012184:	4b65      	ldr	r3, [pc, #404]	; (801231c <mpu_thread+0x29c>)
 8012186:	8819      	ldrh	r1, [r3, #0]
				raw_accel_gyro_mag_tmp[4] -= mpu9150_gyro_offsets[1];
 8012188:	885a      	ldrh	r2, [r3, #2]
				raw_accel_gyro_mag_tmp[5] -= mpu9150_gyro_offsets[2];
 801218a:	889b      	ldrh	r3, [r3, #4]
				chThdSleepMicroseconds(FAIL_DELAY_US);
				reset_init_mpu();
				iteration_timer = chVTGetSystemTime();
			} else {
				memcpy((uint16_t*)raw_accel_gyro_mag_no_offset, raw_accel_gyro_mag_tmp, sizeof(raw_accel_gyro_mag));
				raw_accel_gyro_mag_tmp[3] -= mpu9150_gyro_offsets[0];
 801218c:	1a6d      	subs	r5, r5, r1
				raw_accel_gyro_mag_tmp[4] -= mpu9150_gyro_offsets[1];
 801218e:	1ab6      	subs	r6, r6, r2
				raw_accel_gyro_mag_tmp[5] -= mpu9150_gyro_offsets[2];
 8012190:	1aff      	subs	r7, r7, r3
				chThdSleepMicroseconds(FAIL_DELAY_US);
				reset_init_mpu();
				iteration_timer = chVTGetSystemTime();
			} else {
				memcpy((uint16_t*)raw_accel_gyro_mag_no_offset, raw_accel_gyro_mag_tmp, sizeof(raw_accel_gyro_mag));
				raw_accel_gyro_mag_tmp[3] -= mpu9150_gyro_offsets[0];
 8012192:	f824 5c0a 	strh.w	r5, [r4, #-10]
				raw_accel_gyro_mag_tmp[4] -= mpu9150_gyro_offsets[1];
 8012196:	f8aa 6008 	strh.w	r6, [sl, #8]
				raw_accel_gyro_mag_tmp[5] -= mpu9150_gyro_offsets[2];
 801219a:	f8aa 700a 	strh.w	r7, [sl, #10]
				memcpy((uint16_t*)raw_accel_gyro_mag, raw_accel_gyro_mag_tmp, sizeof(raw_accel_gyro_mag));
 801219e:	4655      	mov	r5, sl
 80121a0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80121a2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80121a6:	6823      	ldr	r3, [r4, #0]
 80121a8:	f8ae 3000 	strh.w	r3, [lr]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80121ac:	b672      	cpsid	i
 80121ae:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80121b2:	b662      	cpsie	i

				update_time_diff = chVTGetSystemTime() - last_update_time;
 80121b4:	4a5a      	ldr	r2, [pc, #360]	; (8012320 <mpu_thread+0x2a0>)
 80121b6:	6812      	ldr	r2, [r2, #0]
 80121b8:	1a9b      	subs	r3, r3, r2
 80121ba:	4a5a      	ldr	r2, [pc, #360]	; (8012324 <mpu_thread+0x2a4>)
 80121bc:	6013      	str	r3, [r2, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80121be:	b672      	cpsid	i
 80121c0:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80121c4:	b662      	cpsie	i
				last_update_time = chVTGetSystemTime();

				if (read_callback) {
 80121c6:	4b58      	ldr	r3, [pc, #352]	; (8012328 <mpu_thread+0x2a8>)
				raw_accel_gyro_mag_tmp[4] -= mpu9150_gyro_offsets[1];
				raw_accel_gyro_mag_tmp[5] -= mpu9150_gyro_offsets[2];
				memcpy((uint16_t*)raw_accel_gyro_mag, raw_accel_gyro_mag_tmp, sizeof(raw_accel_gyro_mag));

				update_time_diff = chVTGetSystemTime() - last_update_time;
				last_update_time = chVTGetSystemTime();
 80121c8:	4955      	ldr	r1, [pc, #340]	; (8012320 <mpu_thread+0x2a0>)

				if (read_callback) {
 80121ca:	681b      	ldr	r3, [r3, #0]
				raw_accel_gyro_mag_tmp[4] -= mpu9150_gyro_offsets[1];
				raw_accel_gyro_mag_tmp[5] -= mpu9150_gyro_offsets[2];
				memcpy((uint16_t*)raw_accel_gyro_mag, raw_accel_gyro_mag_tmp, sizeof(raw_accel_gyro_mag));

				update_time_diff = chVTGetSystemTime() - last_update_time;
				last_update_time = chVTGetSystemTime();
 80121cc:	600a      	str	r2, [r1, #0]

				if (read_callback) {
 80121ce:	b103      	cbz	r3, 80121d2 <mpu_thread+0x152>
					read_callback();
 80121d0:	4798      	blx	r3
				}

#if USE_MAGNETOMETER
				mag_cnt++;
 80121d2:	4b56      	ldr	r3, [pc, #344]	; (801232c <mpu_thread+0x2ac>)
 80121d4:	4a55      	ldr	r2, [pc, #340]	; (801232c <mpu_thread+0x2ac>)
 80121d6:	681b      	ldr	r3, [r3, #0]
 80121d8:	3301      	adds	r3, #1
				if (mag_cnt >= MAG_DIV) {
 80121da:	2b09      	cmp	r3, #9
				if (read_callback) {
					read_callback();
				}

#if USE_MAGNETOMETER
				mag_cnt++;
 80121dc:	6013      	str	r3, [r2, #0]
				if (mag_cnt >= MAG_DIV) {
 80121de:	dc35      	bgt.n	801224c <mpu_thread+0x1cc>
						chThdSleepMicroseconds(FAIL_DELAY_US);
						reset_init_mpu();
						iteration_timer = chVTGetSystemTime();
					}
				} else {
					mag_updated = 0;
 80121e0:	4953      	ldr	r1, [pc, #332]	; (8012330 <mpu_thread+0x2b0>)
 80121e2:	f8d9 3000 	ldr.w	r3, [r9]
 80121e6:	2200      	movs	r2, #0
 80121e8:	600a      	str	r2, [r1, #0]
			chThdSleepMicroseconds(FAIL_DELAY_US);
			reset_init_mpu();
			iteration_timer = chVTGetSystemTime();
		}

		iteration_timer += US2ST(ITERATION_TIME_US);
 80121ea:	330a      	adds	r3, #10
 80121ec:	f8c9 3000 	str.w	r3, [r9]
 80121f0:	4c50      	ldr	r4, [pc, #320]	; (8012334 <mpu_thread+0x2b4>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80121f2:	b672      	cpsid	i
 80121f4:	4d50      	ldr	r5, [pc, #320]	; (8012338 <mpu_thread+0x2b8>)
 80121f6:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80121fa:	b662      	cpsie	i
		systime_t time_start = chVTGetSystemTime();
		if (iteration_timer > time_start) {
 80121fc:	f8d9 0000 	ldr.w	r0, [r9]
 8012200:	4283      	cmp	r3, r0
 8012202:	d203      	bcs.n	801220c <mpu_thread+0x18c>
			chThdSleep(iteration_timer - time_start);
 8012204:	1ac0      	subs	r0, r0, r3
 8012206:	f7fb fa7b 	bl	800d700 <chThdSleep>
 801220a:	e74e      	b.n	80120aa <mpu_thread+0x2a>
		} else {
			chThdSleepMicroseconds(MIN_ITERATION_DELAY_US);
 801220c:	2005      	movs	r0, #5
 801220e:	f7fb fa77 	bl	800d700 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8012212:	b672      	cpsid	i
 8012214:	6aab      	ldr	r3, [r5, #40]	; 0x28
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8012216:	b662      	cpsie	i
			iteration_timer = chVTGetSystemTime();
 8012218:	6023      	str	r3, [r4, #0]
 801221a:	e746      	b.n	80120aa <mpu_thread+0x2a>
					mag_updated = 0;
				}
#endif
			}
		} else {
			failed_reads++;
 801221c:	4b47      	ldr	r3, [pc, #284]	; (801233c <mpu_thread+0x2bc>)
 801221e:	681b      	ldr	r3, [r3, #0]
			chThdSleepMicroseconds(FAIL_DELAY_US);
 8012220:	4630      	mov	r0, r6
					mag_updated = 0;
				}
#endif
			}
		} else {
			failed_reads++;
 8012222:	3301      	adds	r3, #1
 8012224:	4a45      	ldr	r2, [pc, #276]	; (801233c <mpu_thread+0x2bc>)
 8012226:	6013      	str	r3, [r2, #0]
			chThdSleepMicroseconds(FAIL_DELAY_US);
 8012228:	f7fb fa6a 	bl	800d700 <chThdSleep>
			reset_init_mpu();
 801222c:	f7ff fe38 	bl	8011ea0 <reset_init_mpu>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8012230:	b672      	cpsid	i
 8012232:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8012236:	b662      	cpsie	i
 8012238:	e7d7      	b.n	80121ea <mpu_thread+0x16a>
			} else {
				identical_reads = 0;
			}

			if (identical_reads >= MAX_IDENTICAL_READS) {
				failed_reads++;
 801223a:	4b40      	ldr	r3, [pc, #256]	; (801233c <mpu_thread+0x2bc>)
 801223c:	681b      	ldr	r3, [r3, #0]
				chThdSleepMicroseconds(FAIL_DELAY_US);
 801223e:	200a      	movs	r0, #10
			} else {
				identical_reads = 0;
			}

			if (identical_reads >= MAX_IDENTICAL_READS) {
				failed_reads++;
 8012240:	3301      	adds	r3, #1
 8012242:	e7ef      	b.n	8012224 <mpu_thread+0x1a4>
			}

			if (is_identical) {
				identical_reads++;
			} else {
				identical_reads = 0;
 8012244:	4a33      	ldr	r2, [pc, #204]	; (8012314 <mpu_thread+0x294>)
 8012246:	2300      	movs	r3, #0
 8012248:	6013      	str	r3, [r2, #0]
 801224a:	e78e      	b.n	801216a <mpu_thread+0xea>
				}

#if USE_MAGNETOMETER
				mag_cnt++;
				if (mag_cnt >= MAG_DIV) {
					mag_cnt = 0;
 801224c:	2100      	movs	r1, #0
 801224e:	6011      	str	r1, [r2, #0]

#if USE_MAGNETOMETER
static int get_raw_mag(int16_t* mag) {
	msg_t res = MSG_OK;

	tx_buf[0] = MPU9150_HXL;
 8012250:	4c2c      	ldr	r4, [pc, #176]	; (8012304 <mpu_thread+0x284>)

#if USE_MAGNETOMETER
				mag_cnt++;
				if (mag_cnt >= MAG_DIV) {
					mag_cnt = 0;
					mag_updated = 1;
 8012252:	4a37      	ldr	r2, [pc, #220]	; (8012330 <mpu_thread+0x2b0>)
#if USE_MAGNETOMETER
static int get_raw_mag(int16_t* mag) {
	msg_t res = MSG_OK;

	tx_buf[0] = MPU9150_HXL;
	i2cAcquireBus(&I2C_DEV);
 8012254:	482c      	ldr	r0, [pc, #176]	; (8012308 <mpu_thread+0x288>)
	res = i2cMasterTransmitTimeout(&I2C_DEV, 0x0C, tx_buf, 1, rx_buf, 6, MPU_I2C_TIMEOUT);
 8012256:	4f2d      	ldr	r7, [pc, #180]	; (801230c <mpu_thread+0x28c>)

#if USE_MAGNETOMETER
static int get_raw_mag(int16_t* mag) {
	msg_t res = MSG_OK;

	tx_buf[0] = MPU9150_HXL;
 8012258:	2303      	movs	r3, #3

#if USE_MAGNETOMETER
				mag_cnt++;
				if (mag_cnt >= MAG_DIV) {
					mag_cnt = 0;
					mag_updated = 1;
 801225a:	2501      	movs	r5, #1
 801225c:	6015      	str	r5, [r2, #0]

#if USE_MAGNETOMETER
static int get_raw_mag(int16_t* mag) {
	msg_t res = MSG_OK;

	tx_buf[0] = MPU9150_HXL;
 801225e:	7023      	strb	r3, [r4, #0]
	i2cAcquireBus(&I2C_DEV);
	res = i2cMasterTransmitTimeout(&I2C_DEV, 0x0C, tx_buf, 1, rx_buf, 6, MPU_I2C_TIMEOUT);
 8012260:	260a      	movs	r6, #10
#if USE_MAGNETOMETER
static int get_raw_mag(int16_t* mag) {
	msg_t res = MSG_OK;

	tx_buf[0] = MPU9150_HXL;
	i2cAcquireBus(&I2C_DEV);
 8012262:	f7fb fe95 	bl	800df90 <i2cAcquireBus>
	res = i2cMasterTransmitTimeout(&I2C_DEV, 0x0C, tx_buf, 1, rx_buf, 6, MPU_I2C_TIMEOUT);
 8012266:	2106      	movs	r1, #6
 8012268:	4b28      	ldr	r3, [pc, #160]	; (801230c <mpu_thread+0x28c>)
 801226a:	9300      	str	r3, [sp, #0]
 801226c:	4622      	mov	r2, r4
 801226e:	462b      	mov	r3, r5
 8012270:	9101      	str	r1, [sp, #4]
 8012272:	9602      	str	r6, [sp, #8]
 8012274:	210c      	movs	r1, #12
 8012276:	4824      	ldr	r0, [pc, #144]	; (8012308 <mpu_thread+0x288>)
 8012278:	f7fb fe6a 	bl	800df50 <i2cMasterTransmitTimeout>
 801227c:	9005      	str	r0, [sp, #20]
	i2cReleaseBus(&I2C_DEV);
 801227e:	4822      	ldr	r0, [pc, #136]	; (8012308 <mpu_thread+0x288>)
 8012280:	f7fb fe8e 	bl	800dfa0 <i2cReleaseBus>

	if (res != MSG_OK) {
 8012284:	9b05      	ldr	r3, [sp, #20]
 8012286:	2b00      	cmp	r3, #0
 8012288:	d134      	bne.n	80122f4 <mpu_thread+0x274>
		return 0;
	}

	for (int i = 0; i < 3; i++) {
		mag[i] = ((int16_t) ((uint16_t) rx_buf[2 * i + 1] << 8) + rx_buf[2 * i]);
 801228a:	787a      	ldrb	r2, [r7, #1]
 801228c:	9206      	str	r2, [sp, #24]
 801228e:	783a      	ldrb	r2, [r7, #0]
 8012290:	9207      	str	r2, [sp, #28]
 8012292:	78fa      	ldrb	r2, [r7, #3]
 8012294:	9208      	str	r2, [sp, #32]
 8012296:	78ba      	ldrb	r2, [r7, #2]
 8012298:	9209      	str	r2, [sp, #36]	; 0x24
 801229a:	797a      	ldrb	r2, [r7, #5]
	}

	// Start the measurement for the next iteration
	i2cAcquireBus(&I2C_DEV);
 801229c:	481a      	ldr	r0, [pc, #104]	; (8012308 <mpu_thread+0x288>)
	if (res != MSG_OK) {
		return 0;
	}

	for (int i = 0; i < 3; i++) {
		mag[i] = ((int16_t) ((uint16_t) rx_buf[2 * i + 1] << 8) + rx_buf[2 * i]);
 801229e:	920a      	str	r2, [sp, #40]	; 0x28
 80122a0:	793a      	ldrb	r2, [r7, #4]
 80122a2:	920b      	str	r2, [sp, #44]	; 0x2c
	}

	// Start the measurement for the next iteration
	i2cAcquireBus(&I2C_DEV);
 80122a4:	f7fb fe74 	bl	800df90 <i2cAcquireBus>
	tx_buf[0] = MPU9150_CNTL;
	tx_buf[1] = 0x01;
	res = i2cMasterTransmitTimeout(&I2C_DEV, 0x0C, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 80122a8:	9b05      	ldr	r3, [sp, #20]
 80122aa:	9301      	str	r3, [sp, #4]
 80122ac:	9700      	str	r7, [sp, #0]
 80122ae:	9602      	str	r6, [sp, #8]
 80122b0:	4622      	mov	r2, r4
		mag[i] = ((int16_t) ((uint16_t) rx_buf[2 * i + 1] << 8) + rx_buf[2 * i]);
	}

	// Start the measurement for the next iteration
	i2cAcquireBus(&I2C_DEV);
	tx_buf[0] = MPU9150_CNTL;
 80122b2:	7026      	strb	r6, [r4, #0]
	tx_buf[1] = 0x01;
 80122b4:	7065      	strb	r5, [r4, #1]
	res = i2cMasterTransmitTimeout(&I2C_DEV, 0x0C, tx_buf, 2, rx_buf, 0, MPU_I2C_TIMEOUT);
 80122b6:	4814      	ldr	r0, [pc, #80]	; (8012308 <mpu_thread+0x288>)
 80122b8:	210c      	movs	r1, #12
 80122ba:	2302      	movs	r3, #2
 80122bc:	f7fb fe48 	bl	800df50 <i2cMasterTransmitTimeout>
 80122c0:	4604      	mov	r4, r0
	i2cReleaseBus(&I2C_DEV);
 80122c2:	4811      	ldr	r0, [pc, #68]	; (8012308 <mpu_thread+0x288>)
 80122c4:	f7fb fe6c 	bl	800dfa0 <i2cReleaseBus>

	if (res != MSG_OK) {
 80122c8:	b9a4      	cbnz	r4, 80122f4 <mpu_thread+0x274>
	if (res != MSG_OK) {
		return 0;
	}

	for (int i = 0; i < 3; i++) {
		mag[i] = ((int16_t) ((uint16_t) rx_buf[2 * i + 1] << 8) + rx_buf[2 * i]);
 80122ca:	9b07      	ldr	r3, [sp, #28]
 80122cc:	9a06      	ldr	r2, [sp, #24]
 80122ce:	980a      	ldr	r0, [sp, #40]	; 0x28
 80122d0:	eb03 2102 	add.w	r1, r3, r2, lsl #8
 80122d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80122d6:	9a08      	ldr	r2, [sp, #32]
					mag_updated = 1;

					int16_t raw_mag_tmp[3];

					if (get_raw_mag(raw_mag_tmp)) {
						memcpy((uint16_t*)raw_accel_gyro_mag_tmp + 6, raw_mag_tmp, sizeof(raw_mag_tmp));
 80122d8:	f8aa 100c 	strh.w	r1, [sl, #12]
	if (res != MSG_OK) {
		return 0;
	}

	for (int i = 0; i < 3; i++) {
		mag[i] = ((int16_t) ((uint16_t) rx_buf[2 * i + 1] << 8) + rx_buf[2 * i]);
 80122dc:	eb03 2202 	add.w	r2, r3, r2, lsl #8
 80122e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
					mag_updated = 1;

					int16_t raw_mag_tmp[3];

					if (get_raw_mag(raw_mag_tmp)) {
						memcpy((uint16_t*)raw_accel_gyro_mag_tmp + 6, raw_mag_tmp, sizeof(raw_mag_tmp));
 80122e2:	f8aa 200e 	strh.w	r2, [sl, #14]
	if (res != MSG_OK) {
		return 0;
	}

	for (int i = 0; i < 3; i++) {
		mag[i] = ((int16_t) ((uint16_t) rx_buf[2 * i + 1] << 8) + rx_buf[2 * i]);
 80122e6:	eb03 2300 	add.w	r3, r3, r0, lsl #8
					mag_updated = 1;

					int16_t raw_mag_tmp[3];

					if (get_raw_mag(raw_mag_tmp)) {
						memcpy((uint16_t*)raw_accel_gyro_mag_tmp + 6, raw_mag_tmp, sizeof(raw_mag_tmp));
 80122ea:	f8aa 3010 	strh.w	r3, [sl, #16]
 80122ee:	f8d9 3000 	ldr.w	r3, [r9]
 80122f2:	e77a      	b.n	80121ea <mpu_thread+0x16a>
					} else {
						failed_mag_reads++;
 80122f4:	4b12      	ldr	r3, [pc, #72]	; (8012340 <mpu_thread+0x2c0>)
 80122f6:	4a12      	ldr	r2, [pc, #72]	; (8012340 <mpu_thread+0x2c0>)
 80122f8:	681b      	ldr	r3, [r3, #0]
						chThdSleepMicroseconds(FAIL_DELAY_US);
 80122fa:	200a      	movs	r0, #10
					int16_t raw_mag_tmp[3];

					if (get_raw_mag(raw_mag_tmp)) {
						memcpy((uint16_t*)raw_accel_gyro_mag_tmp + 6, raw_mag_tmp, sizeof(raw_mag_tmp));
					} else {
						failed_mag_reads++;
 80122fc:	3301      	adds	r3, #1
 80122fe:	e792      	b.n	8012226 <mpu_thread+0x1a6>
 8012300:	08016b20 	.word	0x08016b20
 8012304:	20003ab4 	.word	0x20003ab4
 8012308:	20001460 	.word	0x20001460
 801230c:	200044ec 	.word	0x200044ec
 8012310:	20004550 	.word	0x20004550
 8012314:	20003b30 	.word	0x20003b30
 8012318:	200044d8 	.word	0x200044d8
 801231c:	20003aac 	.word	0x20003aac
 8012320:	20003b2c 	.word	0x20003b2c
 8012324:	20003aa8 	.word	0x20003aa8
 8012328:	200044d0 	.word	0x200044d0
 801232c:	20000838 	.word	0x20000838
 8012330:	200044d4 	.word	0x200044d4
 8012334:	20003a8c 	.word	0x20003a8c
 8012338:	200010b8 	.word	0x200010b8
 801233c:	20003aa4 	.word	0x20003aa4
 8012340:	20003a88 	.word	0x20003a88
 8012344:	20003b18 	.word	0x20003b18
 8012348:	20003a90 	.word	0x20003a90
 801234c:	00000000 	.word	0x00000000

08012350 <mpu9150_init>:
static THD_FUNCTION(mpu_thread, arg);

// Function pointers
static void(*read_callback)(void) = 0;

void mpu9150_init(void) {
 8012350:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	last_update_time = 0;
	update_time_diff = 0;
	mag_updated = 0;
	mpu_addr = MPU_ADDR1;

	memset((void*)mpu9150_gyro_offsets, 0, sizeof(mpu9150_gyro_offsets));
 8012354:	4b23      	ldr	r3, [pc, #140]	; (80123e4 <mpu9150_init+0x94>)

void mpu9150_init(void) {
	failed_reads = 0;
	failed_mag_reads = 0;
	read_callback = 0;
	last_update_time = 0;
 8012356:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 8012404 <mpu9150_init+0xb4>
	update_time_diff = 0;
 801235a:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 8012408 <mpu9150_init+0xb8>
	mag_updated = 0;
	mpu_addr = MPU_ADDR1;
 801235e:	4a22      	ldr	r2, [pc, #136]	; (80123e8 <mpu9150_init+0x98>)
	memset((void*)mpu9150_gyro_offsets, 0, sizeof(mpu9150_gyro_offsets));

	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);

	// I2C configuration
	palSetPadMode(SCL_GPIO, SCL_PAD,
 8012360:	4d22      	ldr	r5, [pc, #136]	; (80123ec <mpu9150_init+0x9c>)

// Function pointers
static void(*read_callback)(void) = 0;

void mpu9150_init(void) {
	failed_reads = 0;
 8012362:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 801240c <mpu9150_init+0xbc>
	failed_mag_reads = 0;
 8012366:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8012410 <mpu9150_init+0xc0>
	read_callback = 0;
	last_update_time = 0;
	update_time_diff = 0;
	mag_updated = 0;
 801236a:	4f21      	ldr	r7, [pc, #132]	; (80123f0 <mpu9150_init+0xa0>)
static void(*read_callback)(void) = 0;

void mpu9150_init(void) {
	failed_reads = 0;
	failed_mag_reads = 0;
	read_callback = 0;
 801236c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8012414 <mpu9150_init+0xc4>

// Function pointers
static void(*read_callback)(void) = 0;

void mpu9150_init(void) {
	failed_reads = 0;
 8012370:	2400      	movs	r4, #0
static THD_FUNCTION(mpu_thread, arg);

// Function pointers
static void(*read_callback)(void) = 0;

void mpu9150_init(void) {
 8012372:	b082      	sub	sp, #8
	last_update_time = 0;
	update_time_diff = 0;
	mag_updated = 0;
	mpu_addr = MPU_ADDR1;

	memset((void*)mpu9150_gyro_offsets, 0, sizeof(mpu9150_gyro_offsets));
 8012374:	601c      	str	r4, [r3, #0]
 8012376:	809c      	strh	r4, [r3, #4]
	failed_mag_reads = 0;
	read_callback = 0;
	last_update_time = 0;
	update_time_diff = 0;
	mag_updated = 0;
	mpu_addr = MPU_ADDR1;
 8012378:	2668      	movs	r6, #104	; 0x68

	memset((void*)mpu9150_gyro_offsets, 0, sizeof(mpu9150_gyro_offsets));

	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 801237a:	2002      	movs	r0, #2
 801237c:	2101      	movs	r1, #1

// Function pointers
static void(*read_callback)(void) = 0;

void mpu9150_init(void) {
	failed_reads = 0;
 801237e:	f8ca 4000 	str.w	r4, [sl]
	failed_mag_reads = 0;
	read_callback = 0;
 8012382:	f8c9 4000 	str.w	r4, [r9]
// Function pointers
static void(*read_callback)(void) = 0;

void mpu9150_init(void) {
	failed_reads = 0;
	failed_mag_reads = 0;
 8012386:	f8c8 4000 	str.w	r4, [r8]
	read_callback = 0;
	last_update_time = 0;
 801238a:	f8cc 4000 	str.w	r4, [ip]
	update_time_diff = 0;
 801238e:	f8ce 4000 	str.w	r4, [lr]
	mag_updated = 0;
 8012392:	603c      	str	r4, [r7, #0]
	mpu_addr = MPU_ADDR1;
 8012394:	8016      	strh	r6, [r2, #0]

	memset((void*)mpu9150_gyro_offsets, 0, sizeof(mpu9150_gyro_offsets));

	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8012396:	f000 fb83 	bl	8012aa0 <RCC_AHB1PeriphClockCmd>

	// I2C configuration
	palSetPadMode(SCL_GPIO, SCL_PAD,
 801239a:	4628      	mov	r0, r5
 801239c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80123a0:	f240 220e 	movw	r2, #526	; 0x20e
 80123a4:	f7fd fbf4 	bl	800fb90 <_pal_lld_setgroupmode>
			PAL_MODE_ALTERNATE(GPIO_AF_I2C1) |
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);
	palSetPadMode(SDA_GPIO, SDA_PAD,
 80123a8:	4628      	mov	r0, r5
 80123aa:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80123ae:	f240 220e 	movw	r2, #526	; 0x20e
 80123b2:	f7fd fbed 	bl	800fb90 <_pal_lld_setgroupmode>
			PAL_MODE_ALTERNATE(GPIO_AF_I2C1) |
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);
	chThdSleepMilliseconds(10);
 80123b6:	2064      	movs	r0, #100	; 0x64
 80123b8:	f7fb f9a2 	bl	800d700 <chThdSleep>

	I2C_DEV.state = I2C_STOP;
 80123bc:	4b0d      	ldr	r3, [pc, #52]	; (80123f4 <mpu9150_init+0xa4>)
	i2cStart(&I2C_DEV, &i2cfg);
 80123be:	490e      	ldr	r1, [pc, #56]	; (80123f8 <mpu9150_init+0xa8>)
			PAL_MODE_ALTERNATE(GPIO_AF_I2C1) |
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);
	chThdSleepMilliseconds(10);

	I2C_DEV.state = I2C_STOP;
 80123c0:	2201      	movs	r2, #1
	i2cStart(&I2C_DEV, &i2cfg);
 80123c2:	4618      	mov	r0, r3
			PAL_MODE_ALTERNATE(GPIO_AF_I2C1) |
			PAL_STM32_OTYPE_OPENDRAIN |
			PAL_STM32_OSPEED_MID1);
	chThdSleepMilliseconds(10);

	I2C_DEV.state = I2C_STOP;
 80123c4:	701a      	strb	r2, [r3, #0]
	i2cStart(&I2C_DEV, &i2cfg);
 80123c6:	f7fb fdb3 	bl	800df30 <i2cStart>

	reset_init_mpu();
 80123ca:	f7ff fd69 	bl	8011ea0 <reset_init_mpu>

	chThdCreateStatic(mpu_thread_wa, sizeof(mpu_thread_wa), NORMALPRIO + 1,
 80123ce:	9400      	str	r4, [sp, #0]
 80123d0:	4b0a      	ldr	r3, [pc, #40]	; (80123fc <mpu9150_init+0xac>)
 80123d2:	480b      	ldr	r0, [pc, #44]	; (8012400 <mpu9150_init+0xb0>)
 80123d4:	f640 1198 	movw	r1, #2456	; 0x998
 80123d8:	2241      	movs	r2, #65	; 0x41
 80123da:	f7fb f951 	bl	800d680 <chThdCreateStatic>
			mpu_thread, NULL );
}
 80123de:	b002      	add	sp, #8
 80123e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80123e4:	20003aac 	.word	0x20003aac
 80123e8:	20004550 	.word	0x20004550
 80123ec:	40020400 	.word	0x40020400
 80123f0:	200044d4 	.word	0x200044d4
 80123f4:	20001460 	.word	0x20001460
 80123f8:	08016c60 	.word	0x08016c60
 80123fc:	08012081 	.word	0x08012081
 8012400:	20003b38 	.word	0x20003b38
 8012404:	20003b2c 	.word	0x20003b2c
 8012408:	20003aa8 	.word	0x20003aa8
 801240c:	20003aa4 	.word	0x20003aa4
 8012410:	20003a88 	.word	0x20003a88
 8012414:	200044d0 	.word	0x200044d0
	...

08012420 <mpu9150_sample_gyro_offsets>:
			"Offset Y: %d\r\n"
			"Offset Z: %d\r\n\r\n",
			mpu9150_gyro_offsets[0], mpu9150_gyro_offsets[1], mpu9150_gyro_offsets[2]);
}

void mpu9150_sample_gyro_offsets(uint32_t iteratons) {
 8012420:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8012424:	b085      	sub	sp, #20
	int32_t offsets[3];
	memset(offsets, 0, sizeof(offsets));
 8012426:	2400      	movs	r4, #0
 8012428:	9401      	str	r4, [sp, #4]
 801242a:	9402      	str	r4, [sp, #8]
 801242c:	9403      	str	r4, [sp, #12]

	for(uint32_t i = 0;i < iteratons;i++) {
 801242e:	4607      	mov	r7, r0
 8012430:	b350      	cbz	r0, 8012488 <mpu9150_sample_gyro_offsets+0x68>
 8012432:	f8df 9060 	ldr.w	r9, [pc, #96]	; 8012494 <mpu9150_sample_gyro_offsets+0x74>
 8012436:	4625      	mov	r5, r4
 8012438:	4626      	mov	r6, r4
 801243a:	46a0      	mov	r8, r4
		offsets[0] += raw_accel_gyro_mag_no_offset[3];
 801243c:	f8b9 1006 	ldrh.w	r1, [r9, #6]
		offsets[1] += raw_accel_gyro_mag_no_offset[4];
 8012440:	f8b9 2008 	ldrh.w	r2, [r9, #8]
		offsets[2] += raw_accel_gyro_mag_no_offset[5];
 8012444:	f8b9 300a 	ldrh.w	r3, [r9, #10]
void mpu9150_sample_gyro_offsets(uint32_t iteratons) {
	int32_t offsets[3];
	memset(offsets, 0, sizeof(offsets));

	for(uint32_t i = 0;i < iteratons;i++) {
		offsets[0] += raw_accel_gyro_mag_no_offset[3];
 8012448:	fa06 f681 	sxtah	r6, r6, r1
		offsets[1] += raw_accel_gyro_mag_no_offset[4];
 801244c:	fa05 f582 	sxtah	r5, r5, r2
		offsets[2] += raw_accel_gyro_mag_no_offset[5];
 8012450:	fa04 f483 	sxtah	r4, r4, r3

void mpu9150_sample_gyro_offsets(uint32_t iteratons) {
	int32_t offsets[3];
	memset(offsets, 0, sizeof(offsets));

	for(uint32_t i = 0;i < iteratons;i++) {
 8012454:	f108 0801 	add.w	r8, r8, #1
		offsets[0] += raw_accel_gyro_mag_no_offset[3];
		offsets[1] += raw_accel_gyro_mag_no_offset[4];
		offsets[2] += raw_accel_gyro_mag_no_offset[5];
		chThdSleepMilliseconds(10);
 8012458:	2064      	movs	r0, #100	; 0x64
void mpu9150_sample_gyro_offsets(uint32_t iteratons) {
	int32_t offsets[3];
	memset(offsets, 0, sizeof(offsets));

	for(uint32_t i = 0;i < iteratons;i++) {
		offsets[0] += raw_accel_gyro_mag_no_offset[3];
 801245a:	9601      	str	r6, [sp, #4]
		offsets[1] += raw_accel_gyro_mag_no_offset[4];
 801245c:	9502      	str	r5, [sp, #8]
		offsets[2] += raw_accel_gyro_mag_no_offset[5];
 801245e:	9403      	str	r4, [sp, #12]
		chThdSleepMilliseconds(10);
 8012460:	f7fb f94e 	bl	800d700 <chThdSleep>

void mpu9150_sample_gyro_offsets(uint32_t iteratons) {
	int32_t offsets[3];
	memset(offsets, 0, sizeof(offsets));

	for(uint32_t i = 0;i < iteratons;i++) {
 8012464:	45b8      	cmp	r8, r7
 8012466:	d1e9      	bne.n	801243c <mpu9150_sample_gyro_offsets+0x1c>

	offsets[0] /= (int32_t)iteratons;
	offsets[1] /= (int32_t)iteratons;
	offsets[2] /= (int32_t)iteratons;

	mpu9150_gyro_offsets[0] = offsets[0];
 8012468:	4b09      	ldr	r3, [pc, #36]	; (8012490 <mpu9150_sample_gyro_offsets+0x70>)
		offsets[1] += raw_accel_gyro_mag_no_offset[4];
		offsets[2] += raw_accel_gyro_mag_no_offset[5];
		chThdSleepMilliseconds(10);
	}

	offsets[0] /= (int32_t)iteratons;
 801246a:	fb96 f6f7 	sdiv	r6, r6, r7
	offsets[1] /= (int32_t)iteratons;
 801246e:	fb95 f5f7 	sdiv	r5, r5, r7
	offsets[2] /= (int32_t)iteratons;

	mpu9150_gyro_offsets[0] = offsets[0];
 8012472:	b2b6      	uxth	r6, r6
	mpu9150_gyro_offsets[1] = offsets[1];
 8012474:	b2ad      	uxth	r5, r5
		chThdSleepMilliseconds(10);
	}

	offsets[0] /= (int32_t)iteratons;
	offsets[1] /= (int32_t)iteratons;
	offsets[2] /= (int32_t)iteratons;
 8012476:	fb94 f4f7 	sdiv	r4, r4, r7

	mpu9150_gyro_offsets[0] = offsets[0];
	mpu9150_gyro_offsets[1] = offsets[1];
	mpu9150_gyro_offsets[2] = offsets[2];
 801247a:	b2a4      	uxth	r4, r4

	offsets[0] /= (int32_t)iteratons;
	offsets[1] /= (int32_t)iteratons;
	offsets[2] /= (int32_t)iteratons;

	mpu9150_gyro_offsets[0] = offsets[0];
 801247c:	801e      	strh	r6, [r3, #0]
	mpu9150_gyro_offsets[1] = offsets[1];
 801247e:	805d      	strh	r5, [r3, #2]
	mpu9150_gyro_offsets[2] = offsets[2];
 8012480:	809c      	strh	r4, [r3, #4]
}
 8012482:	b005      	add	sp, #20
 8012484:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

void mpu9150_sample_gyro_offsets(uint32_t iteratons) {
	int32_t offsets[3];
	memset(offsets, 0, sizeof(offsets));

	for(uint32_t i = 0;i < iteratons;i++) {
 8012488:	4604      	mov	r4, r0
 801248a:	4605      	mov	r5, r0
 801248c:	4606      	mov	r6, r0
 801248e:	e7eb      	b.n	8012468 <mpu9150_sample_gyro_offsets+0x48>
 8012490:	20003aac 	.word	0x20003aac
 8012494:	20003b18 	.word	0x20003b18
	...

080124a0 <led_init>:

#include "led.h"
#include "ch.h"
#include "hal.h"

void led_init(void) {
 80124a0:	b510      	push	{r4, lr}
	palSetPadMode(GPIOE, 0,
 80124a2:	4c09      	ldr	r4, [pc, #36]	; (80124c8 <led_init+0x28>)
 80124a4:	2101      	movs	r1, #1
 80124a6:	4620      	mov	r0, r4
 80124a8:	2219      	movs	r2, #25
 80124aa:	f7fd fb71 	bl	800fb90 <_pal_lld_setgroupmode>
			PAL_MODE_OUTPUT_PUSHPULL |
			PAL_STM32_OSPEED_HIGHEST);
	palSetPadMode(GPIOE, 1,
 80124ae:	2219      	movs	r2, #25
 80124b0:	4620      	mov	r0, r4
 80124b2:	2102      	movs	r1, #2
 80124b4:	f7fd fb6c 	bl	800fb90 <_pal_lld_setgroupmode>
}

void led_write(int num, int state) {
	switch (num) {
	case LED_RED:
		palWritePad(GPIOE, 0, state);
 80124b8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
		break;

	case LED_GREEN:
		palWritePad(GPIOE, 1, state);
 80124bc:	f44f 3300 	mov.w	r3, #131072	; 0x20000
}

void led_write(int num, int state) {
	switch (num) {
	case LED_RED:
		palWritePad(GPIOE, 0, state);
 80124c0:	61a2      	str	r2, [r4, #24]
		break;

	case LED_GREEN:
		palWritePad(GPIOE, 1, state);
 80124c2:	61a3      	str	r3, [r4, #24]
 80124c4:	bd10      	pop	{r4, pc}
 80124c6:	bf00      	nop
 80124c8:	40021000 	.word	0x40021000
 80124cc:	00000000 	.word	0x00000000

080124d0 <led_write>:
	led_write(LED_RED, 0);
	led_write(LED_GREEN, 0);
}

void led_write(int num, int state) {
	switch (num) {
 80124d0:	b168      	cbz	r0, 80124ee <led_write+0x1e>
 80124d2:	2801      	cmp	r0, #1
 80124d4:	d10a      	bne.n	80124ec <led_write+0x1c>
	case LED_RED:
		palWritePad(GPIOE, 0, state);
		break;

	case LED_GREEN:
		palWritePad(GPIOE, 1, state);
 80124d6:	f011 0101 	ands.w	r1, r1, #1
 80124da:	bf0c      	ite	eq
 80124dc:	f44f 3300 	moveq.w	r3, #131072	; 0x20000
 80124e0:	2300      	movne	r3, #0
 80124e2:	4a08      	ldr	r2, [pc, #32]	; (8012504 <led_write+0x34>)
 80124e4:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
 80124e8:	6191      	str	r1, [r2, #24]
 80124ea:	4770      	bx	lr
 80124ec:	4770      	bx	lr
}

void led_write(int num, int state) {
	switch (num) {
	case LED_RED:
		palWritePad(GPIOE, 0, state);
 80124ee:	f011 0101 	ands.w	r1, r1, #1
 80124f2:	bf0c      	ite	eq
 80124f4:	f44f 3280 	moveq.w	r2, #65536	; 0x10000
 80124f8:	2200      	movne	r2, #0
 80124fa:	4b02      	ldr	r3, [pc, #8]	; (8012504 <led_write+0x34>)
 80124fc:	4311      	orrs	r1, r2
 80124fe:	6199      	str	r1, [r3, #24]
		break;
 8012500:	4770      	bx	lr
 8012502:	bf00      	nop
 8012504:	40021000 	.word	0x40021000
	...

08012510 <led_toggle>:
		break;
	}
}

void led_toggle(int num) {
	switch (num) {
 8012510:	b140      	cbz	r0, 8012524 <led_toggle+0x14>
 8012512:	2801      	cmp	r0, #1
 8012514:	d105      	bne.n	8012522 <led_toggle+0x12>
	case LED_RED:
		palTogglePad(GPIOE, 0);
		break;

	case LED_GREEN:
		palTogglePad(GPIOE, 1);
 8012516:	4a06      	ldr	r2, [pc, #24]	; (8012530 <led_toggle+0x20>)
 8012518:	6953      	ldr	r3, [r2, #20]
 801251a:	f083 0302 	eor.w	r3, r3, #2
 801251e:	6153      	str	r3, [r2, #20]
 8012520:	4770      	bx	lr
 8012522:	4770      	bx	lr
}

void led_toggle(int num) {
	switch (num) {
	case LED_RED:
		palTogglePad(GPIOE, 0);
 8012524:	4a02      	ldr	r2, [pc, #8]	; (8012530 <led_toggle+0x20>)
 8012526:	6953      	ldr	r3, [r2, #20]
 8012528:	f083 0301 	eor.w	r3, r3, #1
 801252c:	6153      	str	r3, [r2, #20]
		break;
 801252e:	4770      	bx	lr
 8012530:	40021000 	.word	0x40021000
	...

08012540 <ext_cb_init>:
				{EXT_CH_MODE_DISABLED, NULL}
		}
};

void ext_cb_init(void) {
	extStart(&EXTD1, &extcfg);
 8012540:	4801      	ldr	r0, [pc, #4]	; (8012548 <ext_cb_init+0x8>)
 8012542:	4902      	ldr	r1, [pc, #8]	; (801254c <ext_cb_init+0xc>)
 8012544:	f7fb bcc4 	b.w	800ded0 <extStart>
 8012548:	200013f0 	.word	0x200013f0
 801254c:	08016c70 	.word	0x08016c70

08012550 <crc16>:
		0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16(unsigned char *buf, unsigned int len) {
	unsigned int i;
	unsigned short cksum = 0;
	for (i = 0; i < len; i++) {
 8012550:	b191      	cbz	r1, 8012578 <crc16+0x28>
		0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b,
		0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0,
		0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
		0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16(unsigned char *buf, unsigned int len) {
 8012552:	b470      	push	{r4, r5, r6}
 8012554:	4e09      	ldr	r6, [pc, #36]	; (801257c <crc16+0x2c>)
 8012556:	1845      	adds	r5, r0, r1
	unsigned int i;
	unsigned short cksum = 0;
	for (i = 0; i < len; i++) {
 8012558:	2300      	movs	r3, #0
		cksum = crc16_tab[(((cksum >> 8) ^ *buf++) & 0xFF)] ^ (cksum << 8);
 801255a:	f810 2b01 	ldrb.w	r2, [r0], #1
 801255e:	f3c3 240f 	ubfx	r4, r3, #8, #16
 8012562:	4062      	eors	r2, r4
		0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16(unsigned char *buf, unsigned int len) {
	unsigned int i;
	unsigned short cksum = 0;
	for (i = 0; i < len; i++) {
 8012564:	42a8      	cmp	r0, r5
		cksum = crc16_tab[(((cksum >> 8) ^ *buf++) & 0xFF)] ^ (cksum << 8);
 8012566:	f836 1012 	ldrh.w	r1, [r6, r2, lsl #1]
 801256a:	ea81 2303 	eor.w	r3, r1, r3, lsl #8
 801256e:	b29b      	uxth	r3, r3
		0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16(unsigned char *buf, unsigned int len) {
	unsigned int i;
	unsigned short cksum = 0;
	for (i = 0; i < len; i++) {
 8012570:	d1f3      	bne.n	801255a <crc16+0xa>
		cksum = crc16_tab[(((cksum >> 8) ^ *buf++) & 0xFF)] ^ (cksum << 8);
	}
	return cksum;
}
 8012572:	4618      	mov	r0, r3
 8012574:	bc70      	pop	{r4, r5, r6}
 8012576:	4770      	bx	lr
 8012578:	4608      	mov	r0, r1
 801257a:	4770      	bx	lr
 801257c:	08016d30 	.word	0x08016d30

08012580 <adconv_init>:
		ADC_SQR3_SQ6_N(ADC_CHANNEL_IN4)  | ADC_SQR3_SQ5_N(ADC_CHANNEL_IN13) |
		ADC_SQR3_SQ4_N(ADC_CHANNEL_IN12) | ADC_SQR3_SQ3_N(ADC_CHANNEL_IN11) |
		ADC_SQR3_SQ2_N(ADC_CHANNEL_IN10) | ADC_SQR3_SQ1_N(ADC_CHANNEL_IN4)
};

void adconv_init(void) {
 8012580:	b570      	push	{r4, r5, r6, lr}
	palSetPadMode(GPIOA, 4, PAL_MODE_INPUT_ANALOG);
	palSetPadMode(GPIOC, 0, PAL_MODE_INPUT_ANALOG);
 8012582:	4c14      	ldr	r4, [pc, #80]	; (80125d4 <adconv_init+0x54>)
		ADC_SQR3_SQ4_N(ADC_CHANNEL_IN12) | ADC_SQR3_SQ3_N(ADC_CHANNEL_IN11) |
		ADC_SQR3_SQ2_N(ADC_CHANNEL_IN10) | ADC_SQR3_SQ1_N(ADC_CHANNEL_IN4)
};

void adconv_init(void) {
	palSetPadMode(GPIOA, 4, PAL_MODE_INPUT_ANALOG);
 8012584:	4814      	ldr	r0, [pc, #80]	; (80125d8 <adconv_init+0x58>)
	palSetPadMode(GPIOC, 0, PAL_MODE_INPUT_ANALOG);
	palSetPadMode(GPIOC, 1, PAL_MODE_INPUT_ANALOG);
	palSetPadMode(GPIOC, 2, PAL_MODE_INPUT_ANALOG);
	palSetPadMode(GPIOC, 3, PAL_MODE_INPUT_ANALOG);

	adcStart(&ADCD1, NULL);
 8012586:	4d15      	ldr	r5, [pc, #84]	; (80125dc <adconv_init+0x5c>)
		ADC_SQR3_SQ4_N(ADC_CHANNEL_IN12) | ADC_SQR3_SQ3_N(ADC_CHANNEL_IN11) |
		ADC_SQR3_SQ2_N(ADC_CHANNEL_IN10) | ADC_SQR3_SQ1_N(ADC_CHANNEL_IN4)
};

void adconv_init(void) {
	palSetPadMode(GPIOA, 4, PAL_MODE_INPUT_ANALOG);
 8012588:	2110      	movs	r1, #16
 801258a:	2203      	movs	r2, #3
 801258c:	f7fd fb00 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOC, 0, PAL_MODE_INPUT_ANALOG);
 8012590:	4620      	mov	r0, r4
 8012592:	2101      	movs	r1, #1
 8012594:	2203      	movs	r2, #3
 8012596:	f7fd fafb 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOC, 1, PAL_MODE_INPUT_ANALOG);
 801259a:	4620      	mov	r0, r4
 801259c:	2102      	movs	r1, #2
 801259e:	2203      	movs	r2, #3
 80125a0:	f7fd faf6 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOC, 2, PAL_MODE_INPUT_ANALOG);
 80125a4:	4620      	mov	r0, r4
 80125a6:	2104      	movs	r1, #4
 80125a8:	2203      	movs	r2, #3
 80125aa:	f7fd faf1 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOC, 3, PAL_MODE_INPUT_ANALOG);
 80125ae:	2203      	movs	r2, #3
 80125b0:	4620      	mov	r0, r4
 80125b2:	2108      	movs	r1, #8
 80125b4:	f7fd faec 	bl	800fb90 <_pal_lld_setgroupmode>

	adcStart(&ADCD1, NULL);
 80125b8:	4628      	mov	r0, r5
 80125ba:	2100      	movs	r1, #0
 80125bc:	f7fb fc28 	bl	800de10 <adcStart>
	adcSTM32EnableTSVREFE();
 80125c0:	f7fc fe2e 	bl	800f220 <adcSTM32EnableTSVREFE>

	adcStartConversion(&ADCD1, &adcgrpcfg, samples, ADC_GRP_BUF_DEPTH);
 80125c4:	4628      	mov	r0, r5
 80125c6:	4906      	ldr	r1, [pc, #24]	; (80125e0 <adconv_init+0x60>)
 80125c8:	4a06      	ldr	r2, [pc, #24]	; (80125e4 <adconv_init+0x64>)
 80125ca:	2301      	movs	r3, #1
}
 80125cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	palSetPadMode(GPIOC, 3, PAL_MODE_INPUT_ANALOG);

	adcStart(&ADCD1, NULL);
	adcSTM32EnableTSVREFE();

	adcStartConversion(&ADCD1, &adcgrpcfg, samples, ADC_GRP_BUF_DEPTH);
 80125d0:	f7fb bc2e 	b.w	800de30 <adcStartConversion>
 80125d4:	40020800 	.word	0x40020800
 80125d8:	40020000 	.word	0x40020000
 80125dc:	200013bc 	.word	0x200013bc
 80125e0:	08016f30 	.word	0x08016f30
 80125e4:	20004554 	.word	0x20004554
	...

080125f0 <send_packet>:
	commands_set_send_func(comm_usb_send_packet);
	commands_process_packet(data, len);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
	chSequentialStreamWrite(&SDU1, buffer, len);
 80125f0:	4b05      	ldr	r3, [pc, #20]	; (8012608 <send_packet+0x18>)
static void process_packet(unsigned char *data, unsigned int len) {
	commands_set_send_func(comm_usb_send_packet);
	commands_process_packet(data, len);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
 80125f2:	b410      	push	{r4}
	chSequentialStreamWrite(&SDU1, buffer, len);
 80125f4:	681c      	ldr	r4, [r3, #0]
 80125f6:	6824      	ldr	r4, [r4, #0]
static void process_packet(unsigned char *data, unsigned int len) {
	commands_set_send_func(comm_usb_send_packet);
	commands_process_packet(data, len);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
 80125f8:	460a      	mov	r2, r1
	chSequentialStreamWrite(&SDU1, buffer, len);
 80125fa:	4601      	mov	r1, r0
 80125fc:	4618      	mov	r0, r3
 80125fe:	4623      	mov	r3, r4
}
 8012600:	f85d 4b04 	ldr.w	r4, [sp], #4
	commands_set_send_func(comm_usb_send_packet);
	commands_process_packet(data, len);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
	chSequentialStreamWrite(&SDU1, buffer, len);
 8012604:	4718      	bx	r3
 8012606:	bf00      	nop
 8012608:	20002104 	.word	0x20002104
 801260c:	00000000 	.word	0x00000000

08012610 <serial_process_thread>:
 8012610:	4b11      	ldr	r3, [pc, #68]	; (8012658 <serial_process_thread+0x48>)
static THD_FUNCTION(serial_process_thread, arg) {
	(void)arg;

	chRegSetThreadName("USB-Serial process");

	process_tp = chThdGetSelfX();
 8012612:	4a12      	ldr	r2, [pc, #72]	; (801265c <serial_process_thread+0x4c>)
 8012614:	699b      	ldr	r3, [r3, #24]
 8012616:	4c12      	ldr	r4, [pc, #72]	; (8012660 <serial_process_thread+0x50>)
 8012618:	4912      	ldr	r1, [pc, #72]	; (8012664 <serial_process_thread+0x54>)
 801261a:	4e13      	ldr	r6, [pc, #76]	; (8012668 <serial_process_thread+0x58>)
			had_data = 0;
		}
	}
}

static THD_FUNCTION(serial_process_thread, arg) {
 801261c:	b580      	push	{r7, lr}
 801261e:	4f13      	ldr	r7, [pc, #76]	; (801266c <serial_process_thread+0x5c>)
 8012620:	6199      	str	r1, [r3, #24]
	(void)arg;

	chRegSetThreadName("USB-Serial process");

	process_tp = chThdGetSelfX();
 8012622:	6013      	str	r3, [r2, #0]

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while (serial_rx_read_pos != serial_rx_write_pos) {
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8012624:	46a1      	mov	r9, r4
	chRegSetThreadName("USB-Serial process");

	process_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);
 8012626:	2001      	movs	r0, #1
 8012628:	f7fb fa2a 	bl	800da80 <chEvtWaitAny>

		while (serial_rx_read_pos != serial_rx_write_pos) {
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 801262c:	f04f 0800 	mov.w	r8, #0
 8012630:	6823      	ldr	r3, [r4, #0]
	process_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while (serial_rx_read_pos != serial_rx_write_pos) {
 8012632:	6832      	ldr	r2, [r6, #0]
 8012634:	429a      	cmp	r2, r3
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8012636:	f103 0501 	add.w	r5, r3, #1
 801263a:	f04f 0100 	mov.w	r1, #0
	process_tp = chThdGetSelfX();

	for(;;) {
		chEvtWaitAny((eventmask_t) 1);

		while (serial_rx_read_pos != serial_rx_write_pos) {
 801263e:	d0f2      	beq.n	8012626 <serial_process_thread+0x16>
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8012640:	5cf8      	ldrb	r0, [r7, r3]
 8012642:	6025      	str	r5, [r4, #0]
 8012644:	f000 f904 	bl	8012850 <packet_process_byte>

			if (serial_rx_read_pos == SERIAL_RX_BUFFER_SIZE) {
 8012648:	6823      	ldr	r3, [r4, #0]
 801264a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 801264e:	d1f0      	bne.n	8012632 <serial_process_thread+0x22>
				serial_rx_read_pos = 0;
 8012650:	f8c9 8000 	str.w	r8, [r9]
 8012654:	e7ec      	b.n	8012630 <serial_process_thread+0x20>
 8012656:	bf00      	nop
 8012658:	200010b8 	.word	0x200010b8
 801265c:	200062ac 	.word	0x200062ac
 8012660:	200062a8 	.word	0x200062a8
 8012664:	08016f60 	.word	0x08016f60
 8012668:	20004564 	.word	0x20004564
 801266c:	20005710 	.word	0x20005710

08012670 <serial_read_thread>:
	chMtxLock(&send_mutex);
	packet_send_packet(data, len, PACKET_HANDLER);
	chMtxUnlock(&send_mutex);
}

static THD_FUNCTION(serial_read_thread, arg) {
 8012670:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8012674:	4b15      	ldr	r3, [pc, #84]	; (80126cc <serial_read_thread+0x5c>)
 8012676:	4a16      	ldr	r2, [pc, #88]	; (80126d0 <serial_read_thread+0x60>)
 8012678:	699b      	ldr	r3, [r3, #24]
 801267a:	4f16      	ldr	r7, [pc, #88]	; (80126d4 <serial_read_thread+0x64>)
 801267c:	4e16      	ldr	r6, [pc, #88]	; (80126d8 <serial_read_thread+0x68>)
 801267e:	f8df 905c 	ldr.w	r9, [pc, #92]	; 80126dc <serial_read_thread+0x6c>
 8012682:	f8df 805c 	ldr.w	r8, [pc, #92]	; 80126e0 <serial_read_thread+0x70>
 8012686:	619a      	str	r2, [r3, #24]
 8012688:	b0a1      	sub	sp, #132	; 0x84
	int i;
	int len;
	int had_data = 0;

	for(;;) {
		len = chSequentialStreamRead(&SDU1, (uint8_t*) buffer, 1);
 801268a:	683b      	ldr	r3, [r7, #0]
 801268c:	4811      	ldr	r0, [pc, #68]	; (80126d4 <serial_read_thread+0x64>)
 801268e:	685b      	ldr	r3, [r3, #4]
 8012690:	4669      	mov	r1, sp
 8012692:	2201      	movs	r2, #1
 8012694:	4798      	blx	r3

		for (i = 0;i < len;i++) {
 8012696:	2800      	cmp	r0, #0
 8012698:	ddf7      	ble.n	801268a <serial_read_thread+0x1a>
 801269a:	6833      	ldr	r3, [r6, #0]
 801269c:	f10d 34ff 	add.w	r4, sp, #4294967295	; 0xffffffff
 80126a0:	2200      	movs	r2, #0
			serial_rx_buffer[serial_rx_write_pos++] = buffer[i];
 80126a2:	1c59      	adds	r1, r3, #1

			if (serial_rx_write_pos == SERIAL_RX_BUFFER_SIZE) {
				serial_rx_write_pos = 0;
 80126a4:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
	int had_data = 0;

	for(;;) {
		len = chSequentialStreamRead(&SDU1, (uint8_t*) buffer, 1);

		for (i = 0;i < len;i++) {
 80126a8:	f102 0201 	add.w	r2, r2, #1
			serial_rx_buffer[serial_rx_write_pos++] = buffer[i];
 80126ac:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 80126b0:	f809 5003 	strb.w	r5, [r9, r3]

			if (serial_rx_write_pos == SERIAL_RX_BUFFER_SIZE) {
				serial_rx_write_pos = 0;
 80126b4:	bf14      	ite	ne
 80126b6:	460b      	movne	r3, r1
 80126b8:	2300      	moveq	r3, #0
	int had_data = 0;

	for(;;) {
		len = chSequentialStreamRead(&SDU1, (uint8_t*) buffer, 1);

		for (i = 0;i < len;i++) {
 80126ba:	4282      	cmp	r2, r0
 80126bc:	dbf1      	blt.n	80126a2 <serial_read_thread+0x32>

			had_data = 1;
		}

		if (had_data) {
			chEvtSignal(process_tp, (eventmask_t) 1);
 80126be:	f8d8 0000 	ldr.w	r0, [r8]
 80126c2:	6033      	str	r3, [r6, #0]
 80126c4:	2101      	movs	r1, #1
 80126c6:	f7fb f9d3 	bl	800da70 <chEvtSignal>
 80126ca:	e7de      	b.n	801268a <serial_read_thread+0x1a>
 80126cc:	200010b8 	.word	0x200010b8
 80126d0:	08016f74 	.word	0x08016f74
 80126d4:	20002104 	.word	0x20002104
 80126d8:	20004564 	.word	0x20004564
 80126dc:	20005710 	.word	0x20005710
 80126e0:	200062ac 	.word	0x200062ac
	...

080126f0 <process_packet>:
			}
		}
	}
}

static void process_packet(unsigned char *data, unsigned int len) {
 80126f0:	b538      	push	{r3, r4, r5, lr}
 80126f2:	4605      	mov	r5, r0
 80126f4:	460c      	mov	r4, r1
	commands_set_send_func(comm_usb_send_packet);
 80126f6:	4804      	ldr	r0, [pc, #16]	; (8012708 <process_packet+0x18>)
 80126f8:	f000 f952 	bl	80129a0 <commands_set_send_func>
	commands_process_packet(data, len);
 80126fc:	4628      	mov	r0, r5
 80126fe:	4621      	mov	r1, r4
}
 8012700:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	}
}

static void process_packet(unsigned char *data, unsigned int len) {
	commands_set_send_func(comm_usb_send_packet);
	commands_process_packet(data, len);
 8012704:	f000 b954 	b.w	80129b0 <commands_process_packet>
 8012708:	08012711 	.word	0x08012711
 801270c:	00000000 	.word	0x00000000

08012710 <comm_usb_send_packet>:
	// Threads
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
	chThdCreateStatic(serial_process_thread_wa, sizeof(serial_process_thread_wa), NORMALPRIO, serial_process_thread, NULL);
}

void comm_usb_send_packet(unsigned char *data, unsigned int len) {
 8012710:	b570      	push	{r4, r5, r6, lr}
	chMtxLock(&send_mutex);
 8012712:	4c08      	ldr	r4, [pc, #32]	; (8012734 <comm_usb_send_packet+0x24>)
	// Threads
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
	chThdCreateStatic(serial_process_thread_wa, sizeof(serial_process_thread_wa), NORMALPRIO, serial_process_thread, NULL);
}

void comm_usb_send_packet(unsigned char *data, unsigned int len) {
 8012714:	4606      	mov	r6, r0
 8012716:	460d      	mov	r5, r1
	chMtxLock(&send_mutex);
 8012718:	4620      	mov	r0, r4
 801271a:	f7fb f941 	bl	800d9a0 <chMtxLock>
	packet_send_packet(data, len, PACKET_HANDLER);
 801271e:	4630      	mov	r0, r6
 8012720:	4629      	mov	r1, r5
 8012722:	2200      	movs	r2, #0
 8012724:	f000 f84c 	bl	80127c0 <packet_send_packet>
	chMtxUnlock(&send_mutex);
 8012728:	4620      	mov	r0, r4
}
 801272a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
}

void comm_usb_send_packet(unsigned char *data, unsigned int len) {
	chMtxLock(&send_mutex);
	packet_send_packet(data, len, PACKET_HANDLER);
	chMtxUnlock(&send_mutex);
 801272e:	f7fb b93f 	b.w	800d9b0 <chMtxUnlock>
 8012732:	bf00      	nop
 8012734:	20004568 	.word	0x20004568
	...

08012740 <comm_usb_init>:
static void process_packet(unsigned char *data, unsigned int len);
static void send_packet(unsigned char *buffer, unsigned int len);
static THD_FUNCTION(serial_read_thread, arg);
static THD_FUNCTION(serial_process_thread, arg);

void comm_usb_init(void) {
 8012740:	b510      	push	{r4, lr}
 8012742:	b082      	sub	sp, #8
	comm_usb_serial_init();
 8012744:	f7ff f9bc 	bl	8011ac0 <comm_usb_serial_init>
	packet_init(send_packet, process_packet, PACKET_HANDLER);
 8012748:	490d      	ldr	r1, [pc, #52]	; (8012780 <comm_usb_init+0x40>)
 801274a:	480e      	ldr	r0, [pc, #56]	; (8012784 <comm_usb_init+0x44>)
 801274c:	2200      	movs	r2, #0
 801274e:	f000 f827 	bl	80127a0 <packet_init>

	chMtxObjectInit(&send_mutex);

	// Threads
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
 8012752:	2400      	movs	r4, #0

void comm_usb_init(void) {
	comm_usb_serial_init();
	packet_init(send_packet, process_packet, PACKET_HANDLER);

	chMtxObjectInit(&send_mutex);
 8012754:	480c      	ldr	r0, [pc, #48]	; (8012788 <comm_usb_init+0x48>)
 8012756:	f7fb f8b3 	bl	800d8c0 <chMtxObjectInit>

	// Threads
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
 801275a:	9400      	str	r4, [sp, #0]
 801275c:	4b0b      	ldr	r3, [pc, #44]	; (801278c <comm_usb_init+0x4c>)
 801275e:	480c      	ldr	r0, [pc, #48]	; (8012790 <comm_usb_init+0x50>)
 8012760:	f44f 7166 	mov.w	r1, #920	; 0x398
 8012764:	2240      	movs	r2, #64	; 0x40
 8012766:	f7fa ff8b 	bl	800d680 <chThdCreateStatic>
	chThdCreateStatic(serial_process_thread_wa, sizeof(serial_process_thread_wa), NORMALPRIO, serial_process_thread, NULL);
 801276a:	9400      	str	r4, [sp, #0]
 801276c:	4b09      	ldr	r3, [pc, #36]	; (8012794 <comm_usb_init+0x54>)
 801276e:	480a      	ldr	r0, [pc, #40]	; (8012798 <comm_usb_init+0x58>)
 8012770:	f241 1198 	movw	r1, #4504	; 0x1198
 8012774:	2240      	movs	r2, #64	; 0x40
 8012776:	f7fa ff83 	bl	800d680 <chThdCreateStatic>
}
 801277a:	b002      	add	sp, #8
 801277c:	bd10      	pop	{r4, pc}
 801277e:	bf00      	nop
 8012780:	080126f1 	.word	0x080126f1
 8012784:	080125f1 	.word	0x080125f1
 8012788:	20004568 	.word	0x20004568
 801278c:	08012671 	.word	0x08012671
 8012790:	20005f10 	.word	0x20005f10
 8012794:	08012611 	.word	0x08012611
 8012798:	20004578 	.word	0x20004578
 801279c:	00000000 	.word	0x00000000

080127a0 <packet_init>:

static PACKET_STATE_t handler_states[PACKET_HANDLERS];

void packet_init(void (*s_func)(unsigned char *data, unsigned int len),
		void (*p_func)(unsigned char *data, unsigned int len), int handler_num) {
	handler_states[handler_num].send_func = s_func;
 80127a0:	4b03      	ldr	r3, [pc, #12]	; (80127b0 <packet_init+0x10>)
 80127a2:	eb02 1282 	add.w	r2, r2, r2, lsl #6
 80127a6:	eb03 1242 	add.w	r2, r3, r2, lsl #5
 80127aa:	6050      	str	r0, [r2, #4]
	handler_states[handler_num].process_func = p_func;
 80127ac:	6091      	str	r1, [r2, #8]
 80127ae:	4770      	bx	lr
 80127b0:	200062b0 	.word	0x200062b0
	...

080127c0 <packet_send_packet>:
}

void packet_send_packet(unsigned char *data, unsigned int len, int handler_num) {
	if (len > PACKET_MAX_PL_LEN) {
 80127c0:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
		void (*p_func)(unsigned char *data, unsigned int len), int handler_num) {
	handler_states[handler_num].send_func = s_func;
	handler_states[handler_num].process_func = p_func;
}

void packet_send_packet(unsigned char *data, unsigned int len, int handler_num) {
 80127c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80127c8:	460c      	mov	r4, r1
	if (len > PACKET_MAX_PL_LEN) {
 80127ca:	d831      	bhi.n	8012830 <packet_send_packet+0x70>
	}

	int b_ind = 0;

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
 80127cc:	0195      	lsls	r5, r2, #6
 80127ce:	f8df 8070 	ldr.w	r8, [pc, #112]	; 8012840 <packet_send_packet+0x80>
 80127d2:	18ab      	adds	r3, r5, r2
		return;
	}

	int b_ind = 0;

	if (len <= 256) {
 80127d4:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 80127d8:	4681      	mov	r9, r0
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
 80127da:	eb08 1343 	add.w	r3, r8, r3, lsl #5
		return;
	}

	int b_ind = 0;

	if (len <= 256) {
 80127de:	d929      	bls.n	8012834 <packet_send_packet+0x74>
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
		handler_states[handler_num].tx_buffer[b_ind++] = len;
	} else {
		handler_states[handler_num].tx_buffer[b_ind++] = 3;
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
 80127e0:	0a08      	lsrs	r0, r1, #8

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
		handler_states[handler_num].tx_buffer[b_ind++] = len;
	} else {
		handler_states[handler_num].tx_buffer[b_ind++] = 3;
 80127e2:	2603      	movs	r6, #3
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
		handler_states[handler_num].tx_buffer[b_ind++] = len & 0xFF;
 80127e4:	f883 1412 	strb.w	r1, [r3, #1042]	; 0x412
	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
		handler_states[handler_num].tx_buffer[b_ind++] = len;
	} else {
		handler_states[handler_num].tx_buffer[b_ind++] = 3;
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
 80127e8:	f883 0411 	strb.w	r0, [r3, #1041]	; 0x411

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
		handler_states[handler_num].tx_buffer[b_ind++] = len;
	} else {
		handler_states[handler_num].tx_buffer[b_ind++] = 3;
 80127ec:	f883 6410 	strb.w	r6, [r3, #1040]	; 0x410
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
		handler_states[handler_num].tx_buffer[b_ind++] = len & 0xFF;
	}

	memcpy(handler_states[handler_num].tx_buffer + b_ind, data, len);
 80127f0:	442a      	add	r2, r5
 80127f2:	0155      	lsls	r5, r2, #5
 80127f4:	f505 6782 	add.w	r7, r5, #1040	; 0x410
 80127f8:	4447      	add	r7, r8
 80127fa:	4622      	mov	r2, r4
 80127fc:	4649      	mov	r1, r9
 80127fe:	19b8      	adds	r0, r7, r6
 8012800:	f7fa f89e 	bl	800c940 <memcpy>
	b_ind += len;

	unsigned short crc = crc16(data, len);
 8012804:	4621      	mov	r1, r4
 8012806:	4648      	mov	r0, r9
 8012808:	f7ff fea2 	bl	8012550 <crc16>
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
 801280c:	4445      	add	r5, r8
		handler_states[handler_num].tx_buffer[b_ind++] = len >> 8;
		handler_states[handler_num].tx_buffer[b_ind++] = len & 0xFF;
	}

	memcpy(handler_states[handler_num].tx_buffer + b_ind, data, len);
	b_ind += len;
 801280e:	4434      	add	r4, r6

	unsigned short crc = crc16(data, len);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
 8012810:	192b      	adds	r3, r5, r4
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc & 0xFF);
	handler_states[handler_num].tx_buffer[b_ind++] = 3;

	if (handler_states[handler_num].send_func) {
 8012812:	686a      	ldr	r2, [r5, #4]
	memcpy(handler_states[handler_num].tx_buffer + b_ind, data, len);
	b_ind += len;

	unsigned short crc = crc16(data, len);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc & 0xFF);
 8012814:	f883 0411 	strb.w	r0, [r3, #1041]	; 0x411
	handler_states[handler_num].tx_buffer[b_ind++] = 3;
 8012818:	2503      	movs	r5, #3

	memcpy(handler_states[handler_num].tx_buffer + b_ind, data, len);
	b_ind += len;

	unsigned short crc = crc16(data, len);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
 801281a:	0a00      	lsrs	r0, r0, #8
 801281c:	f883 0410 	strb.w	r0, [r3, #1040]	; 0x410
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc & 0xFF);
	handler_states[handler_num].tx_buffer[b_ind++] = 3;
 8012820:	1961      	adds	r1, r4, r5
 8012822:	f883 5412 	strb.w	r5, [r3, #1042]	; 0x412

	if (handler_states[handler_num].send_func) {
 8012826:	b11a      	cbz	r2, 8012830 <packet_send_packet+0x70>
		handler_states[handler_num].send_func(handler_states[handler_num].tx_buffer, b_ind);
 8012828:	4638      	mov	r0, r7
	}
}
 801282a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc >> 8);
	handler_states[handler_num].tx_buffer[b_ind++] = (uint8_t)(crc & 0xFF);
	handler_states[handler_num].tx_buffer[b_ind++] = 3;

	if (handler_states[handler_num].send_func) {
		handler_states[handler_num].send_func(handler_states[handler_num].tx_buffer, b_ind);
 801282e:	4710      	bx	r2
 8012830:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}

	int b_ind = 0;

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
 8012834:	2602      	movs	r6, #2
		handler_states[handler_num].tx_buffer[b_ind++] = len;
 8012836:	f883 1411 	strb.w	r1, [r3, #1041]	; 0x411
	}

	int b_ind = 0;

	if (len <= 256) {
		handler_states[handler_num].tx_buffer[b_ind++] = 2;
 801283a:	f883 6410 	strb.w	r6, [r3, #1040]	; 0x410
 801283e:	e7d7      	b.n	80127f0 <packet_send_packet+0x30>
 8012840:	200062b0 	.word	0x200062b0
	...

08012850 <packet_process_byte>:
			handler_states[i].rx_state = 0;
		}
	}
}

void packet_process_byte(uint8_t rx_data, int handler_num) {
 8012850:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	switch (handler_states[handler_num].rx_state) {
 8012854:	018e      	lsls	r6, r1, #6
 8012856:	1873      	adds	r3, r6, r1
 8012858:	015b      	lsls	r3, r3, #5
 801285a:	4d4e      	ldr	r5, [pc, #312]	; (8012994 <packet_process_byte+0x144>)
 801285c:	5ceb      	ldrb	r3, [r5, r3]
			handler_states[i].rx_state = 0;
		}
	}
}

void packet_process_byte(uint8_t rx_data, int handler_num) {
 801285e:	460c      	mov	r4, r1
	switch (handler_states[handler_num].rx_state) {
 8012860:	2b06      	cmp	r3, #6
 8012862:	d821      	bhi.n	80128a8 <packet_process_byte+0x58>
 8012864:	e8df f003 	tbb	[pc, r3]
 8012868:	5a473a26 	.word	0x5a473a26
 801286c:	8578      	.short	0x8578
 801286e:	04          	.byte	0x04
 801286f:	00          	.byte	0x00
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 6:
		if (rx_data == 3) {
 8012870:	2803      	cmp	r0, #3
 8012872:	d119      	bne.n	80128a8 <packet_process_byte+0x58>
			if (crc16(handler_states[handler_num].rx_buffer, handler_states[handler_num].payload_length)
 8012874:	1873      	adds	r3, r6, r1
 8012876:	015b      	lsls	r3, r3, #5
 8012878:	eb05 0803 	add.w	r8, r5, r3
 801287c:	3310      	adds	r3, #16
 801287e:	18ef      	adds	r7, r5, r3
 8012880:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8012884:	4638      	mov	r0, r7
 8012886:	f7ff fe63 	bl	8012550 <crc16>
					== ((unsigned short)handler_states[handler_num].crc_high << 8
 801288a:	f898 181d 	ldrb.w	r1, [r8, #2077]	; 0x81d
							| (unsigned short)handler_states[handler_num].crc_low)) {
 801288e:	f898 381c 	ldrb.w	r3, [r8, #2076]	; 0x81c
 8012892:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 6:
		if (rx_data == 3) {
			if (crc16(handler_states[handler_num].rx_buffer, handler_states[handler_num].payload_length)
 8012896:	4298      	cmp	r0, r3
 8012898:	d106      	bne.n	80128a8 <packet_process_byte+0x58>
					== ((unsigned short)handler_states[handler_num].crc_high << 8
							| (unsigned short)handler_states[handler_num].crc_low)) {
				// Packet received!
				if (handler_states[handler_num].process_func) {
 801289a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801289e:	b11b      	cbz	r3, 80128a8 <packet_process_byte+0x58>
					handler_states[handler_num].process_func(handler_states[handler_num].rx_buffer,
 80128a0:	4638      	mov	r0, r7
 80128a2:	f8d8 100c 	ldr.w	r1, [r8, #12]
 80128a6:	4798      	blx	r3
		}
		handler_states[handler_num].rx_state = 0;
		break;

	default:
		handler_states[handler_num].rx_state = 0;
 80128a8:	4434      	add	r4, r6
 80128aa:	0164      	lsls	r4, r4, #5
 80128ac:	2300      	movs	r3, #0
 80128ae:	552b      	strb	r3, [r5, r4]
 80128b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
void packet_process_byte(uint8_t rx_data, int handler_num) {
	switch (handler_states[handler_num].rx_state) {
	case 0:
		if (rx_data == 2) {
			// 1 byte PL len
			handler_states[handler_num].rx_state += 2;
 80128b4:	4434      	add	r4, r6
}

void packet_process_byte(uint8_t rx_data, int handler_num) {
	switch (handler_states[handler_num].rx_state) {
	case 0:
		if (rx_data == 2) {
 80128b6:	2802      	cmp	r0, #2
			// 1 byte PL len
			handler_states[handler_num].rx_state += 2;
 80128b8:	ea4f 1444 	mov.w	r4, r4, lsl #5
}

void packet_process_byte(uint8_t rx_data, int handler_num) {
	switch (handler_states[handler_num].rx_state) {
	case 0:
		if (rx_data == 2) {
 80128bc:	d064      	beq.n	8012988 <packet_process_byte+0x138>
			// 1 byte PL len
			handler_states[handler_num].rx_state += 2;
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
			handler_states[handler_num].rx_data_ptr = 0;
			handler_states[handler_num].payload_length = 0;
		} else if (rx_data == 3) {
 80128be:	2803      	cmp	r0, #3
 80128c0:	d1f4      	bne.n	80128ac <packet_process_byte+0x5c>
			// 2 byte PL len
			handler_states[handler_num].rx_state++;
 80128c2:	5d2b      	ldrb	r3, [r5, r4]
 80128c4:	3301      	adds	r3, #1
 80128c6:	192a      	adds	r2, r5, r4
 80128c8:	b2db      	uxtb	r3, r3
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80128ca:	2002      	movs	r0, #2
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
			handler_states[handler_num].rx_data_ptr = 0;
			handler_states[handler_num].payload_length = 0;
		} else if (rx_data == 3) {
			// 2 byte PL len
			handler_states[handler_num].rx_state++;
 80128cc:	552b      	strb	r3, [r5, r4]
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
			handler_states[handler_num].rx_data_ptr = 0;
 80128ce:	2100      	movs	r1, #0
			handler_states[handler_num].rx_data_ptr = 0;
			handler_states[handler_num].payload_length = 0;
		} else if (rx_data == 3) {
			// 2 byte PL len
			handler_states[handler_num].rx_state++;
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80128d0:	7050      	strb	r0, [r2, #1]
			handler_states[handler_num].rx_data_ptr = 0;
			handler_states[handler_num].payload_length = 0;
 80128d2:	60d1      	str	r1, [r2, #12]
			handler_states[handler_num].payload_length = 0;
		} else if (rx_data == 3) {
			// 2 byte PL len
			handler_states[handler_num].rx_state++;
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
			handler_states[handler_num].rx_data_ptr = 0;
 80128d4:	f8c2 1818 	str.w	r1, [r2, #2072]	; 0x818
 80128d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 1:
		handler_states[handler_num].payload_length = (unsigned int)rx_data << 8;
 80128dc:	4434      	add	r4, r6
 80128de:	0164      	lsls	r4, r4, #5
 80128e0:	192a      	adds	r2, r5, r4
		handler_states[handler_num].rx_state++;
 80128e2:	5d2b      	ldrb	r3, [r5, r4]
 80128e4:	3301      	adds	r3, #1
 80128e6:	b2db      	uxtb	r3, r3
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80128e8:	2102      	movs	r1, #2
		}
		break;

	case 1:
		handler_states[handler_num].payload_length = (unsigned int)rx_data << 8;
		handler_states[handler_num].rx_state++;
 80128ea:	552b      	strb	r3, [r5, r4]
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 1:
		handler_states[handler_num].payload_length = (unsigned int)rx_data << 8;
 80128ec:	0200      	lsls	r0, r0, #8
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 80128ee:	7051      	strb	r1, [r2, #1]
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 1:
		handler_states[handler_num].payload_length = (unsigned int)rx_data << 8;
 80128f0:	60d0      	str	r0, [r2, #12]
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;
 80128f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	case 2:
		handler_states[handler_num].payload_length |= (unsigned int)rx_data;
 80128f6:	4434      	add	r4, r6
 80128f8:	0164      	lsls	r4, r4, #5
 80128fa:	4425      	add	r5, r4
 80128fc:	4925      	ldr	r1, [pc, #148]	; (8012994 <packet_process_byte+0x144>)
 80128fe:	68eb      	ldr	r3, [r5, #12]
 8012900:	4318      	orrs	r0, r3
		if (handler_states[handler_num].payload_length > 0 &&
 8012902:	1e43      	subs	r3, r0, #1
 8012904:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 2:
		handler_states[handler_num].payload_length |= (unsigned int)rx_data;
 8012908:	60e8      	str	r0, [r5, #12]
		if (handler_states[handler_num].payload_length > 0 &&
 801290a:	d239      	bcs.n	8012980 <packet_process_byte+0x130>
				handler_states[handler_num].payload_length <= PACKET_MAX_PL_LEN) {
			handler_states[handler_num].rx_state++;
 801290c:	5d0b      	ldrb	r3, [r1, r4]
 801290e:	3301      	adds	r3, #1
 8012910:	b2db      	uxtb	r3, r3
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 8012912:	2202      	movs	r2, #2

	case 2:
		handler_states[handler_num].payload_length |= (unsigned int)rx_data;
		if (handler_states[handler_num].payload_length > 0 &&
				handler_states[handler_num].payload_length <= PACKET_MAX_PL_LEN) {
			handler_states[handler_num].rx_state++;
 8012914:	550b      	strb	r3, [r1, r4]
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 8012916:	706a      	strb	r2, [r5, #1]
 8012918:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 3:
		handler_states[handler_num].rx_buffer[handler_states[handler_num].rx_data_ptr++] = rx_data;
 801291c:	1871      	adds	r1, r6, r1
 801291e:	0149      	lsls	r1, r1, #5
 8012920:	186a      	adds	r2, r5, r1
 8012922:	f8df c070 	ldr.w	ip, [pc, #112]	; 8012994 <packet_process_byte+0x144>
 8012926:	f8d2 3818 	ldr.w	r3, [r2, #2072]	; 0x818
		if (handler_states[handler_num].rx_data_ptr == handler_states[handler_num].payload_length) {
 801292a:	68d7      	ldr	r7, [r2, #12]
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 3:
		handler_states[handler_num].rx_buffer[handler_states[handler_num].rx_data_ptr++] = rx_data;
 801292c:	eb02 0e03 	add.w	lr, r2, r3
 8012930:	3301      	adds	r3, #1
		if (handler_states[handler_num].rx_data_ptr == handler_states[handler_num].payload_length) {
 8012932:	42bb      	cmp	r3, r7
			handler_states[handler_num].rx_state = 0;
		}
		break;

	case 3:
		handler_states[handler_num].rx_buffer[handler_states[handler_num].rx_data_ptr++] = rx_data;
 8012934:	f88e 0010 	strb.w	r0, [lr, #16]
 8012938:	f8c2 3818 	str.w	r3, [r2, #2072]	; 0x818
		if (handler_states[handler_num].rx_data_ptr == handler_states[handler_num].payload_length) {
 801293c:	d105      	bne.n	801294a <packet_process_byte+0xfa>
			handler_states[handler_num].rx_state++;
 801293e:	f81c 3001 	ldrb.w	r3, [ip, r1]
 8012942:	3301      	adds	r3, #1
 8012944:	b2db      	uxtb	r3, r3
 8012946:	f80c 3001 	strb.w	r3, [ip, r1]
		}
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 801294a:	4434      	add	r4, r6
 801294c:	eb05 1444 	add.w	r4, r5, r4, lsl #5
 8012950:	2302      	movs	r3, #2
 8012952:	7063      	strb	r3, [r4, #1]
		break;
 8012954:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	case 4:
		handler_states[handler_num].crc_high = rx_data;
 8012958:	4434      	add	r4, r6
 801295a:	0164      	lsls	r4, r4, #5
 801295c:	192a      	adds	r2, r5, r4
		handler_states[handler_num].rx_state++;
 801295e:	5d2b      	ldrb	r3, [r5, r4]
		}
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 4:
		handler_states[handler_num].crc_high = rx_data;
 8012960:	f882 081d 	strb.w	r0, [r2, #2077]	; 0x81d
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 5:
		handler_states[handler_num].crc_low = rx_data;
		handler_states[handler_num].rx_state++;
 8012964:	3301      	adds	r3, #1
 8012966:	b2db      	uxtb	r3, r3
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 8012968:	2102      	movs	r1, #2
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 5:
		handler_states[handler_num].crc_low = rx_data;
		handler_states[handler_num].rx_state++;
 801296a:	552b      	strb	r3, [r5, r4]
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
 801296c:	7051      	strb	r1, [r2, #1]
		break;
 801296e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 5:
		handler_states[handler_num].crc_low = rx_data;
 8012972:	4434      	add	r4, r6
 8012974:	0164      	lsls	r4, r4, #5
 8012976:	192a      	adds	r2, r5, r4
		handler_states[handler_num].rx_state++;
 8012978:	5d2b      	ldrb	r3, [r5, r4]
		handler_states[handler_num].rx_state++;
		handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		break;

	case 5:
		handler_states[handler_num].crc_low = rx_data;
 801297a:	f882 081c 	strb.w	r0, [r2, #2076]	; 0x81c
 801297e:	e7f1      	b.n	8012964 <packet_process_byte+0x114>
		if (handler_states[handler_num].payload_length > 0 &&
				handler_states[handler_num].payload_length <= PACKET_MAX_PL_LEN) {
			handler_states[handler_num].rx_state++;
			handler_states[handler_num].rx_timeout = PACKET_RX_TIMEOUT;
		} else {
			handler_states[handler_num].rx_state = 0;
 8012980:	2300      	movs	r3, #0
 8012982:	550b      	strb	r3, [r1, r4]
 8012984:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
void packet_process_byte(uint8_t rx_data, int handler_num) {
	switch (handler_states[handler_num].rx_state) {
	case 0:
		if (rx_data == 2) {
			// 1 byte PL len
			handler_states[handler_num].rx_state += 2;
 8012988:	5d2b      	ldrb	r3, [r5, r4]
 801298a:	3302      	adds	r3, #2
 801298c:	192a      	adds	r2, r5, r4
 801298e:	b2db      	uxtb	r3, r3
 8012990:	e79c      	b.n	80128cc <packet_process_byte+0x7c>
 8012992:	bf00      	nop
 8012994:	200062b0 	.word	0x200062b0
	...

080129a0 <commands_set_send_func>:
 *
 * @param func
 * A pointer to the packet sending function.
 */
void commands_set_send_func(void(*func)(unsigned char *data, unsigned int len)) {
	send_func = func;
 80129a0:	4b01      	ldr	r3, [pc, #4]	; (80129a8 <commands_set_send_func+0x8>)
 80129a2:	6018      	str	r0, [r3, #0]
 80129a4:	4770      	bx	lr
 80129a6:	bf00      	nop
 80129a8:	20006ad0 	.word	0x20006ad0
 80129ac:	00000000 	.word	0x00000000

080129b0 <commands_process_packet>:
 * The buffer to process.
 *
 * @param len
 * The length of the buffer.
 */
void commands_process_packet(unsigned char *data, unsigned int len) {
 80129b0:	4770      	bx	lr
 80129b2:	bf00      	nop
	...

080129c0 <commands_printf>:
			break;
		}
	}
}

void commands_printf(char* format, ...) {
 80129c0:	b40f      	push	{r0, r1, r2, r3}
 80129c2:	b570      	push	{r4, r5, r6, lr}
 80129c4:	b082      	sub	sp, #8
 80129c6:	ab06      	add	r3, sp, #24
	va_list arg;
	va_start (arg, format);
	int len;
	static char print_buffer[255];

	print_buffer[0] = main_config.id;
 80129c8:	4c0e      	ldr	r4, [pc, #56]	; (8012a04 <commands_printf+0x44>)
 80129ca:	490f      	ldr	r1, [pc, #60]	; (8012a08 <commands_printf+0x48>)
			break;
		}
	}
}

void commands_printf(char* format, ...) {
 80129cc:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list arg;
	va_start (arg, format);
	int len;
	static char print_buffer[255];

	print_buffer[0] = main_config.id;
 80129d0:	680e      	ldr	r6, [r1, #0]
	}
}

void commands_printf(char* format, ...) {
	va_list arg;
	va_start (arg, format);
 80129d2:	9301      	str	r3, [sp, #4]
	int len;
	static char print_buffer[255];

	print_buffer[0] = main_config.id;
	print_buffer[1] = COMM_PRINTF;
 80129d4:	2500      	movs	r5, #0
	len = vsnprintf(print_buffer + 2, 253, format, arg);
 80129d6:	1ca0      	adds	r0, r4, #2
 80129d8:	21fd      	movs	r1, #253	; 0xfd
	va_list arg;
	va_start (arg, format);
	int len;
	static char print_buffer[255];

	print_buffer[0] = main_config.id;
 80129da:	7026      	strb	r6, [r4, #0]
	print_buffer[1] = COMM_PRINTF;
 80129dc:	7065      	strb	r5, [r4, #1]
	len = vsnprintf(print_buffer + 2, 253, format, arg);
 80129de:	f000 f8ff 	bl	8012be0 <vsnprintf>
	va_end (arg);

	if(len > 0) {
 80129e2:	2800      	cmp	r0, #0
 80129e4:	dd08      	ble.n	80129f8 <commands_printf+0x38>
 *
 * @param len
 * The data length.
 */
void commands_send_packet(unsigned char *data, unsigned int len) {
	if (send_func) {
 80129e6:	4b09      	ldr	r3, [pc, #36]	; (8012a0c <commands_printf+0x4c>)
 80129e8:	681b      	ldr	r3, [r3, #0]
	print_buffer[1] = COMM_PRINTF;
	len = vsnprintf(print_buffer + 2, 253, format, arg);
	va_end (arg);

	if(len > 0) {
		commands_send_packet((unsigned char*)print_buffer, (len<253)? len+2: 255);
 80129ea:	28fc      	cmp	r0, #252	; 0xfc
 80129ec:	bfd4      	ite	le
 80129ee:	1c81      	addle	r1, r0, #2
 80129f0:	21ff      	movgt	r1, #255	; 0xff
 *
 * @param len
 * The data length.
 */
void commands_send_packet(unsigned char *data, unsigned int len) {
	if (send_func) {
 80129f2:	b10b      	cbz	r3, 80129f8 <commands_printf+0x38>
		send_func(data, len);
 80129f4:	4803      	ldr	r0, [pc, #12]	; (8012a04 <commands_printf+0x44>)
 80129f6:	4798      	blx	r3
	va_end (arg);

	if(len > 0) {
		commands_send_packet((unsigned char*)print_buffer, (len<253)? len+2: 255);
	}
}
 80129f8:	b002      	add	sp, #8
 80129fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80129fe:	b004      	add	sp, #16
 8012a00:	4770      	bx	lr
 8012a02:	bf00      	nop
 8012a04:	20006ad4 	.word	0x20006ad4
 8012a08:	20006bd4 	.word	0x20006bd4
 8012a0c:	20006ad0 	.word	0x20006ad0

08012a10 <conf_general_init>:
#include "stm32f4xx_conf.h"

// Global variables
MAIN_CONFIG main_config;

void conf_general_init(void) {
 8012a10:	b510      	push	{r4, lr}
	palSetPadMode(GPIOE, 8, PAL_MODE_INPUT_PULLUP);
 8012a12:	4c1e      	ldr	r4, [pc, #120]	; (8012a8c <conf_general_init+0x7c>)
 8012a14:	f44f 7180 	mov.w	r1, #256	; 0x100
 8012a18:	4620      	mov	r0, r4
 8012a1a:	2220      	movs	r2, #32
 8012a1c:	f7fd f8b8 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOE, 9, PAL_MODE_INPUT_PULLUP);
 8012a20:	4620      	mov	r0, r4
 8012a22:	f44f 7100 	mov.w	r1, #512	; 0x200
 8012a26:	2220      	movs	r2, #32
 8012a28:	f7fd f8b2 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOE, 10, PAL_MODE_INPUT_PULLUP);
 8012a2c:	4620      	mov	r0, r4
 8012a2e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8012a32:	2220      	movs	r2, #32
 8012a34:	f7fd f8ac 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOE, 11, PAL_MODE_INPUT_PULLUP);
 8012a38:	4620      	mov	r0, r4
 8012a3a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8012a3e:	2220      	movs	r2, #32
 8012a40:	f7fd f8a6 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOE, 12, PAL_MODE_INPUT_PULLUP);
 8012a44:	4620      	mov	r0, r4
 8012a46:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8012a4a:	2220      	movs	r2, #32
 8012a4c:	f7fd f8a0 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOE, 13, PAL_MODE_INPUT_PULLUP);
 8012a50:	4620      	mov	r0, r4
 8012a52:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8012a56:	2220      	movs	r2, #32
 8012a58:	f7fd f89a 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOE, 14, PAL_MODE_INPUT_PULLUP);
 8012a5c:	4620      	mov	r0, r4
 8012a5e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8012a62:	2220      	movs	r2, #32
 8012a64:	f7fd f894 	bl	800fb90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOE, 15, PAL_MODE_INPUT_PULLUP);
 8012a68:	2220      	movs	r2, #32
 8012a6a:	4620      	mov	r0, r4
 8012a6c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8012a70:	f7fd f88e 	bl	800fb90 <_pal_lld_setgroupmode>

	chThdSleepMilliseconds(10);
 8012a74:	2064      	movs	r0, #100	; 0x64
 8012a76:	f7fa fe43 	bl	800d700 <chThdSleep>

	main_config.id = (~(palReadPort(GPIOE) >> 8)) & 0x0F;
 8012a7a:	6923      	ldr	r3, [r4, #16]
 8012a7c:	4a04      	ldr	r2, [pc, #16]	; (8012a90 <conf_general_init+0x80>)
 8012a7e:	ea6f 2313 	mvn.w	r3, r3, lsr #8
 8012a82:	f003 030f 	and.w	r3, r3, #15
 8012a86:	6013      	str	r3, [r2, #0]
 8012a88:	bd10      	pop	{r4, pc}
 8012a8a:	bf00      	nop
 8012a8c:	40021000 	.word	0x40021000
 8012a90:	20006bd4 	.word	0x20006bd4
	...

08012aa0 <RCC_AHB1PeriphClockCmd>:
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8012aa0:	4a04      	ldr	r2, [pc, #16]	; (8012ab4 <RCC_AHB1PeriphClockCmd+0x14>)
 8012aa2:	6b13      	ldr	r3, [r2, #48]	; 0x30
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8012aa4:	b919      	cbnz	r1, 8012aae <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8012aa6:	ea23 0000 	bic.w	r0, r3, r0
 8012aaa:	6310      	str	r0, [r2, #48]	; 0x30
 8012aac:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8012aae:	4318      	orrs	r0, r3
 8012ab0:	6310      	str	r0, [r2, #48]	; 0x30
 8012ab2:	4770      	bx	lr
 8012ab4:	40023800 	.word	0x40023800
	...

08012ac0 <memset>:
 8012ac0:	b470      	push	{r4, r5, r6}
 8012ac2:	0784      	lsls	r4, r0, #30
 8012ac4:	d046      	beq.n	8012b54 <memset+0x94>
 8012ac6:	1e54      	subs	r4, r2, #1
 8012ac8:	2a00      	cmp	r2, #0
 8012aca:	d041      	beq.n	8012b50 <memset+0x90>
 8012acc:	b2cd      	uxtb	r5, r1
 8012ace:	4603      	mov	r3, r0
 8012ad0:	e002      	b.n	8012ad8 <memset+0x18>
 8012ad2:	1e62      	subs	r2, r4, #1
 8012ad4:	b3e4      	cbz	r4, 8012b50 <memset+0x90>
 8012ad6:	4614      	mov	r4, r2
 8012ad8:	f803 5b01 	strb.w	r5, [r3], #1
 8012adc:	079a      	lsls	r2, r3, #30
 8012ade:	d1f8      	bne.n	8012ad2 <memset+0x12>
 8012ae0:	2c03      	cmp	r4, #3
 8012ae2:	d92e      	bls.n	8012b42 <memset+0x82>
 8012ae4:	b2cd      	uxtb	r5, r1
 8012ae6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8012aea:	2c0f      	cmp	r4, #15
 8012aec:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8012af0:	d919      	bls.n	8012b26 <memset+0x66>
 8012af2:	f103 0210 	add.w	r2, r3, #16
 8012af6:	4626      	mov	r6, r4
 8012af8:	3e10      	subs	r6, #16
 8012afa:	2e0f      	cmp	r6, #15
 8012afc:	f842 5c10 	str.w	r5, [r2, #-16]
 8012b00:	f842 5c0c 	str.w	r5, [r2, #-12]
 8012b04:	f842 5c08 	str.w	r5, [r2, #-8]
 8012b08:	f842 5c04 	str.w	r5, [r2, #-4]
 8012b0c:	f102 0210 	add.w	r2, r2, #16
 8012b10:	d8f2      	bhi.n	8012af8 <memset+0x38>
 8012b12:	f1a4 0210 	sub.w	r2, r4, #16
 8012b16:	f022 020f 	bic.w	r2, r2, #15
 8012b1a:	f004 040f 	and.w	r4, r4, #15
 8012b1e:	3210      	adds	r2, #16
 8012b20:	2c03      	cmp	r4, #3
 8012b22:	4413      	add	r3, r2
 8012b24:	d90d      	bls.n	8012b42 <memset+0x82>
 8012b26:	461e      	mov	r6, r3
 8012b28:	4622      	mov	r2, r4
 8012b2a:	3a04      	subs	r2, #4
 8012b2c:	2a03      	cmp	r2, #3
 8012b2e:	f846 5b04 	str.w	r5, [r6], #4
 8012b32:	d8fa      	bhi.n	8012b2a <memset+0x6a>
 8012b34:	1f22      	subs	r2, r4, #4
 8012b36:	f022 0203 	bic.w	r2, r2, #3
 8012b3a:	3204      	adds	r2, #4
 8012b3c:	4413      	add	r3, r2
 8012b3e:	f004 0403 	and.w	r4, r4, #3
 8012b42:	b12c      	cbz	r4, 8012b50 <memset+0x90>
 8012b44:	b2c9      	uxtb	r1, r1
 8012b46:	441c      	add	r4, r3
 8012b48:	f803 1b01 	strb.w	r1, [r3], #1
 8012b4c:	42a3      	cmp	r3, r4
 8012b4e:	d1fb      	bne.n	8012b48 <memset+0x88>
 8012b50:	bc70      	pop	{r4, r5, r6}
 8012b52:	4770      	bx	lr
 8012b54:	4614      	mov	r4, r2
 8012b56:	4603      	mov	r3, r0
 8012b58:	e7c2      	b.n	8012ae0 <memset+0x20>
 8012b5a:	bf00      	nop
 8012b5c:	0000      	movs	r0, r0
	...

08012b60 <_vsnprintf_r>:
 8012b60:	b570      	push	{r4, r5, r6, lr}
 8012b62:	2a00      	cmp	r2, #0
 8012b64:	b09a      	sub	sp, #104	; 0x68
 8012b66:	4605      	mov	r5, r0
 8012b68:	db2f      	blt.n	8012bca <_vsnprintf_r+0x6a>
 8012b6a:	4614      	mov	r4, r2
 8012b6c:	461a      	mov	r2, r3
 8012b6e:	f44f 7302 	mov.w	r3, #520	; 0x208
 8012b72:	9100      	str	r1, [sp, #0]
 8012b74:	9104      	str	r1, [sp, #16]
 8012b76:	f8ad 300c 	strh.w	r3, [sp, #12]
 8012b7a:	d011      	beq.n	8012ba0 <_vsnprintf_r+0x40>
 8012b7c:	3c01      	subs	r4, #1
 8012b7e:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8012b82:	4669      	mov	r1, sp
 8012b84:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8012b86:	9402      	str	r4, [sp, #8]
 8012b88:	9405      	str	r4, [sp, #20]
 8012b8a:	f8ad 600e 	strh.w	r6, [sp, #14]
 8012b8e:	f000 f837 	bl	8012c00 <_svfprintf_r>
 8012b92:	1c42      	adds	r2, r0, #1
 8012b94:	db16      	blt.n	8012bc4 <_vsnprintf_r+0x64>
 8012b96:	9b00      	ldr	r3, [sp, #0]
 8012b98:	2200      	movs	r2, #0
 8012b9a:	701a      	strb	r2, [r3, #0]
 8012b9c:	b01a      	add	sp, #104	; 0x68
 8012b9e:	bd70      	pop	{r4, r5, r6, pc}
 8012ba0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8012ba2:	9402      	str	r4, [sp, #8]
 8012ba4:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8012ba8:	4669      	mov	r1, sp
 8012baa:	9405      	str	r4, [sp, #20]
 8012bac:	f8ad 600e 	strh.w	r6, [sp, #14]
 8012bb0:	f000 f826 	bl	8012c00 <_svfprintf_r>
 8012bb4:	1c43      	adds	r3, r0, #1
 8012bb6:	db01      	blt.n	8012bbc <_vsnprintf_r+0x5c>
 8012bb8:	b01a      	add	sp, #104	; 0x68
 8012bba:	bd70      	pop	{r4, r5, r6, pc}
 8012bbc:	238b      	movs	r3, #139	; 0x8b
 8012bbe:	602b      	str	r3, [r5, #0]
 8012bc0:	b01a      	add	sp, #104	; 0x68
 8012bc2:	bd70      	pop	{r4, r5, r6, pc}
 8012bc4:	238b      	movs	r3, #139	; 0x8b
 8012bc6:	602b      	str	r3, [r5, #0]
 8012bc8:	e7e5      	b.n	8012b96 <_vsnprintf_r+0x36>
 8012bca:	238b      	movs	r3, #139	; 0x8b
 8012bcc:	6003      	str	r3, [r0, #0]
 8012bce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8012bd2:	e7f1      	b.n	8012bb8 <_vsnprintf_r+0x58>
	...

08012be0 <vsnprintf>:
 8012be0:	b530      	push	{r4, r5, lr}
 8012be2:	b083      	sub	sp, #12
 8012be4:	4c05      	ldr	r4, [pc, #20]	; (8012bfc <vsnprintf+0x1c>)
 8012be6:	9300      	str	r3, [sp, #0]
 8012be8:	6824      	ldr	r4, [r4, #0]
 8012bea:	460d      	mov	r5, r1
 8012bec:	4613      	mov	r3, r2
 8012bee:	4601      	mov	r1, r0
 8012bf0:	462a      	mov	r2, r5
 8012bf2:	4620      	mov	r0, r4
 8012bf4:	f7ff ffb4 	bl	8012b60 <_vsnprintf_r>
 8012bf8:	b003      	add	sp, #12
 8012bfa:	bd30      	pop	{r4, r5, pc}
 8012bfc:	20000c68 	.word	0x20000c68

08012c00 <_svfprintf_r>:
 8012c00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012c04:	b0bf      	sub	sp, #252	; 0xfc
 8012c06:	4689      	mov	r9, r1
 8012c08:	9206      	str	r2, [sp, #24]
 8012c0a:	930a      	str	r3, [sp, #40]	; 0x28
 8012c0c:	9004      	str	r0, [sp, #16]
 8012c0e:	f002 fa4f 	bl	80150b0 <_localeconv_r>
 8012c12:	6803      	ldr	r3, [r0, #0]
 8012c14:	9313      	str	r3, [sp, #76]	; 0x4c
 8012c16:	4618      	mov	r0, r3
 8012c18:	f003 f89a 	bl	8015d50 <strlen>
 8012c1c:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8012c20:	9014      	str	r0, [sp, #80]	; 0x50
 8012c22:	061a      	lsls	r2, r3, #24
 8012c24:	d504      	bpl.n	8012c30 <_svfprintf_r+0x30>
 8012c26:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8012c2a:	2b00      	cmp	r3, #0
 8012c2c:	f001 80a1 	beq.w	8013d72 <_svfprintf_r+0x1172>
 8012c30:	ed9f 7b99 	vldr	d7, [pc, #612]	; 8012e98 <_svfprintf_r+0x298>
 8012c34:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8012c38:	2300      	movs	r3, #0
 8012c3a:	af2e      	add	r7, sp, #184	; 0xb8
 8012c3c:	930f      	str	r3, [sp, #60]	; 0x3c
 8012c3e:	9323      	str	r3, [sp, #140]	; 0x8c
 8012c40:	9322      	str	r3, [sp, #136]	; 0x88
 8012c42:	9312      	str	r3, [sp, #72]	; 0x48
 8012c44:	9315      	str	r3, [sp, #84]	; 0x54
 8012c46:	9307      	str	r3, [sp, #28]
 8012c48:	9721      	str	r7, [sp, #132]	; 0x84
 8012c4a:	463c      	mov	r4, r7
 8012c4c:	464e      	mov	r6, r9
 8012c4e:	9d06      	ldr	r5, [sp, #24]
 8012c50:	782b      	ldrb	r3, [r5, #0]
 8012c52:	2b00      	cmp	r3, #0
 8012c54:	f000 80a9 	beq.w	8012daa <_svfprintf_r+0x1aa>
 8012c58:	2b25      	cmp	r3, #37	; 0x25
 8012c5a:	d102      	bne.n	8012c62 <_svfprintf_r+0x62>
 8012c5c:	e0a5      	b.n	8012daa <_svfprintf_r+0x1aa>
 8012c5e:	2b25      	cmp	r3, #37	; 0x25
 8012c60:	d003      	beq.n	8012c6a <_svfprintf_r+0x6a>
 8012c62:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8012c66:	2b00      	cmp	r3, #0
 8012c68:	d1f9      	bne.n	8012c5e <_svfprintf_r+0x5e>
 8012c6a:	9b06      	ldr	r3, [sp, #24]
 8012c6c:	1aeb      	subs	r3, r5, r3
 8012c6e:	b173      	cbz	r3, 8012c8e <_svfprintf_r+0x8e>
 8012c70:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012c72:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012c74:	9806      	ldr	r0, [sp, #24]
 8012c76:	6020      	str	r0, [r4, #0]
 8012c78:	3201      	adds	r2, #1
 8012c7a:	4419      	add	r1, r3
 8012c7c:	2a07      	cmp	r2, #7
 8012c7e:	6063      	str	r3, [r4, #4]
 8012c80:	9123      	str	r1, [sp, #140]	; 0x8c
 8012c82:	9222      	str	r2, [sp, #136]	; 0x88
 8012c84:	dc72      	bgt.n	8012d6c <_svfprintf_r+0x16c>
 8012c86:	3408      	adds	r4, #8
 8012c88:	9a07      	ldr	r2, [sp, #28]
 8012c8a:	441a      	add	r2, r3
 8012c8c:	9207      	str	r2, [sp, #28]
 8012c8e:	782b      	ldrb	r3, [r5, #0]
 8012c90:	2b00      	cmp	r3, #0
 8012c92:	f000 87cb 	beq.w	8013c2c <_svfprintf_r+0x102c>
 8012c96:	2300      	movs	r3, #0
 8012c98:	1c69      	adds	r1, r5, #1
 8012c9a:	786d      	ldrb	r5, [r5, #1]
 8012c9c:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
 8012ca0:	461a      	mov	r2, r3
 8012ca2:	9308      	str	r3, [sp, #32]
 8012ca4:	9303      	str	r3, [sp, #12]
 8012ca6:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
 8012caa:	1c4b      	adds	r3, r1, #1
 8012cac:	f1a5 0120 	sub.w	r1, r5, #32
 8012cb0:	2958      	cmp	r1, #88	; 0x58
 8012cb2:	f200 83e4 	bhi.w	801347e <_svfprintf_r+0x87e>
 8012cb6:	e8df f011 	tbh	[pc, r1, lsl #1]
 8012cba:	0277      	.short	0x0277
 8012cbc:	03e203e2 	.word	0x03e203e2
 8012cc0:	03e2037b 	.word	0x03e2037b
 8012cc4:	03e203e2 	.word	0x03e203e2
 8012cc8:	03e203e2 	.word	0x03e203e2
 8012ccc:	02f703e2 	.word	0x02f703e2
 8012cd0:	03e20214 	.word	0x03e20214
 8012cd4:	021801fb 	.word	0x021801fb
 8012cd8:	038203e2 	.word	0x038203e2
 8012cdc:	02c102c1 	.word	0x02c102c1
 8012ce0:	02c102c1 	.word	0x02c102c1
 8012ce4:	02c102c1 	.word	0x02c102c1
 8012ce8:	02c102c1 	.word	0x02c102c1
 8012cec:	03e202c1 	.word	0x03e202c1
 8012cf0:	03e203e2 	.word	0x03e203e2
 8012cf4:	03e203e2 	.word	0x03e203e2
 8012cf8:	03e203e2 	.word	0x03e203e2
 8012cfc:	03e203e2 	.word	0x03e203e2
 8012d00:	02d003e2 	.word	0x02d003e2
 8012d04:	03e20391 	.word	0x03e20391
 8012d08:	03e20391 	.word	0x03e20391
 8012d0c:	03e203e2 	.word	0x03e203e2
 8012d10:	037403e2 	.word	0x037403e2
 8012d14:	03e203e2 	.word	0x03e203e2
 8012d18:	03e2030c 	.word	0x03e2030c
 8012d1c:	03e203e2 	.word	0x03e203e2
 8012d20:	03e203e2 	.word	0x03e203e2
 8012d24:	03e2032a 	.word	0x03e2032a
 8012d28:	034403e2 	.word	0x034403e2
 8012d2c:	03e203e2 	.word	0x03e203e2
 8012d30:	03e203e2 	.word	0x03e203e2
 8012d34:	03e203e2 	.word	0x03e203e2
 8012d38:	03e203e2 	.word	0x03e203e2
 8012d3c:	03e203e2 	.word	0x03e203e2
 8012d40:	0233035f 	.word	0x0233035f
 8012d44:	03910391 	.word	0x03910391
 8012d48:	03050391 	.word	0x03050391
 8012d4c:	03e20233 	.word	0x03e20233
 8012d50:	02ed03e2 	.word	0x02ed03e2
 8012d54:	028503e2 	.word	0x028503e2
 8012d58:	03cb0202 	.word	0x03cb0202
 8012d5c:	03e2027e 	.word	0x03e2027e
 8012d60:	03e20299 	.word	0x03e20299
 8012d64:	03e2007a 	.word	0x03e2007a
 8012d68:	025103e2 	.word	0x025103e2
 8012d6c:	9804      	ldr	r0, [sp, #16]
 8012d6e:	9303      	str	r3, [sp, #12]
 8012d70:	4631      	mov	r1, r6
 8012d72:	aa21      	add	r2, sp, #132	; 0x84
 8012d74:	f003 f81c 	bl	8015db0 <__ssprint_r>
 8012d78:	b950      	cbnz	r0, 8012d90 <_svfprintf_r+0x190>
 8012d7a:	463c      	mov	r4, r7
 8012d7c:	9b03      	ldr	r3, [sp, #12]
 8012d7e:	e783      	b.n	8012c88 <_svfprintf_r+0x88>
 8012d80:	9804      	ldr	r0, [sp, #16]
 8012d82:	4631      	mov	r1, r6
 8012d84:	aa21      	add	r2, sp, #132	; 0x84
 8012d86:	f003 f813 	bl	8015db0 <__ssprint_r>
 8012d8a:	2800      	cmp	r0, #0
 8012d8c:	f000 818c 	beq.w	80130a8 <_svfprintf_r+0x4a8>
 8012d90:	46b1      	mov	r9, r6
 8012d92:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8012d96:	f013 0f40 	tst.w	r3, #64	; 0x40
 8012d9a:	9b07      	ldr	r3, [sp, #28]
 8012d9c:	bf18      	it	ne
 8012d9e:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
 8012da2:	4618      	mov	r0, r3
 8012da4:	b03f      	add	sp, #252	; 0xfc
 8012da6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012daa:	9d06      	ldr	r5, [sp, #24]
 8012dac:	e76f      	b.n	8012c8e <_svfprintf_r+0x8e>
 8012dae:	9306      	str	r3, [sp, #24]
 8012db0:	9b03      	ldr	r3, [sp, #12]
 8012db2:	0698      	lsls	r0, r3, #26
 8012db4:	f140 82b4 	bpl.w	8013320 <_svfprintf_r+0x720>
 8012db8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012dba:	f103 0907 	add.w	r9, r3, #7
 8012dbe:	f029 0307 	bic.w	r3, r9, #7
 8012dc2:	f103 0208 	add.w	r2, r3, #8
 8012dc6:	e9d3 8900 	ldrd	r8, r9, [r3]
 8012dca:	920a      	str	r2, [sp, #40]	; 0x28
 8012dcc:	2301      	movs	r3, #1
 8012dce:	f04f 0c00 	mov.w	ip, #0
 8012dd2:	f88d c067 	strb.w	ip, [sp, #103]	; 0x67
 8012dd6:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8012dda:	f1ba 0f00 	cmp.w	sl, #0
 8012dde:	db03      	blt.n	8012de8 <_svfprintf_r+0x1e8>
 8012de0:	9a03      	ldr	r2, [sp, #12]
 8012de2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8012de6:	9203      	str	r2, [sp, #12]
 8012de8:	ea58 0209 	orrs.w	r2, r8, r9
 8012dec:	f040 8357 	bne.w	801349e <_svfprintf_r+0x89e>
 8012df0:	f1ba 0f00 	cmp.w	sl, #0
 8012df4:	f000 845c 	beq.w	80136b0 <_svfprintf_r+0xab0>
 8012df8:	2b01      	cmp	r3, #1
 8012dfa:	f000 835a 	beq.w	80134b2 <_svfprintf_r+0x8b2>
 8012dfe:	2b02      	cmp	r3, #2
 8012e00:	f000 849a 	beq.w	8013738 <_svfprintf_r+0xb38>
 8012e04:	4639      	mov	r1, r7
 8012e06:	ea4f 02d8 	mov.w	r2, r8, lsr #3
 8012e0a:	ea42 7249 	orr.w	r2, r2, r9, lsl #29
 8012e0e:	ea4f 00d9 	mov.w	r0, r9, lsr #3
 8012e12:	f008 0307 	and.w	r3, r8, #7
 8012e16:	4681      	mov	r9, r0
 8012e18:	4690      	mov	r8, r2
 8012e1a:	3330      	adds	r3, #48	; 0x30
 8012e1c:	ea58 0209 	orrs.w	r2, r8, r9
 8012e20:	f801 3d01 	strb.w	r3, [r1, #-1]!
 8012e24:	d1ef      	bne.n	8012e06 <_svfprintf_r+0x206>
 8012e26:	9a03      	ldr	r2, [sp, #12]
 8012e28:	910c      	str	r1, [sp, #48]	; 0x30
 8012e2a:	07d2      	lsls	r2, r2, #31
 8012e2c:	f100 856e 	bmi.w	801390c <_svfprintf_r+0xd0c>
 8012e30:	1a7b      	subs	r3, r7, r1
 8012e32:	9309      	str	r3, [sp, #36]	; 0x24
 8012e34:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8012e36:	4592      	cmp	sl, r2
 8012e38:	4653      	mov	r3, sl
 8012e3a:	bfb8      	it	lt
 8012e3c:	4613      	movlt	r3, r2
 8012e3e:	9305      	str	r3, [sp, #20]
 8012e40:	2300      	movs	r3, #0
 8012e42:	930e      	str	r3, [sp, #56]	; 0x38
 8012e44:	f1bc 0f00 	cmp.w	ip, #0
 8012e48:	d002      	beq.n	8012e50 <_svfprintf_r+0x250>
 8012e4a:	9b05      	ldr	r3, [sp, #20]
 8012e4c:	3301      	adds	r3, #1
 8012e4e:	9305      	str	r3, [sp, #20]
 8012e50:	9b03      	ldr	r3, [sp, #12]
 8012e52:	f013 0302 	ands.w	r3, r3, #2
 8012e56:	930b      	str	r3, [sp, #44]	; 0x2c
 8012e58:	d002      	beq.n	8012e60 <_svfprintf_r+0x260>
 8012e5a:	9b05      	ldr	r3, [sp, #20]
 8012e5c:	3302      	adds	r3, #2
 8012e5e:	9305      	str	r3, [sp, #20]
 8012e60:	9b03      	ldr	r3, [sp, #12]
 8012e62:	f013 0984 	ands.w	r9, r3, #132	; 0x84
 8012e66:	f040 8317 	bne.w	8013498 <_svfprintf_r+0x898>
 8012e6a:	9b08      	ldr	r3, [sp, #32]
 8012e6c:	9a05      	ldr	r2, [sp, #20]
 8012e6e:	ebc2 0803 	rsb	r8, r2, r3
 8012e72:	f1b8 0f00 	cmp.w	r8, #0
 8012e76:	f340 830f 	ble.w	8013498 <_svfprintf_r+0x898>
 8012e7a:	f1b8 0f10 	cmp.w	r8, #16
 8012e7e:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012e80:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012e82:	f8df a01c 	ldr.w	sl, [pc, #28]	; 8012ea0 <_svfprintf_r+0x2a0>
 8012e86:	dd30      	ble.n	8012eea <_svfprintf_r+0x2ea>
 8012e88:	4653      	mov	r3, sl
 8012e8a:	f04f 0b10 	mov.w	fp, #16
 8012e8e:	46c2      	mov	sl, r8
 8012e90:	46a8      	mov	r8, r5
 8012e92:	461d      	mov	r5, r3
 8012e94:	e00d      	b.n	8012eb2 <_svfprintf_r+0x2b2>
 8012e96:	bf00      	nop
	...
 8012ea0:	08016fb0 	.word	0x08016fb0
 8012ea4:	f1aa 0a10 	sub.w	sl, sl, #16
 8012ea8:	f1ba 0f10 	cmp.w	sl, #16
 8012eac:	f104 0408 	add.w	r4, r4, #8
 8012eb0:	dd17      	ble.n	8012ee2 <_svfprintf_r+0x2e2>
 8012eb2:	3201      	adds	r2, #1
 8012eb4:	3110      	adds	r1, #16
 8012eb6:	2a07      	cmp	r2, #7
 8012eb8:	9123      	str	r1, [sp, #140]	; 0x8c
 8012eba:	9222      	str	r2, [sp, #136]	; 0x88
 8012ebc:	e884 0820 	stmia.w	r4, {r5, fp}
 8012ec0:	ddf0      	ble.n	8012ea4 <_svfprintf_r+0x2a4>
 8012ec2:	9804      	ldr	r0, [sp, #16]
 8012ec4:	4631      	mov	r1, r6
 8012ec6:	aa21      	add	r2, sp, #132	; 0x84
 8012ec8:	f002 ff72 	bl	8015db0 <__ssprint_r>
 8012ecc:	2800      	cmp	r0, #0
 8012ece:	f47f af5f 	bne.w	8012d90 <_svfprintf_r+0x190>
 8012ed2:	f1aa 0a10 	sub.w	sl, sl, #16
 8012ed6:	f1ba 0f10 	cmp.w	sl, #16
 8012eda:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012edc:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012ede:	463c      	mov	r4, r7
 8012ee0:	dce7      	bgt.n	8012eb2 <_svfprintf_r+0x2b2>
 8012ee2:	462b      	mov	r3, r5
 8012ee4:	4645      	mov	r5, r8
 8012ee6:	46d0      	mov	r8, sl
 8012ee8:	469a      	mov	sl, r3
 8012eea:	3201      	adds	r2, #1
 8012eec:	eb08 0b01 	add.w	fp, r8, r1
 8012ef0:	2a07      	cmp	r2, #7
 8012ef2:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8012ef6:	9222      	str	r2, [sp, #136]	; 0x88
 8012ef8:	f8c4 a000 	str.w	sl, [r4]
 8012efc:	f8c4 8004 	str.w	r8, [r4, #4]
 8012f00:	f300 847e 	bgt.w	8013800 <_svfprintf_r+0xc00>
 8012f04:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8012f08:	3408      	adds	r4, #8
 8012f0a:	f1bc 0f00 	cmp.w	ip, #0
 8012f0e:	d00f      	beq.n	8012f30 <_svfprintf_r+0x330>
 8012f10:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012f12:	3301      	adds	r3, #1
 8012f14:	f10b 0b01 	add.w	fp, fp, #1
 8012f18:	f10d 0167 	add.w	r1, sp, #103	; 0x67
 8012f1c:	2201      	movs	r2, #1
 8012f1e:	2b07      	cmp	r3, #7
 8012f20:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8012f24:	9322      	str	r3, [sp, #136]	; 0x88
 8012f26:	e884 0006 	stmia.w	r4, {r1, r2}
 8012f2a:	f300 83ea 	bgt.w	8013702 <_svfprintf_r+0xb02>
 8012f2e:	3408      	adds	r4, #8
 8012f30:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012f32:	b173      	cbz	r3, 8012f52 <_svfprintf_r+0x352>
 8012f34:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012f36:	3301      	adds	r3, #1
 8012f38:	f10b 0b02 	add.w	fp, fp, #2
 8012f3c:	a91a      	add	r1, sp, #104	; 0x68
 8012f3e:	2202      	movs	r2, #2
 8012f40:	2b07      	cmp	r3, #7
 8012f42:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8012f46:	9322      	str	r3, [sp, #136]	; 0x88
 8012f48:	e884 0006 	stmia.w	r4, {r1, r2}
 8012f4c:	f300 83cd 	bgt.w	80136ea <_svfprintf_r+0xaea>
 8012f50:	3408      	adds	r4, #8
 8012f52:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
 8012f56:	f000 8315 	beq.w	8013584 <_svfprintf_r+0x984>
 8012f5a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012f5c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8012f5e:	ebc2 0a03 	rsb	sl, r2, r3
 8012f62:	f1ba 0f00 	cmp.w	sl, #0
 8012f66:	dd3c      	ble.n	8012fe2 <_svfprintf_r+0x3e2>
 8012f68:	f1ba 0f10 	cmp.w	sl, #16
 8012f6c:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012f6e:	f8df 9464 	ldr.w	r9, [pc, #1124]	; 80133d4 <_svfprintf_r+0x7d4>
 8012f72:	dd2b      	ble.n	8012fcc <_svfprintf_r+0x3cc>
 8012f74:	4649      	mov	r1, r9
 8012f76:	465b      	mov	r3, fp
 8012f78:	46a9      	mov	r9, r5
 8012f7a:	f04f 0810 	mov.w	r8, #16
 8012f7e:	f8dd b010 	ldr.w	fp, [sp, #16]
 8012f82:	460d      	mov	r5, r1
 8012f84:	e006      	b.n	8012f94 <_svfprintf_r+0x394>
 8012f86:	f1aa 0a10 	sub.w	sl, sl, #16
 8012f8a:	f1ba 0f10 	cmp.w	sl, #16
 8012f8e:	f104 0408 	add.w	r4, r4, #8
 8012f92:	dd17      	ble.n	8012fc4 <_svfprintf_r+0x3c4>
 8012f94:	3201      	adds	r2, #1
 8012f96:	3310      	adds	r3, #16
 8012f98:	2a07      	cmp	r2, #7
 8012f9a:	9323      	str	r3, [sp, #140]	; 0x8c
 8012f9c:	9222      	str	r2, [sp, #136]	; 0x88
 8012f9e:	e884 0120 	stmia.w	r4, {r5, r8}
 8012fa2:	ddf0      	ble.n	8012f86 <_svfprintf_r+0x386>
 8012fa4:	4658      	mov	r0, fp
 8012fa6:	4631      	mov	r1, r6
 8012fa8:	aa21      	add	r2, sp, #132	; 0x84
 8012faa:	f002 ff01 	bl	8015db0 <__ssprint_r>
 8012fae:	2800      	cmp	r0, #0
 8012fb0:	f47f aeee 	bne.w	8012d90 <_svfprintf_r+0x190>
 8012fb4:	f1aa 0a10 	sub.w	sl, sl, #16
 8012fb8:	f1ba 0f10 	cmp.w	sl, #16
 8012fbc:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012fbe:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012fc0:	463c      	mov	r4, r7
 8012fc2:	dce7      	bgt.n	8012f94 <_svfprintf_r+0x394>
 8012fc4:	469b      	mov	fp, r3
 8012fc6:	462b      	mov	r3, r5
 8012fc8:	464d      	mov	r5, r9
 8012fca:	4699      	mov	r9, r3
 8012fcc:	3201      	adds	r2, #1
 8012fce:	44d3      	add	fp, sl
 8012fd0:	2a07      	cmp	r2, #7
 8012fd2:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8012fd6:	9222      	str	r2, [sp, #136]	; 0x88
 8012fd8:	e884 0600 	stmia.w	r4, {r9, sl}
 8012fdc:	f300 8379 	bgt.w	80136d2 <_svfprintf_r+0xad2>
 8012fe0:	3408      	adds	r4, #8
 8012fe2:	9b03      	ldr	r3, [sp, #12]
 8012fe4:	05d9      	lsls	r1, r3, #23
 8012fe6:	f100 8270 	bmi.w	80134ca <_svfprintf_r+0x8ca>
 8012fea:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012fec:	9909      	ldr	r1, [sp, #36]	; 0x24
 8012fee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8012ff0:	6022      	str	r2, [r4, #0]
 8012ff2:	3301      	adds	r3, #1
 8012ff4:	448b      	add	fp, r1
 8012ff6:	2b07      	cmp	r3, #7
 8012ff8:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8012ffc:	6061      	str	r1, [r4, #4]
 8012ffe:	9322      	str	r3, [sp, #136]	; 0x88
 8013000:	f300 834a 	bgt.w	8013698 <_svfprintf_r+0xa98>
 8013004:	3408      	adds	r4, #8
 8013006:	9b03      	ldr	r3, [sp, #12]
 8013008:	075a      	lsls	r2, r3, #29
 801300a:	d541      	bpl.n	8013090 <_svfprintf_r+0x490>
 801300c:	9b08      	ldr	r3, [sp, #32]
 801300e:	9a05      	ldr	r2, [sp, #20]
 8013010:	1a9d      	subs	r5, r3, r2
 8013012:	2d00      	cmp	r5, #0
 8013014:	dd3c      	ble.n	8013090 <_svfprintf_r+0x490>
 8013016:	2d10      	cmp	r5, #16
 8013018:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801301a:	f8df a3bc 	ldr.w	sl, [pc, #956]	; 80133d8 <_svfprintf_r+0x7d8>
 801301e:	dd23      	ble.n	8013068 <_svfprintf_r+0x468>
 8013020:	f04f 0810 	mov.w	r8, #16
 8013024:	465a      	mov	r2, fp
 8013026:	f8dd 9010 	ldr.w	r9, [sp, #16]
 801302a:	e004      	b.n	8013036 <_svfprintf_r+0x436>
 801302c:	3d10      	subs	r5, #16
 801302e:	2d10      	cmp	r5, #16
 8013030:	f104 0408 	add.w	r4, r4, #8
 8013034:	dd17      	ble.n	8013066 <_svfprintf_r+0x466>
 8013036:	3301      	adds	r3, #1
 8013038:	3210      	adds	r2, #16
 801303a:	2b07      	cmp	r3, #7
 801303c:	9223      	str	r2, [sp, #140]	; 0x8c
 801303e:	9322      	str	r3, [sp, #136]	; 0x88
 8013040:	f8c4 a000 	str.w	sl, [r4]
 8013044:	f8c4 8004 	str.w	r8, [r4, #4]
 8013048:	ddf0      	ble.n	801302c <_svfprintf_r+0x42c>
 801304a:	4648      	mov	r0, r9
 801304c:	4631      	mov	r1, r6
 801304e:	aa21      	add	r2, sp, #132	; 0x84
 8013050:	f002 feae 	bl	8015db0 <__ssprint_r>
 8013054:	2800      	cmp	r0, #0
 8013056:	f47f ae9b 	bne.w	8012d90 <_svfprintf_r+0x190>
 801305a:	3d10      	subs	r5, #16
 801305c:	2d10      	cmp	r5, #16
 801305e:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8013060:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013062:	463c      	mov	r4, r7
 8013064:	dce7      	bgt.n	8013036 <_svfprintf_r+0x436>
 8013066:	4693      	mov	fp, r2
 8013068:	3301      	adds	r3, #1
 801306a:	44ab      	add	fp, r5
 801306c:	2b07      	cmp	r3, #7
 801306e:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013072:	9322      	str	r3, [sp, #136]	; 0x88
 8013074:	f8c4 a000 	str.w	sl, [r4]
 8013078:	6065      	str	r5, [r4, #4]
 801307a:	dd09      	ble.n	8013090 <_svfprintf_r+0x490>
 801307c:	9804      	ldr	r0, [sp, #16]
 801307e:	4631      	mov	r1, r6
 8013080:	aa21      	add	r2, sp, #132	; 0x84
 8013082:	f002 fe95 	bl	8015db0 <__ssprint_r>
 8013086:	2800      	cmp	r0, #0
 8013088:	f47f ae82 	bne.w	8012d90 <_svfprintf_r+0x190>
 801308c:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013090:	9b07      	ldr	r3, [sp, #28]
 8013092:	9a05      	ldr	r2, [sp, #20]
 8013094:	9908      	ldr	r1, [sp, #32]
 8013096:	428a      	cmp	r2, r1
 8013098:	bfac      	ite	ge
 801309a:	189b      	addge	r3, r3, r2
 801309c:	185b      	addlt	r3, r3, r1
 801309e:	9307      	str	r3, [sp, #28]
 80130a0:	f1bb 0f00 	cmp.w	fp, #0
 80130a4:	f47f ae6c 	bne.w	8012d80 <_svfprintf_r+0x180>
 80130a8:	2300      	movs	r3, #0
 80130aa:	9322      	str	r3, [sp, #136]	; 0x88
 80130ac:	463c      	mov	r4, r7
 80130ae:	e5ce      	b.n	8012c4e <_svfprintf_r+0x4e>
 80130b0:	4619      	mov	r1, r3
 80130b2:	9803      	ldr	r0, [sp, #12]
 80130b4:	781d      	ldrb	r5, [r3, #0]
 80130b6:	f040 0004 	orr.w	r0, r0, #4
 80130ba:	9003      	str	r0, [sp, #12]
 80130bc:	e5f5      	b.n	8012caa <_svfprintf_r+0xaa>
 80130be:	9306      	str	r3, [sp, #24]
 80130c0:	9b03      	ldr	r3, [sp, #12]
 80130c2:	f013 0320 	ands.w	r3, r3, #32
 80130c6:	f000 810e 	beq.w	80132e6 <_svfprintf_r+0x6e6>
 80130ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80130cc:	f103 0907 	add.w	r9, r3, #7
 80130d0:	f029 0307 	bic.w	r3, r9, #7
 80130d4:	f103 0208 	add.w	r2, r3, #8
 80130d8:	e9d3 8900 	ldrd	r8, r9, [r3]
 80130dc:	920a      	str	r2, [sp, #40]	; 0x28
 80130de:	2300      	movs	r3, #0
 80130e0:	e675      	b.n	8012dce <_svfprintf_r+0x1ce>
 80130e2:	781d      	ldrb	r5, [r3, #0]
 80130e4:	4619      	mov	r1, r3
 80130e6:	222b      	movs	r2, #43	; 0x2b
 80130e8:	e5df      	b.n	8012caa <_svfprintf_r+0xaa>
 80130ea:	781d      	ldrb	r5, [r3, #0]
 80130ec:	2d2a      	cmp	r5, #42	; 0x2a
 80130ee:	f103 0101 	add.w	r1, r3, #1
 80130f2:	f000 87b8 	beq.w	8014066 <_svfprintf_r+0x1466>
 80130f6:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
 80130fa:	2809      	cmp	r0, #9
 80130fc:	460b      	mov	r3, r1
 80130fe:	f04f 0a00 	mov.w	sl, #0
 8013102:	f63f add3 	bhi.w	8012cac <_svfprintf_r+0xac>
 8013106:	f813 5b01 	ldrb.w	r5, [r3], #1
 801310a:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
 801310e:	eb00 0a4a 	add.w	sl, r0, sl, lsl #1
 8013112:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
 8013116:	2809      	cmp	r0, #9
 8013118:	d9f5      	bls.n	8013106 <_svfprintf_r+0x506>
 801311a:	ea4a 7aea 	orr.w	sl, sl, sl, asr #31
 801311e:	e5c5      	b.n	8012cac <_svfprintf_r+0xac>
 8013120:	9306      	str	r3, [sp, #24]
 8013122:	9b03      	ldr	r3, [sp, #12]
 8013124:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 8013128:	069b      	lsls	r3, r3, #26
 801312a:	f140 80a1 	bpl.w	8013270 <_svfprintf_r+0x670>
 801312e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013130:	f103 0907 	add.w	r9, r3, #7
 8013134:	f029 0907 	bic.w	r9, r9, #7
 8013138:	e9d9 2300 	ldrd	r2, r3, [r9]
 801313c:	f109 0108 	add.w	r1, r9, #8
 8013140:	910a      	str	r1, [sp, #40]	; 0x28
 8013142:	4690      	mov	r8, r2
 8013144:	4699      	mov	r9, r3
 8013146:	2a00      	cmp	r2, #0
 8013148:	f173 0300 	sbcs.w	r3, r3, #0
 801314c:	f2c0 840e 	blt.w	801396c <_svfprintf_r+0xd6c>
 8013150:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8013154:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8013158:	2301      	movs	r3, #1
 801315a:	e63e      	b.n	8012dda <_svfprintf_r+0x1da>
 801315c:	9306      	str	r3, [sp, #24]
 801315e:	4b9b      	ldr	r3, [pc, #620]	; (80133cc <_svfprintf_r+0x7cc>)
 8013160:	9312      	str	r3, [sp, #72]	; 0x48
 8013162:	9b03      	ldr	r3, [sp, #12]
 8013164:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 8013168:	069b      	lsls	r3, r3, #26
 801316a:	f140 80f3 	bpl.w	8013354 <_svfprintf_r+0x754>
 801316e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013170:	f103 0907 	add.w	r9, r3, #7
 8013174:	f029 0307 	bic.w	r3, r9, #7
 8013178:	e9d3 8900 	ldrd	r8, r9, [r3]
 801317c:	f103 0208 	add.w	r2, r3, #8
 8013180:	920a      	str	r2, [sp, #40]	; 0x28
 8013182:	9b03      	ldr	r3, [sp, #12]
 8013184:	07d9      	lsls	r1, r3, #31
 8013186:	f140 80f5 	bpl.w	8013374 <_svfprintf_r+0x774>
 801318a:	ea58 0309 	orrs.w	r3, r8, r9
 801318e:	f000 80f1 	beq.w	8013374 <_svfprintf_r+0x774>
 8013192:	9a03      	ldr	r2, [sp, #12]
 8013194:	f88d 5069 	strb.w	r5, [sp, #105]	; 0x69
 8013198:	2330      	movs	r3, #48	; 0x30
 801319a:	f042 0202 	orr.w	r2, r2, #2
 801319e:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
 80131a2:	9203      	str	r2, [sp, #12]
 80131a4:	2302      	movs	r3, #2
 80131a6:	e612      	b.n	8012dce <_svfprintf_r+0x1ce>
 80131a8:	781d      	ldrb	r5, [r3, #0]
 80131aa:	4619      	mov	r1, r3
 80131ac:	2a00      	cmp	r2, #0
 80131ae:	f47f ad7c 	bne.w	8012caa <_svfprintf_r+0xaa>
 80131b2:	2220      	movs	r2, #32
 80131b4:	e579      	b.n	8012caa <_svfprintf_r+0xaa>
 80131b6:	9903      	ldr	r1, [sp, #12]
 80131b8:	f041 0120 	orr.w	r1, r1, #32
 80131bc:	9103      	str	r1, [sp, #12]
 80131be:	781d      	ldrb	r5, [r3, #0]
 80131c0:	4619      	mov	r1, r3
 80131c2:	e572      	b.n	8012caa <_svfprintf_r+0xaa>
 80131c4:	9306      	str	r3, [sp, #24]
 80131c6:	9b03      	ldr	r3, [sp, #12]
 80131c8:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 80131cc:	069a      	lsls	r2, r3, #26
 80131ce:	f140 84b0 	bpl.w	8013b32 <_svfprintf_r+0xf32>
 80131d2:	9907      	ldr	r1, [sp, #28]
 80131d4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80131d6:	ea4f 79e1 	mov.w	r9, r1, asr #31
 80131da:	6813      	ldr	r3, [r2, #0]
 80131dc:	4608      	mov	r0, r1
 80131de:	4688      	mov	r8, r1
 80131e0:	3204      	adds	r2, #4
 80131e2:	4649      	mov	r1, r9
 80131e4:	920a      	str	r2, [sp, #40]	; 0x28
 80131e6:	e9c3 0100 	strd	r0, r1, [r3]
 80131ea:	e530      	b.n	8012c4e <_svfprintf_r+0x4e>
 80131ec:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80131ee:	9306      	str	r3, [sp, #24]
 80131f0:	6813      	ldr	r3, [r2, #0]
 80131f2:	930c      	str	r3, [sp, #48]	; 0x30
 80131f4:	f04f 0b00 	mov.w	fp, #0
 80131f8:	f88d b067 	strb.w	fp, [sp, #103]	; 0x67
 80131fc:	f102 0904 	add.w	r9, r2, #4
 8013200:	2b00      	cmp	r3, #0
 8013202:	f000 8646 	beq.w	8013e92 <_svfprintf_r+0x1292>
 8013206:	f1ba 0f00 	cmp.w	sl, #0
 801320a:	980c      	ldr	r0, [sp, #48]	; 0x30
 801320c:	f2c0 85f6 	blt.w	8013dfc <_svfprintf_r+0x11fc>
 8013210:	4659      	mov	r1, fp
 8013212:	4652      	mov	r2, sl
 8013214:	f002 f9ec 	bl	80155f0 <memchr>
 8013218:	2800      	cmp	r0, #0
 801321a:	f000 8677 	beq.w	8013f0c <_svfprintf_r+0x130c>
 801321e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013220:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
 8013224:	1ac3      	subs	r3, r0, r3
 8013226:	9309      	str	r3, [sp, #36]	; 0x24
 8013228:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 801322c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8013230:	9305      	str	r3, [sp, #20]
 8013232:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
 8013236:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 801323a:	e603      	b.n	8012e44 <_svfprintf_r+0x244>
 801323c:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
 8013240:	2100      	movs	r1, #0
 8013242:	f813 5b01 	ldrb.w	r5, [r3], #1
 8013246:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 801324a:	eb00 0141 	add.w	r1, r0, r1, lsl #1
 801324e:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
 8013252:	2809      	cmp	r0, #9
 8013254:	d9f5      	bls.n	8013242 <_svfprintf_r+0x642>
 8013256:	9108      	str	r1, [sp, #32]
 8013258:	e528      	b.n	8012cac <_svfprintf_r+0xac>
 801325a:	9306      	str	r3, [sp, #24]
 801325c:	9b03      	ldr	r3, [sp, #12]
 801325e:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 8013262:	f043 0310 	orr.w	r3, r3, #16
 8013266:	9303      	str	r3, [sp, #12]
 8013268:	9b03      	ldr	r3, [sp, #12]
 801326a:	069b      	lsls	r3, r3, #26
 801326c:	f53f af5f 	bmi.w	801312e <_svfprintf_r+0x52e>
 8013270:	9b03      	ldr	r3, [sp, #12]
 8013272:	06d8      	lsls	r0, r3, #27
 8013274:	f100 836b 	bmi.w	801394e <_svfprintf_r+0xd4e>
 8013278:	9b03      	ldr	r3, [sp, #12]
 801327a:	0659      	lsls	r1, r3, #25
 801327c:	f140 8367 	bpl.w	801394e <_svfprintf_r+0xd4e>
 8013280:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013282:	f9b1 8000 	ldrsh.w	r8, [r1]
 8013286:	3104      	adds	r1, #4
 8013288:	ea4f 79e8 	mov.w	r9, r8, asr #31
 801328c:	4642      	mov	r2, r8
 801328e:	464b      	mov	r3, r9
 8013290:	910a      	str	r1, [sp, #40]	; 0x28
 8013292:	e758      	b.n	8013146 <_svfprintf_r+0x546>
 8013294:	781d      	ldrb	r5, [r3, #0]
 8013296:	9903      	ldr	r1, [sp, #12]
 8013298:	2d6c      	cmp	r5, #108	; 0x6c
 801329a:	f000 84d3 	beq.w	8013c44 <_svfprintf_r+0x1044>
 801329e:	f041 0110 	orr.w	r1, r1, #16
 80132a2:	9103      	str	r1, [sp, #12]
 80132a4:	4619      	mov	r1, r3
 80132a6:	e500      	b.n	8012caa <_svfprintf_r+0xaa>
 80132a8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80132aa:	6829      	ldr	r1, [r5, #0]
 80132ac:	9108      	str	r1, [sp, #32]
 80132ae:	4608      	mov	r0, r1
 80132b0:	2800      	cmp	r0, #0
 80132b2:	4629      	mov	r1, r5
 80132b4:	f101 0104 	add.w	r1, r1, #4
 80132b8:	f2c0 84cb 	blt.w	8013c52 <_svfprintf_r+0x1052>
 80132bc:	910a      	str	r1, [sp, #40]	; 0x28
 80132be:	781d      	ldrb	r5, [r3, #0]
 80132c0:	4619      	mov	r1, r3
 80132c2:	e4f2      	b.n	8012caa <_svfprintf_r+0xaa>
 80132c4:	9903      	ldr	r1, [sp, #12]
 80132c6:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 80132ca:	9103      	str	r1, [sp, #12]
 80132cc:	781d      	ldrb	r5, [r3, #0]
 80132ce:	4619      	mov	r1, r3
 80132d0:	e4eb      	b.n	8012caa <_svfprintf_r+0xaa>
 80132d2:	9306      	str	r3, [sp, #24]
 80132d4:	9b03      	ldr	r3, [sp, #12]
 80132d6:	f043 0310 	orr.w	r3, r3, #16
 80132da:	9303      	str	r3, [sp, #12]
 80132dc:	9b03      	ldr	r3, [sp, #12]
 80132de:	f013 0320 	ands.w	r3, r3, #32
 80132e2:	f47f aef2 	bne.w	80130ca <_svfprintf_r+0x4ca>
 80132e6:	9a03      	ldr	r2, [sp, #12]
 80132e8:	f012 0210 	ands.w	r2, r2, #16
 80132ec:	f040 831c 	bne.w	8013928 <_svfprintf_r+0xd28>
 80132f0:	9b03      	ldr	r3, [sp, #12]
 80132f2:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 80132f6:	f000 8317 	beq.w	8013928 <_svfprintf_r+0xd28>
 80132fa:	990a      	ldr	r1, [sp, #40]	; 0x28
 80132fc:	4613      	mov	r3, r2
 80132fe:	460a      	mov	r2, r1
 8013300:	3204      	adds	r2, #4
 8013302:	f8b1 8000 	ldrh.w	r8, [r1]
 8013306:	920a      	str	r2, [sp, #40]	; 0x28
 8013308:	f04f 0900 	mov.w	r9, #0
 801330c:	e55f      	b.n	8012dce <_svfprintf_r+0x1ce>
 801330e:	9306      	str	r3, [sp, #24]
 8013310:	9b03      	ldr	r3, [sp, #12]
 8013312:	f043 0310 	orr.w	r3, r3, #16
 8013316:	9303      	str	r3, [sp, #12]
 8013318:	9b03      	ldr	r3, [sp, #12]
 801331a:	0698      	lsls	r0, r3, #26
 801331c:	f53f ad4c 	bmi.w	8012db8 <_svfprintf_r+0x1b8>
 8013320:	9b03      	ldr	r3, [sp, #12]
 8013322:	06d9      	lsls	r1, r3, #27
 8013324:	f100 8309 	bmi.w	801393a <_svfprintf_r+0xd3a>
 8013328:	9b03      	ldr	r3, [sp, #12]
 801332a:	065a      	lsls	r2, r3, #25
 801332c:	f140 8305 	bpl.w	801393a <_svfprintf_r+0xd3a>
 8013330:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013332:	f8b2 8000 	ldrh.w	r8, [r2]
 8013336:	3204      	adds	r2, #4
 8013338:	f04f 0900 	mov.w	r9, #0
 801333c:	2301      	movs	r3, #1
 801333e:	920a      	str	r2, [sp, #40]	; 0x28
 8013340:	e545      	b.n	8012dce <_svfprintf_r+0x1ce>
 8013342:	9306      	str	r3, [sp, #24]
 8013344:	4b22      	ldr	r3, [pc, #136]	; (80133d0 <_svfprintf_r+0x7d0>)
 8013346:	9312      	str	r3, [sp, #72]	; 0x48
 8013348:	9b03      	ldr	r3, [sp, #12]
 801334a:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 801334e:	069b      	lsls	r3, r3, #26
 8013350:	f53f af0d 	bmi.w	801316e <_svfprintf_r+0x56e>
 8013354:	9b03      	ldr	r3, [sp, #12]
 8013356:	06d8      	lsls	r0, r3, #27
 8013358:	f140 83dc 	bpl.w	8013b14 <_svfprintf_r+0xf14>
 801335c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801335e:	4613      	mov	r3, r2
 8013360:	681b      	ldr	r3, [r3, #0]
 8013362:	4698      	mov	r8, r3
 8013364:	9b03      	ldr	r3, [sp, #12]
 8013366:	3204      	adds	r2, #4
 8013368:	07d9      	lsls	r1, r3, #31
 801336a:	920a      	str	r2, [sp, #40]	; 0x28
 801336c:	f04f 0900 	mov.w	r9, #0
 8013370:	f53f af0b 	bmi.w	801318a <_svfprintf_r+0x58a>
 8013374:	2302      	movs	r3, #2
 8013376:	e52a      	b.n	8012dce <_svfprintf_r+0x1ce>
 8013378:	990a      	ldr	r1, [sp, #40]	; 0x28
 801337a:	9306      	str	r3, [sp, #24]
 801337c:	680a      	ldr	r2, [r1, #0]
 801337e:	f88d 2090 	strb.w	r2, [sp, #144]	; 0x90
 8013382:	2300      	movs	r3, #0
 8013384:	2201      	movs	r2, #1
 8013386:	3104      	adds	r1, #4
 8013388:	469c      	mov	ip, r3
 801338a:	9205      	str	r2, [sp, #20]
 801338c:	910a      	str	r1, [sp, #40]	; 0x28
 801338e:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
 8013392:	ab24      	add	r3, sp, #144	; 0x90
 8013394:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 8013398:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
 801339c:	9209      	str	r2, [sp, #36]	; 0x24
 801339e:	930c      	str	r3, [sp, #48]	; 0x30
 80133a0:	e556      	b.n	8012e50 <_svfprintf_r+0x250>
 80133a2:	9903      	ldr	r1, [sp, #12]
 80133a4:	f041 0108 	orr.w	r1, r1, #8
 80133a8:	9103      	str	r1, [sp, #12]
 80133aa:	781d      	ldrb	r5, [r3, #0]
 80133ac:	4619      	mov	r1, r3
 80133ae:	e47c      	b.n	8012caa <_svfprintf_r+0xaa>
 80133b0:	9903      	ldr	r1, [sp, #12]
 80133b2:	f041 0101 	orr.w	r1, r1, #1
 80133b6:	9103      	str	r1, [sp, #12]
 80133b8:	781d      	ldrb	r5, [r3, #0]
 80133ba:	4619      	mov	r1, r3
 80133bc:	e475      	b.n	8012caa <_svfprintf_r+0xaa>
 80133be:	9903      	ldr	r1, [sp, #12]
 80133c0:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 80133c4:	9103      	str	r1, [sp, #12]
 80133c6:	781d      	ldrb	r5, [r3, #0]
 80133c8:	4619      	mov	r1, r3
 80133ca:	e46e      	b.n	8012caa <_svfprintf_r+0xaa>
 80133cc:	08016fe4 	.word	0x08016fe4
 80133d0:	08016fd0 	.word	0x08016fd0
 80133d4:	08016fa0 	.word	0x08016fa0
 80133d8:	08016fb0 	.word	0x08016fb0
 80133dc:	9306      	str	r3, [sp, #24]
 80133de:	9b03      	ldr	r3, [sp, #12]
 80133e0:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 80133e4:	f013 0f08 	tst.w	r3, #8
 80133e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80133ea:	46d3      	mov	fp, sl
 80133ec:	f103 0907 	add.w	r9, r3, #7
 80133f0:	f000 8386 	beq.w	8013b00 <_svfprintf_r+0xf00>
 80133f4:	f029 0307 	bic.w	r3, r9, #7
 80133f8:	ed93 7b00 	vldr	d7, [r3]
 80133fc:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8013400:	f103 0208 	add.w	r2, r3, #8
 8013404:	920a      	str	r2, [sp, #40]	; 0x28
 8013406:	ed9d 0b10 	vldr	d0, [sp, #64]	; 0x40
 801340a:	f002 fc71 	bl	8015cf0 <__fpclassifyd>
 801340e:	2801      	cmp	r0, #1
 8013410:	f040 835a 	bne.w	8013ac8 <_svfprintf_r+0xec8>
 8013414:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8013418:	2200      	movs	r2, #0
 801341a:	2300      	movs	r3, #0
 801341c:	f7f9 fb90 	bl	800cb40 <__aeabi_dcmplt>
 8013420:	2800      	cmp	r0, #0
 8013422:	f040 856b 	bne.w	8013efc <_svfprintf_r+0x12fc>
 8013426:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 801342a:	9b03      	ldr	r3, [sp, #12]
 801342c:	4abd      	ldr	r2, [pc, #756]	; (8013724 <_svfprintf_r+0xb24>)
 801342e:	f8df e300 	ldr.w	lr, [pc, #768]	; 8013730 <_svfprintf_r+0xb30>
 8013432:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8013436:	9303      	str	r3, [sp, #12]
 8013438:	4613      	mov	r3, r2
 801343a:	2103      	movs	r1, #3
 801343c:	2000      	movs	r0, #0
 801343e:	2d47      	cmp	r5, #71	; 0x47
 8013440:	bfd8      	it	le
 8013442:	4673      	movle	r3, lr
 8013444:	9105      	str	r1, [sp, #20]
 8013446:	900d      	str	r0, [sp, #52]	; 0x34
 8013448:	930c      	str	r3, [sp, #48]	; 0x30
 801344a:	9109      	str	r1, [sp, #36]	; 0x24
 801344c:	900e      	str	r0, [sp, #56]	; 0x38
 801344e:	e4f9      	b.n	8012e44 <_svfprintf_r+0x244>
 8013450:	980a      	ldr	r0, [sp, #40]	; 0x28
 8013452:	9903      	ldr	r1, [sp, #12]
 8013454:	9306      	str	r3, [sp, #24]
 8013456:	2230      	movs	r2, #48	; 0x30
 8013458:	6803      	ldr	r3, [r0, #0]
 801345a:	f88d 2068 	strb.w	r2, [sp, #104]	; 0x68
 801345e:	4602      	mov	r2, r0
 8013460:	2578      	movs	r5, #120	; 0x78
 8013462:	f041 0102 	orr.w	r1, r1, #2
 8013466:	3204      	adds	r2, #4
 8013468:	4698      	mov	r8, r3
 801346a:	4baf      	ldr	r3, [pc, #700]	; (8013728 <_svfprintf_r+0xb28>)
 801346c:	9312      	str	r3, [sp, #72]	; 0x48
 801346e:	9103      	str	r1, [sp, #12]
 8013470:	920a      	str	r2, [sp, #40]	; 0x28
 8013472:	f04f 0900 	mov.w	r9, #0
 8013476:	f88d 5069 	strb.w	r5, [sp, #105]	; 0x69
 801347a:	2302      	movs	r3, #2
 801347c:	e4a7      	b.n	8012dce <_svfprintf_r+0x1ce>
 801347e:	9306      	str	r3, [sp, #24]
 8013480:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 8013484:	2d00      	cmp	r5, #0
 8013486:	f000 83d1 	beq.w	8013c2c <_svfprintf_r+0x102c>
 801348a:	2300      	movs	r3, #0
 801348c:	2201      	movs	r2, #1
 801348e:	469c      	mov	ip, r3
 8013490:	9205      	str	r2, [sp, #20]
 8013492:	f88d 5090 	strb.w	r5, [sp, #144]	; 0x90
 8013496:	e77a      	b.n	801338e <_svfprintf_r+0x78e>
 8013498:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 801349c:	e535      	b.n	8012f0a <_svfprintf_r+0x30a>
 801349e:	2b01      	cmp	r3, #1
 80134a0:	f47f acad 	bne.w	8012dfe <_svfprintf_r+0x1fe>
 80134a4:	f1b9 0f00 	cmp.w	r9, #0
 80134a8:	bf08      	it	eq
 80134aa:	f1b8 0f0a 	cmpeq.w	r8, #10
 80134ae:	f080 820d 	bcs.w	80138cc <_svfprintf_r+0xccc>
 80134b2:	f10d 0bf8 	add.w	fp, sp, #248	; 0xf8
 80134b6:	f108 0830 	add.w	r8, r8, #48	; 0x30
 80134ba:	f80b 8d41 	strb.w	r8, [fp, #-65]!
 80134be:	ebcb 0307 	rsb	r3, fp, r7
 80134c2:	9309      	str	r3, [sp, #36]	; 0x24
 80134c4:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 80134c8:	e4b4      	b.n	8012e34 <_svfprintf_r+0x234>
 80134ca:	2d65      	cmp	r5, #101	; 0x65
 80134cc:	f340 80a0 	ble.w	8013610 <_svfprintf_r+0xa10>
 80134d0:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 80134d4:	2200      	movs	r2, #0
 80134d6:	2300      	movs	r3, #0
 80134d8:	f7f9 fb28 	bl	800cb2c <__aeabi_dcmpeq>
 80134dc:	2800      	cmp	r0, #0
 80134de:	f000 8144 	beq.w	801376a <_svfprintf_r+0xb6a>
 80134e2:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80134e4:	4a91      	ldr	r2, [pc, #580]	; (801372c <_svfprintf_r+0xb2c>)
 80134e6:	6022      	str	r2, [r4, #0]
 80134e8:	3301      	adds	r3, #1
 80134ea:	f10b 0b01 	add.w	fp, fp, #1
 80134ee:	2201      	movs	r2, #1
 80134f0:	2b07      	cmp	r3, #7
 80134f2:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 80134f6:	9322      	str	r3, [sp, #136]	; 0x88
 80134f8:	6062      	str	r2, [r4, #4]
 80134fa:	f300 833f 	bgt.w	8013b7c <_svfprintf_r+0xf7c>
 80134fe:	3408      	adds	r4, #8
 8013500:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8013502:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8013504:	4293      	cmp	r3, r2
 8013506:	db03      	blt.n	8013510 <_svfprintf_r+0x910>
 8013508:	9b03      	ldr	r3, [sp, #12]
 801350a:	07da      	lsls	r2, r3, #31
 801350c:	f57f ad7b 	bpl.w	8013006 <_svfprintf_r+0x406>
 8013510:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013512:	9914      	ldr	r1, [sp, #80]	; 0x50
 8013514:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8013516:	6022      	str	r2, [r4, #0]
 8013518:	3301      	adds	r3, #1
 801351a:	448b      	add	fp, r1
 801351c:	2b07      	cmp	r3, #7
 801351e:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013522:	6061      	str	r1, [r4, #4]
 8013524:	9322      	str	r3, [sp, #136]	; 0x88
 8013526:	f300 839b 	bgt.w	8013c60 <_svfprintf_r+0x1060>
 801352a:	3408      	adds	r4, #8
 801352c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801352e:	1e5d      	subs	r5, r3, #1
 8013530:	2d00      	cmp	r5, #0
 8013532:	f77f ad68 	ble.w	8013006 <_svfprintf_r+0x406>
 8013536:	2d10      	cmp	r5, #16
 8013538:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801353a:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 8013734 <_svfprintf_r+0xb34>
 801353e:	f340 81b9 	ble.w	80138b4 <_svfprintf_r+0xcb4>
 8013542:	f04f 0810 	mov.w	r8, #16
 8013546:	465a      	mov	r2, fp
 8013548:	f8dd a010 	ldr.w	sl, [sp, #16]
 801354c:	e004      	b.n	8013558 <_svfprintf_r+0x958>
 801354e:	3408      	adds	r4, #8
 8013550:	3d10      	subs	r5, #16
 8013552:	2d10      	cmp	r5, #16
 8013554:	f340 81ad 	ble.w	80138b2 <_svfprintf_r+0xcb2>
 8013558:	3301      	adds	r3, #1
 801355a:	3210      	adds	r2, #16
 801355c:	2b07      	cmp	r3, #7
 801355e:	9223      	str	r2, [sp, #140]	; 0x8c
 8013560:	9322      	str	r3, [sp, #136]	; 0x88
 8013562:	f8c4 9000 	str.w	r9, [r4]
 8013566:	f8c4 8004 	str.w	r8, [r4, #4]
 801356a:	ddf0      	ble.n	801354e <_svfprintf_r+0x94e>
 801356c:	4650      	mov	r0, sl
 801356e:	4631      	mov	r1, r6
 8013570:	aa21      	add	r2, sp, #132	; 0x84
 8013572:	f002 fc1d 	bl	8015db0 <__ssprint_r>
 8013576:	2800      	cmp	r0, #0
 8013578:	f47f ac0a 	bne.w	8012d90 <_svfprintf_r+0x190>
 801357c:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801357e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013580:	463c      	mov	r4, r7
 8013582:	e7e5      	b.n	8013550 <_svfprintf_r+0x950>
 8013584:	9b08      	ldr	r3, [sp, #32]
 8013586:	9a05      	ldr	r2, [sp, #20]
 8013588:	ebc2 0a03 	rsb	sl, r2, r3
 801358c:	f1ba 0f00 	cmp.w	sl, #0
 8013590:	f77f ace3 	ble.w	8012f5a <_svfprintf_r+0x35a>
 8013594:	f1ba 0f10 	cmp.w	sl, #16
 8013598:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801359a:	f8df 9198 	ldr.w	r9, [pc, #408]	; 8013734 <_svfprintf_r+0xb34>
 801359e:	dd2b      	ble.n	80135f8 <_svfprintf_r+0x9f8>
 80135a0:	4649      	mov	r1, r9
 80135a2:	465b      	mov	r3, fp
 80135a4:	46a9      	mov	r9, r5
 80135a6:	f04f 0810 	mov.w	r8, #16
 80135aa:	f8dd b010 	ldr.w	fp, [sp, #16]
 80135ae:	460d      	mov	r5, r1
 80135b0:	e006      	b.n	80135c0 <_svfprintf_r+0x9c0>
 80135b2:	f1aa 0a10 	sub.w	sl, sl, #16
 80135b6:	f1ba 0f10 	cmp.w	sl, #16
 80135ba:	f104 0408 	add.w	r4, r4, #8
 80135be:	dd17      	ble.n	80135f0 <_svfprintf_r+0x9f0>
 80135c0:	3201      	adds	r2, #1
 80135c2:	3310      	adds	r3, #16
 80135c4:	2a07      	cmp	r2, #7
 80135c6:	9323      	str	r3, [sp, #140]	; 0x8c
 80135c8:	9222      	str	r2, [sp, #136]	; 0x88
 80135ca:	e884 0120 	stmia.w	r4, {r5, r8}
 80135ce:	ddf0      	ble.n	80135b2 <_svfprintf_r+0x9b2>
 80135d0:	4658      	mov	r0, fp
 80135d2:	4631      	mov	r1, r6
 80135d4:	aa21      	add	r2, sp, #132	; 0x84
 80135d6:	f002 fbeb 	bl	8015db0 <__ssprint_r>
 80135da:	2800      	cmp	r0, #0
 80135dc:	f47f abd8 	bne.w	8012d90 <_svfprintf_r+0x190>
 80135e0:	f1aa 0a10 	sub.w	sl, sl, #16
 80135e4:	f1ba 0f10 	cmp.w	sl, #16
 80135e8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80135ea:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80135ec:	463c      	mov	r4, r7
 80135ee:	dce7      	bgt.n	80135c0 <_svfprintf_r+0x9c0>
 80135f0:	469b      	mov	fp, r3
 80135f2:	462b      	mov	r3, r5
 80135f4:	464d      	mov	r5, r9
 80135f6:	4699      	mov	r9, r3
 80135f8:	3201      	adds	r2, #1
 80135fa:	44d3      	add	fp, sl
 80135fc:	2a07      	cmp	r2, #7
 80135fe:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013602:	9222      	str	r2, [sp, #136]	; 0x88
 8013604:	e884 0600 	stmia.w	r4, {r9, sl}
 8013608:	f300 8251 	bgt.w	8013aae <_svfprintf_r+0xeae>
 801360c:	3408      	adds	r4, #8
 801360e:	e4a4      	b.n	8012f5a <_svfprintf_r+0x35a>
 8013610:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013612:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8013614:	2b01      	cmp	r3, #1
 8013616:	f340 821f 	ble.w	8013a58 <_svfprintf_r+0xe58>
 801361a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801361c:	6023      	str	r3, [r4, #0]
 801361e:	3501      	adds	r5, #1
 8013620:	f10b 0301 	add.w	r3, fp, #1
 8013624:	2201      	movs	r2, #1
 8013626:	2d07      	cmp	r5, #7
 8013628:	9323      	str	r3, [sp, #140]	; 0x8c
 801362a:	9522      	str	r5, [sp, #136]	; 0x88
 801362c:	6062      	str	r2, [r4, #4]
 801362e:	f300 8225 	bgt.w	8013a7c <_svfprintf_r+0xe7c>
 8013632:	3408      	adds	r4, #8
 8013634:	9914      	ldr	r1, [sp, #80]	; 0x50
 8013636:	6061      	str	r1, [r4, #4]
 8013638:	3501      	adds	r5, #1
 801363a:	eb03 0b01 	add.w	fp, r3, r1
 801363e:	2d07      	cmp	r5, #7
 8013640:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8013642:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013646:	9522      	str	r5, [sp, #136]	; 0x88
 8013648:	6023      	str	r3, [r4, #0]
 801364a:	f300 8223 	bgt.w	8013a94 <_svfprintf_r+0xe94>
 801364e:	3408      	adds	r4, #8
 8013650:	2300      	movs	r3, #0
 8013652:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8013656:	2200      	movs	r2, #0
 8013658:	f7f9 fa68 	bl	800cb2c <__aeabi_dcmpeq>
 801365c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801365e:	2800      	cmp	r0, #0
 8013660:	f040 80dd 	bne.w	801381e <_svfprintf_r+0xc1e>
 8013664:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8013666:	3b01      	subs	r3, #1
 8013668:	3501      	adds	r5, #1
 801366a:	3201      	adds	r2, #1
 801366c:	449b      	add	fp, r3
 801366e:	2d07      	cmp	r5, #7
 8013670:	9522      	str	r5, [sp, #136]	; 0x88
 8013672:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013676:	6022      	str	r2, [r4, #0]
 8013678:	6063      	str	r3, [r4, #4]
 801367a:	f300 810d 	bgt.w	8013898 <_svfprintf_r+0xc98>
 801367e:	3408      	adds	r4, #8
 8013680:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8013682:	6062      	str	r2, [r4, #4]
 8013684:	3501      	adds	r5, #1
 8013686:	4493      	add	fp, r2
 8013688:	ab1d      	add	r3, sp, #116	; 0x74
 801368a:	2d07      	cmp	r5, #7
 801368c:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013690:	9522      	str	r5, [sp, #136]	; 0x88
 8013692:	6023      	str	r3, [r4, #0]
 8013694:	f77f acb6 	ble.w	8013004 <_svfprintf_r+0x404>
 8013698:	9804      	ldr	r0, [sp, #16]
 801369a:	4631      	mov	r1, r6
 801369c:	aa21      	add	r2, sp, #132	; 0x84
 801369e:	f002 fb87 	bl	8015db0 <__ssprint_r>
 80136a2:	2800      	cmp	r0, #0
 80136a4:	f47f ab74 	bne.w	8012d90 <_svfprintf_r+0x190>
 80136a8:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 80136ac:	463c      	mov	r4, r7
 80136ae:	e4aa      	b.n	8013006 <_svfprintf_r+0x406>
 80136b0:	2b00      	cmp	r3, #0
 80136b2:	d132      	bne.n	801371a <_svfprintf_r+0xb1a>
 80136b4:	9b03      	ldr	r3, [sp, #12]
 80136b6:	07d8      	lsls	r0, r3, #31
 80136b8:	d52f      	bpl.n	801371a <_svfprintf_r+0xb1a>
 80136ba:	f10d 0bf8 	add.w	fp, sp, #248	; 0xf8
 80136be:	2330      	movs	r3, #48	; 0x30
 80136c0:	f80b 3d41 	strb.w	r3, [fp, #-65]!
 80136c4:	ebcb 0307 	rsb	r3, fp, r7
 80136c8:	9309      	str	r3, [sp, #36]	; 0x24
 80136ca:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 80136ce:	f7ff bbb1 	b.w	8012e34 <_svfprintf_r+0x234>
 80136d2:	9804      	ldr	r0, [sp, #16]
 80136d4:	4631      	mov	r1, r6
 80136d6:	aa21      	add	r2, sp, #132	; 0x84
 80136d8:	f002 fb6a 	bl	8015db0 <__ssprint_r>
 80136dc:	2800      	cmp	r0, #0
 80136de:	f47f ab57 	bne.w	8012d90 <_svfprintf_r+0x190>
 80136e2:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 80136e6:	463c      	mov	r4, r7
 80136e8:	e47b      	b.n	8012fe2 <_svfprintf_r+0x3e2>
 80136ea:	9804      	ldr	r0, [sp, #16]
 80136ec:	4631      	mov	r1, r6
 80136ee:	aa21      	add	r2, sp, #132	; 0x84
 80136f0:	f002 fb5e 	bl	8015db0 <__ssprint_r>
 80136f4:	2800      	cmp	r0, #0
 80136f6:	f47f ab4b 	bne.w	8012d90 <_svfprintf_r+0x190>
 80136fa:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 80136fe:	463c      	mov	r4, r7
 8013700:	e427      	b.n	8012f52 <_svfprintf_r+0x352>
 8013702:	9804      	ldr	r0, [sp, #16]
 8013704:	4631      	mov	r1, r6
 8013706:	aa21      	add	r2, sp, #132	; 0x84
 8013708:	f002 fb52 	bl	8015db0 <__ssprint_r>
 801370c:	2800      	cmp	r0, #0
 801370e:	f47f ab3f 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013712:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013716:	463c      	mov	r4, r7
 8013718:	e40a      	b.n	8012f30 <_svfprintf_r+0x330>
 801371a:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 801371e:	970c      	str	r7, [sp, #48]	; 0x30
 8013720:	f7ff bb88 	b.w	8012e34 <_svfprintf_r+0x234>
 8013724:	08016fc4 	.word	0x08016fc4
 8013728:	08016fe4 	.word	0x08016fe4
 801372c:	08017000 	.word	0x08017000
 8013730:	08016fc0 	.word	0x08016fc0
 8013734:	08016fa0 	.word	0x08016fa0
 8013738:	9812      	ldr	r0, [sp, #72]	; 0x48
 801373a:	46bb      	mov	fp, r7
 801373c:	ea4f 1318 	mov.w	r3, r8, lsr #4
 8013740:	f008 010f 	and.w	r1, r8, #15
 8013744:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
 8013748:	ea4f 1219 	mov.w	r2, r9, lsr #4
 801374c:	4698      	mov	r8, r3
 801374e:	4691      	mov	r9, r2
 8013750:	5c43      	ldrb	r3, [r0, r1]
 8013752:	f80b 3d01 	strb.w	r3, [fp, #-1]!
 8013756:	ea58 0309 	orrs.w	r3, r8, r9
 801375a:	d1ef      	bne.n	801373c <_svfprintf_r+0xb3c>
 801375c:	465b      	mov	r3, fp
 801375e:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 8013762:	1afb      	subs	r3, r7, r3
 8013764:	9309      	str	r3, [sp, #36]	; 0x24
 8013766:	f7ff bb65 	b.w	8012e34 <_svfprintf_r+0x234>
 801376a:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 801376c:	2d00      	cmp	r5, #0
 801376e:	f340 8211 	ble.w	8013b94 <_svfprintf_r+0xf94>
 8013772:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8013774:	990e      	ldr	r1, [sp, #56]	; 0x38
 8013776:	428a      	cmp	r2, r1
 8013778:	4613      	mov	r3, r2
 801377a:	bfa8      	it	ge
 801377c:	460b      	movge	r3, r1
 801377e:	461d      	mov	r5, r3
 8013780:	990c      	ldr	r1, [sp, #48]	; 0x30
 8013782:	2d00      	cmp	r5, #0
 8013784:	eb01 0a02 	add.w	sl, r1, r2
 8013788:	dd0b      	ble.n	80137a2 <_svfprintf_r+0xba2>
 801378a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801378c:	6021      	str	r1, [r4, #0]
 801378e:	3301      	adds	r3, #1
 8013790:	44ab      	add	fp, r5
 8013792:	2b07      	cmp	r3, #7
 8013794:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013798:	6065      	str	r5, [r4, #4]
 801379a:	9322      	str	r3, [sp, #136]	; 0x88
 801379c:	f300 8355 	bgt.w	8013e4a <_svfprintf_r+0x124a>
 80137a0:	3408      	adds	r4, #8
 80137a2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80137a4:	2d00      	cmp	r5, #0
 80137a6:	bfa8      	it	ge
 80137a8:	1b5b      	subge	r3, r3, r5
 80137aa:	2b00      	cmp	r3, #0
 80137ac:	461d      	mov	r5, r3
 80137ae:	f340 80f5 	ble.w	801399c <_svfprintf_r+0xd9c>
 80137b2:	2d10      	cmp	r5, #16
 80137b4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80137b6:	f8df 9608 	ldr.w	r9, [pc, #1544]	; 8013dc0 <_svfprintf_r+0x11c0>
 80137ba:	f340 81d2 	ble.w	8013b62 <_svfprintf_r+0xf62>
 80137be:	465a      	mov	r2, fp
 80137c0:	f04f 0810 	mov.w	r8, #16
 80137c4:	f8dd b010 	ldr.w	fp, [sp, #16]
 80137c8:	e004      	b.n	80137d4 <_svfprintf_r+0xbd4>
 80137ca:	3408      	adds	r4, #8
 80137cc:	3d10      	subs	r5, #16
 80137ce:	2d10      	cmp	r5, #16
 80137d0:	f340 81c6 	ble.w	8013b60 <_svfprintf_r+0xf60>
 80137d4:	3301      	adds	r3, #1
 80137d6:	3210      	adds	r2, #16
 80137d8:	2b07      	cmp	r3, #7
 80137da:	9223      	str	r2, [sp, #140]	; 0x8c
 80137dc:	9322      	str	r3, [sp, #136]	; 0x88
 80137de:	f8c4 9000 	str.w	r9, [r4]
 80137e2:	f8c4 8004 	str.w	r8, [r4, #4]
 80137e6:	ddf0      	ble.n	80137ca <_svfprintf_r+0xbca>
 80137e8:	4658      	mov	r0, fp
 80137ea:	4631      	mov	r1, r6
 80137ec:	aa21      	add	r2, sp, #132	; 0x84
 80137ee:	f002 fadf 	bl	8015db0 <__ssprint_r>
 80137f2:	2800      	cmp	r0, #0
 80137f4:	f47f aacc 	bne.w	8012d90 <_svfprintf_r+0x190>
 80137f8:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80137fa:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80137fc:	463c      	mov	r4, r7
 80137fe:	e7e5      	b.n	80137cc <_svfprintf_r+0xbcc>
 8013800:	9804      	ldr	r0, [sp, #16]
 8013802:	4631      	mov	r1, r6
 8013804:	aa21      	add	r2, sp, #132	; 0x84
 8013806:	f002 fad3 	bl	8015db0 <__ssprint_r>
 801380a:	2800      	cmp	r0, #0
 801380c:	f47f aac0 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013810:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8013814:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013818:	463c      	mov	r4, r7
 801381a:	f7ff bb76 	b.w	8012f0a <_svfprintf_r+0x30a>
 801381e:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 8013822:	f1b8 0f00 	cmp.w	r8, #0
 8013826:	f77f af2b 	ble.w	8013680 <_svfprintf_r+0xa80>
 801382a:	f1b8 0f10 	cmp.w	r8, #16
 801382e:	f8df 9590 	ldr.w	r9, [pc, #1424]	; 8013dc0 <_svfprintf_r+0x11c0>
 8013832:	dd25      	ble.n	8013880 <_svfprintf_r+0xc80>
 8013834:	465b      	mov	r3, fp
 8013836:	f04f 0a10 	mov.w	sl, #16
 801383a:	f8dd b010 	ldr.w	fp, [sp, #16]
 801383e:	e006      	b.n	801384e <_svfprintf_r+0xc4e>
 8013840:	f1a8 0810 	sub.w	r8, r8, #16
 8013844:	f1b8 0f10 	cmp.w	r8, #16
 8013848:	f104 0408 	add.w	r4, r4, #8
 801384c:	dd17      	ble.n	801387e <_svfprintf_r+0xc7e>
 801384e:	3501      	adds	r5, #1
 8013850:	3310      	adds	r3, #16
 8013852:	2d07      	cmp	r5, #7
 8013854:	9323      	str	r3, [sp, #140]	; 0x8c
 8013856:	9522      	str	r5, [sp, #136]	; 0x88
 8013858:	e884 0600 	stmia.w	r4, {r9, sl}
 801385c:	ddf0      	ble.n	8013840 <_svfprintf_r+0xc40>
 801385e:	4658      	mov	r0, fp
 8013860:	4631      	mov	r1, r6
 8013862:	aa21      	add	r2, sp, #132	; 0x84
 8013864:	f002 faa4 	bl	8015db0 <__ssprint_r>
 8013868:	2800      	cmp	r0, #0
 801386a:	f47f aa91 	bne.w	8012d90 <_svfprintf_r+0x190>
 801386e:	f1a8 0810 	sub.w	r8, r8, #16
 8013872:	f1b8 0f10 	cmp.w	r8, #16
 8013876:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8013878:	9d22      	ldr	r5, [sp, #136]	; 0x88
 801387a:	463c      	mov	r4, r7
 801387c:	dce7      	bgt.n	801384e <_svfprintf_r+0xc4e>
 801387e:	469b      	mov	fp, r3
 8013880:	3501      	adds	r5, #1
 8013882:	44c3      	add	fp, r8
 8013884:	2d07      	cmp	r5, #7
 8013886:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 801388a:	9522      	str	r5, [sp, #136]	; 0x88
 801388c:	f8c4 9000 	str.w	r9, [r4]
 8013890:	f8c4 8004 	str.w	r8, [r4, #4]
 8013894:	f77f aef3 	ble.w	801367e <_svfprintf_r+0xa7e>
 8013898:	9804      	ldr	r0, [sp, #16]
 801389a:	4631      	mov	r1, r6
 801389c:	aa21      	add	r2, sp, #132	; 0x84
 801389e:	f002 fa87 	bl	8015db0 <__ssprint_r>
 80138a2:	2800      	cmp	r0, #0
 80138a4:	f47f aa74 	bne.w	8012d90 <_svfprintf_r+0x190>
 80138a8:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 80138ac:	9d22      	ldr	r5, [sp, #136]	; 0x88
 80138ae:	463c      	mov	r4, r7
 80138b0:	e6e6      	b.n	8013680 <_svfprintf_r+0xa80>
 80138b2:	4693      	mov	fp, r2
 80138b4:	3301      	adds	r3, #1
 80138b6:	44ab      	add	fp, r5
 80138b8:	2b07      	cmp	r3, #7
 80138ba:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 80138be:	9322      	str	r3, [sp, #136]	; 0x88
 80138c0:	f8c4 9000 	str.w	r9, [r4]
 80138c4:	6065      	str	r5, [r4, #4]
 80138c6:	f77f ab9d 	ble.w	8013004 <_svfprintf_r+0x404>
 80138ca:	e6e5      	b.n	8013698 <_svfprintf_r+0xa98>
 80138cc:	46bb      	mov	fp, r7
 80138ce:	f8cd c014 	str.w	ip, [sp, #20]
 80138d2:	4640      	mov	r0, r8
 80138d4:	4649      	mov	r1, r9
 80138d6:	220a      	movs	r2, #10
 80138d8:	2300      	movs	r3, #0
 80138da:	f7f9 f959 	bl	800cb90 <__aeabi_uldivmod>
 80138de:	3230      	adds	r2, #48	; 0x30
 80138e0:	4640      	mov	r0, r8
 80138e2:	4649      	mov	r1, r9
 80138e4:	f80b 2d01 	strb.w	r2, [fp, #-1]!
 80138e8:	2300      	movs	r3, #0
 80138ea:	220a      	movs	r2, #10
 80138ec:	f7f9 f950 	bl	800cb90 <__aeabi_uldivmod>
 80138f0:	4680      	mov	r8, r0
 80138f2:	4689      	mov	r9, r1
 80138f4:	ea58 0309 	orrs.w	r3, r8, r9
 80138f8:	d1eb      	bne.n	80138d2 <_svfprintf_r+0xcd2>
 80138fa:	465b      	mov	r3, fp
 80138fc:	1afb      	subs	r3, r7, r3
 80138fe:	f8dd c014 	ldr.w	ip, [sp, #20]
 8013902:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 8013906:	9309      	str	r3, [sp, #36]	; 0x24
 8013908:	f7ff ba94 	b.w	8012e34 <_svfprintf_r+0x234>
 801390c:	2b30      	cmp	r3, #48	; 0x30
 801390e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013910:	f43f af27 	beq.w	8013762 <_svfprintf_r+0xb62>
 8013914:	3b01      	subs	r3, #1
 8013916:	461a      	mov	r2, r3
 8013918:	930c      	str	r3, [sp, #48]	; 0x30
 801391a:	1aba      	subs	r2, r7, r2
 801391c:	2330      	movs	r3, #48	; 0x30
 801391e:	9209      	str	r2, [sp, #36]	; 0x24
 8013920:	f801 3c01 	strb.w	r3, [r1, #-1]
 8013924:	f7ff ba86 	b.w	8012e34 <_svfprintf_r+0x234>
 8013928:	990a      	ldr	r1, [sp, #40]	; 0x28
 801392a:	680a      	ldr	r2, [r1, #0]
 801392c:	3104      	adds	r1, #4
 801392e:	910a      	str	r1, [sp, #40]	; 0x28
 8013930:	4690      	mov	r8, r2
 8013932:	f04f 0900 	mov.w	r9, #0
 8013936:	f7ff ba4a 	b.w	8012dce <_svfprintf_r+0x1ce>
 801393a:	990a      	ldr	r1, [sp, #40]	; 0x28
 801393c:	680a      	ldr	r2, [r1, #0]
 801393e:	3104      	adds	r1, #4
 8013940:	2301      	movs	r3, #1
 8013942:	910a      	str	r1, [sp, #40]	; 0x28
 8013944:	4690      	mov	r8, r2
 8013946:	f04f 0900 	mov.w	r9, #0
 801394a:	f7ff ba40 	b.w	8012dce <_svfprintf_r+0x1ce>
 801394e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013950:	6813      	ldr	r3, [r2, #0]
 8013952:	4698      	mov	r8, r3
 8013954:	ea4f 79e3 	mov.w	r9, r3, asr #31
 8013958:	4613      	mov	r3, r2
 801395a:	3304      	adds	r3, #4
 801395c:	4642      	mov	r2, r8
 801395e:	930a      	str	r3, [sp, #40]	; 0x28
 8013960:	2a00      	cmp	r2, #0
 8013962:	464b      	mov	r3, r9
 8013964:	f173 0300 	sbcs.w	r3, r3, #0
 8013968:	f6bf abf2 	bge.w	8013150 <_svfprintf_r+0x550>
 801396c:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
 8013970:	f1d8 0800 	rsbs	r8, r8, #0
 8013974:	eb69 0949 	sbc.w	r9, r9, r9, lsl #1
 8013978:	f88d c067 	strb.w	ip, [sp, #103]	; 0x67
 801397c:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8013980:	2301      	movs	r3, #1
 8013982:	f7ff ba2a 	b.w	8012dda <_svfprintf_r+0x1da>
 8013986:	9804      	ldr	r0, [sp, #16]
 8013988:	4631      	mov	r1, r6
 801398a:	aa21      	add	r2, sp, #132	; 0x84
 801398c:	f002 fa10 	bl	8015db0 <__ssprint_r>
 8013990:	2800      	cmp	r0, #0
 8013992:	f47f a9fd 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013996:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 801399a:	463c      	mov	r4, r7
 801399c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801399e:	990e      	ldr	r1, [sp, #56]	; 0x38
 80139a0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80139a2:	440a      	add	r2, r1
 80139a4:	4690      	mov	r8, r2
 80139a6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80139a8:	4293      	cmp	r3, r2
 80139aa:	db46      	blt.n	8013a3a <_svfprintf_r+0xe3a>
 80139ac:	9a03      	ldr	r2, [sp, #12]
 80139ae:	07d0      	lsls	r0, r2, #31
 80139b0:	d443      	bmi.n	8013a3a <_svfprintf_r+0xe3a>
 80139b2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80139b4:	ebc8 050a 	rsb	r5, r8, sl
 80139b8:	1ad3      	subs	r3, r2, r3
 80139ba:	429d      	cmp	r5, r3
 80139bc:	bfa8      	it	ge
 80139be:	461d      	movge	r5, r3
 80139c0:	2d00      	cmp	r5, #0
 80139c2:	dd0c      	ble.n	80139de <_svfprintf_r+0xdde>
 80139c4:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80139c6:	f8c4 8000 	str.w	r8, [r4]
 80139ca:	3201      	adds	r2, #1
 80139cc:	44ab      	add	fp, r5
 80139ce:	2a07      	cmp	r2, #7
 80139d0:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 80139d4:	6065      	str	r5, [r4, #4]
 80139d6:	9222      	str	r2, [sp, #136]	; 0x88
 80139d8:	f300 826f 	bgt.w	8013eba <_svfprintf_r+0x12ba>
 80139dc:	3408      	adds	r4, #8
 80139de:	2d00      	cmp	r5, #0
 80139e0:	bfac      	ite	ge
 80139e2:	1b5d      	subge	r5, r3, r5
 80139e4:	461d      	movlt	r5, r3
 80139e6:	2d00      	cmp	r5, #0
 80139e8:	f77f ab0d 	ble.w	8013006 <_svfprintf_r+0x406>
 80139ec:	2d10      	cmp	r5, #16
 80139ee:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80139f0:	f8df 93cc 	ldr.w	r9, [pc, #972]	; 8013dc0 <_svfprintf_r+0x11c0>
 80139f4:	f77f af5e 	ble.w	80138b4 <_svfprintf_r+0xcb4>
 80139f8:	f04f 0810 	mov.w	r8, #16
 80139fc:	465a      	mov	r2, fp
 80139fe:	f8dd a010 	ldr.w	sl, [sp, #16]
 8013a02:	e004      	b.n	8013a0e <_svfprintf_r+0xe0e>
 8013a04:	3408      	adds	r4, #8
 8013a06:	3d10      	subs	r5, #16
 8013a08:	2d10      	cmp	r5, #16
 8013a0a:	f77f af52 	ble.w	80138b2 <_svfprintf_r+0xcb2>
 8013a0e:	3301      	adds	r3, #1
 8013a10:	3210      	adds	r2, #16
 8013a12:	2b07      	cmp	r3, #7
 8013a14:	9223      	str	r2, [sp, #140]	; 0x8c
 8013a16:	9322      	str	r3, [sp, #136]	; 0x88
 8013a18:	f8c4 9000 	str.w	r9, [r4]
 8013a1c:	f8c4 8004 	str.w	r8, [r4, #4]
 8013a20:	ddf0      	ble.n	8013a04 <_svfprintf_r+0xe04>
 8013a22:	4650      	mov	r0, sl
 8013a24:	4631      	mov	r1, r6
 8013a26:	aa21      	add	r2, sp, #132	; 0x84
 8013a28:	f002 f9c2 	bl	8015db0 <__ssprint_r>
 8013a2c:	2800      	cmp	r0, #0
 8013a2e:	f47f a9af 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013a32:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8013a34:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013a36:	463c      	mov	r4, r7
 8013a38:	e7e5      	b.n	8013a06 <_svfprintf_r+0xe06>
 8013a3a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8013a3c:	9814      	ldr	r0, [sp, #80]	; 0x50
 8013a3e:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8013a40:	6021      	str	r1, [r4, #0]
 8013a42:	3201      	adds	r2, #1
 8013a44:	4483      	add	fp, r0
 8013a46:	2a07      	cmp	r2, #7
 8013a48:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013a4c:	6060      	str	r0, [r4, #4]
 8013a4e:	9222      	str	r2, [sp, #136]	; 0x88
 8013a50:	f300 8207 	bgt.w	8013e62 <_svfprintf_r+0x1262>
 8013a54:	3408      	adds	r4, #8
 8013a56:	e7ac      	b.n	80139b2 <_svfprintf_r+0xdb2>
 8013a58:	9b03      	ldr	r3, [sp, #12]
 8013a5a:	07d9      	lsls	r1, r3, #31
 8013a5c:	f53f addd 	bmi.w	801361a <_svfprintf_r+0xa1a>
 8013a60:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013a62:	6023      	str	r3, [r4, #0]
 8013a64:	3501      	adds	r5, #1
 8013a66:	f10b 0b01 	add.w	fp, fp, #1
 8013a6a:	2301      	movs	r3, #1
 8013a6c:	2d07      	cmp	r5, #7
 8013a6e:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013a72:	9522      	str	r5, [sp, #136]	; 0x88
 8013a74:	6063      	str	r3, [r4, #4]
 8013a76:	f77f ae02 	ble.w	801367e <_svfprintf_r+0xa7e>
 8013a7a:	e70d      	b.n	8013898 <_svfprintf_r+0xc98>
 8013a7c:	9804      	ldr	r0, [sp, #16]
 8013a7e:	4631      	mov	r1, r6
 8013a80:	aa21      	add	r2, sp, #132	; 0x84
 8013a82:	f002 f995 	bl	8015db0 <__ssprint_r>
 8013a86:	2800      	cmp	r0, #0
 8013a88:	f47f a982 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013a8c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8013a8e:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8013a90:	463c      	mov	r4, r7
 8013a92:	e5cf      	b.n	8013634 <_svfprintf_r+0xa34>
 8013a94:	9804      	ldr	r0, [sp, #16]
 8013a96:	4631      	mov	r1, r6
 8013a98:	aa21      	add	r2, sp, #132	; 0x84
 8013a9a:	f002 f989 	bl	8015db0 <__ssprint_r>
 8013a9e:	2800      	cmp	r0, #0
 8013aa0:	f47f a976 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013aa4:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013aa8:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8013aaa:	463c      	mov	r4, r7
 8013aac:	e5d0      	b.n	8013650 <_svfprintf_r+0xa50>
 8013aae:	9804      	ldr	r0, [sp, #16]
 8013ab0:	4631      	mov	r1, r6
 8013ab2:	aa21      	add	r2, sp, #132	; 0x84
 8013ab4:	f002 f97c 	bl	8015db0 <__ssprint_r>
 8013ab8:	2800      	cmp	r0, #0
 8013aba:	f47f a969 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013abe:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013ac2:	463c      	mov	r4, r7
 8013ac4:	f7ff ba49 	b.w	8012f5a <_svfprintf_r+0x35a>
 8013ac8:	ed9d 0b10 	vldr	d0, [sp, #64]	; 0x40
 8013acc:	f002 f910 	bl	8015cf0 <__fpclassifyd>
 8013ad0:	2800      	cmp	r0, #0
 8013ad2:	f040 80d1 	bne.w	8013c78 <_svfprintf_r+0x1078>
 8013ad6:	4686      	mov	lr, r0
 8013ad8:	4ab6      	ldr	r2, [pc, #728]	; (8013db4 <_svfprintf_r+0x11b4>)
 8013ada:	4bb7      	ldr	r3, [pc, #732]	; (8013db8 <_svfprintf_r+0x11b8>)
 8013adc:	900d      	str	r0, [sp, #52]	; 0x34
 8013ade:	9803      	ldr	r0, [sp, #12]
 8013ae0:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8013ae4:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
 8013ae8:	2103      	movs	r1, #3
 8013aea:	f020 0080 	bic.w	r0, r0, #128	; 0x80
 8013aee:	2d47      	cmp	r5, #71	; 0x47
 8013af0:	bfd8      	it	le
 8013af2:	461a      	movle	r2, r3
 8013af4:	9105      	str	r1, [sp, #20]
 8013af6:	9003      	str	r0, [sp, #12]
 8013af8:	920c      	str	r2, [sp, #48]	; 0x30
 8013afa:	9109      	str	r1, [sp, #36]	; 0x24
 8013afc:	f7ff b9a2 	b.w	8012e44 <_svfprintf_r+0x244>
 8013b00:	f029 0907 	bic.w	r9, r9, #7
 8013b04:	ed99 7b00 	vldr	d7, [r9]
 8013b08:	f109 0308 	add.w	r3, r9, #8
 8013b0c:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8013b10:	930a      	str	r3, [sp, #40]	; 0x28
 8013b12:	e478      	b.n	8013406 <_svfprintf_r+0x806>
 8013b14:	9b03      	ldr	r3, [sp, #12]
 8013b16:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013b18:	f013 0f40 	tst.w	r3, #64	; 0x40
 8013b1c:	4613      	mov	r3, r2
 8013b1e:	f43f ac1f 	beq.w	8013360 <_svfprintf_r+0x760>
 8013b22:	3304      	adds	r3, #4
 8013b24:	f8b2 8000 	ldrh.w	r8, [r2]
 8013b28:	930a      	str	r3, [sp, #40]	; 0x28
 8013b2a:	f04f 0900 	mov.w	r9, #0
 8013b2e:	f7ff bb28 	b.w	8013182 <_svfprintf_r+0x582>
 8013b32:	9b03      	ldr	r3, [sp, #12]
 8013b34:	06db      	lsls	r3, r3, #27
 8013b36:	d40b      	bmi.n	8013b50 <_svfprintf_r+0xf50>
 8013b38:	9b03      	ldr	r3, [sp, #12]
 8013b3a:	065d      	lsls	r5, r3, #25
 8013b3c:	d508      	bpl.n	8013b50 <_svfprintf_r+0xf50>
 8013b3e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013b40:	6813      	ldr	r3, [r2, #0]
 8013b42:	3204      	adds	r2, #4
 8013b44:	920a      	str	r2, [sp, #40]	; 0x28
 8013b46:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8013b4a:	801a      	strh	r2, [r3, #0]
 8013b4c:	f7ff b87f 	b.w	8012c4e <_svfprintf_r+0x4e>
 8013b50:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013b52:	6813      	ldr	r3, [r2, #0]
 8013b54:	3204      	adds	r2, #4
 8013b56:	920a      	str	r2, [sp, #40]	; 0x28
 8013b58:	9a07      	ldr	r2, [sp, #28]
 8013b5a:	601a      	str	r2, [r3, #0]
 8013b5c:	f7ff b877 	b.w	8012c4e <_svfprintf_r+0x4e>
 8013b60:	4693      	mov	fp, r2
 8013b62:	3301      	adds	r3, #1
 8013b64:	44ab      	add	fp, r5
 8013b66:	2b07      	cmp	r3, #7
 8013b68:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013b6c:	9322      	str	r3, [sp, #136]	; 0x88
 8013b6e:	f8c4 9000 	str.w	r9, [r4]
 8013b72:	6065      	str	r5, [r4, #4]
 8013b74:	f73f af07 	bgt.w	8013986 <_svfprintf_r+0xd86>
 8013b78:	3408      	adds	r4, #8
 8013b7a:	e70f      	b.n	801399c <_svfprintf_r+0xd9c>
 8013b7c:	9804      	ldr	r0, [sp, #16]
 8013b7e:	4631      	mov	r1, r6
 8013b80:	aa21      	add	r2, sp, #132	; 0x84
 8013b82:	f002 f915 	bl	8015db0 <__ssprint_r>
 8013b86:	2800      	cmp	r0, #0
 8013b88:	f47f a902 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013b8c:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013b90:	463c      	mov	r4, r7
 8013b92:	e4b5      	b.n	8013500 <_svfprintf_r+0x900>
 8013b94:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013b96:	4a89      	ldr	r2, [pc, #548]	; (8013dbc <_svfprintf_r+0x11bc>)
 8013b98:	6022      	str	r2, [r4, #0]
 8013b9a:	3301      	adds	r3, #1
 8013b9c:	f10b 0b01 	add.w	fp, fp, #1
 8013ba0:	2201      	movs	r2, #1
 8013ba2:	2b07      	cmp	r3, #7
 8013ba4:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013ba8:	9322      	str	r3, [sp, #136]	; 0x88
 8013baa:	6062      	str	r2, [r4, #4]
 8013bac:	f300 80f1 	bgt.w	8013d92 <_svfprintf_r+0x1192>
 8013bb0:	3408      	adds	r4, #8
 8013bb2:	b92d      	cbnz	r5, 8013bc0 <_svfprintf_r+0xfc0>
 8013bb4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013bb6:	b91b      	cbnz	r3, 8013bc0 <_svfprintf_r+0xfc0>
 8013bb8:	9b03      	ldr	r3, [sp, #12]
 8013bba:	07db      	lsls	r3, r3, #31
 8013bbc:	f57f aa23 	bpl.w	8013006 <_svfprintf_r+0x406>
 8013bc0:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013bc2:	9814      	ldr	r0, [sp, #80]	; 0x50
 8013bc4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8013bc6:	6022      	str	r2, [r4, #0]
 8013bc8:	3301      	adds	r3, #1
 8013bca:	eb0b 0100 	add.w	r1, fp, r0
 8013bce:	2b07      	cmp	r3, #7
 8013bd0:	9123      	str	r1, [sp, #140]	; 0x8c
 8013bd2:	6060      	str	r0, [r4, #4]
 8013bd4:	9322      	str	r3, [sp, #136]	; 0x88
 8013bd6:	f300 81ef 	bgt.w	8013fb8 <_svfprintf_r+0x13b8>
 8013bda:	f104 0208 	add.w	r2, r4, #8
 8013bde:	426d      	negs	r5, r5
 8013be0:	2d00      	cmp	r5, #0
 8013be2:	f340 80fa 	ble.w	8013dda <_svfprintf_r+0x11da>
 8013be6:	2d10      	cmp	r5, #16
 8013be8:	f8df 91d4 	ldr.w	r9, [pc, #468]	; 8013dc0 <_svfprintf_r+0x11c0>
 8013bec:	f340 8146 	ble.w	8013e7c <_svfprintf_r+0x127c>
 8013bf0:	2410      	movs	r4, #16
 8013bf2:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8013bf6:	e004      	b.n	8013c02 <_svfprintf_r+0x1002>
 8013bf8:	3208      	adds	r2, #8
 8013bfa:	3d10      	subs	r5, #16
 8013bfc:	2d10      	cmp	r5, #16
 8013bfe:	f340 813d 	ble.w	8013e7c <_svfprintf_r+0x127c>
 8013c02:	3301      	adds	r3, #1
 8013c04:	3110      	adds	r1, #16
 8013c06:	2b07      	cmp	r3, #7
 8013c08:	9123      	str	r1, [sp, #140]	; 0x8c
 8013c0a:	9322      	str	r3, [sp, #136]	; 0x88
 8013c0c:	f8c2 9000 	str.w	r9, [r2]
 8013c10:	6054      	str	r4, [r2, #4]
 8013c12:	ddf1      	ble.n	8013bf8 <_svfprintf_r+0xff8>
 8013c14:	4640      	mov	r0, r8
 8013c16:	4631      	mov	r1, r6
 8013c18:	aa21      	add	r2, sp, #132	; 0x84
 8013c1a:	f002 f8c9 	bl	8015db0 <__ssprint_r>
 8013c1e:	2800      	cmp	r0, #0
 8013c20:	f47f a8b6 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013c24:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8013c26:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013c28:	463a      	mov	r2, r7
 8013c2a:	e7e6      	b.n	8013bfa <_svfprintf_r+0xffa>
 8013c2c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8013c2e:	46b1      	mov	r9, r6
 8013c30:	2b00      	cmp	r3, #0
 8013c32:	f43f a8ae 	beq.w	8012d92 <_svfprintf_r+0x192>
 8013c36:	9804      	ldr	r0, [sp, #16]
 8013c38:	4631      	mov	r1, r6
 8013c3a:	aa21      	add	r2, sp, #132	; 0x84
 8013c3c:	f002 f8b8 	bl	8015db0 <__ssprint_r>
 8013c40:	f7ff b8a7 	b.w	8012d92 <_svfprintf_r+0x192>
 8013c44:	f041 0120 	orr.w	r1, r1, #32
 8013c48:	9103      	str	r1, [sp, #12]
 8013c4a:	785d      	ldrb	r5, [r3, #1]
 8013c4c:	1c59      	adds	r1, r3, #1
 8013c4e:	f7ff b82c 	b.w	8012caa <_svfprintf_r+0xaa>
 8013c52:	9808      	ldr	r0, [sp, #32]
 8013c54:	910a      	str	r1, [sp, #40]	; 0x28
 8013c56:	4240      	negs	r0, r0
 8013c58:	9008      	str	r0, [sp, #32]
 8013c5a:	4619      	mov	r1, r3
 8013c5c:	f7ff ba29 	b.w	80130b2 <_svfprintf_r+0x4b2>
 8013c60:	9804      	ldr	r0, [sp, #16]
 8013c62:	4631      	mov	r1, r6
 8013c64:	aa21      	add	r2, sp, #132	; 0x84
 8013c66:	f002 f8a3 	bl	8015db0 <__ssprint_r>
 8013c6a:	2800      	cmp	r0, #0
 8013c6c:	f47f a890 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013c70:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013c74:	463c      	mov	r4, r7
 8013c76:	e459      	b.n	801352c <_svfprintf_r+0x92c>
 8013c78:	f025 0320 	bic.w	r3, r5, #32
 8013c7c:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 8013c80:	9305      	str	r3, [sp, #20]
 8013c82:	f000 8093 	beq.w	8013dac <_svfprintf_r+0x11ac>
 8013c86:	2b47      	cmp	r3, #71	; 0x47
 8013c88:	d105      	bne.n	8013c96 <_svfprintf_r+0x1096>
 8013c8a:	f1ba 0f00 	cmp.w	sl, #0
 8013c8e:	bf14      	ite	ne
 8013c90:	46d3      	movne	fp, sl
 8013c92:	f04f 0b01 	moveq.w	fp, #1
 8013c96:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013c98:	9a03      	ldr	r2, [sp, #12]
 8013c9a:	2b00      	cmp	r3, #0
 8013c9c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8013ca0:	920b      	str	r2, [sp, #44]	; 0x2c
 8013ca2:	f2c0 81a4 	blt.w	8013fee <_svfprintf_r+0x13ee>
 8013ca6:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 8013caa:	ed8d 7b16 	vstr	d7, [sp, #88]	; 0x58
 8013cae:	f04f 0a00 	mov.w	sl, #0
 8013cb2:	2d66      	cmp	r5, #102	; 0x66
 8013cb4:	f000 80ac 	beq.w	8013e10 <_svfprintf_r+0x1210>
 8013cb8:	2d46      	cmp	r5, #70	; 0x46
 8013cba:	f000 80a9 	beq.w	8013e10 <_svfprintf_r+0x1210>
 8013cbe:	9b05      	ldr	r3, [sp, #20]
 8013cc0:	9804      	ldr	r0, [sp, #16]
 8013cc2:	2b45      	cmp	r3, #69	; 0x45
 8013cc4:	bf0c      	ite	eq
 8013cc6:	f10b 0901 	addeq.w	r9, fp, #1
 8013cca:	46d9      	movne	r9, fp
 8013ccc:	aa1c      	add	r2, sp, #112	; 0x70
 8013cce:	ab1f      	add	r3, sp, #124	; 0x7c
 8013cd0:	e88d 000c 	stmia.w	sp, {r2, r3}
 8013cd4:	ed9d 0b16 	vldr	d0, [sp, #88]	; 0x58
 8013cd8:	2102      	movs	r1, #2
 8013cda:	464a      	mov	r2, r9
 8013cdc:	ab1b      	add	r3, sp, #108	; 0x6c
 8013cde:	f000 fa8f 	bl	8014200 <_dtoa_r>
 8013ce2:	2d67      	cmp	r5, #103	; 0x67
 8013ce4:	900c      	str	r0, [sp, #48]	; 0x30
 8013ce6:	d002      	beq.n	8013cee <_svfprintf_r+0x10ee>
 8013ce8:	2d47      	cmp	r5, #71	; 0x47
 8013cea:	f040 809f 	bne.w	8013e2c <_svfprintf_r+0x122c>
 8013cee:	9b03      	ldr	r3, [sp, #12]
 8013cf0:	07db      	lsls	r3, r3, #31
 8013cf2:	f140 8192 	bpl.w	801401a <_svfprintf_r+0x141a>
 8013cf6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013cf8:	eb03 0809 	add.w	r8, r3, r9
 8013cfc:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 8013d00:	2200      	movs	r2, #0
 8013d02:	2300      	movs	r3, #0
 8013d04:	f7f8 ff12 	bl	800cb2c <__aeabi_dcmpeq>
 8013d08:	2800      	cmp	r0, #0
 8013d0a:	f040 80fd 	bne.w	8013f08 <_svfprintf_r+0x1308>
 8013d0e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8013d10:	4598      	cmp	r8, r3
 8013d12:	d906      	bls.n	8013d22 <_svfprintf_r+0x1122>
 8013d14:	2130      	movs	r1, #48	; 0x30
 8013d16:	1c5a      	adds	r2, r3, #1
 8013d18:	921f      	str	r2, [sp, #124]	; 0x7c
 8013d1a:	7019      	strb	r1, [r3, #0]
 8013d1c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8013d1e:	4598      	cmp	r8, r3
 8013d20:	d8f9      	bhi.n	8013d16 <_svfprintf_r+0x1116>
 8013d22:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8013d24:	1a9b      	subs	r3, r3, r2
 8013d26:	930f      	str	r3, [sp, #60]	; 0x3c
 8013d28:	9b05      	ldr	r3, [sp, #20]
 8013d2a:	2b47      	cmp	r3, #71	; 0x47
 8013d2c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8013d2e:	f000 80de 	beq.w	8013eee <_svfprintf_r+0x12ee>
 8013d32:	2d65      	cmp	r5, #101	; 0x65
 8013d34:	f340 80f8 	ble.w	8013f28 <_svfprintf_r+0x1328>
 8013d38:	2d66      	cmp	r5, #102	; 0x66
 8013d3a:	930e      	str	r3, [sp, #56]	; 0x38
 8013d3c:	f000 8160 	beq.w	8014000 <_svfprintf_r+0x1400>
 8013d40:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013d42:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8013d44:	4293      	cmp	r3, r2
 8013d46:	f300 8144 	bgt.w	8013fd2 <_svfprintf_r+0x13d2>
 8013d4a:	9b03      	ldr	r3, [sp, #12]
 8013d4c:	07d9      	lsls	r1, r3, #31
 8013d4e:	f100 8166 	bmi.w	801401e <_svfprintf_r+0x141e>
 8013d52:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 8013d56:	9209      	str	r2, [sp, #36]	; 0x24
 8013d58:	f1ba 0f00 	cmp.w	sl, #0
 8013d5c:	f040 80bc 	bne.w	8013ed8 <_svfprintf_r+0x12d8>
 8013d60:	9305      	str	r3, [sp, #20]
 8013d62:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013d64:	9303      	str	r3, [sp, #12]
 8013d66:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8013d6a:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8013d6e:	f7ff b869 	b.w	8012e44 <_svfprintf_r+0x244>
 8013d72:	9804      	ldr	r0, [sp, #16]
 8013d74:	2140      	movs	r1, #64	; 0x40
 8013d76:	f001 f9a3 	bl	80150c0 <_malloc_r>
 8013d7a:	f8c9 0000 	str.w	r0, [r9]
 8013d7e:	f8c9 0010 	str.w	r0, [r9, #16]
 8013d82:	2800      	cmp	r0, #0
 8013d84:	f000 8197 	beq.w	80140b6 <_svfprintf_r+0x14b6>
 8013d88:	2340      	movs	r3, #64	; 0x40
 8013d8a:	f8c9 3014 	str.w	r3, [r9, #20]
 8013d8e:	f7fe bf4f 	b.w	8012c30 <_svfprintf_r+0x30>
 8013d92:	9804      	ldr	r0, [sp, #16]
 8013d94:	4631      	mov	r1, r6
 8013d96:	aa21      	add	r2, sp, #132	; 0x84
 8013d98:	f002 f80a 	bl	8015db0 <__ssprint_r>
 8013d9c:	2800      	cmp	r0, #0
 8013d9e:	f47e aff7 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013da2:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 8013da4:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013da8:	463c      	mov	r4, r7
 8013daa:	e702      	b.n	8013bb2 <_svfprintf_r+0xfb2>
 8013dac:	f04f 0b06 	mov.w	fp, #6
 8013db0:	e771      	b.n	8013c96 <_svfprintf_r+0x1096>
 8013db2:	bf00      	nop
 8013db4:	08016fcc 	.word	0x08016fcc
 8013db8:	08016fc8 	.word	0x08016fc8
 8013dbc:	08017000 	.word	0x08017000
 8013dc0:	08016fa0 	.word	0x08016fa0
 8013dc4:	9804      	ldr	r0, [sp, #16]
 8013dc6:	4631      	mov	r1, r6
 8013dc8:	aa21      	add	r2, sp, #132	; 0x84
 8013dca:	f001 fff1 	bl	8015db0 <__ssprint_r>
 8013dce:	2800      	cmp	r0, #0
 8013dd0:	f47e afde 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013dd4:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8013dd6:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013dd8:	463a      	mov	r2, r7
 8013dda:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8013ddc:	6054      	str	r4, [r2, #4]
 8013dde:	3301      	adds	r3, #1
 8013de0:	eb01 0b04 	add.w	fp, r1, r4
 8013de4:	2b07      	cmp	r3, #7
 8013de6:	990c      	ldr	r1, [sp, #48]	; 0x30
 8013de8:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8013dec:	9322      	str	r3, [sp, #136]	; 0x88
 8013dee:	6011      	str	r1, [r2, #0]
 8013df0:	f73f ac52 	bgt.w	8013698 <_svfprintf_r+0xa98>
 8013df4:	f102 0408 	add.w	r4, r2, #8
 8013df8:	f7ff b905 	b.w	8013006 <_svfprintf_r+0x406>
 8013dfc:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
 8013e00:	f001 ffa6 	bl	8015d50 <strlen>
 8013e04:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 8013e08:	9009      	str	r0, [sp, #36]	; 0x24
 8013e0a:	4603      	mov	r3, r0
 8013e0c:	f7ff ba0e 	b.w	801322c <_svfprintf_r+0x62c>
 8013e10:	aa1c      	add	r2, sp, #112	; 0x70
 8013e12:	ab1f      	add	r3, sp, #124	; 0x7c
 8013e14:	e88d 000c 	stmia.w	sp, {r2, r3}
 8013e18:	9804      	ldr	r0, [sp, #16]
 8013e1a:	ed9d 0b16 	vldr	d0, [sp, #88]	; 0x58
 8013e1e:	2103      	movs	r1, #3
 8013e20:	465a      	mov	r2, fp
 8013e22:	ab1b      	add	r3, sp, #108	; 0x6c
 8013e24:	f000 f9ec 	bl	8014200 <_dtoa_r>
 8013e28:	46d9      	mov	r9, fp
 8013e2a:	900c      	str	r0, [sp, #48]	; 0x30
 8013e2c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013e2e:	eb03 0809 	add.w	r8, r3, r9
 8013e32:	9b05      	ldr	r3, [sp, #20]
 8013e34:	2b46      	cmp	r3, #70	; 0x46
 8013e36:	f47f af61 	bne.w	8013cfc <_svfprintf_r+0x10fc>
 8013e3a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013e3c:	781b      	ldrb	r3, [r3, #0]
 8013e3e:	2b30      	cmp	r3, #48	; 0x30
 8013e40:	f000 8103 	beq.w	801404a <_svfprintf_r+0x144a>
 8013e44:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8013e46:	4498      	add	r8, r3
 8013e48:	e758      	b.n	8013cfc <_svfprintf_r+0x10fc>
 8013e4a:	9804      	ldr	r0, [sp, #16]
 8013e4c:	4631      	mov	r1, r6
 8013e4e:	aa21      	add	r2, sp, #132	; 0x84
 8013e50:	f001 ffae 	bl	8015db0 <__ssprint_r>
 8013e54:	2800      	cmp	r0, #0
 8013e56:	f47e af9b 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013e5a:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013e5e:	463c      	mov	r4, r7
 8013e60:	e49f      	b.n	80137a2 <_svfprintf_r+0xba2>
 8013e62:	9804      	ldr	r0, [sp, #16]
 8013e64:	4631      	mov	r1, r6
 8013e66:	aa21      	add	r2, sp, #132	; 0x84
 8013e68:	f001 ffa2 	bl	8015db0 <__ssprint_r>
 8013e6c:	2800      	cmp	r0, #0
 8013e6e:	f47e af8f 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013e72:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8013e74:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013e78:	463c      	mov	r4, r7
 8013e7a:	e59a      	b.n	80139b2 <_svfprintf_r+0xdb2>
 8013e7c:	3301      	adds	r3, #1
 8013e7e:	4429      	add	r1, r5
 8013e80:	2b07      	cmp	r3, #7
 8013e82:	9123      	str	r1, [sp, #140]	; 0x8c
 8013e84:	9322      	str	r3, [sp, #136]	; 0x88
 8013e86:	f8c2 9000 	str.w	r9, [r2]
 8013e8a:	6055      	str	r5, [r2, #4]
 8013e8c:	dc9a      	bgt.n	8013dc4 <_svfprintf_r+0x11c4>
 8013e8e:	3208      	adds	r2, #8
 8013e90:	e7a3      	b.n	8013dda <_svfprintf_r+0x11da>
 8013e92:	4653      	mov	r3, sl
 8013e94:	2b06      	cmp	r3, #6
 8013e96:	bf28      	it	cs
 8013e98:	2306      	movcs	r3, #6
 8013e9a:	9309      	str	r3, [sp, #36]	; 0x24
 8013e9c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8013ea0:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
 8013ea4:	9305      	str	r3, [sp, #20]
 8013ea6:	4b87      	ldr	r3, [pc, #540]	; (80140c4 <_svfprintf_r+0x14c4>)
 8013ea8:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 8013eac:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 8013eb0:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
 8013eb4:	930c      	str	r3, [sp, #48]	; 0x30
 8013eb6:	f7fe bfc5 	b.w	8012e44 <_svfprintf_r+0x244>
 8013eba:	9804      	ldr	r0, [sp, #16]
 8013ebc:	4631      	mov	r1, r6
 8013ebe:	aa21      	add	r2, sp, #132	; 0x84
 8013ec0:	f001 ff76 	bl	8015db0 <__ssprint_r>
 8013ec4:	2800      	cmp	r0, #0
 8013ec6:	f47e af63 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013eca:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8013ecc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8013ece:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8013ed2:	1ad3      	subs	r3, r2, r3
 8013ed4:	463c      	mov	r4, r7
 8013ed6:	e582      	b.n	80139de <_svfprintf_r+0xdde>
 8013ed8:	9305      	str	r3, [sp, #20]
 8013eda:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013edc:	9303      	str	r3, [sp, #12]
 8013ede:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
 8013ee2:	2300      	movs	r3, #0
 8013ee4:	f88d c067 	strb.w	ip, [sp, #103]	; 0x67
 8013ee8:	930d      	str	r3, [sp, #52]	; 0x34
 8013eea:	f7fe bfae 	b.w	8012e4a <_svfprintf_r+0x24a>
 8013eee:	1cda      	adds	r2, r3, #3
 8013ef0:	db19      	blt.n	8013f26 <_svfprintf_r+0x1326>
 8013ef2:	459b      	cmp	fp, r3
 8013ef4:	db17      	blt.n	8013f26 <_svfprintf_r+0x1326>
 8013ef6:	930e      	str	r3, [sp, #56]	; 0x38
 8013ef8:	2567      	movs	r5, #103	; 0x67
 8013efa:	e721      	b.n	8013d40 <_svfprintf_r+0x1140>
 8013efc:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
 8013f00:	f88d c067 	strb.w	ip, [sp, #103]	; 0x67
 8013f04:	f7ff ba91 	b.w	801342a <_svfprintf_r+0x82a>
 8013f08:	4643      	mov	r3, r8
 8013f0a:	e70a      	b.n	8013d22 <_svfprintf_r+0x1122>
 8013f0c:	ea2a 73ea 	bic.w	r3, sl, sl, asr #31
 8013f10:	900d      	str	r0, [sp, #52]	; 0x34
 8013f12:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 8013f16:	900e      	str	r0, [sp, #56]	; 0x38
 8013f18:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8013f1c:	9305      	str	r3, [sp, #20]
 8013f1e:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 8013f22:	f7fe bf8f 	b.w	8012e44 <_svfprintf_r+0x244>
 8013f26:	3d02      	subs	r5, #2
 8013f28:	3b01      	subs	r3, #1
 8013f2a:	2b00      	cmp	r3, #0
 8013f2c:	931b      	str	r3, [sp, #108]	; 0x6c
 8013f2e:	bfba      	itte	lt
 8013f30:	425b      	neglt	r3, r3
 8013f32:	222d      	movlt	r2, #45	; 0x2d
 8013f34:	222b      	movge	r2, #43	; 0x2b
 8013f36:	2b09      	cmp	r3, #9
 8013f38:	f88d 5074 	strb.w	r5, [sp, #116]	; 0x74
 8013f3c:	f88d 2075 	strb.w	r2, [sp, #117]	; 0x75
 8013f40:	dd7b      	ble.n	801403a <_svfprintf_r+0x143a>
 8013f42:	f10d 0e83 	add.w	lr, sp, #131	; 0x83
 8013f46:	4670      	mov	r0, lr
 8013f48:	4a5f      	ldr	r2, [pc, #380]	; (80140c8 <_svfprintf_r+0x14c8>)
 8013f4a:	fb82 2103 	smull	r2, r1, r2, r3
 8013f4e:	17da      	asrs	r2, r3, #31
 8013f50:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 8013f54:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 8013f58:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
 8013f5c:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8013f60:	2a09      	cmp	r2, #9
 8013f62:	4613      	mov	r3, r2
 8013f64:	f800 1d01 	strb.w	r1, [r0, #-1]!
 8013f68:	dcee      	bgt.n	8013f48 <_svfprintf_r+0x1348>
 8013f6a:	4602      	mov	r2, r0
 8013f6c:	3330      	adds	r3, #48	; 0x30
 8013f6e:	b2d9      	uxtb	r1, r3
 8013f70:	f802 1d01 	strb.w	r1, [r2, #-1]!
 8013f74:	4596      	cmp	lr, r2
 8013f76:	f240 809b 	bls.w	80140b0 <_svfprintf_r+0x14b0>
 8013f7a:	f10d 0276 	add.w	r2, sp, #118	; 0x76
 8013f7e:	4603      	mov	r3, r0
 8013f80:	e001      	b.n	8013f86 <_svfprintf_r+0x1386>
 8013f82:	f813 1b01 	ldrb.w	r1, [r3], #1
 8013f86:	f802 1b01 	strb.w	r1, [r2], #1
 8013f8a:	4573      	cmp	r3, lr
 8013f8c:	d1f9      	bne.n	8013f82 <_svfprintf_r+0x1382>
 8013f8e:	ab21      	add	r3, sp, #132	; 0x84
 8013f90:	1a1b      	subs	r3, r3, r0
 8013f92:	f10d 0276 	add.w	r2, sp, #118	; 0x76
 8013f96:	4413      	add	r3, r2
 8013f98:	aa1d      	add	r2, sp, #116	; 0x74
 8013f9a:	1a9b      	subs	r3, r3, r2
 8013f9c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8013f9e:	9315      	str	r3, [sp, #84]	; 0x54
 8013fa0:	2a01      	cmp	r2, #1
 8013fa2:	4413      	add	r3, r2
 8013fa4:	9309      	str	r3, [sp, #36]	; 0x24
 8013fa6:	dd74      	ble.n	8014092 <_svfprintf_r+0x1492>
 8013fa8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013faa:	2200      	movs	r2, #0
 8013fac:	3301      	adds	r3, #1
 8013fae:	9309      	str	r3, [sp, #36]	; 0x24
 8013fb0:	920e      	str	r2, [sp, #56]	; 0x38
 8013fb2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8013fb6:	e6cf      	b.n	8013d58 <_svfprintf_r+0x1158>
 8013fb8:	9804      	ldr	r0, [sp, #16]
 8013fba:	4631      	mov	r1, r6
 8013fbc:	aa21      	add	r2, sp, #132	; 0x84
 8013fbe:	f001 fef7 	bl	8015db0 <__ssprint_r>
 8013fc2:	2800      	cmp	r0, #0
 8013fc4:	f47e aee4 	bne.w	8012d90 <_svfprintf_r+0x190>
 8013fc8:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 8013fca:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8013fcc:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013fce:	463a      	mov	r2, r7
 8013fd0:	e605      	b.n	8013bde <_svfprintf_r+0xfde>
 8013fd2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8013fd4:	2b00      	cmp	r3, #0
 8013fd6:	bfd8      	it	le
 8013fd8:	f1c3 0802 	rsble	r8, r3, #2
 8013fdc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013fde:	bfc8      	it	gt
 8013fe0:	f04f 0801 	movgt.w	r8, #1
 8013fe4:	4443      	add	r3, r8
 8013fe6:	9309      	str	r3, [sp, #36]	; 0x24
 8013fe8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8013fec:	e6b4      	b.n	8013d58 <_svfprintf_r+0x1158>
 8013fee:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8013ff2:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8013ff6:	9016      	str	r0, [sp, #88]	; 0x58
 8013ff8:	9317      	str	r3, [sp, #92]	; 0x5c
 8013ffa:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
 8013ffe:	e658      	b.n	8013cb2 <_svfprintf_r+0x10b2>
 8014000:	2b00      	cmp	r3, #0
 8014002:	dd3d      	ble.n	8014080 <_svfprintf_r+0x1480>
 8014004:	f1bb 0f00 	cmp.w	fp, #0
 8014008:	d10f      	bne.n	801402a <_svfprintf_r+0x142a>
 801400a:	9b03      	ldr	r3, [sp, #12]
 801400c:	07db      	lsls	r3, r3, #31
 801400e:	d40c      	bmi.n	801402a <_svfprintf_r+0x142a>
 8014010:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8014012:	9209      	str	r2, [sp, #36]	; 0x24
 8014014:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 8014018:	e69e      	b.n	8013d58 <_svfprintf_r+0x1158>
 801401a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801401c:	e681      	b.n	8013d22 <_svfprintf_r+0x1122>
 801401e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8014020:	3301      	adds	r3, #1
 8014022:	9309      	str	r3, [sp, #36]	; 0x24
 8014024:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8014028:	e696      	b.n	8013d58 <_svfprintf_r+0x1158>
 801402a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801402c:	f10b 0801 	add.w	r8, fp, #1
 8014030:	4443      	add	r3, r8
 8014032:	9309      	str	r3, [sp, #36]	; 0x24
 8014034:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8014038:	e68e      	b.n	8013d58 <_svfprintf_r+0x1158>
 801403a:	3330      	adds	r3, #48	; 0x30
 801403c:	2230      	movs	r2, #48	; 0x30
 801403e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
 8014042:	f88d 2076 	strb.w	r2, [sp, #118]	; 0x76
 8014046:	ab1e      	add	r3, sp, #120	; 0x78
 8014048:	e7a6      	b.n	8013f98 <_svfprintf_r+0x1398>
 801404a:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 801404e:	2200      	movs	r2, #0
 8014050:	2300      	movs	r3, #0
 8014052:	f7f8 fd6b 	bl	800cb2c <__aeabi_dcmpeq>
 8014056:	2800      	cmp	r0, #0
 8014058:	f47f aef4 	bne.w	8013e44 <_svfprintf_r+0x1244>
 801405c:	f1c9 0301 	rsb	r3, r9, #1
 8014060:	931b      	str	r3, [sp, #108]	; 0x6c
 8014062:	4498      	add	r8, r3
 8014064:	e64a      	b.n	8013cfc <_svfprintf_r+0x10fc>
 8014066:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8014068:	f8d5 a000 	ldr.w	sl, [r5]
 801406c:	4628      	mov	r0, r5
 801406e:	3004      	adds	r0, #4
 8014070:	f1ba 0f00 	cmp.w	sl, #0
 8014074:	785d      	ldrb	r5, [r3, #1]
 8014076:	900a      	str	r0, [sp, #40]	; 0x28
 8014078:	f6be ae17 	bge.w	8012caa <_svfprintf_r+0xaa>
 801407c:	f7fe be13 	b.w	8012ca6 <_svfprintf_r+0xa6>
 8014080:	f1bb 0f00 	cmp.w	fp, #0
 8014084:	d10e      	bne.n	80140a4 <_svfprintf_r+0x14a4>
 8014086:	9b03      	ldr	r3, [sp, #12]
 8014088:	07d8      	lsls	r0, r3, #31
 801408a:	d40b      	bmi.n	80140a4 <_svfprintf_r+0x14a4>
 801408c:	2301      	movs	r3, #1
 801408e:	9309      	str	r3, [sp, #36]	; 0x24
 8014090:	e662      	b.n	8013d58 <_svfprintf_r+0x1158>
 8014092:	9b03      	ldr	r3, [sp, #12]
 8014094:	f013 0301 	ands.w	r3, r3, #1
 8014098:	d186      	bne.n	8013fa8 <_svfprintf_r+0x13a8>
 801409a:	930e      	str	r3, [sp, #56]	; 0x38
 801409c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801409e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80140a2:	e659      	b.n	8013d58 <_svfprintf_r+0x1158>
 80140a4:	f10b 0302 	add.w	r3, fp, #2
 80140a8:	9309      	str	r3, [sp, #36]	; 0x24
 80140aa:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80140ae:	e653      	b.n	8013d58 <_svfprintf_r+0x1158>
 80140b0:	f10d 0376 	add.w	r3, sp, #118	; 0x76
 80140b4:	e770      	b.n	8013f98 <_svfprintf_r+0x1398>
 80140b6:	9a04      	ldr	r2, [sp, #16]
 80140b8:	230c      	movs	r3, #12
 80140ba:	6013      	str	r3, [r2, #0]
 80140bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80140c0:	f7fe be70 	b.w	8012da4 <_svfprintf_r+0x1a4>
 80140c4:	08016ff8 	.word	0x08016ff8
 80140c8:	66666667 	.word	0x66666667
 80140cc:	00000000 	.word	0x00000000

080140d0 <quorem>:
 80140d0:	6902      	ldr	r2, [r0, #16]
 80140d2:	690b      	ldr	r3, [r1, #16]
 80140d4:	4293      	cmp	r3, r2
 80140d6:	f300 808f 	bgt.w	80141f8 <quorem+0x128>
 80140da:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80140de:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 80140e2:	f101 0714 	add.w	r7, r1, #20
 80140e6:	f100 0b14 	add.w	fp, r0, #20
 80140ea:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
 80140ee:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
 80140f2:	ea4f 0488 	mov.w	r4, r8, lsl #2
 80140f6:	b083      	sub	sp, #12
 80140f8:	3201      	adds	r2, #1
 80140fa:	fbb3 f9f2 	udiv	r9, r3, r2
 80140fe:	eb0b 0304 	add.w	r3, fp, r4
 8014102:	9400      	str	r4, [sp, #0]
 8014104:	eb07 0a04 	add.w	sl, r7, r4
 8014108:	9301      	str	r3, [sp, #4]
 801410a:	f1b9 0f00 	cmp.w	r9, #0
 801410e:	d03b      	beq.n	8014188 <quorem+0xb8>
 8014110:	2600      	movs	r6, #0
 8014112:	4632      	mov	r2, r6
 8014114:	46bc      	mov	ip, r7
 8014116:	46de      	mov	lr, fp
 8014118:	4634      	mov	r4, r6
 801411a:	f85c 6b04 	ldr.w	r6, [ip], #4
 801411e:	f8de 5000 	ldr.w	r5, [lr]
 8014122:	b2b3      	uxth	r3, r6
 8014124:	0c36      	lsrs	r6, r6, #16
 8014126:	fb03 4409 	mla	r4, r3, r9, r4
 801412a:	fb06 f609 	mul.w	r6, r6, r9
 801412e:	eb06 4614 	add.w	r6, r6, r4, lsr #16
 8014132:	b2a3      	uxth	r3, r4
 8014134:	1ad3      	subs	r3, r2, r3
 8014136:	b2b4      	uxth	r4, r6
 8014138:	fa13 f385 	uxtah	r3, r3, r5
 801413c:	ebc4 4415 	rsb	r4, r4, r5, lsr #16
 8014140:	eb04 4423 	add.w	r4, r4, r3, asr #16
 8014144:	b29b      	uxth	r3, r3
 8014146:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 801414a:	45e2      	cmp	sl, ip
 801414c:	ea4f 4224 	mov.w	r2, r4, asr #16
 8014150:	f84e 3b04 	str.w	r3, [lr], #4
 8014154:	ea4f 4416 	mov.w	r4, r6, lsr #16
 8014158:	d2df      	bcs.n	801411a <quorem+0x4a>
 801415a:	9b00      	ldr	r3, [sp, #0]
 801415c:	f85b 3003 	ldr.w	r3, [fp, r3]
 8014160:	b993      	cbnz	r3, 8014188 <quorem+0xb8>
 8014162:	9c01      	ldr	r4, [sp, #4]
 8014164:	1f23      	subs	r3, r4, #4
 8014166:	459b      	cmp	fp, r3
 8014168:	d20c      	bcs.n	8014184 <quorem+0xb4>
 801416a:	f854 3c04 	ldr.w	r3, [r4, #-4]
 801416e:	b94b      	cbnz	r3, 8014184 <quorem+0xb4>
 8014170:	f1a4 0308 	sub.w	r3, r4, #8
 8014174:	e002      	b.n	801417c <quorem+0xac>
 8014176:	681a      	ldr	r2, [r3, #0]
 8014178:	3b04      	subs	r3, #4
 801417a:	b91a      	cbnz	r2, 8014184 <quorem+0xb4>
 801417c:	459b      	cmp	fp, r3
 801417e:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 8014182:	d3f8      	bcc.n	8014176 <quorem+0xa6>
 8014184:	f8c0 8010 	str.w	r8, [r0, #16]
 8014188:	4604      	mov	r4, r0
 801418a:	f001 fcb9 	bl	8015b00 <__mcmp>
 801418e:	2800      	cmp	r0, #0
 8014190:	db2e      	blt.n	80141f0 <quorem+0x120>
 8014192:	f109 0901 	add.w	r9, r9, #1
 8014196:	465d      	mov	r5, fp
 8014198:	2300      	movs	r3, #0
 801419a:	f857 1b04 	ldr.w	r1, [r7], #4
 801419e:	6828      	ldr	r0, [r5, #0]
 80141a0:	b28a      	uxth	r2, r1
 80141a2:	1a9a      	subs	r2, r3, r2
 80141a4:	0c09      	lsrs	r1, r1, #16
 80141a6:	fa12 f280 	uxtah	r2, r2, r0
 80141aa:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
 80141ae:	eb03 4322 	add.w	r3, r3, r2, asr #16
 80141b2:	b291      	uxth	r1, r2
 80141b4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80141b8:	45ba      	cmp	sl, r7
 80141ba:	f845 1b04 	str.w	r1, [r5], #4
 80141be:	ea4f 4323 	mov.w	r3, r3, asr #16
 80141c2:	d2ea      	bcs.n	801419a <quorem+0xca>
 80141c4:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
 80141c8:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
 80141cc:	b982      	cbnz	r2, 80141f0 <quorem+0x120>
 80141ce:	1f1a      	subs	r2, r3, #4
 80141d0:	4593      	cmp	fp, r2
 80141d2:	d20b      	bcs.n	80141ec <quorem+0x11c>
 80141d4:	f853 2c04 	ldr.w	r2, [r3, #-4]
 80141d8:	b942      	cbnz	r2, 80141ec <quorem+0x11c>
 80141da:	3b08      	subs	r3, #8
 80141dc:	e002      	b.n	80141e4 <quorem+0x114>
 80141de:	681a      	ldr	r2, [r3, #0]
 80141e0:	3b04      	subs	r3, #4
 80141e2:	b91a      	cbnz	r2, 80141ec <quorem+0x11c>
 80141e4:	459b      	cmp	fp, r3
 80141e6:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 80141ea:	d3f8      	bcc.n	80141de <quorem+0x10e>
 80141ec:	f8c4 8010 	str.w	r8, [r4, #16]
 80141f0:	4648      	mov	r0, r9
 80141f2:	b003      	add	sp, #12
 80141f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80141f8:	2000      	movs	r0, #0
 80141fa:	4770      	bx	lr
 80141fc:	0000      	movs	r0, r0
	...

08014200 <_dtoa_r>:
 8014200:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014204:	b099      	sub	sp, #100	; 0x64
 8014206:	4604      	mov	r4, r0
 8014208:	9103      	str	r1, [sp, #12]
 801420a:	6c01      	ldr	r1, [r0, #64]	; 0x40
 801420c:	9d22      	ldr	r5, [sp, #136]	; 0x88
 801420e:	9304      	str	r3, [sp, #16]
 8014210:	4692      	mov	sl, r2
 8014212:	ed8d 0b00 	vstr	d0, [sp]
 8014216:	b141      	cbz	r1, 801422a <_dtoa_r+0x2a>
 8014218:	6c42      	ldr	r2, [r0, #68]	; 0x44
 801421a:	604a      	str	r2, [r1, #4]
 801421c:	2301      	movs	r3, #1
 801421e:	4093      	lsls	r3, r2
 8014220:	608b      	str	r3, [r1, #8]
 8014222:	f001 fa6d 	bl	8015700 <_Bfree>
 8014226:	2300      	movs	r3, #0
 8014228:	6423      	str	r3, [r4, #64]	; 0x40
 801422a:	e9dd 2300 	ldrd	r2, r3, [sp]
 801422e:	2b00      	cmp	r3, #0
 8014230:	4699      	mov	r9, r3
 8014232:	db36      	blt.n	80142a2 <_dtoa_r+0xa2>
 8014234:	2300      	movs	r3, #0
 8014236:	602b      	str	r3, [r5, #0]
 8014238:	4ba5      	ldr	r3, [pc, #660]	; (80144d0 <_dtoa_r+0x2d0>)
 801423a:	461a      	mov	r2, r3
 801423c:	ea09 0303 	and.w	r3, r9, r3
 8014240:	4293      	cmp	r3, r2
 8014242:	d017      	beq.n	8014274 <_dtoa_r+0x74>
 8014244:	e9dd 6700 	ldrd	r6, r7, [sp]
 8014248:	2200      	movs	r2, #0
 801424a:	2300      	movs	r3, #0
 801424c:	4630      	mov	r0, r6
 801424e:	4639      	mov	r1, r7
 8014250:	f7f8 fc6c 	bl	800cb2c <__aeabi_dcmpeq>
 8014254:	4680      	mov	r8, r0
 8014256:	2800      	cmp	r0, #0
 8014258:	d02b      	beq.n	80142b2 <_dtoa_r+0xb2>
 801425a:	9a04      	ldr	r2, [sp, #16]
 801425c:	2301      	movs	r3, #1
 801425e:	6013      	str	r3, [r2, #0]
 8014260:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8014262:	2b00      	cmp	r3, #0
 8014264:	f000 80cc 	beq.w	8014400 <_dtoa_r+0x200>
 8014268:	489a      	ldr	r0, [pc, #616]	; (80144d4 <_dtoa_r+0x2d4>)
 801426a:	6018      	str	r0, [r3, #0]
 801426c:	3801      	subs	r0, #1
 801426e:	b019      	add	sp, #100	; 0x64
 8014270:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014274:	9a04      	ldr	r2, [sp, #16]
 8014276:	f242 730f 	movw	r3, #9999	; 0x270f
 801427a:	6013      	str	r3, [r2, #0]
 801427c:	9b00      	ldr	r3, [sp, #0]
 801427e:	2b00      	cmp	r3, #0
 8014280:	f000 80a7 	beq.w	80143d2 <_dtoa_r+0x1d2>
 8014284:	4894      	ldr	r0, [pc, #592]	; (80144d8 <_dtoa_r+0x2d8>)
 8014286:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8014288:	2b00      	cmp	r3, #0
 801428a:	d0f0      	beq.n	801426e <_dtoa_r+0x6e>
 801428c:	78c3      	ldrb	r3, [r0, #3]
 801428e:	2b00      	cmp	r3, #0
 8014290:	f000 80b8 	beq.w	8014404 <_dtoa_r+0x204>
 8014294:	f100 0308 	add.w	r3, r0, #8
 8014298:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801429a:	6013      	str	r3, [r2, #0]
 801429c:	b019      	add	sp, #100	; 0x64
 801429e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80142a2:	9a01      	ldr	r2, [sp, #4]
 80142a4:	2301      	movs	r3, #1
 80142a6:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
 80142aa:	602b      	str	r3, [r5, #0]
 80142ac:	f8cd 9004 	str.w	r9, [sp, #4]
 80142b0:	e7c2      	b.n	8014238 <_dtoa_r+0x38>
 80142b2:	4620      	mov	r0, r4
 80142b4:	ec47 6b10 	vmov	d0, r6, r7
 80142b8:	a917      	add	r1, sp, #92	; 0x5c
 80142ba:	aa16      	add	r2, sp, #88	; 0x58
 80142bc:	f001 fcb8 	bl	8015c30 <__d2b>
 80142c0:	ea5f 5519 	movs.w	r5, r9, lsr #20
 80142c4:	4683      	mov	fp, r0
 80142c6:	f040 808d 	bne.w	80143e4 <_dtoa_r+0x1e4>
 80142ca:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 80142ce:	9d17      	ldr	r5, [sp, #92]	; 0x5c
 80142d0:	f46f 6382 	mvn.w	r3, #1040	; 0x410
 80142d4:	4445      	add	r5, r8
 80142d6:	429d      	cmp	r5, r3
 80142d8:	f2c0 829e 	blt.w	8014818 <_dtoa_r+0x618>
 80142dc:	4a7f      	ldr	r2, [pc, #508]	; (80144dc <_dtoa_r+0x2dc>)
 80142de:	1b52      	subs	r2, r2, r5
 80142e0:	fa09 f902 	lsl.w	r9, r9, r2
 80142e4:	9a00      	ldr	r2, [sp, #0]
 80142e6:	f205 4312 	addw	r3, r5, #1042	; 0x412
 80142ea:	fa22 f003 	lsr.w	r0, r2, r3
 80142ee:	ea49 0000 	orr.w	r0, r9, r0
 80142f2:	f7f8 f86f 	bl	800c3d4 <__aeabi_ui2d>
 80142f6:	2301      	movs	r3, #1
 80142f8:	3d01      	subs	r5, #1
 80142fa:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
 80142fe:	930f      	str	r3, [sp, #60]	; 0x3c
 8014300:	2200      	movs	r2, #0
 8014302:	4b77      	ldr	r3, [pc, #476]	; (80144e0 <_dtoa_r+0x2e0>)
 8014304:	f7f7 ff28 	bl	800c158 <__aeabi_dsub>
 8014308:	a36b      	add	r3, pc, #428	; (adr r3, 80144b8 <_dtoa_r+0x2b8>)
 801430a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801430e:	f7f8 f8d7 	bl	800c4c0 <__aeabi_dmul>
 8014312:	a36b      	add	r3, pc, #428	; (adr r3, 80144c0 <_dtoa_r+0x2c0>)
 8014314:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014318:	f7f7 ff20 	bl	800c15c <__adddf3>
 801431c:	4606      	mov	r6, r0
 801431e:	4628      	mov	r0, r5
 8014320:	460f      	mov	r7, r1
 8014322:	f7f8 f867 	bl	800c3f4 <__aeabi_i2d>
 8014326:	a368      	add	r3, pc, #416	; (adr r3, 80144c8 <_dtoa_r+0x2c8>)
 8014328:	e9d3 2300 	ldrd	r2, r3, [r3]
 801432c:	f7f8 f8c8 	bl	800c4c0 <__aeabi_dmul>
 8014330:	4602      	mov	r2, r0
 8014332:	460b      	mov	r3, r1
 8014334:	4630      	mov	r0, r6
 8014336:	4639      	mov	r1, r7
 8014338:	f7f7 ff10 	bl	800c15c <__adddf3>
 801433c:	4606      	mov	r6, r0
 801433e:	460f      	mov	r7, r1
 8014340:	f7f8 fad6 	bl	800c8f0 <__aeabi_d2iz>
 8014344:	4639      	mov	r1, r7
 8014346:	9005      	str	r0, [sp, #20]
 8014348:	2200      	movs	r2, #0
 801434a:	4630      	mov	r0, r6
 801434c:	2300      	movs	r3, #0
 801434e:	f7f8 fbf7 	bl	800cb40 <__aeabi_dcmplt>
 8014352:	2800      	cmp	r0, #0
 8014354:	f040 81ab 	bne.w	80146ae <_dtoa_r+0x4ae>
 8014358:	9b05      	ldr	r3, [sp, #20]
 801435a:	2b16      	cmp	r3, #22
 801435c:	f200 81a4 	bhi.w	80146a8 <_dtoa_r+0x4a8>
 8014360:	9a05      	ldr	r2, [sp, #20]
 8014362:	4b60      	ldr	r3, [pc, #384]	; (80144e4 <_dtoa_r+0x2e4>)
 8014364:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8014368:	e9d3 0100 	ldrd	r0, r1, [r3]
 801436c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8014370:	f7f8 fc04 	bl	800cb7c <__aeabi_dcmpgt>
 8014374:	2800      	cmp	r0, #0
 8014376:	f000 8255 	beq.w	8014824 <_dtoa_r+0x624>
 801437a:	9b05      	ldr	r3, [sp, #20]
 801437c:	3b01      	subs	r3, #1
 801437e:	9305      	str	r3, [sp, #20]
 8014380:	2300      	movs	r3, #0
 8014382:	930d      	str	r3, [sp, #52]	; 0x34
 8014384:	ebc5 0508 	rsb	r5, r5, r8
 8014388:	1e6b      	subs	r3, r5, #1
 801438a:	9306      	str	r3, [sp, #24]
 801438c:	f100 81a6 	bmi.w	80146dc <_dtoa_r+0x4dc>
 8014390:	2300      	movs	r3, #0
 8014392:	9307      	str	r3, [sp, #28]
 8014394:	9b05      	ldr	r3, [sp, #20]
 8014396:	2b00      	cmp	r3, #0
 8014398:	f2c0 8197 	blt.w	80146ca <_dtoa_r+0x4ca>
 801439c:	9a06      	ldr	r2, [sp, #24]
 801439e:	930c      	str	r3, [sp, #48]	; 0x30
 80143a0:	4611      	mov	r1, r2
 80143a2:	4419      	add	r1, r3
 80143a4:	2300      	movs	r3, #0
 80143a6:	9106      	str	r1, [sp, #24]
 80143a8:	930a      	str	r3, [sp, #40]	; 0x28
 80143aa:	9b03      	ldr	r3, [sp, #12]
 80143ac:	2b09      	cmp	r3, #9
 80143ae:	d82b      	bhi.n	8014408 <_dtoa_r+0x208>
 80143b0:	2b05      	cmp	r3, #5
 80143b2:	f340 8673 	ble.w	801509c <_dtoa_r+0xe9c>
 80143b6:	3b04      	subs	r3, #4
 80143b8:	9303      	str	r3, [sp, #12]
 80143ba:	2700      	movs	r7, #0
 80143bc:	9b03      	ldr	r3, [sp, #12]
 80143be:	3b02      	subs	r3, #2
 80143c0:	2b03      	cmp	r3, #3
 80143c2:	f200 8651 	bhi.w	8015068 <_dtoa_r+0xe68>
 80143c6:	e8df f013 	tbh	[pc, r3, lsl #1]
 80143ca:	03d1      	.short	0x03d1
 80143cc:	02b603c4 	.word	0x02b603c4
 80143d0:	0666      	.short	0x0666
 80143d2:	4b41      	ldr	r3, [pc, #260]	; (80144d8 <_dtoa_r+0x2d8>)
 80143d4:	4a44      	ldr	r2, [pc, #272]	; (80144e8 <_dtoa_r+0x2e8>)
 80143d6:	f3c9 0013 	ubfx	r0, r9, #0, #20
 80143da:	2800      	cmp	r0, #0
 80143dc:	bf14      	ite	ne
 80143de:	4618      	movne	r0, r3
 80143e0:	4610      	moveq	r0, r2
 80143e2:	e750      	b.n	8014286 <_dtoa_r+0x86>
 80143e4:	f3c7 0313 	ubfx	r3, r7, #0, #20
 80143e8:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
 80143ec:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 80143f0:	4630      	mov	r0, r6
 80143f2:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 80143f6:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
 80143fa:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 80143fe:	e77f      	b.n	8014300 <_dtoa_r+0x100>
 8014400:	483a      	ldr	r0, [pc, #232]	; (80144ec <_dtoa_r+0x2ec>)
 8014402:	e734      	b.n	801426e <_dtoa_r+0x6e>
 8014404:	1cc3      	adds	r3, r0, #3
 8014406:	e747      	b.n	8014298 <_dtoa_r+0x98>
 8014408:	2100      	movs	r1, #0
 801440a:	6461      	str	r1, [r4, #68]	; 0x44
 801440c:	4620      	mov	r0, r4
 801440e:	468a      	mov	sl, r1
 8014410:	9103      	str	r1, [sp, #12]
 8014412:	f001 f94d 	bl	80156b0 <_Balloc>
 8014416:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 801441a:	9308      	str	r3, [sp, #32]
 801441c:	930e      	str	r3, [sp, #56]	; 0x38
 801441e:	2301      	movs	r3, #1
 8014420:	9009      	str	r0, [sp, #36]	; 0x24
 8014422:	6420      	str	r0, [r4, #64]	; 0x40
 8014424:	930b      	str	r3, [sp, #44]	; 0x2c
 8014426:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8014428:	2b00      	cmp	r3, #0
 801442a:	f2c0 80d3 	blt.w	80145d4 <_dtoa_r+0x3d4>
 801442e:	9a05      	ldr	r2, [sp, #20]
 8014430:	2a0e      	cmp	r2, #14
 8014432:	f300 80cf 	bgt.w	80145d4 <_dtoa_r+0x3d4>
 8014436:	4b2b      	ldr	r3, [pc, #172]	; (80144e4 <_dtoa_r+0x2e4>)
 8014438:	f1ba 0f00 	cmp.w	sl, #0
 801443c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8014440:	e9d3 8900 	ldrd	r8, r9, [r3]
 8014444:	f2c0 8395 	blt.w	8014b72 <_dtoa_r+0x972>
 8014448:	e9dd 6700 	ldrd	r6, r7, [sp]
 801444c:	4642      	mov	r2, r8
 801444e:	464b      	mov	r3, r9
 8014450:	4630      	mov	r0, r6
 8014452:	4639      	mov	r1, r7
 8014454:	f7f8 f95e 	bl	800c714 <__aeabi_ddiv>
 8014458:	f7f8 fa4a 	bl	800c8f0 <__aeabi_d2iz>
 801445c:	4682      	mov	sl, r0
 801445e:	f7f7 ffc9 	bl	800c3f4 <__aeabi_i2d>
 8014462:	4642      	mov	r2, r8
 8014464:	464b      	mov	r3, r9
 8014466:	f7f8 f82b 	bl	800c4c0 <__aeabi_dmul>
 801446a:	460b      	mov	r3, r1
 801446c:	4602      	mov	r2, r0
 801446e:	4639      	mov	r1, r7
 8014470:	4630      	mov	r0, r6
 8014472:	f7f7 fe71 	bl	800c158 <__aeabi_dsub>
 8014476:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8014478:	f10a 0330 	add.w	r3, sl, #48	; 0x30
 801447c:	702b      	strb	r3, [r5, #0]
 801447e:	9b08      	ldr	r3, [sp, #32]
 8014480:	2b01      	cmp	r3, #1
 8014482:	4606      	mov	r6, r0
 8014484:	460f      	mov	r7, r1
 8014486:	f105 0501 	add.w	r5, r5, #1
 801448a:	d063      	beq.n	8014554 <_dtoa_r+0x354>
 801448c:	2200      	movs	r2, #0
 801448e:	4b18      	ldr	r3, [pc, #96]	; (80144f0 <_dtoa_r+0x2f0>)
 8014490:	f7f8 f816 	bl	800c4c0 <__aeabi_dmul>
 8014494:	2200      	movs	r2, #0
 8014496:	2300      	movs	r3, #0
 8014498:	4606      	mov	r6, r0
 801449a:	460f      	mov	r7, r1
 801449c:	f7f8 fb46 	bl	800cb2c <__aeabi_dcmpeq>
 80144a0:	2800      	cmp	r0, #0
 80144a2:	f040 8084 	bne.w	80145ae <_dtoa_r+0x3ae>
 80144a6:	f8cd b000 	str.w	fp, [sp]
 80144aa:	9403      	str	r4, [sp, #12]
 80144ac:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 80144b0:	9c08      	ldr	r4, [sp, #32]
 80144b2:	e02a      	b.n	801450a <_dtoa_r+0x30a>
 80144b4:	f3af 8000 	nop.w
 80144b8:	636f4361 	.word	0x636f4361
 80144bc:	3fd287a7 	.word	0x3fd287a7
 80144c0:	8b60c8b3 	.word	0x8b60c8b3
 80144c4:	3fc68a28 	.word	0x3fc68a28
 80144c8:	509f79fb 	.word	0x509f79fb
 80144cc:	3fd34413 	.word	0x3fd34413
 80144d0:	7ff00000 	.word	0x7ff00000
 80144d4:	08017001 	.word	0x08017001
 80144d8:	0801701c 	.word	0x0801701c
 80144dc:	fffffc0e 	.word	0xfffffc0e
 80144e0:	3ff80000 	.word	0x3ff80000
 80144e4:	08017030 	.word	0x08017030
 80144e8:	08017010 	.word	0x08017010
 80144ec:	08017000 	.word	0x08017000
 80144f0:	40240000 	.word	0x40240000
 80144f4:	f7f7 ffe4 	bl	800c4c0 <__aeabi_dmul>
 80144f8:	2200      	movs	r2, #0
 80144fa:	2300      	movs	r3, #0
 80144fc:	4606      	mov	r6, r0
 80144fe:	460f      	mov	r7, r1
 8014500:	f7f8 fb14 	bl	800cb2c <__aeabi_dcmpeq>
 8014504:	2800      	cmp	r0, #0
 8014506:	f040 83e4 	bne.w	8014cd2 <_dtoa_r+0xad2>
 801450a:	4642      	mov	r2, r8
 801450c:	464b      	mov	r3, r9
 801450e:	4630      	mov	r0, r6
 8014510:	4639      	mov	r1, r7
 8014512:	f7f8 f8ff 	bl	800c714 <__aeabi_ddiv>
 8014516:	f7f8 f9eb 	bl	800c8f0 <__aeabi_d2iz>
 801451a:	4682      	mov	sl, r0
 801451c:	f7f7 ff6a 	bl	800c3f4 <__aeabi_i2d>
 8014520:	4642      	mov	r2, r8
 8014522:	464b      	mov	r3, r9
 8014524:	f7f7 ffcc 	bl	800c4c0 <__aeabi_dmul>
 8014528:	4602      	mov	r2, r0
 801452a:	460b      	mov	r3, r1
 801452c:	4630      	mov	r0, r6
 801452e:	4639      	mov	r1, r7
 8014530:	f7f7 fe12 	bl	800c158 <__aeabi_dsub>
 8014534:	f10a 0e30 	add.w	lr, sl, #48	; 0x30
 8014538:	f805 eb01 	strb.w	lr, [r5], #1
 801453c:	ebcb 0e05 	rsb	lr, fp, r5
 8014540:	4574      	cmp	r4, lr
 8014542:	4606      	mov	r6, r0
 8014544:	460f      	mov	r7, r1
 8014546:	f04f 0200 	mov.w	r2, #0
 801454a:	4bb7      	ldr	r3, [pc, #732]	; (8014828 <_dtoa_r+0x628>)
 801454c:	d1d2      	bne.n	80144f4 <_dtoa_r+0x2f4>
 801454e:	f8dd b000 	ldr.w	fp, [sp]
 8014552:	9c03      	ldr	r4, [sp, #12]
 8014554:	4632      	mov	r2, r6
 8014556:	463b      	mov	r3, r7
 8014558:	4630      	mov	r0, r6
 801455a:	4639      	mov	r1, r7
 801455c:	f7f7 fdfe 	bl	800c15c <__adddf3>
 8014560:	4606      	mov	r6, r0
 8014562:	460f      	mov	r7, r1
 8014564:	4640      	mov	r0, r8
 8014566:	4649      	mov	r1, r9
 8014568:	4632      	mov	r2, r6
 801456a:	463b      	mov	r3, r7
 801456c:	f7f8 fae8 	bl	800cb40 <__aeabi_dcmplt>
 8014570:	b948      	cbnz	r0, 8014586 <_dtoa_r+0x386>
 8014572:	4640      	mov	r0, r8
 8014574:	4649      	mov	r1, r9
 8014576:	4632      	mov	r2, r6
 8014578:	463b      	mov	r3, r7
 801457a:	f7f8 fad7 	bl	800cb2c <__aeabi_dcmpeq>
 801457e:	b1b0      	cbz	r0, 80145ae <_dtoa_r+0x3ae>
 8014580:	f01a 0f01 	tst.w	sl, #1
 8014584:	d013      	beq.n	80145ae <_dtoa_r+0x3ae>
 8014586:	f815 8c01 	ldrb.w	r8, [r5, #-1]
 801458a:	9909      	ldr	r1, [sp, #36]	; 0x24
 801458c:	1e6b      	subs	r3, r5, #1
 801458e:	e004      	b.n	801459a <_dtoa_r+0x39a>
 8014590:	428b      	cmp	r3, r1
 8014592:	f000 8448 	beq.w	8014e26 <_dtoa_r+0xc26>
 8014596:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
 801459a:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 801459e:	f103 0501 	add.w	r5, r3, #1
 80145a2:	461a      	mov	r2, r3
 80145a4:	d0f4      	beq.n	8014590 <_dtoa_r+0x390>
 80145a6:	f108 0301 	add.w	r3, r8, #1
 80145aa:	b2db      	uxtb	r3, r3
 80145ac:	7013      	strb	r3, [r2, #0]
 80145ae:	4620      	mov	r0, r4
 80145b0:	4659      	mov	r1, fp
 80145b2:	f001 f8a5 	bl	8015700 <_Bfree>
 80145b6:	2200      	movs	r2, #0
 80145b8:	9b05      	ldr	r3, [sp, #20]
 80145ba:	702a      	strb	r2, [r5, #0]
 80145bc:	9a04      	ldr	r2, [sp, #16]
 80145be:	3301      	adds	r3, #1
 80145c0:	6013      	str	r3, [r2, #0]
 80145c2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80145c4:	2b00      	cmp	r3, #0
 80145c6:	f000 834b 	beq.w	8014c60 <_dtoa_r+0xa60>
 80145ca:	9809      	ldr	r0, [sp, #36]	; 0x24
 80145cc:	601d      	str	r5, [r3, #0]
 80145ce:	b019      	add	sp, #100	; 0x64
 80145d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80145d4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80145d6:	2a00      	cmp	r2, #0
 80145d8:	f000 8085 	beq.w	80146e6 <_dtoa_r+0x4e6>
 80145dc:	9a03      	ldr	r2, [sp, #12]
 80145de:	2a01      	cmp	r2, #1
 80145e0:	f340 830a 	ble.w	8014bf8 <_dtoa_r+0x9f8>
 80145e4:	9b08      	ldr	r3, [sp, #32]
 80145e6:	1e5f      	subs	r7, r3, #1
 80145e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80145ea:	42bb      	cmp	r3, r7
 80145ec:	f2c0 83a6 	blt.w	8014d3c <_dtoa_r+0xb3c>
 80145f0:	1bdf      	subs	r7, r3, r7
 80145f2:	9b08      	ldr	r3, [sp, #32]
 80145f4:	2b00      	cmp	r3, #0
 80145f6:	f2c0 84a4 	blt.w	8014f42 <_dtoa_r+0xd42>
 80145fa:	9d07      	ldr	r5, [sp, #28]
 80145fc:	9b08      	ldr	r3, [sp, #32]
 80145fe:	9a07      	ldr	r2, [sp, #28]
 8014600:	441a      	add	r2, r3
 8014602:	9207      	str	r2, [sp, #28]
 8014604:	9a06      	ldr	r2, [sp, #24]
 8014606:	4620      	mov	r0, r4
 8014608:	441a      	add	r2, r3
 801460a:	2101      	movs	r1, #1
 801460c:	9206      	str	r2, [sp, #24]
 801460e:	f001 f91f 	bl	8015850 <__i2b>
 8014612:	4606      	mov	r6, r0
 8014614:	b165      	cbz	r5, 8014630 <_dtoa_r+0x430>
 8014616:	9906      	ldr	r1, [sp, #24]
 8014618:	2900      	cmp	r1, #0
 801461a:	460b      	mov	r3, r1
 801461c:	dd08      	ble.n	8014630 <_dtoa_r+0x430>
 801461e:	42a9      	cmp	r1, r5
 8014620:	9a07      	ldr	r2, [sp, #28]
 8014622:	bfa8      	it	ge
 8014624:	462b      	movge	r3, r5
 8014626:	1ad2      	subs	r2, r2, r3
 8014628:	1aed      	subs	r5, r5, r3
 801462a:	1acb      	subs	r3, r1, r3
 801462c:	9207      	str	r2, [sp, #28]
 801462e:	9306      	str	r3, [sp, #24]
 8014630:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014632:	2b00      	cmp	r3, #0
 8014634:	dd1a      	ble.n	801466c <_dtoa_r+0x46c>
 8014636:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014638:	2b00      	cmp	r3, #0
 801463a:	f000 8378 	beq.w	8014d2e <_dtoa_r+0xb2e>
 801463e:	2f00      	cmp	r7, #0
 8014640:	dd10      	ble.n	8014664 <_dtoa_r+0x464>
 8014642:	4631      	mov	r1, r6
 8014644:	463a      	mov	r2, r7
 8014646:	4620      	mov	r0, r4
 8014648:	f001 f9b2 	bl	80159b0 <__pow5mult>
 801464c:	4606      	mov	r6, r0
 801464e:	465a      	mov	r2, fp
 8014650:	4631      	mov	r1, r6
 8014652:	4620      	mov	r0, r4
 8014654:	f001 f90c 	bl	8015870 <__multiply>
 8014658:	4659      	mov	r1, fp
 801465a:	4680      	mov	r8, r0
 801465c:	4620      	mov	r0, r4
 801465e:	f001 f84f 	bl	8015700 <_Bfree>
 8014662:	46c3      	mov	fp, r8
 8014664:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014666:	1bda      	subs	r2, r3, r7
 8014668:	f040 82a5 	bne.w	8014bb6 <_dtoa_r+0x9b6>
 801466c:	4620      	mov	r0, r4
 801466e:	2101      	movs	r1, #1
 8014670:	f001 f8ee 	bl	8015850 <__i2b>
 8014674:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8014676:	2b00      	cmp	r3, #0
 8014678:	4680      	mov	r8, r0
 801467a:	dd38      	ble.n	80146ee <_dtoa_r+0x4ee>
 801467c:	4601      	mov	r1, r0
 801467e:	461a      	mov	r2, r3
 8014680:	4620      	mov	r0, r4
 8014682:	f001 f995 	bl	80159b0 <__pow5mult>
 8014686:	9b03      	ldr	r3, [sp, #12]
 8014688:	2b01      	cmp	r3, #1
 801468a:	4680      	mov	r8, r0
 801468c:	f340 8299 	ble.w	8014bc2 <_dtoa_r+0x9c2>
 8014690:	f04f 0900 	mov.w	r9, #0
 8014694:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8014698:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 801469c:	6918      	ldr	r0, [r3, #16]
 801469e:	f001 f887 	bl	80157b0 <__hi0bits>
 80146a2:	f1c0 0020 	rsb	r0, r0, #32
 80146a6:	e02c      	b.n	8014702 <_dtoa_r+0x502>
 80146a8:	2301      	movs	r3, #1
 80146aa:	930d      	str	r3, [sp, #52]	; 0x34
 80146ac:	e66a      	b.n	8014384 <_dtoa_r+0x184>
 80146ae:	9805      	ldr	r0, [sp, #20]
 80146b0:	f7f7 fea0 	bl	800c3f4 <__aeabi_i2d>
 80146b4:	4632      	mov	r2, r6
 80146b6:	463b      	mov	r3, r7
 80146b8:	f7f8 fa38 	bl	800cb2c <__aeabi_dcmpeq>
 80146bc:	2800      	cmp	r0, #0
 80146be:	f47f ae4b 	bne.w	8014358 <_dtoa_r+0x158>
 80146c2:	9b05      	ldr	r3, [sp, #20]
 80146c4:	3b01      	subs	r3, #1
 80146c6:	9305      	str	r3, [sp, #20]
 80146c8:	e646      	b.n	8014358 <_dtoa_r+0x158>
 80146ca:	9a07      	ldr	r2, [sp, #28]
 80146cc:	9b05      	ldr	r3, [sp, #20]
 80146ce:	1ad2      	subs	r2, r2, r3
 80146d0:	425b      	negs	r3, r3
 80146d2:	930a      	str	r3, [sp, #40]	; 0x28
 80146d4:	2300      	movs	r3, #0
 80146d6:	9207      	str	r2, [sp, #28]
 80146d8:	930c      	str	r3, [sp, #48]	; 0x30
 80146da:	e666      	b.n	80143aa <_dtoa_r+0x1aa>
 80146dc:	425b      	negs	r3, r3
 80146de:	9307      	str	r3, [sp, #28]
 80146e0:	2300      	movs	r3, #0
 80146e2:	9306      	str	r3, [sp, #24]
 80146e4:	e656      	b.n	8014394 <_dtoa_r+0x194>
 80146e6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80146e8:	9d07      	ldr	r5, [sp, #28]
 80146ea:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 80146ec:	e792      	b.n	8014614 <_dtoa_r+0x414>
 80146ee:	9b03      	ldr	r3, [sp, #12]
 80146f0:	2b01      	cmp	r3, #1
 80146f2:	f340 82b8 	ble.w	8014c66 <_dtoa_r+0xa66>
 80146f6:	f04f 0900 	mov.w	r9, #0
 80146fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80146fc:	2b00      	cmp	r3, #0
 80146fe:	d1c9      	bne.n	8014694 <_dtoa_r+0x494>
 8014700:	2001      	movs	r0, #1
 8014702:	9b06      	ldr	r3, [sp, #24]
 8014704:	4418      	add	r0, r3
 8014706:	f010 001f 	ands.w	r0, r0, #31
 801470a:	f000 8083 	beq.w	8014814 <_dtoa_r+0x614>
 801470e:	f1c0 0320 	rsb	r3, r0, #32
 8014712:	2b04      	cmp	r3, #4
 8014714:	f340 84b9 	ble.w	801508a <_dtoa_r+0xe8a>
 8014718:	f1c0 001c 	rsb	r0, r0, #28
 801471c:	9b07      	ldr	r3, [sp, #28]
 801471e:	4403      	add	r3, r0
 8014720:	9307      	str	r3, [sp, #28]
 8014722:	9b06      	ldr	r3, [sp, #24]
 8014724:	4403      	add	r3, r0
 8014726:	4405      	add	r5, r0
 8014728:	9306      	str	r3, [sp, #24]
 801472a:	9b07      	ldr	r3, [sp, #28]
 801472c:	2b00      	cmp	r3, #0
 801472e:	dd05      	ble.n	801473c <_dtoa_r+0x53c>
 8014730:	4659      	mov	r1, fp
 8014732:	461a      	mov	r2, r3
 8014734:	4620      	mov	r0, r4
 8014736:	f001 f98b 	bl	8015a50 <__lshift>
 801473a:	4683      	mov	fp, r0
 801473c:	9b06      	ldr	r3, [sp, #24]
 801473e:	2b00      	cmp	r3, #0
 8014740:	dd05      	ble.n	801474e <_dtoa_r+0x54e>
 8014742:	4641      	mov	r1, r8
 8014744:	461a      	mov	r2, r3
 8014746:	4620      	mov	r0, r4
 8014748:	f001 f982 	bl	8015a50 <__lshift>
 801474c:	4680      	mov	r8, r0
 801474e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8014750:	2b00      	cmp	r3, #0
 8014752:	f040 826a 	bne.w	8014c2a <_dtoa_r+0xa2a>
 8014756:	9b08      	ldr	r3, [sp, #32]
 8014758:	2b00      	cmp	r3, #0
 801475a:	f340 8297 	ble.w	8014c8c <_dtoa_r+0xa8c>
 801475e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014760:	2b00      	cmp	r3, #0
 8014762:	d171      	bne.n	8014848 <_dtoa_r+0x648>
 8014764:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8014768:	9f08      	ldr	r7, [sp, #32]
 801476a:	464d      	mov	r5, r9
 801476c:	e002      	b.n	8014774 <_dtoa_r+0x574>
 801476e:	f000 ffd7 	bl	8015720 <__multadd>
 8014772:	4683      	mov	fp, r0
 8014774:	4641      	mov	r1, r8
 8014776:	4658      	mov	r0, fp
 8014778:	f7ff fcaa 	bl	80140d0 <quorem>
 801477c:	f100 0c30 	add.w	ip, r0, #48	; 0x30
 8014780:	f805 cb01 	strb.w	ip, [r5], #1
 8014784:	ebc9 0305 	rsb	r3, r9, r5
 8014788:	42bb      	cmp	r3, r7
 801478a:	4620      	mov	r0, r4
 801478c:	4659      	mov	r1, fp
 801478e:	f04f 020a 	mov.w	r2, #10
 8014792:	f04f 0300 	mov.w	r3, #0
 8014796:	dbea      	blt.n	801476e <_dtoa_r+0x56e>
 8014798:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801479a:	9a08      	ldr	r2, [sp, #32]
 801479c:	2a01      	cmp	r2, #1
 801479e:	bfac      	ite	ge
 80147a0:	189b      	addge	r3, r3, r2
 80147a2:	3301      	addlt	r3, #1
 80147a4:	461d      	mov	r5, r3
 80147a6:	f04f 0a00 	mov.w	sl, #0
 80147aa:	4659      	mov	r1, fp
 80147ac:	2201      	movs	r2, #1
 80147ae:	4620      	mov	r0, r4
 80147b0:	f8cd c000 	str.w	ip, [sp]
 80147b4:	f001 f94c 	bl	8015a50 <__lshift>
 80147b8:	4641      	mov	r1, r8
 80147ba:	4683      	mov	fp, r0
 80147bc:	f001 f9a0 	bl	8015b00 <__mcmp>
 80147c0:	2800      	cmp	r0, #0
 80147c2:	f8dd c000 	ldr.w	ip, [sp]
 80147c6:	f340 82ef 	ble.w	8014da8 <_dtoa_r+0xba8>
 80147ca:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 80147ce:	9909      	ldr	r1, [sp, #36]	; 0x24
 80147d0:	1e6b      	subs	r3, r5, #1
 80147d2:	e004      	b.n	80147de <_dtoa_r+0x5de>
 80147d4:	428b      	cmp	r3, r1
 80147d6:	f000 8275 	beq.w	8014cc4 <_dtoa_r+0xac4>
 80147da:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 80147de:	2a39      	cmp	r2, #57	; 0x39
 80147e0:	f103 0501 	add.w	r5, r3, #1
 80147e4:	d0f6      	beq.n	80147d4 <_dtoa_r+0x5d4>
 80147e6:	3201      	adds	r2, #1
 80147e8:	701a      	strb	r2, [r3, #0]
 80147ea:	4641      	mov	r1, r8
 80147ec:	4620      	mov	r0, r4
 80147ee:	f000 ff87 	bl	8015700 <_Bfree>
 80147f2:	2e00      	cmp	r6, #0
 80147f4:	f43f aedb 	beq.w	80145ae <_dtoa_r+0x3ae>
 80147f8:	f1ba 0f00 	cmp.w	sl, #0
 80147fc:	d005      	beq.n	801480a <_dtoa_r+0x60a>
 80147fe:	45b2      	cmp	sl, r6
 8014800:	d003      	beq.n	801480a <_dtoa_r+0x60a>
 8014802:	4651      	mov	r1, sl
 8014804:	4620      	mov	r0, r4
 8014806:	f000 ff7b 	bl	8015700 <_Bfree>
 801480a:	4631      	mov	r1, r6
 801480c:	4620      	mov	r0, r4
 801480e:	f000 ff77 	bl	8015700 <_Bfree>
 8014812:	e6cc      	b.n	80145ae <_dtoa_r+0x3ae>
 8014814:	201c      	movs	r0, #28
 8014816:	e781      	b.n	801471c <_dtoa_r+0x51c>
 8014818:	4b04      	ldr	r3, [pc, #16]	; (801482c <_dtoa_r+0x62c>)
 801481a:	9a00      	ldr	r2, [sp, #0]
 801481c:	1b5b      	subs	r3, r3, r5
 801481e:	fa02 f003 	lsl.w	r0, r2, r3
 8014822:	e566      	b.n	80142f2 <_dtoa_r+0xf2>
 8014824:	900d      	str	r0, [sp, #52]	; 0x34
 8014826:	e5ad      	b.n	8014384 <_dtoa_r+0x184>
 8014828:	40240000 	.word	0x40240000
 801482c:	fffffbee 	.word	0xfffffbee
 8014830:	4631      	mov	r1, r6
 8014832:	2300      	movs	r3, #0
 8014834:	4620      	mov	r0, r4
 8014836:	220a      	movs	r2, #10
 8014838:	f000 ff72 	bl	8015720 <__multadd>
 801483c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801483e:	2b00      	cmp	r3, #0
 8014840:	4606      	mov	r6, r0
 8014842:	f340 840b 	ble.w	801505c <_dtoa_r+0xe5c>
 8014846:	9308      	str	r3, [sp, #32]
 8014848:	2d00      	cmp	r5, #0
 801484a:	dd05      	ble.n	8014858 <_dtoa_r+0x658>
 801484c:	4631      	mov	r1, r6
 801484e:	462a      	mov	r2, r5
 8014850:	4620      	mov	r0, r4
 8014852:	f001 f8fd 	bl	8015a50 <__lshift>
 8014856:	4606      	mov	r6, r0
 8014858:	f1b9 0f00 	cmp.w	r9, #0
 801485c:	f040 82ed 	bne.w	8014e3a <_dtoa_r+0xc3a>
 8014860:	46b1      	mov	r9, r6
 8014862:	9b08      	ldr	r3, [sp, #32]
 8014864:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8014866:	3b01      	subs	r3, #1
 8014868:	18d3      	adds	r3, r2, r3
 801486a:	9308      	str	r3, [sp, #32]
 801486c:	9b00      	ldr	r3, [sp, #0]
 801486e:	f003 0301 	and.w	r3, r3, #1
 8014872:	930a      	str	r3, [sp, #40]	; 0x28
 8014874:	4617      	mov	r7, r2
 8014876:	4641      	mov	r1, r8
 8014878:	4658      	mov	r0, fp
 801487a:	f7ff fc29 	bl	80140d0 <quorem>
 801487e:	4631      	mov	r1, r6
 8014880:	4605      	mov	r5, r0
 8014882:	4658      	mov	r0, fp
 8014884:	f001 f93c 	bl	8015b00 <__mcmp>
 8014888:	464a      	mov	r2, r9
 801488a:	4682      	mov	sl, r0
 801488c:	4641      	mov	r1, r8
 801488e:	4620      	mov	r0, r4
 8014890:	f001 f95e 	bl	8015b50 <__mdiff>
 8014894:	68c2      	ldr	r2, [r0, #12]
 8014896:	4603      	mov	r3, r0
 8014898:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 801489c:	2a00      	cmp	r2, #0
 801489e:	f040 81ba 	bne.w	8014c16 <_dtoa_r+0xa16>
 80148a2:	4619      	mov	r1, r3
 80148a4:	4658      	mov	r0, fp
 80148a6:	f8cd c01c 	str.w	ip, [sp, #28]
 80148aa:	9306      	str	r3, [sp, #24]
 80148ac:	f001 f928 	bl	8015b00 <__mcmp>
 80148b0:	9b06      	ldr	r3, [sp, #24]
 80148b2:	9000      	str	r0, [sp, #0]
 80148b4:	4619      	mov	r1, r3
 80148b6:	4620      	mov	r0, r4
 80148b8:	f000 ff22 	bl	8015700 <_Bfree>
 80148bc:	9a00      	ldr	r2, [sp, #0]
 80148be:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80148c2:	b92a      	cbnz	r2, 80148d0 <_dtoa_r+0x6d0>
 80148c4:	9b03      	ldr	r3, [sp, #12]
 80148c6:	b91b      	cbnz	r3, 80148d0 <_dtoa_r+0x6d0>
 80148c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80148ca:	2b00      	cmp	r3, #0
 80148cc:	f000 83aa 	beq.w	8015024 <_dtoa_r+0xe24>
 80148d0:	f1ba 0f00 	cmp.w	sl, #0
 80148d4:	f2c0 824a 	blt.w	8014d6c <_dtoa_r+0xb6c>
 80148d8:	d105      	bne.n	80148e6 <_dtoa_r+0x6e6>
 80148da:	9b03      	ldr	r3, [sp, #12]
 80148dc:	b91b      	cbnz	r3, 80148e6 <_dtoa_r+0x6e6>
 80148de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80148e0:	2b00      	cmp	r3, #0
 80148e2:	f000 8243 	beq.w	8014d6c <_dtoa_r+0xb6c>
 80148e6:	2a00      	cmp	r2, #0
 80148e8:	f300 82bb 	bgt.w	8014e62 <_dtoa_r+0xc62>
 80148ec:	9b08      	ldr	r3, [sp, #32]
 80148ee:	f887 c000 	strb.w	ip, [r7]
 80148f2:	f107 0a01 	add.w	sl, r7, #1
 80148f6:	429f      	cmp	r7, r3
 80148f8:	4655      	mov	r5, sl
 80148fa:	f000 82be 	beq.w	8014e7a <_dtoa_r+0xc7a>
 80148fe:	4659      	mov	r1, fp
 8014900:	220a      	movs	r2, #10
 8014902:	2300      	movs	r3, #0
 8014904:	4620      	mov	r0, r4
 8014906:	f000 ff0b 	bl	8015720 <__multadd>
 801490a:	454e      	cmp	r6, r9
 801490c:	4683      	mov	fp, r0
 801490e:	4631      	mov	r1, r6
 8014910:	4620      	mov	r0, r4
 8014912:	f04f 020a 	mov.w	r2, #10
 8014916:	f04f 0300 	mov.w	r3, #0
 801491a:	f000 8176 	beq.w	8014c0a <_dtoa_r+0xa0a>
 801491e:	f000 feff 	bl	8015720 <__multadd>
 8014922:	4649      	mov	r1, r9
 8014924:	4606      	mov	r6, r0
 8014926:	220a      	movs	r2, #10
 8014928:	4620      	mov	r0, r4
 801492a:	2300      	movs	r3, #0
 801492c:	f000 fef8 	bl	8015720 <__multadd>
 8014930:	4657      	mov	r7, sl
 8014932:	4681      	mov	r9, r0
 8014934:	e79f      	b.n	8014876 <_dtoa_r+0x676>
 8014936:	2301      	movs	r3, #1
 8014938:	930b      	str	r3, [sp, #44]	; 0x2c
 801493a:	f1ba 0f00 	cmp.w	sl, #0
 801493e:	f340 820c 	ble.w	8014d5a <_dtoa_r+0xb5a>
 8014942:	4656      	mov	r6, sl
 8014944:	4655      	mov	r5, sl
 8014946:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
 801494a:	f8cd a020 	str.w	sl, [sp, #32]
 801494e:	2100      	movs	r1, #0
 8014950:	2e17      	cmp	r6, #23
 8014952:	6461      	str	r1, [r4, #68]	; 0x44
 8014954:	d90a      	bls.n	801496c <_dtoa_r+0x76c>
 8014956:	2201      	movs	r2, #1
 8014958:	2304      	movs	r3, #4
 801495a:	005b      	lsls	r3, r3, #1
 801495c:	f103 0014 	add.w	r0, r3, #20
 8014960:	4286      	cmp	r6, r0
 8014962:	4611      	mov	r1, r2
 8014964:	f102 0201 	add.w	r2, r2, #1
 8014968:	d2f7      	bcs.n	801495a <_dtoa_r+0x75a>
 801496a:	6461      	str	r1, [r4, #68]	; 0x44
 801496c:	4620      	mov	r0, r4
 801496e:	f000 fe9f 	bl	80156b0 <_Balloc>
 8014972:	2d0e      	cmp	r5, #14
 8014974:	9009      	str	r0, [sp, #36]	; 0x24
 8014976:	6420      	str	r0, [r4, #64]	; 0x40
 8014978:	f63f ad55 	bhi.w	8014426 <_dtoa_r+0x226>
 801497c:	2f00      	cmp	r7, #0
 801497e:	f43f ad52 	beq.w	8014426 <_dtoa_r+0x226>
 8014982:	ed9d 7b00 	vldr	d7, [sp]
 8014986:	9905      	ldr	r1, [sp, #20]
 8014988:	2900      	cmp	r1, #0
 801498a:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 801498e:	f340 8223 	ble.w	8014dd8 <_dtoa_r+0xbd8>
 8014992:	4bb7      	ldr	r3, [pc, #732]	; (8014c70 <_dtoa_r+0xa70>)
 8014994:	f001 020f 	and.w	r2, r1, #15
 8014998:	110d      	asrs	r5, r1, #4
 801499a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801499e:	06e9      	lsls	r1, r5, #27
 80149a0:	e9d3 6700 	ldrd	r6, r7, [r3]
 80149a4:	f140 81d2 	bpl.w	8014d4c <_dtoa_r+0xb4c>
 80149a8:	4bb2      	ldr	r3, [pc, #712]	; (8014c74 <_dtoa_r+0xa74>)
 80149aa:	ec51 0b17 	vmov	r0, r1, d7
 80149ae:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80149b2:	f7f7 feaf 	bl	800c714 <__aeabi_ddiv>
 80149b6:	e9cd 0100 	strd	r0, r1, [sp]
 80149ba:	f005 050f 	and.w	r5, r5, #15
 80149be:	f04f 0803 	mov.w	r8, #3
 80149c2:	b18d      	cbz	r5, 80149e8 <_dtoa_r+0x7e8>
 80149c4:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 8014c74 <_dtoa_r+0xa74>
 80149c8:	4630      	mov	r0, r6
 80149ca:	4639      	mov	r1, r7
 80149cc:	07ea      	lsls	r2, r5, #31
 80149ce:	d505      	bpl.n	80149dc <_dtoa_r+0x7dc>
 80149d0:	e9d9 2300 	ldrd	r2, r3, [r9]
 80149d4:	f7f7 fd74 	bl	800c4c0 <__aeabi_dmul>
 80149d8:	f108 0801 	add.w	r8, r8, #1
 80149dc:	106d      	asrs	r5, r5, #1
 80149de:	f109 0908 	add.w	r9, r9, #8
 80149e2:	d1f3      	bne.n	80149cc <_dtoa_r+0x7cc>
 80149e4:	4606      	mov	r6, r0
 80149e6:	460f      	mov	r7, r1
 80149e8:	e9dd 0100 	ldrd	r0, r1, [sp]
 80149ec:	4632      	mov	r2, r6
 80149ee:	463b      	mov	r3, r7
 80149f0:	f7f7 fe90 	bl	800c714 <__aeabi_ddiv>
 80149f4:	e9cd 0100 	strd	r0, r1, [sp]
 80149f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80149fa:	b143      	cbz	r3, 8014a0e <_dtoa_r+0x80e>
 80149fc:	e9dd 0100 	ldrd	r0, r1, [sp]
 8014a00:	2200      	movs	r2, #0
 8014a02:	4b9d      	ldr	r3, [pc, #628]	; (8014c78 <_dtoa_r+0xa78>)
 8014a04:	f7f8 f89c 	bl	800cb40 <__aeabi_dcmplt>
 8014a08:	2800      	cmp	r0, #0
 8014a0a:	f040 82ae 	bne.w	8014f6a <_dtoa_r+0xd6a>
 8014a0e:	4640      	mov	r0, r8
 8014a10:	f7f7 fcf0 	bl	800c3f4 <__aeabi_i2d>
 8014a14:	e9dd 2300 	ldrd	r2, r3, [sp]
 8014a18:	f7f7 fd52 	bl	800c4c0 <__aeabi_dmul>
 8014a1c:	4b97      	ldr	r3, [pc, #604]	; (8014c7c <_dtoa_r+0xa7c>)
 8014a1e:	2200      	movs	r2, #0
 8014a20:	f7f7 fb9c 	bl	800c15c <__adddf3>
 8014a24:	9b08      	ldr	r3, [sp, #32]
 8014a26:	4606      	mov	r6, r0
 8014a28:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 8014a2c:	2b00      	cmp	r3, #0
 8014a2e:	f000 8162 	beq.w	8014cf6 <_dtoa_r+0xaf6>
 8014a32:	9b05      	ldr	r3, [sp, #20]
 8014a34:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8014a38:	9314      	str	r3, [sp, #80]	; 0x50
 8014a3a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014a3c:	2b00      	cmp	r3, #0
 8014a3e:	f000 8223 	beq.w	8014e88 <_dtoa_r+0xc88>
 8014a42:	4b8b      	ldr	r3, [pc, #556]	; (8014c70 <_dtoa_r+0xa70>)
 8014a44:	498e      	ldr	r1, [pc, #568]	; (8014c80 <_dtoa_r+0xa80>)
 8014a46:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
 8014a4a:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8014a4e:	2000      	movs	r0, #0
 8014a50:	f7f7 fe60 	bl	800c714 <__aeabi_ddiv>
 8014a54:	4632      	mov	r2, r6
 8014a56:	463b      	mov	r3, r7
 8014a58:	f7f7 fb7e 	bl	800c158 <__aeabi_dsub>
 8014a5c:	e9dd 6700 	ldrd	r6, r7, [sp]
 8014a60:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 8014a64:	4639      	mov	r1, r7
 8014a66:	4630      	mov	r0, r6
 8014a68:	f7f7 ff42 	bl	800c8f0 <__aeabi_d2iz>
 8014a6c:	4605      	mov	r5, r0
 8014a6e:	f7f7 fcc1 	bl	800c3f4 <__aeabi_i2d>
 8014a72:	3530      	adds	r5, #48	; 0x30
 8014a74:	4602      	mov	r2, r0
 8014a76:	460b      	mov	r3, r1
 8014a78:	4630      	mov	r0, r6
 8014a7a:	4639      	mov	r1, r7
 8014a7c:	f7f7 fb6c 	bl	800c158 <__aeabi_dsub>
 8014a80:	fa5f f885 	uxtb.w	r8, r5
 8014a84:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8014a86:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8014a8a:	f885 8000 	strb.w	r8, [r5]
 8014a8e:	4606      	mov	r6, r0
 8014a90:	460f      	mov	r7, r1
 8014a92:	3501      	adds	r5, #1
 8014a94:	f7f8 f854 	bl	800cb40 <__aeabi_dcmplt>
 8014a98:	2800      	cmp	r0, #0
 8014a9a:	f040 82a7 	bne.w	8014fec <_dtoa_r+0xdec>
 8014a9e:	4632      	mov	r2, r6
 8014aa0:	463b      	mov	r3, r7
 8014aa2:	2000      	movs	r0, #0
 8014aa4:	4974      	ldr	r1, [pc, #464]	; (8014c78 <_dtoa_r+0xa78>)
 8014aa6:	f7f7 fb57 	bl	800c158 <__aeabi_dsub>
 8014aaa:	4602      	mov	r2, r0
 8014aac:	460b      	mov	r3, r1
 8014aae:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 8014ab2:	f7f8 f863 	bl	800cb7c <__aeabi_dcmpgt>
 8014ab6:	2800      	cmp	r0, #0
 8014ab8:	f040 82ad 	bne.w	8015016 <_dtoa_r+0xe16>
 8014abc:	f1b9 0f01 	cmp.w	r9, #1
 8014ac0:	f340 8184 	ble.w	8014dcc <_dtoa_r+0xbcc>
 8014ac4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014ac6:	f8cd b000 	str.w	fp, [sp]
 8014aca:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
 8014ace:	4499      	add	r9, r3
 8014ad0:	46a0      	mov	r8, r4
 8014ad2:	e9dd ab12 	ldrd	sl, fp, [sp, #72]	; 0x48
 8014ad6:	e00d      	b.n	8014af4 <_dtoa_r+0x8f4>
 8014ad8:	2000      	movs	r0, #0
 8014ada:	4967      	ldr	r1, [pc, #412]	; (8014c78 <_dtoa_r+0xa78>)
 8014adc:	f7f7 fb3c 	bl	800c158 <__aeabi_dsub>
 8014ae0:	4652      	mov	r2, sl
 8014ae2:	465b      	mov	r3, fp
 8014ae4:	f7f8 f82c 	bl	800cb40 <__aeabi_dcmplt>
 8014ae8:	2800      	cmp	r0, #0
 8014aea:	f040 828f 	bne.w	801500c <_dtoa_r+0xe0c>
 8014aee:	454d      	cmp	r5, r9
 8014af0:	f000 8167 	beq.w	8014dc2 <_dtoa_r+0xbc2>
 8014af4:	4650      	mov	r0, sl
 8014af6:	4659      	mov	r1, fp
 8014af8:	2200      	movs	r2, #0
 8014afa:	4b62      	ldr	r3, [pc, #392]	; (8014c84 <_dtoa_r+0xa84>)
 8014afc:	f7f7 fce0 	bl	800c4c0 <__aeabi_dmul>
 8014b00:	2200      	movs	r2, #0
 8014b02:	4b60      	ldr	r3, [pc, #384]	; (8014c84 <_dtoa_r+0xa84>)
 8014b04:	4682      	mov	sl, r0
 8014b06:	468b      	mov	fp, r1
 8014b08:	4630      	mov	r0, r6
 8014b0a:	4639      	mov	r1, r7
 8014b0c:	f7f7 fcd8 	bl	800c4c0 <__aeabi_dmul>
 8014b10:	460f      	mov	r7, r1
 8014b12:	4606      	mov	r6, r0
 8014b14:	f7f7 feec 	bl	800c8f0 <__aeabi_d2iz>
 8014b18:	4604      	mov	r4, r0
 8014b1a:	f7f7 fc6b 	bl	800c3f4 <__aeabi_i2d>
 8014b1e:	4602      	mov	r2, r0
 8014b20:	460b      	mov	r3, r1
 8014b22:	4630      	mov	r0, r6
 8014b24:	4639      	mov	r1, r7
 8014b26:	f7f7 fb17 	bl	800c158 <__aeabi_dsub>
 8014b2a:	3430      	adds	r4, #48	; 0x30
 8014b2c:	b2e4      	uxtb	r4, r4
 8014b2e:	4652      	mov	r2, sl
 8014b30:	465b      	mov	r3, fp
 8014b32:	f805 4b01 	strb.w	r4, [r5], #1
 8014b36:	4606      	mov	r6, r0
 8014b38:	460f      	mov	r7, r1
 8014b3a:	f7f8 f801 	bl	800cb40 <__aeabi_dcmplt>
 8014b3e:	4632      	mov	r2, r6
 8014b40:	463b      	mov	r3, r7
 8014b42:	2800      	cmp	r0, #0
 8014b44:	d0c8      	beq.n	8014ad8 <_dtoa_r+0x8d8>
 8014b46:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8014b48:	f8dd b000 	ldr.w	fp, [sp]
 8014b4c:	9305      	str	r3, [sp, #20]
 8014b4e:	4644      	mov	r4, r8
 8014b50:	e52d      	b.n	80145ae <_dtoa_r+0x3ae>
 8014b52:	2300      	movs	r3, #0
 8014b54:	930b      	str	r3, [sp, #44]	; 0x2c
 8014b56:	9b05      	ldr	r3, [sp, #20]
 8014b58:	4453      	add	r3, sl
 8014b5a:	930e      	str	r3, [sp, #56]	; 0x38
 8014b5c:	3301      	adds	r3, #1
 8014b5e:	2b00      	cmp	r3, #0
 8014b60:	9308      	str	r3, [sp, #32]
 8014b62:	f340 8101 	ble.w	8014d68 <_dtoa_r+0xb68>
 8014b66:	9d08      	ldr	r5, [sp, #32]
 8014b68:	462e      	mov	r6, r5
 8014b6a:	e6f0      	b.n	801494e <_dtoa_r+0x74e>
 8014b6c:	2300      	movs	r3, #0
 8014b6e:	930b      	str	r3, [sp, #44]	; 0x2c
 8014b70:	e6e3      	b.n	801493a <_dtoa_r+0x73a>
 8014b72:	9b08      	ldr	r3, [sp, #32]
 8014b74:	2b00      	cmp	r3, #0
 8014b76:	f73f ac67 	bgt.w	8014448 <_dtoa_r+0x248>
 8014b7a:	f040 80d4 	bne.w	8014d26 <_dtoa_r+0xb26>
 8014b7e:	4640      	mov	r0, r8
 8014b80:	2200      	movs	r2, #0
 8014b82:	4b41      	ldr	r3, [pc, #260]	; (8014c88 <_dtoa_r+0xa88>)
 8014b84:	4649      	mov	r1, r9
 8014b86:	f7f7 fc9b 	bl	800c4c0 <__aeabi_dmul>
 8014b8a:	e9dd 2300 	ldrd	r2, r3, [sp]
 8014b8e:	f7f7 ffeb 	bl	800cb68 <__aeabi_dcmpge>
 8014b92:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8014b96:	4646      	mov	r6, r8
 8014b98:	2800      	cmp	r0, #0
 8014b9a:	f000 808b 	beq.w	8014cb4 <_dtoa_r+0xab4>
 8014b9e:	ea6f 030a 	mvn.w	r3, sl
 8014ba2:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8014ba4:	9305      	str	r3, [sp, #20]
 8014ba6:	4641      	mov	r1, r8
 8014ba8:	4620      	mov	r0, r4
 8014baa:	f000 fda9 	bl	8015700 <_Bfree>
 8014bae:	2e00      	cmp	r6, #0
 8014bb0:	f47f ae2b 	bne.w	801480a <_dtoa_r+0x60a>
 8014bb4:	e4fb      	b.n	80145ae <_dtoa_r+0x3ae>
 8014bb6:	4659      	mov	r1, fp
 8014bb8:	4620      	mov	r0, r4
 8014bba:	f000 fef9 	bl	80159b0 <__pow5mult>
 8014bbe:	4683      	mov	fp, r0
 8014bc0:	e554      	b.n	801466c <_dtoa_r+0x46c>
 8014bc2:	9b00      	ldr	r3, [sp, #0]
 8014bc4:	2b00      	cmp	r3, #0
 8014bc6:	f47f ad63 	bne.w	8014690 <_dtoa_r+0x490>
 8014bca:	9b01      	ldr	r3, [sp, #4]
 8014bcc:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8014bd0:	2b00      	cmp	r3, #0
 8014bd2:	f47f ad90 	bne.w	80146f6 <_dtoa_r+0x4f6>
 8014bd6:	9b01      	ldr	r3, [sp, #4]
 8014bd8:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
 8014bdc:	0d3f      	lsrs	r7, r7, #20
 8014bde:	053f      	lsls	r7, r7, #20
 8014be0:	2f00      	cmp	r7, #0
 8014be2:	f000 821c 	beq.w	801501e <_dtoa_r+0xe1e>
 8014be6:	9b07      	ldr	r3, [sp, #28]
 8014be8:	3301      	adds	r3, #1
 8014bea:	9307      	str	r3, [sp, #28]
 8014bec:	9b06      	ldr	r3, [sp, #24]
 8014bee:	3301      	adds	r3, #1
 8014bf0:	9306      	str	r3, [sp, #24]
 8014bf2:	f04f 0901 	mov.w	r9, #1
 8014bf6:	e580      	b.n	80146fa <_dtoa_r+0x4fa>
 8014bf8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014bfa:	2a00      	cmp	r2, #0
 8014bfc:	f000 81a7 	beq.w	8014f4e <_dtoa_r+0xd4e>
 8014c00:	f203 4333 	addw	r3, r3, #1075	; 0x433
 8014c04:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8014c06:	9d07      	ldr	r5, [sp, #28]
 8014c08:	e4f9      	b.n	80145fe <_dtoa_r+0x3fe>
 8014c0a:	f000 fd89 	bl	8015720 <__multadd>
 8014c0e:	4657      	mov	r7, sl
 8014c10:	4606      	mov	r6, r0
 8014c12:	4681      	mov	r9, r0
 8014c14:	e62f      	b.n	8014876 <_dtoa_r+0x676>
 8014c16:	4601      	mov	r1, r0
 8014c18:	4620      	mov	r0, r4
 8014c1a:	f8cd c000 	str.w	ip, [sp]
 8014c1e:	f000 fd6f 	bl	8015700 <_Bfree>
 8014c22:	2201      	movs	r2, #1
 8014c24:	f8dd c000 	ldr.w	ip, [sp]
 8014c28:	e652      	b.n	80148d0 <_dtoa_r+0x6d0>
 8014c2a:	4658      	mov	r0, fp
 8014c2c:	4641      	mov	r1, r8
 8014c2e:	f000 ff67 	bl	8015b00 <__mcmp>
 8014c32:	2800      	cmp	r0, #0
 8014c34:	f6bf ad8f 	bge.w	8014756 <_dtoa_r+0x556>
 8014c38:	9f05      	ldr	r7, [sp, #20]
 8014c3a:	4659      	mov	r1, fp
 8014c3c:	2300      	movs	r3, #0
 8014c3e:	4620      	mov	r0, r4
 8014c40:	220a      	movs	r2, #10
 8014c42:	3f01      	subs	r7, #1
 8014c44:	9705      	str	r7, [sp, #20]
 8014c46:	f000 fd6b 	bl	8015720 <__multadd>
 8014c4a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014c4c:	4683      	mov	fp, r0
 8014c4e:	2b00      	cmp	r3, #0
 8014c50:	f47f adee 	bne.w	8014830 <_dtoa_r+0x630>
 8014c54:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8014c56:	2b00      	cmp	r3, #0
 8014c58:	f340 81f5 	ble.w	8015046 <_dtoa_r+0xe46>
 8014c5c:	9308      	str	r3, [sp, #32]
 8014c5e:	e581      	b.n	8014764 <_dtoa_r+0x564>
 8014c60:	9809      	ldr	r0, [sp, #36]	; 0x24
 8014c62:	f7ff bb04 	b.w	801426e <_dtoa_r+0x6e>
 8014c66:	9b00      	ldr	r3, [sp, #0]
 8014c68:	2b00      	cmp	r3, #0
 8014c6a:	f47f ad44 	bne.w	80146f6 <_dtoa_r+0x4f6>
 8014c6e:	e7ac      	b.n	8014bca <_dtoa_r+0x9ca>
 8014c70:	08017030 	.word	0x08017030
 8014c74:	08017110 	.word	0x08017110
 8014c78:	3ff00000 	.word	0x3ff00000
 8014c7c:	401c0000 	.word	0x401c0000
 8014c80:	3fe00000 	.word	0x3fe00000
 8014c84:	40240000 	.word	0x40240000
 8014c88:	40140000 	.word	0x40140000
 8014c8c:	9b03      	ldr	r3, [sp, #12]
 8014c8e:	2b02      	cmp	r3, #2
 8014c90:	f77f ad65 	ble.w	801475e <_dtoa_r+0x55e>
 8014c94:	9b08      	ldr	r3, [sp, #32]
 8014c96:	2b00      	cmp	r3, #0
 8014c98:	d181      	bne.n	8014b9e <_dtoa_r+0x99e>
 8014c9a:	4641      	mov	r1, r8
 8014c9c:	2205      	movs	r2, #5
 8014c9e:	4620      	mov	r0, r4
 8014ca0:	f000 fd3e 	bl	8015720 <__multadd>
 8014ca4:	4680      	mov	r8, r0
 8014ca6:	4641      	mov	r1, r8
 8014ca8:	4658      	mov	r0, fp
 8014caa:	f000 ff29 	bl	8015b00 <__mcmp>
 8014cae:	2800      	cmp	r0, #0
 8014cb0:	f77f af75 	ble.w	8014b9e <_dtoa_r+0x99e>
 8014cb4:	9a05      	ldr	r2, [sp, #20]
 8014cb6:	9909      	ldr	r1, [sp, #36]	; 0x24
 8014cb8:	2331      	movs	r3, #49	; 0x31
 8014cba:	3201      	adds	r2, #1
 8014cbc:	9205      	str	r2, [sp, #20]
 8014cbe:	700b      	strb	r3, [r1, #0]
 8014cc0:	1c4d      	adds	r5, r1, #1
 8014cc2:	e770      	b.n	8014ba6 <_dtoa_r+0x9a6>
 8014cc4:	9a05      	ldr	r2, [sp, #20]
 8014cc6:	3201      	adds	r2, #1
 8014cc8:	9205      	str	r2, [sp, #20]
 8014cca:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8014ccc:	2331      	movs	r3, #49	; 0x31
 8014cce:	7013      	strb	r3, [r2, #0]
 8014cd0:	e58b      	b.n	80147ea <_dtoa_r+0x5ea>
 8014cd2:	f8dd b000 	ldr.w	fp, [sp]
 8014cd6:	9c03      	ldr	r4, [sp, #12]
 8014cd8:	e469      	b.n	80145ae <_dtoa_r+0x3ae>
 8014cda:	4640      	mov	r0, r8
 8014cdc:	f7f7 fb8a 	bl	800c3f4 <__aeabi_i2d>
 8014ce0:	e9dd 2300 	ldrd	r2, r3, [sp]
 8014ce4:	f7f7 fbec 	bl	800c4c0 <__aeabi_dmul>
 8014ce8:	2200      	movs	r2, #0
 8014cea:	4bc2      	ldr	r3, [pc, #776]	; (8014ff4 <_dtoa_r+0xdf4>)
 8014cec:	f7f7 fa36 	bl	800c15c <__adddf3>
 8014cf0:	4606      	mov	r6, r0
 8014cf2:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 8014cf6:	2200      	movs	r2, #0
 8014cf8:	4bbf      	ldr	r3, [pc, #764]	; (8014ff8 <_dtoa_r+0xdf8>)
 8014cfa:	e9dd 0100 	ldrd	r0, r1, [sp]
 8014cfe:	f7f7 fa2b 	bl	800c158 <__aeabi_dsub>
 8014d02:	4632      	mov	r2, r6
 8014d04:	463b      	mov	r3, r7
 8014d06:	4680      	mov	r8, r0
 8014d08:	4689      	mov	r9, r1
 8014d0a:	f7f7 ff37 	bl	800cb7c <__aeabi_dcmpgt>
 8014d0e:	2800      	cmp	r0, #0
 8014d10:	f040 80b6 	bne.w	8014e80 <_dtoa_r+0xc80>
 8014d14:	4632      	mov	r2, r6
 8014d16:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 8014d1a:	4640      	mov	r0, r8
 8014d1c:	4649      	mov	r1, r9
 8014d1e:	f7f7 ff0f 	bl	800cb40 <__aeabi_dcmplt>
 8014d22:	2800      	cmp	r0, #0
 8014d24:	d052      	beq.n	8014dcc <_dtoa_r+0xbcc>
 8014d26:	f04f 0800 	mov.w	r8, #0
 8014d2a:	4646      	mov	r6, r8
 8014d2c:	e737      	b.n	8014b9e <_dtoa_r+0x99e>
 8014d2e:	4659      	mov	r1, fp
 8014d30:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8014d32:	4620      	mov	r0, r4
 8014d34:	f000 fe3c 	bl	80159b0 <__pow5mult>
 8014d38:	4683      	mov	fp, r0
 8014d3a:	e497      	b.n	801466c <_dtoa_r+0x46c>
 8014d3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014d3e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8014d40:	970a      	str	r7, [sp, #40]	; 0x28
 8014d42:	1afb      	subs	r3, r7, r3
 8014d44:	441a      	add	r2, r3
 8014d46:	920c      	str	r2, [sp, #48]	; 0x30
 8014d48:	2700      	movs	r7, #0
 8014d4a:	e452      	b.n	80145f2 <_dtoa_r+0x3f2>
 8014d4c:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 8014d50:	f04f 0802 	mov.w	r8, #2
 8014d54:	ed8d 7b00 	vstr	d7, [sp]
 8014d58:	e633      	b.n	80149c2 <_dtoa_r+0x7c2>
 8014d5a:	2501      	movs	r5, #1
 8014d5c:	950e      	str	r5, [sp, #56]	; 0x38
 8014d5e:	9508      	str	r5, [sp, #32]
 8014d60:	46aa      	mov	sl, r5
 8014d62:	2100      	movs	r1, #0
 8014d64:	6461      	str	r1, [r4, #68]	; 0x44
 8014d66:	e601      	b.n	801496c <_dtoa_r+0x76c>
 8014d68:	461d      	mov	r5, r3
 8014d6a:	e7fa      	b.n	8014d62 <_dtoa_r+0xb62>
 8014d6c:	2a00      	cmp	r2, #0
 8014d6e:	dd15      	ble.n	8014d9c <_dtoa_r+0xb9c>
 8014d70:	4659      	mov	r1, fp
 8014d72:	2201      	movs	r2, #1
 8014d74:	4620      	mov	r0, r4
 8014d76:	f8cd c000 	str.w	ip, [sp]
 8014d7a:	f000 fe69 	bl	8015a50 <__lshift>
 8014d7e:	4641      	mov	r1, r8
 8014d80:	4683      	mov	fp, r0
 8014d82:	f000 febd 	bl	8015b00 <__mcmp>
 8014d86:	2800      	cmp	r0, #0
 8014d88:	f8dd c000 	ldr.w	ip, [sp]
 8014d8c:	f340 8154 	ble.w	8015038 <_dtoa_r+0xe38>
 8014d90:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
 8014d94:	f000 8111 	beq.w	8014fba <_dtoa_r+0xdba>
 8014d98:	f10c 0c01 	add.w	ip, ip, #1
 8014d9c:	46b2      	mov	sl, r6
 8014d9e:	f887 c000 	strb.w	ip, [r7]
 8014da2:	1c7d      	adds	r5, r7, #1
 8014da4:	464e      	mov	r6, r9
 8014da6:	e520      	b.n	80147ea <_dtoa_r+0x5ea>
 8014da8:	d104      	bne.n	8014db4 <_dtoa_r+0xbb4>
 8014daa:	f01c 0f01 	tst.w	ip, #1
 8014dae:	d001      	beq.n	8014db4 <_dtoa_r+0xbb4>
 8014db0:	e50b      	b.n	80147ca <_dtoa_r+0x5ca>
 8014db2:	4615      	mov	r5, r2
 8014db4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8014db8:	2b30      	cmp	r3, #48	; 0x30
 8014dba:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
 8014dbe:	d0f8      	beq.n	8014db2 <_dtoa_r+0xbb2>
 8014dc0:	e513      	b.n	80147ea <_dtoa_r+0x5ea>
 8014dc2:	f8dd b000 	ldr.w	fp, [sp]
 8014dc6:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
 8014dca:	4644      	mov	r4, r8
 8014dcc:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 8014dd0:	e9cd 2300 	strd	r2, r3, [sp]
 8014dd4:	f7ff bb27 	b.w	8014426 <_dtoa_r+0x226>
 8014dd8:	9b05      	ldr	r3, [sp, #20]
 8014dda:	425d      	negs	r5, r3
 8014ddc:	2d00      	cmp	r5, #0
 8014dde:	f000 80bd 	beq.w	8014f5c <_dtoa_r+0xd5c>
 8014de2:	4b86      	ldr	r3, [pc, #536]	; (8014ffc <_dtoa_r+0xdfc>)
 8014de4:	f005 020f 	and.w	r2, r5, #15
 8014de8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8014dec:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014df0:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8014df4:	f7f7 fb64 	bl	800c4c0 <__aeabi_dmul>
 8014df8:	112d      	asrs	r5, r5, #4
 8014dfa:	e9cd 0100 	strd	r0, r1, [sp]
 8014dfe:	f000 8127 	beq.w	8015050 <_dtoa_r+0xe50>
 8014e02:	4e7f      	ldr	r6, [pc, #508]	; (8015000 <_dtoa_r+0xe00>)
 8014e04:	f04f 0802 	mov.w	r8, #2
 8014e08:	07eb      	lsls	r3, r5, #31
 8014e0a:	d505      	bpl.n	8014e18 <_dtoa_r+0xc18>
 8014e0c:	e9d6 2300 	ldrd	r2, r3, [r6]
 8014e10:	f7f7 fb56 	bl	800c4c0 <__aeabi_dmul>
 8014e14:	f108 0801 	add.w	r8, r8, #1
 8014e18:	106d      	asrs	r5, r5, #1
 8014e1a:	f106 0608 	add.w	r6, r6, #8
 8014e1e:	d1f3      	bne.n	8014e08 <_dtoa_r+0xc08>
 8014e20:	e9cd 0100 	strd	r0, r1, [sp]
 8014e24:	e5e8      	b.n	80149f8 <_dtoa_r+0x7f8>
 8014e26:	9a05      	ldr	r2, [sp, #20]
 8014e28:	3201      	adds	r2, #1
 8014e2a:	9205      	str	r2, [sp, #20]
 8014e2c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8014e2e:	2330      	movs	r3, #48	; 0x30
 8014e30:	7013      	strb	r3, [r2, #0]
 8014e32:	2331      	movs	r3, #49	; 0x31
 8014e34:	7013      	strb	r3, [r2, #0]
 8014e36:	f7ff bbba 	b.w	80145ae <_dtoa_r+0x3ae>
 8014e3a:	6871      	ldr	r1, [r6, #4]
 8014e3c:	4620      	mov	r0, r4
 8014e3e:	f000 fc37 	bl	80156b0 <_Balloc>
 8014e42:	6933      	ldr	r3, [r6, #16]
 8014e44:	1c9a      	adds	r2, r3, #2
 8014e46:	4605      	mov	r5, r0
 8014e48:	0092      	lsls	r2, r2, #2
 8014e4a:	f106 010c 	add.w	r1, r6, #12
 8014e4e:	300c      	adds	r0, #12
 8014e50:	f7f7 fd76 	bl	800c940 <memcpy>
 8014e54:	4620      	mov	r0, r4
 8014e56:	4629      	mov	r1, r5
 8014e58:	2201      	movs	r2, #1
 8014e5a:	f000 fdf9 	bl	8015a50 <__lshift>
 8014e5e:	4681      	mov	r9, r0
 8014e60:	e4ff      	b.n	8014862 <_dtoa_r+0x662>
 8014e62:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
 8014e66:	f000 80a8 	beq.w	8014fba <_dtoa_r+0xdba>
 8014e6a:	f10c 0c01 	add.w	ip, ip, #1
 8014e6e:	46b2      	mov	sl, r6
 8014e70:	f887 c000 	strb.w	ip, [r7]
 8014e74:	1c7d      	adds	r5, r7, #1
 8014e76:	464e      	mov	r6, r9
 8014e78:	e4b7      	b.n	80147ea <_dtoa_r+0x5ea>
 8014e7a:	46b2      	mov	sl, r6
 8014e7c:	464e      	mov	r6, r9
 8014e7e:	e494      	b.n	80147aa <_dtoa_r+0x5aa>
 8014e80:	f04f 0800 	mov.w	r8, #0
 8014e84:	4646      	mov	r6, r8
 8014e86:	e715      	b.n	8014cb4 <_dtoa_r+0xab4>
 8014e88:	495c      	ldr	r1, [pc, #368]	; (8014ffc <_dtoa_r+0xdfc>)
 8014e8a:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
 8014e8e:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8014e92:	4632      	mov	r2, r6
 8014e94:	9315      	str	r3, [sp, #84]	; 0x54
 8014e96:	e9d1 0100 	ldrd	r0, r1, [r1]
 8014e9a:	463b      	mov	r3, r7
 8014e9c:	f7f7 fb10 	bl	800c4c0 <__aeabi_dmul>
 8014ea0:	e9dd 6700 	ldrd	r6, r7, [sp]
 8014ea4:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 8014ea8:	4639      	mov	r1, r7
 8014eaa:	4630      	mov	r0, r6
 8014eac:	f7f7 fd20 	bl	800c8f0 <__aeabi_d2iz>
 8014eb0:	4605      	mov	r5, r0
 8014eb2:	f7f7 fa9f 	bl	800c3f4 <__aeabi_i2d>
 8014eb6:	4602      	mov	r2, r0
 8014eb8:	460b      	mov	r3, r1
 8014eba:	4630      	mov	r0, r6
 8014ebc:	4639      	mov	r1, r7
 8014ebe:	f7f7 f94b 	bl	800c158 <__aeabi_dsub>
 8014ec2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8014ec4:	3530      	adds	r5, #48	; 0x30
 8014ec6:	f1b9 0f01 	cmp.w	r9, #1
 8014eca:	7015      	strb	r5, [r2, #0]
 8014ecc:	4606      	mov	r6, r0
 8014ece:	460f      	mov	r7, r1
 8014ed0:	f102 0501 	add.w	r5, r2, #1
 8014ed4:	d023      	beq.n	8014f1e <_dtoa_r+0xd1e>
 8014ed6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014ed8:	f8cd b000 	str.w	fp, [sp]
 8014edc:	444b      	add	r3, r9
 8014ede:	4698      	mov	r8, r3
 8014ee0:	46a9      	mov	r9, r5
 8014ee2:	46ab      	mov	fp, r5
 8014ee4:	2200      	movs	r2, #0
 8014ee6:	4b47      	ldr	r3, [pc, #284]	; (8015004 <_dtoa_r+0xe04>)
 8014ee8:	f7f7 faea 	bl	800c4c0 <__aeabi_dmul>
 8014eec:	460f      	mov	r7, r1
 8014eee:	4606      	mov	r6, r0
 8014ef0:	f7f7 fcfe 	bl	800c8f0 <__aeabi_d2iz>
 8014ef4:	4605      	mov	r5, r0
 8014ef6:	f7f7 fa7d 	bl	800c3f4 <__aeabi_i2d>
 8014efa:	3530      	adds	r5, #48	; 0x30
 8014efc:	4602      	mov	r2, r0
 8014efe:	460b      	mov	r3, r1
 8014f00:	4630      	mov	r0, r6
 8014f02:	4639      	mov	r1, r7
 8014f04:	f7f7 f928 	bl	800c158 <__aeabi_dsub>
 8014f08:	f809 5b01 	strb.w	r5, [r9], #1
 8014f0c:	45c1      	cmp	r9, r8
 8014f0e:	d1e9      	bne.n	8014ee4 <_dtoa_r+0xce4>
 8014f10:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8014f12:	465d      	mov	r5, fp
 8014f14:	f8dd b000 	ldr.w	fp, [sp]
 8014f18:	4606      	mov	r6, r0
 8014f1a:	460f      	mov	r7, r1
 8014f1c:	441d      	add	r5, r3
 8014f1e:	2200      	movs	r2, #0
 8014f20:	4b39      	ldr	r3, [pc, #228]	; (8015008 <_dtoa_r+0xe08>)
 8014f22:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 8014f26:	f7f7 f919 	bl	800c15c <__adddf3>
 8014f2a:	4632      	mov	r2, r6
 8014f2c:	463b      	mov	r3, r7
 8014f2e:	f7f7 fe07 	bl	800cb40 <__aeabi_dcmplt>
 8014f32:	2800      	cmp	r0, #0
 8014f34:	d047      	beq.n	8014fc6 <_dtoa_r+0xdc6>
 8014f36:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8014f38:	9305      	str	r3, [sp, #20]
 8014f3a:	f815 8c01 	ldrb.w	r8, [r5, #-1]
 8014f3e:	f7ff bb24 	b.w	801458a <_dtoa_r+0x38a>
 8014f42:	9b07      	ldr	r3, [sp, #28]
 8014f44:	9a08      	ldr	r2, [sp, #32]
 8014f46:	1a9d      	subs	r5, r3, r2
 8014f48:	2300      	movs	r3, #0
 8014f4a:	f7ff bb58 	b.w	80145fe <_dtoa_r+0x3fe>
 8014f4e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8014f50:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8014f52:	9d07      	ldr	r5, [sp, #28]
 8014f54:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 8014f58:	f7ff bb51 	b.w	80145fe <_dtoa_r+0x3fe>
 8014f5c:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 8014f60:	f04f 0802 	mov.w	r8, #2
 8014f64:	ed8d 7b00 	vstr	d7, [sp]
 8014f68:	e546      	b.n	80149f8 <_dtoa_r+0x7f8>
 8014f6a:	9b08      	ldr	r3, [sp, #32]
 8014f6c:	2b00      	cmp	r3, #0
 8014f6e:	f43f aeb4 	beq.w	8014cda <_dtoa_r+0xada>
 8014f72:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8014f74:	2d00      	cmp	r5, #0
 8014f76:	f77f af29 	ble.w	8014dcc <_dtoa_r+0xbcc>
 8014f7a:	2200      	movs	r2, #0
 8014f7c:	4b21      	ldr	r3, [pc, #132]	; (8015004 <_dtoa_r+0xe04>)
 8014f7e:	e9dd 0100 	ldrd	r0, r1, [sp]
 8014f82:	f7f7 fa9d 	bl	800c4c0 <__aeabi_dmul>
 8014f86:	4606      	mov	r6, r0
 8014f88:	460f      	mov	r7, r1
 8014f8a:	f108 0001 	add.w	r0, r8, #1
 8014f8e:	e9cd 6700 	strd	r6, r7, [sp]
 8014f92:	f7f7 fa2f 	bl	800c3f4 <__aeabi_i2d>
 8014f96:	4602      	mov	r2, r0
 8014f98:	460b      	mov	r3, r1
 8014f9a:	4630      	mov	r0, r6
 8014f9c:	4639      	mov	r1, r7
 8014f9e:	f7f7 fa8f 	bl	800c4c0 <__aeabi_dmul>
 8014fa2:	4b14      	ldr	r3, [pc, #80]	; (8014ff4 <_dtoa_r+0xdf4>)
 8014fa4:	2200      	movs	r2, #0
 8014fa6:	f7f7 f8d9 	bl	800c15c <__adddf3>
 8014faa:	9b05      	ldr	r3, [sp, #20]
 8014fac:	3b01      	subs	r3, #1
 8014fae:	4606      	mov	r6, r0
 8014fb0:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 8014fb4:	9314      	str	r3, [sp, #80]	; 0x50
 8014fb6:	46a9      	mov	r9, r5
 8014fb8:	e53f      	b.n	8014a3a <_dtoa_r+0x83a>
 8014fba:	2239      	movs	r2, #57	; 0x39
 8014fbc:	46b2      	mov	sl, r6
 8014fbe:	703a      	strb	r2, [r7, #0]
 8014fc0:	464e      	mov	r6, r9
 8014fc2:	1c7d      	adds	r5, r7, #1
 8014fc4:	e403      	b.n	80147ce <_dtoa_r+0x5ce>
 8014fc6:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8014fca:	2000      	movs	r0, #0
 8014fcc:	490e      	ldr	r1, [pc, #56]	; (8015008 <_dtoa_r+0xe08>)
 8014fce:	f7f7 f8c3 	bl	800c158 <__aeabi_dsub>
 8014fd2:	4632      	mov	r2, r6
 8014fd4:	463b      	mov	r3, r7
 8014fd6:	f7f7 fdd1 	bl	800cb7c <__aeabi_dcmpgt>
 8014fda:	b908      	cbnz	r0, 8014fe0 <_dtoa_r+0xde0>
 8014fdc:	e6f6      	b.n	8014dcc <_dtoa_r+0xbcc>
 8014fde:	4615      	mov	r5, r2
 8014fe0:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8014fe4:	2b30      	cmp	r3, #48	; 0x30
 8014fe6:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
 8014fea:	d0f8      	beq.n	8014fde <_dtoa_r+0xdde>
 8014fec:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8014fee:	9305      	str	r3, [sp, #20]
 8014ff0:	f7ff badd 	b.w	80145ae <_dtoa_r+0x3ae>
 8014ff4:	401c0000 	.word	0x401c0000
 8014ff8:	40140000 	.word	0x40140000
 8014ffc:	08017030 	.word	0x08017030
 8015000:	08017110 	.word	0x08017110
 8015004:	40240000 	.word	0x40240000
 8015008:	3fe00000 	.word	0x3fe00000
 801500c:	4643      	mov	r3, r8
 801500e:	f8dd b000 	ldr.w	fp, [sp]
 8015012:	46a0      	mov	r8, r4
 8015014:	461c      	mov	r4, r3
 8015016:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8015018:	9305      	str	r3, [sp, #20]
 801501a:	f7ff bab6 	b.w	801458a <_dtoa_r+0x38a>
 801501e:	46b9      	mov	r9, r7
 8015020:	f7ff bb6b 	b.w	80146fa <_dtoa_r+0x4fa>
 8015024:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
 8015028:	d0c7      	beq.n	8014fba <_dtoa_r+0xdba>
 801502a:	f1ba 0f00 	cmp.w	sl, #0
 801502e:	f77f aeb5 	ble.w	8014d9c <_dtoa_r+0xb9c>
 8015032:	f105 0c31 	add.w	ip, r5, #49	; 0x31
 8015036:	e6b1      	b.n	8014d9c <_dtoa_r+0xb9c>
 8015038:	f47f aeb0 	bne.w	8014d9c <_dtoa_r+0xb9c>
 801503c:	f01c 0f01 	tst.w	ip, #1
 8015040:	f43f aeac 	beq.w	8014d9c <_dtoa_r+0xb9c>
 8015044:	e6a4      	b.n	8014d90 <_dtoa_r+0xb90>
 8015046:	9b03      	ldr	r3, [sp, #12]
 8015048:	2b02      	cmp	r3, #2
 801504a:	dc04      	bgt.n	8015056 <_dtoa_r+0xe56>
 801504c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801504e:	e605      	b.n	8014c5c <_dtoa_r+0xa5c>
 8015050:	f04f 0802 	mov.w	r8, #2
 8015054:	e4d0      	b.n	80149f8 <_dtoa_r+0x7f8>
 8015056:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8015058:	9308      	str	r3, [sp, #32]
 801505a:	e61b      	b.n	8014c94 <_dtoa_r+0xa94>
 801505c:	9b03      	ldr	r3, [sp, #12]
 801505e:	2b02      	cmp	r3, #2
 8015060:	dcf9      	bgt.n	8015056 <_dtoa_r+0xe56>
 8015062:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8015064:	f7ff bbef 	b.w	8014846 <_dtoa_r+0x646>
 8015068:	2500      	movs	r5, #0
 801506a:	6465      	str	r5, [r4, #68]	; 0x44
 801506c:	4629      	mov	r1, r5
 801506e:	4620      	mov	r0, r4
 8015070:	f000 fb1e 	bl	80156b0 <_Balloc>
 8015074:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8015078:	9308      	str	r3, [sp, #32]
 801507a:	930e      	str	r3, [sp, #56]	; 0x38
 801507c:	2301      	movs	r3, #1
 801507e:	9009      	str	r0, [sp, #36]	; 0x24
 8015080:	46aa      	mov	sl, r5
 8015082:	6420      	str	r0, [r4, #64]	; 0x40
 8015084:	930b      	str	r3, [sp, #44]	; 0x2c
 8015086:	f7ff b9ce 	b.w	8014426 <_dtoa_r+0x226>
 801508a:	f43f ab4e 	beq.w	801472a <_dtoa_r+0x52a>
 801508e:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
 8015092:	f7ff bb43 	b.w	801471c <_dtoa_r+0x51c>
 8015096:	2301      	movs	r3, #1
 8015098:	930b      	str	r3, [sp, #44]	; 0x2c
 801509a:	e55c      	b.n	8014b56 <_dtoa_r+0x956>
 801509c:	2701      	movs	r7, #1
 801509e:	f7ff b98d 	b.w	80143bc <_dtoa_r+0x1bc>
 80150a2:	bf00      	nop
	...

080150b0 <_localeconv_r>:
 80150b0:	4800      	ldr	r0, [pc, #0]	; (80150b4 <_localeconv_r+0x4>)
 80150b2:	4770      	bx	lr
 80150b4:	20000c6c 	.word	0x20000c6c
	...

080150c0 <_malloc_r>:
 80150c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80150c4:	f101 050b 	add.w	r5, r1, #11
 80150c8:	2d16      	cmp	r5, #22
 80150ca:	b083      	sub	sp, #12
 80150cc:	4606      	mov	r6, r0
 80150ce:	d927      	bls.n	8015120 <_malloc_r+0x60>
 80150d0:	f035 0507 	bics.w	r5, r5, #7
 80150d4:	f100 80b6 	bmi.w	8015244 <_malloc_r+0x184>
 80150d8:	42a9      	cmp	r1, r5
 80150da:	f200 80b3 	bhi.w	8015244 <_malloc_r+0x184>
 80150de:	f000 fad7 	bl	8015690 <__malloc_lock>
 80150e2:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 80150e6:	d222      	bcs.n	801512e <_malloc_r+0x6e>
 80150e8:	4fc2      	ldr	r7, [pc, #776]	; (80153f4 <_malloc_r+0x334>)
 80150ea:	08e8      	lsrs	r0, r5, #3
 80150ec:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
 80150f0:	68dc      	ldr	r4, [r3, #12]
 80150f2:	429c      	cmp	r4, r3
 80150f4:	f000 81c8 	beq.w	8015488 <_malloc_r+0x3c8>
 80150f8:	6863      	ldr	r3, [r4, #4]
 80150fa:	68e1      	ldr	r1, [r4, #12]
 80150fc:	68a5      	ldr	r5, [r4, #8]
 80150fe:	f023 0303 	bic.w	r3, r3, #3
 8015102:	4423      	add	r3, r4
 8015104:	4630      	mov	r0, r6
 8015106:	685a      	ldr	r2, [r3, #4]
 8015108:	60e9      	str	r1, [r5, #12]
 801510a:	f042 0201 	orr.w	r2, r2, #1
 801510e:	608d      	str	r5, [r1, #8]
 8015110:	605a      	str	r2, [r3, #4]
 8015112:	f000 fac5 	bl	80156a0 <__malloc_unlock>
 8015116:	3408      	adds	r4, #8
 8015118:	4620      	mov	r0, r4
 801511a:	b003      	add	sp, #12
 801511c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015120:	2910      	cmp	r1, #16
 8015122:	f200 808f 	bhi.w	8015244 <_malloc_r+0x184>
 8015126:	f000 fab3 	bl	8015690 <__malloc_lock>
 801512a:	2510      	movs	r5, #16
 801512c:	e7dc      	b.n	80150e8 <_malloc_r+0x28>
 801512e:	0a68      	lsrs	r0, r5, #9
 8015130:	f000 808f 	beq.w	8015252 <_malloc_r+0x192>
 8015134:	2804      	cmp	r0, #4
 8015136:	f200 8154 	bhi.w	80153e2 <_malloc_r+0x322>
 801513a:	09a8      	lsrs	r0, r5, #6
 801513c:	3038      	adds	r0, #56	; 0x38
 801513e:	0041      	lsls	r1, r0, #1
 8015140:	4fac      	ldr	r7, [pc, #688]	; (80153f4 <_malloc_r+0x334>)
 8015142:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8015146:	68cc      	ldr	r4, [r1, #12]
 8015148:	42a1      	cmp	r1, r4
 801514a:	d106      	bne.n	801515a <_malloc_r+0x9a>
 801514c:	e00c      	b.n	8015168 <_malloc_r+0xa8>
 801514e:	2a00      	cmp	r2, #0
 8015150:	f280 8082 	bge.w	8015258 <_malloc_r+0x198>
 8015154:	68e4      	ldr	r4, [r4, #12]
 8015156:	42a1      	cmp	r1, r4
 8015158:	d006      	beq.n	8015168 <_malloc_r+0xa8>
 801515a:	6863      	ldr	r3, [r4, #4]
 801515c:	f023 0303 	bic.w	r3, r3, #3
 8015160:	1b5a      	subs	r2, r3, r5
 8015162:	2a0f      	cmp	r2, #15
 8015164:	ddf3      	ble.n	801514e <_malloc_r+0x8e>
 8015166:	3801      	subs	r0, #1
 8015168:	3001      	adds	r0, #1
 801516a:	49a2      	ldr	r1, [pc, #648]	; (80153f4 <_malloc_r+0x334>)
 801516c:	693c      	ldr	r4, [r7, #16]
 801516e:	f101 0e08 	add.w	lr, r1, #8
 8015172:	4574      	cmp	r4, lr
 8015174:	f000 817d 	beq.w	8015472 <_malloc_r+0x3b2>
 8015178:	6863      	ldr	r3, [r4, #4]
 801517a:	f023 0303 	bic.w	r3, r3, #3
 801517e:	1b5a      	subs	r2, r3, r5
 8015180:	2a0f      	cmp	r2, #15
 8015182:	f300 8163 	bgt.w	801544c <_malloc_r+0x38c>
 8015186:	2a00      	cmp	r2, #0
 8015188:	f8c1 e014 	str.w	lr, [r1, #20]
 801518c:	f8c1 e010 	str.w	lr, [r1, #16]
 8015190:	da73      	bge.n	801527a <_malloc_r+0x1ba>
 8015192:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8015196:	f080 8139 	bcs.w	801540c <_malloc_r+0x34c>
 801519a:	08db      	lsrs	r3, r3, #3
 801519c:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
 80151a0:	ea4f 0ca3 	mov.w	ip, r3, asr #2
 80151a4:	684a      	ldr	r2, [r1, #4]
 80151a6:	f8d8 9008 	ldr.w	r9, [r8, #8]
 80151aa:	f8c4 9008 	str.w	r9, [r4, #8]
 80151ae:	2301      	movs	r3, #1
 80151b0:	fa03 f30c 	lsl.w	r3, r3, ip
 80151b4:	4313      	orrs	r3, r2
 80151b6:	f8c4 800c 	str.w	r8, [r4, #12]
 80151ba:	604b      	str	r3, [r1, #4]
 80151bc:	f8c8 4008 	str.w	r4, [r8, #8]
 80151c0:	f8c9 400c 	str.w	r4, [r9, #12]
 80151c4:	1082      	asrs	r2, r0, #2
 80151c6:	2401      	movs	r4, #1
 80151c8:	4094      	lsls	r4, r2
 80151ca:	429c      	cmp	r4, r3
 80151cc:	d862      	bhi.n	8015294 <_malloc_r+0x1d4>
 80151ce:	4223      	tst	r3, r4
 80151d0:	d106      	bne.n	80151e0 <_malloc_r+0x120>
 80151d2:	f020 0003 	bic.w	r0, r0, #3
 80151d6:	0064      	lsls	r4, r4, #1
 80151d8:	4223      	tst	r3, r4
 80151da:	f100 0004 	add.w	r0, r0, #4
 80151de:	d0fa      	beq.n	80151d6 <_malloc_r+0x116>
 80151e0:	eb07 08c0 	add.w	r8, r7, r0, lsl #3
 80151e4:	46c4      	mov	ip, r8
 80151e6:	4681      	mov	r9, r0
 80151e8:	f8dc 300c 	ldr.w	r3, [ip, #12]
 80151ec:	459c      	cmp	ip, r3
 80151ee:	d107      	bne.n	8015200 <_malloc_r+0x140>
 80151f0:	e141      	b.n	8015476 <_malloc_r+0x3b6>
 80151f2:	2900      	cmp	r1, #0
 80151f4:	f280 8151 	bge.w	801549a <_malloc_r+0x3da>
 80151f8:	68db      	ldr	r3, [r3, #12]
 80151fa:	459c      	cmp	ip, r3
 80151fc:	f000 813b 	beq.w	8015476 <_malloc_r+0x3b6>
 8015200:	685a      	ldr	r2, [r3, #4]
 8015202:	f022 0203 	bic.w	r2, r2, #3
 8015206:	1b51      	subs	r1, r2, r5
 8015208:	290f      	cmp	r1, #15
 801520a:	ddf2      	ble.n	80151f2 <_malloc_r+0x132>
 801520c:	461c      	mov	r4, r3
 801520e:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8015212:	f854 8f08 	ldr.w	r8, [r4, #8]!
 8015216:	195a      	adds	r2, r3, r5
 8015218:	f045 0901 	orr.w	r9, r5, #1
 801521c:	f041 0501 	orr.w	r5, r1, #1
 8015220:	f8c3 9004 	str.w	r9, [r3, #4]
 8015224:	4630      	mov	r0, r6
 8015226:	f8c8 c00c 	str.w	ip, [r8, #12]
 801522a:	f8cc 8008 	str.w	r8, [ip, #8]
 801522e:	617a      	str	r2, [r7, #20]
 8015230:	613a      	str	r2, [r7, #16]
 8015232:	f8c2 e00c 	str.w	lr, [r2, #12]
 8015236:	f8c2 e008 	str.w	lr, [r2, #8]
 801523a:	6055      	str	r5, [r2, #4]
 801523c:	5051      	str	r1, [r2, r1]
 801523e:	f000 fa2f 	bl	80156a0 <__malloc_unlock>
 8015242:	e769      	b.n	8015118 <_malloc_r+0x58>
 8015244:	2400      	movs	r4, #0
 8015246:	230c      	movs	r3, #12
 8015248:	4620      	mov	r0, r4
 801524a:	6033      	str	r3, [r6, #0]
 801524c:	b003      	add	sp, #12
 801524e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015252:	217e      	movs	r1, #126	; 0x7e
 8015254:	203f      	movs	r0, #63	; 0x3f
 8015256:	e773      	b.n	8015140 <_malloc_r+0x80>
 8015258:	4423      	add	r3, r4
 801525a:	68e1      	ldr	r1, [r4, #12]
 801525c:	685a      	ldr	r2, [r3, #4]
 801525e:	68a5      	ldr	r5, [r4, #8]
 8015260:	f042 0201 	orr.w	r2, r2, #1
 8015264:	60e9      	str	r1, [r5, #12]
 8015266:	4630      	mov	r0, r6
 8015268:	608d      	str	r5, [r1, #8]
 801526a:	605a      	str	r2, [r3, #4]
 801526c:	f000 fa18 	bl	80156a0 <__malloc_unlock>
 8015270:	3408      	adds	r4, #8
 8015272:	4620      	mov	r0, r4
 8015274:	b003      	add	sp, #12
 8015276:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801527a:	4423      	add	r3, r4
 801527c:	4630      	mov	r0, r6
 801527e:	685a      	ldr	r2, [r3, #4]
 8015280:	f042 0201 	orr.w	r2, r2, #1
 8015284:	605a      	str	r2, [r3, #4]
 8015286:	f000 fa0b 	bl	80156a0 <__malloc_unlock>
 801528a:	3408      	adds	r4, #8
 801528c:	4620      	mov	r0, r4
 801528e:	b003      	add	sp, #12
 8015290:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015294:	68bc      	ldr	r4, [r7, #8]
 8015296:	6863      	ldr	r3, [r4, #4]
 8015298:	f023 0803 	bic.w	r8, r3, #3
 801529c:	4545      	cmp	r5, r8
 801529e:	d804      	bhi.n	80152aa <_malloc_r+0x1ea>
 80152a0:	ebc5 0308 	rsb	r3, r5, r8
 80152a4:	2b0f      	cmp	r3, #15
 80152a6:	f300 808c 	bgt.w	80153c2 <_malloc_r+0x302>
 80152aa:	4b53      	ldr	r3, [pc, #332]	; (80153f8 <_malloc_r+0x338>)
 80152ac:	f8df a158 	ldr.w	sl, [pc, #344]	; 8015408 <_malloc_r+0x348>
 80152b0:	681a      	ldr	r2, [r3, #0]
 80152b2:	f8da 3000 	ldr.w	r3, [sl]
 80152b6:	3301      	adds	r3, #1
 80152b8:	442a      	add	r2, r5
 80152ba:	eb04 0b08 	add.w	fp, r4, r8
 80152be:	f000 8150 	beq.w	8015562 <_malloc_r+0x4a2>
 80152c2:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 80152c6:	320f      	adds	r2, #15
 80152c8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 80152cc:	f022 020f 	bic.w	r2, r2, #15
 80152d0:	4611      	mov	r1, r2
 80152d2:	4630      	mov	r0, r6
 80152d4:	9201      	str	r2, [sp, #4]
 80152d6:	f7fb fea3 	bl	8011020 <_sbrk_r>
 80152da:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 80152de:	4681      	mov	r9, r0
 80152e0:	9a01      	ldr	r2, [sp, #4]
 80152e2:	f000 8147 	beq.w	8015574 <_malloc_r+0x4b4>
 80152e6:	4583      	cmp	fp, r0
 80152e8:	f200 80ee 	bhi.w	80154c8 <_malloc_r+0x408>
 80152ec:	4b43      	ldr	r3, [pc, #268]	; (80153fc <_malloc_r+0x33c>)
 80152ee:	6819      	ldr	r1, [r3, #0]
 80152f0:	45cb      	cmp	fp, r9
 80152f2:	4411      	add	r1, r2
 80152f4:	6019      	str	r1, [r3, #0]
 80152f6:	f000 8142 	beq.w	801557e <_malloc_r+0x4be>
 80152fa:	f8da 0000 	ldr.w	r0, [sl]
 80152fe:	f8df e108 	ldr.w	lr, [pc, #264]	; 8015408 <_malloc_r+0x348>
 8015302:	3001      	adds	r0, #1
 8015304:	bf1b      	ittet	ne
 8015306:	ebcb 0b09 	rsbne	fp, fp, r9
 801530a:	4459      	addne	r1, fp
 801530c:	f8ce 9000 	streq.w	r9, [lr]
 8015310:	6019      	strne	r1, [r3, #0]
 8015312:	f019 0107 	ands.w	r1, r9, #7
 8015316:	f000 8107 	beq.w	8015528 <_malloc_r+0x468>
 801531a:	f1c1 0008 	rsb	r0, r1, #8
 801531e:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
 8015322:	4481      	add	r9, r0
 8015324:	3108      	adds	r1, #8
 8015326:	444a      	add	r2, r9
 8015328:	f3c2 020b 	ubfx	r2, r2, #0, #12
 801532c:	ebc2 0a01 	rsb	sl, r2, r1
 8015330:	4651      	mov	r1, sl
 8015332:	4630      	mov	r0, r6
 8015334:	9301      	str	r3, [sp, #4]
 8015336:	f7fb fe73 	bl	8011020 <_sbrk_r>
 801533a:	1c43      	adds	r3, r0, #1
 801533c:	9b01      	ldr	r3, [sp, #4]
 801533e:	f000 812c 	beq.w	801559a <_malloc_r+0x4da>
 8015342:	ebc9 0200 	rsb	r2, r9, r0
 8015346:	4452      	add	r2, sl
 8015348:	f042 0201 	orr.w	r2, r2, #1
 801534c:	6819      	ldr	r1, [r3, #0]
 801534e:	f8c7 9008 	str.w	r9, [r7, #8]
 8015352:	4451      	add	r1, sl
 8015354:	42bc      	cmp	r4, r7
 8015356:	f8c9 2004 	str.w	r2, [r9, #4]
 801535a:	6019      	str	r1, [r3, #0]
 801535c:	f8df a09c 	ldr.w	sl, [pc, #156]	; 80153fc <_malloc_r+0x33c>
 8015360:	d016      	beq.n	8015390 <_malloc_r+0x2d0>
 8015362:	f1b8 0f0f 	cmp.w	r8, #15
 8015366:	f240 80ee 	bls.w	8015546 <_malloc_r+0x486>
 801536a:	6862      	ldr	r2, [r4, #4]
 801536c:	f1a8 030c 	sub.w	r3, r8, #12
 8015370:	f023 0307 	bic.w	r3, r3, #7
 8015374:	18e0      	adds	r0, r4, r3
 8015376:	f002 0201 	and.w	r2, r2, #1
 801537a:	f04f 0e05 	mov.w	lr, #5
 801537e:	431a      	orrs	r2, r3
 8015380:	2b0f      	cmp	r3, #15
 8015382:	6062      	str	r2, [r4, #4]
 8015384:	f8c0 e004 	str.w	lr, [r0, #4]
 8015388:	f8c0 e008 	str.w	lr, [r0, #8]
 801538c:	f200 8109 	bhi.w	80155a2 <_malloc_r+0x4e2>
 8015390:	4b1b      	ldr	r3, [pc, #108]	; (8015400 <_malloc_r+0x340>)
 8015392:	68bc      	ldr	r4, [r7, #8]
 8015394:	681a      	ldr	r2, [r3, #0]
 8015396:	4291      	cmp	r1, r2
 8015398:	bf88      	it	hi
 801539a:	6019      	strhi	r1, [r3, #0]
 801539c:	4b19      	ldr	r3, [pc, #100]	; (8015404 <_malloc_r+0x344>)
 801539e:	681a      	ldr	r2, [r3, #0]
 80153a0:	4291      	cmp	r1, r2
 80153a2:	6862      	ldr	r2, [r4, #4]
 80153a4:	bf88      	it	hi
 80153a6:	6019      	strhi	r1, [r3, #0]
 80153a8:	f022 0203 	bic.w	r2, r2, #3
 80153ac:	4295      	cmp	r5, r2
 80153ae:	eba2 0305 	sub.w	r3, r2, r5
 80153b2:	d801      	bhi.n	80153b8 <_malloc_r+0x2f8>
 80153b4:	2b0f      	cmp	r3, #15
 80153b6:	dc04      	bgt.n	80153c2 <_malloc_r+0x302>
 80153b8:	4630      	mov	r0, r6
 80153ba:	f000 f971 	bl	80156a0 <__malloc_unlock>
 80153be:	2400      	movs	r4, #0
 80153c0:	e6aa      	b.n	8015118 <_malloc_r+0x58>
 80153c2:	1962      	adds	r2, r4, r5
 80153c4:	f043 0301 	orr.w	r3, r3, #1
 80153c8:	f045 0501 	orr.w	r5, r5, #1
 80153cc:	6065      	str	r5, [r4, #4]
 80153ce:	4630      	mov	r0, r6
 80153d0:	60ba      	str	r2, [r7, #8]
 80153d2:	6053      	str	r3, [r2, #4]
 80153d4:	f000 f964 	bl	80156a0 <__malloc_unlock>
 80153d8:	3408      	adds	r4, #8
 80153da:	4620      	mov	r0, r4
 80153dc:	b003      	add	sp, #12
 80153de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80153e2:	2814      	cmp	r0, #20
 80153e4:	d968      	bls.n	80154b8 <_malloc_r+0x3f8>
 80153e6:	2854      	cmp	r0, #84	; 0x54
 80153e8:	f200 8097 	bhi.w	801551a <_malloc_r+0x45a>
 80153ec:	0b28      	lsrs	r0, r5, #12
 80153ee:	306e      	adds	r0, #110	; 0x6e
 80153f0:	0041      	lsls	r1, r0, #1
 80153f2:	e6a5      	b.n	8015140 <_malloc_r+0x80>
 80153f4:	20000ca4 	.word	0x20000ca4
 80153f8:	20006be0 	.word	0x20006be0
 80153fc:	20006be4 	.word	0x20006be4
 8015400:	20006bdc 	.word	0x20006bdc
 8015404:	20006bd8 	.word	0x20006bd8
 8015408:	200010b0 	.word	0x200010b0
 801540c:	0a5a      	lsrs	r2, r3, #9
 801540e:	2a04      	cmp	r2, #4
 8015410:	d955      	bls.n	80154be <_malloc_r+0x3fe>
 8015412:	2a14      	cmp	r2, #20
 8015414:	f200 80a7 	bhi.w	8015566 <_malloc_r+0x4a6>
 8015418:	325b      	adds	r2, #91	; 0x5b
 801541a:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 801541e:	eb07 0c8c 	add.w	ip, r7, ip, lsl #2
 8015422:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 80155e0 <_malloc_r+0x520>
 8015426:	f8dc 1008 	ldr.w	r1, [ip, #8]
 801542a:	4561      	cmp	r1, ip
 801542c:	d07f      	beq.n	801552e <_malloc_r+0x46e>
 801542e:	684a      	ldr	r2, [r1, #4]
 8015430:	f022 0203 	bic.w	r2, r2, #3
 8015434:	4293      	cmp	r3, r2
 8015436:	d202      	bcs.n	801543e <_malloc_r+0x37e>
 8015438:	6889      	ldr	r1, [r1, #8]
 801543a:	458c      	cmp	ip, r1
 801543c:	d1f7      	bne.n	801542e <_malloc_r+0x36e>
 801543e:	68ca      	ldr	r2, [r1, #12]
 8015440:	687b      	ldr	r3, [r7, #4]
 8015442:	60e2      	str	r2, [r4, #12]
 8015444:	60a1      	str	r1, [r4, #8]
 8015446:	6094      	str	r4, [r2, #8]
 8015448:	60cc      	str	r4, [r1, #12]
 801544a:	e6bb      	b.n	80151c4 <_malloc_r+0x104>
 801544c:	1963      	adds	r3, r4, r5
 801544e:	f042 0701 	orr.w	r7, r2, #1
 8015452:	f045 0501 	orr.w	r5, r5, #1
 8015456:	6065      	str	r5, [r4, #4]
 8015458:	4630      	mov	r0, r6
 801545a:	614b      	str	r3, [r1, #20]
 801545c:	610b      	str	r3, [r1, #16]
 801545e:	f8c3 e00c 	str.w	lr, [r3, #12]
 8015462:	f8c3 e008 	str.w	lr, [r3, #8]
 8015466:	605f      	str	r7, [r3, #4]
 8015468:	509a      	str	r2, [r3, r2]
 801546a:	3408      	adds	r4, #8
 801546c:	f000 f918 	bl	80156a0 <__malloc_unlock>
 8015470:	e652      	b.n	8015118 <_malloc_r+0x58>
 8015472:	684b      	ldr	r3, [r1, #4]
 8015474:	e6a6      	b.n	80151c4 <_malloc_r+0x104>
 8015476:	f109 0901 	add.w	r9, r9, #1
 801547a:	f019 0f03 	tst.w	r9, #3
 801547e:	f10c 0c08 	add.w	ip, ip, #8
 8015482:	f47f aeb1 	bne.w	80151e8 <_malloc_r+0x128>
 8015486:	e02c      	b.n	80154e2 <_malloc_r+0x422>
 8015488:	f104 0308 	add.w	r3, r4, #8
 801548c:	6964      	ldr	r4, [r4, #20]
 801548e:	42a3      	cmp	r3, r4
 8015490:	bf08      	it	eq
 8015492:	3002      	addeq	r0, #2
 8015494:	f43f ae69 	beq.w	801516a <_malloc_r+0xaa>
 8015498:	e62e      	b.n	80150f8 <_malloc_r+0x38>
 801549a:	441a      	add	r2, r3
 801549c:	461c      	mov	r4, r3
 801549e:	6851      	ldr	r1, [r2, #4]
 80154a0:	68db      	ldr	r3, [r3, #12]
 80154a2:	f854 5f08 	ldr.w	r5, [r4, #8]!
 80154a6:	f041 0101 	orr.w	r1, r1, #1
 80154aa:	6051      	str	r1, [r2, #4]
 80154ac:	4630      	mov	r0, r6
 80154ae:	60eb      	str	r3, [r5, #12]
 80154b0:	609d      	str	r5, [r3, #8]
 80154b2:	f000 f8f5 	bl	80156a0 <__malloc_unlock>
 80154b6:	e62f      	b.n	8015118 <_malloc_r+0x58>
 80154b8:	305b      	adds	r0, #91	; 0x5b
 80154ba:	0041      	lsls	r1, r0, #1
 80154bc:	e640      	b.n	8015140 <_malloc_r+0x80>
 80154be:	099a      	lsrs	r2, r3, #6
 80154c0:	3238      	adds	r2, #56	; 0x38
 80154c2:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 80154c6:	e7aa      	b.n	801541e <_malloc_r+0x35e>
 80154c8:	42bc      	cmp	r4, r7
 80154ca:	4b45      	ldr	r3, [pc, #276]	; (80155e0 <_malloc_r+0x520>)
 80154cc:	f43f af0e 	beq.w	80152ec <_malloc_r+0x22c>
 80154d0:	689c      	ldr	r4, [r3, #8]
 80154d2:	6862      	ldr	r2, [r4, #4]
 80154d4:	f022 0203 	bic.w	r2, r2, #3
 80154d8:	e768      	b.n	80153ac <_malloc_r+0x2ec>
 80154da:	f8d8 8000 	ldr.w	r8, [r8]
 80154de:	4598      	cmp	r8, r3
 80154e0:	d17c      	bne.n	80155dc <_malloc_r+0x51c>
 80154e2:	f010 0f03 	tst.w	r0, #3
 80154e6:	f1a8 0308 	sub.w	r3, r8, #8
 80154ea:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 80154ee:	d1f4      	bne.n	80154da <_malloc_r+0x41a>
 80154f0:	687b      	ldr	r3, [r7, #4]
 80154f2:	ea23 0304 	bic.w	r3, r3, r4
 80154f6:	607b      	str	r3, [r7, #4]
 80154f8:	0064      	lsls	r4, r4, #1
 80154fa:	429c      	cmp	r4, r3
 80154fc:	f63f aeca 	bhi.w	8015294 <_malloc_r+0x1d4>
 8015500:	2c00      	cmp	r4, #0
 8015502:	f43f aec7 	beq.w	8015294 <_malloc_r+0x1d4>
 8015506:	4223      	tst	r3, r4
 8015508:	4648      	mov	r0, r9
 801550a:	f47f ae69 	bne.w	80151e0 <_malloc_r+0x120>
 801550e:	0064      	lsls	r4, r4, #1
 8015510:	4223      	tst	r3, r4
 8015512:	f100 0004 	add.w	r0, r0, #4
 8015516:	d0fa      	beq.n	801550e <_malloc_r+0x44e>
 8015518:	e662      	b.n	80151e0 <_malloc_r+0x120>
 801551a:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
 801551e:	d818      	bhi.n	8015552 <_malloc_r+0x492>
 8015520:	0be8      	lsrs	r0, r5, #15
 8015522:	3077      	adds	r0, #119	; 0x77
 8015524:	0041      	lsls	r1, r0, #1
 8015526:	e60b      	b.n	8015140 <_malloc_r+0x80>
 8015528:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 801552c:	e6fb      	b.n	8015326 <_malloc_r+0x266>
 801552e:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8015532:	1092      	asrs	r2, r2, #2
 8015534:	f04f 0c01 	mov.w	ip, #1
 8015538:	fa0c f202 	lsl.w	r2, ip, r2
 801553c:	4313      	orrs	r3, r2
 801553e:	f8c8 3004 	str.w	r3, [r8, #4]
 8015542:	460a      	mov	r2, r1
 8015544:	e77d      	b.n	8015442 <_malloc_r+0x382>
 8015546:	2301      	movs	r3, #1
 8015548:	f8c9 3004 	str.w	r3, [r9, #4]
 801554c:	464c      	mov	r4, r9
 801554e:	2200      	movs	r2, #0
 8015550:	e72c      	b.n	80153ac <_malloc_r+0x2ec>
 8015552:	f240 5354 	movw	r3, #1364	; 0x554
 8015556:	4298      	cmp	r0, r3
 8015558:	d81c      	bhi.n	8015594 <_malloc_r+0x4d4>
 801555a:	0ca8      	lsrs	r0, r5, #18
 801555c:	307c      	adds	r0, #124	; 0x7c
 801555e:	0041      	lsls	r1, r0, #1
 8015560:	e5ee      	b.n	8015140 <_malloc_r+0x80>
 8015562:	3210      	adds	r2, #16
 8015564:	e6b4      	b.n	80152d0 <_malloc_r+0x210>
 8015566:	2a54      	cmp	r2, #84	; 0x54
 8015568:	d823      	bhi.n	80155b2 <_malloc_r+0x4f2>
 801556a:	0b1a      	lsrs	r2, r3, #12
 801556c:	326e      	adds	r2, #110	; 0x6e
 801556e:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8015572:	e754      	b.n	801541e <_malloc_r+0x35e>
 8015574:	68bc      	ldr	r4, [r7, #8]
 8015576:	6862      	ldr	r2, [r4, #4]
 8015578:	f022 0203 	bic.w	r2, r2, #3
 801557c:	e716      	b.n	80153ac <_malloc_r+0x2ec>
 801557e:	f3cb 000b 	ubfx	r0, fp, #0, #12
 8015582:	2800      	cmp	r0, #0
 8015584:	f47f aeb9 	bne.w	80152fa <_malloc_r+0x23a>
 8015588:	4442      	add	r2, r8
 801558a:	68bb      	ldr	r3, [r7, #8]
 801558c:	f042 0201 	orr.w	r2, r2, #1
 8015590:	605a      	str	r2, [r3, #4]
 8015592:	e6fd      	b.n	8015390 <_malloc_r+0x2d0>
 8015594:	21fc      	movs	r1, #252	; 0xfc
 8015596:	207e      	movs	r0, #126	; 0x7e
 8015598:	e5d2      	b.n	8015140 <_malloc_r+0x80>
 801559a:	2201      	movs	r2, #1
 801559c:	f04f 0a00 	mov.w	sl, #0
 80155a0:	e6d4      	b.n	801534c <_malloc_r+0x28c>
 80155a2:	f104 0108 	add.w	r1, r4, #8
 80155a6:	4630      	mov	r0, r6
 80155a8:	f000 fd0a 	bl	8015fc0 <_free_r>
 80155ac:	f8da 1000 	ldr.w	r1, [sl]
 80155b0:	e6ee      	b.n	8015390 <_malloc_r+0x2d0>
 80155b2:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 80155b6:	d804      	bhi.n	80155c2 <_malloc_r+0x502>
 80155b8:	0bda      	lsrs	r2, r3, #15
 80155ba:	3277      	adds	r2, #119	; 0x77
 80155bc:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 80155c0:	e72d      	b.n	801541e <_malloc_r+0x35e>
 80155c2:	f240 5154 	movw	r1, #1364	; 0x554
 80155c6:	428a      	cmp	r2, r1
 80155c8:	d804      	bhi.n	80155d4 <_malloc_r+0x514>
 80155ca:	0c9a      	lsrs	r2, r3, #18
 80155cc:	327c      	adds	r2, #124	; 0x7c
 80155ce:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 80155d2:	e724      	b.n	801541e <_malloc_r+0x35e>
 80155d4:	f04f 0cfc 	mov.w	ip, #252	; 0xfc
 80155d8:	227e      	movs	r2, #126	; 0x7e
 80155da:	e720      	b.n	801541e <_malloc_r+0x35e>
 80155dc:	687b      	ldr	r3, [r7, #4]
 80155de:	e78b      	b.n	80154f8 <_malloc_r+0x438>
 80155e0:	20000ca4 	.word	0x20000ca4
	...

080155f0 <memchr>:
 80155f0:	0783      	lsls	r3, r0, #30
 80155f2:	b470      	push	{r4, r5, r6}
 80155f4:	b2c9      	uxtb	r1, r1
 80155f6:	d040      	beq.n	801567a <memchr+0x8a>
 80155f8:	1e54      	subs	r4, r2, #1
 80155fa:	2a00      	cmp	r2, #0
 80155fc:	d03f      	beq.n	801567e <memchr+0x8e>
 80155fe:	7803      	ldrb	r3, [r0, #0]
 8015600:	428b      	cmp	r3, r1
 8015602:	bf18      	it	ne
 8015604:	1c43      	addne	r3, r0, #1
 8015606:	d106      	bne.n	8015616 <memchr+0x26>
 8015608:	e01d      	b.n	8015646 <memchr+0x56>
 801560a:	b1f4      	cbz	r4, 801564a <memchr+0x5a>
 801560c:	7802      	ldrb	r2, [r0, #0]
 801560e:	428a      	cmp	r2, r1
 8015610:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 8015614:	d017      	beq.n	8015646 <memchr+0x56>
 8015616:	f013 0f03 	tst.w	r3, #3
 801561a:	4618      	mov	r0, r3
 801561c:	f103 0301 	add.w	r3, r3, #1
 8015620:	d1f3      	bne.n	801560a <memchr+0x1a>
 8015622:	2c03      	cmp	r4, #3
 8015624:	d814      	bhi.n	8015650 <memchr+0x60>
 8015626:	b184      	cbz	r4, 801564a <memchr+0x5a>
 8015628:	7803      	ldrb	r3, [r0, #0]
 801562a:	428b      	cmp	r3, r1
 801562c:	d00b      	beq.n	8015646 <memchr+0x56>
 801562e:	1905      	adds	r5, r0, r4
 8015630:	1c43      	adds	r3, r0, #1
 8015632:	e002      	b.n	801563a <memchr+0x4a>
 8015634:	7802      	ldrb	r2, [r0, #0]
 8015636:	428a      	cmp	r2, r1
 8015638:	d005      	beq.n	8015646 <memchr+0x56>
 801563a:	42ab      	cmp	r3, r5
 801563c:	4618      	mov	r0, r3
 801563e:	f103 0301 	add.w	r3, r3, #1
 8015642:	d1f7      	bne.n	8015634 <memchr+0x44>
 8015644:	2000      	movs	r0, #0
 8015646:	bc70      	pop	{r4, r5, r6}
 8015648:	4770      	bx	lr
 801564a:	4620      	mov	r0, r4
 801564c:	bc70      	pop	{r4, r5, r6}
 801564e:	4770      	bx	lr
 8015650:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8015654:	4602      	mov	r2, r0
 8015656:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 801565a:	4610      	mov	r0, r2
 801565c:	3204      	adds	r2, #4
 801565e:	6803      	ldr	r3, [r0, #0]
 8015660:	4073      	eors	r3, r6
 8015662:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 8015666:	ea25 0303 	bic.w	r3, r5, r3
 801566a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 801566e:	d1da      	bne.n	8015626 <memchr+0x36>
 8015670:	3c04      	subs	r4, #4
 8015672:	2c03      	cmp	r4, #3
 8015674:	4610      	mov	r0, r2
 8015676:	d8f0      	bhi.n	801565a <memchr+0x6a>
 8015678:	e7d5      	b.n	8015626 <memchr+0x36>
 801567a:	4614      	mov	r4, r2
 801567c:	e7d1      	b.n	8015622 <memchr+0x32>
 801567e:	4610      	mov	r0, r2
 8015680:	e7e1      	b.n	8015646 <memchr+0x56>
 8015682:	bf00      	nop
	...

08015690 <__malloc_lock>:
 8015690:	4770      	bx	lr
 8015692:	bf00      	nop
	...

080156a0 <__malloc_unlock>:
 80156a0:	4770      	bx	lr
 80156a2:	bf00      	nop
	...

080156b0 <_Balloc>:
 80156b0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80156b2:	b570      	push	{r4, r5, r6, lr}
 80156b4:	4605      	mov	r5, r0
 80156b6:	460c      	mov	r4, r1
 80156b8:	b14b      	cbz	r3, 80156ce <_Balloc+0x1e>
 80156ba:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80156be:	b180      	cbz	r0, 80156e2 <_Balloc+0x32>
 80156c0:	6802      	ldr	r2, [r0, #0]
 80156c2:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 80156c6:	2300      	movs	r3, #0
 80156c8:	6103      	str	r3, [r0, #16]
 80156ca:	60c3      	str	r3, [r0, #12]
 80156cc:	bd70      	pop	{r4, r5, r6, pc}
 80156ce:	2104      	movs	r1, #4
 80156d0:	2221      	movs	r2, #33	; 0x21
 80156d2:	f000 fbf5 	bl	8015ec0 <_calloc_r>
 80156d6:	64e8      	str	r0, [r5, #76]	; 0x4c
 80156d8:	4603      	mov	r3, r0
 80156da:	2800      	cmp	r0, #0
 80156dc:	d1ed      	bne.n	80156ba <_Balloc+0xa>
 80156de:	2000      	movs	r0, #0
 80156e0:	bd70      	pop	{r4, r5, r6, pc}
 80156e2:	2101      	movs	r1, #1
 80156e4:	fa01 f604 	lsl.w	r6, r1, r4
 80156e8:	1d72      	adds	r2, r6, #5
 80156ea:	4628      	mov	r0, r5
 80156ec:	0092      	lsls	r2, r2, #2
 80156ee:	f000 fbe7 	bl	8015ec0 <_calloc_r>
 80156f2:	2800      	cmp	r0, #0
 80156f4:	d0f3      	beq.n	80156de <_Balloc+0x2e>
 80156f6:	6044      	str	r4, [r0, #4]
 80156f8:	6086      	str	r6, [r0, #8]
 80156fa:	e7e4      	b.n	80156c6 <_Balloc+0x16>
 80156fc:	0000      	movs	r0, r0
	...

08015700 <_Bfree>:
 8015700:	b131      	cbz	r1, 8015710 <_Bfree+0x10>
 8015702:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8015704:	684a      	ldr	r2, [r1, #4]
 8015706:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 801570a:	6008      	str	r0, [r1, #0]
 801570c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8015710:	4770      	bx	lr
 8015712:	bf00      	nop
	...

08015720 <__multadd>:
 8015720:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015722:	690c      	ldr	r4, [r1, #16]
 8015724:	b083      	sub	sp, #12
 8015726:	460d      	mov	r5, r1
 8015728:	4606      	mov	r6, r0
 801572a:	f101 0e14 	add.w	lr, r1, #20
 801572e:	2700      	movs	r7, #0
 8015730:	f8de 1000 	ldr.w	r1, [lr]
 8015734:	b288      	uxth	r0, r1
 8015736:	0c09      	lsrs	r1, r1, #16
 8015738:	fb02 3300 	mla	r3, r2, r0, r3
 801573c:	fb02 f101 	mul.w	r1, r2, r1
 8015740:	eb01 4113 	add.w	r1, r1, r3, lsr #16
 8015744:	3701      	adds	r7, #1
 8015746:	b29b      	uxth	r3, r3
 8015748:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 801574c:	42bc      	cmp	r4, r7
 801574e:	f84e 3b04 	str.w	r3, [lr], #4
 8015752:	ea4f 4311 	mov.w	r3, r1, lsr #16
 8015756:	dceb      	bgt.n	8015730 <__multadd+0x10>
 8015758:	b13b      	cbz	r3, 801576a <__multadd+0x4a>
 801575a:	68aa      	ldr	r2, [r5, #8]
 801575c:	4294      	cmp	r4, r2
 801575e:	da07      	bge.n	8015770 <__multadd+0x50>
 8015760:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 8015764:	3401      	adds	r4, #1
 8015766:	6153      	str	r3, [r2, #20]
 8015768:	612c      	str	r4, [r5, #16]
 801576a:	4628      	mov	r0, r5
 801576c:	b003      	add	sp, #12
 801576e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015770:	6869      	ldr	r1, [r5, #4]
 8015772:	9301      	str	r3, [sp, #4]
 8015774:	3101      	adds	r1, #1
 8015776:	4630      	mov	r0, r6
 8015778:	f7ff ff9a 	bl	80156b0 <_Balloc>
 801577c:	692a      	ldr	r2, [r5, #16]
 801577e:	3202      	adds	r2, #2
 8015780:	f105 010c 	add.w	r1, r5, #12
 8015784:	4607      	mov	r7, r0
 8015786:	0092      	lsls	r2, r2, #2
 8015788:	300c      	adds	r0, #12
 801578a:	f7f7 f8d9 	bl	800c940 <memcpy>
 801578e:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 8015790:	6869      	ldr	r1, [r5, #4]
 8015792:	9b01      	ldr	r3, [sp, #4]
 8015794:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 8015798:	6028      	str	r0, [r5, #0]
 801579a:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 801579e:	463d      	mov	r5, r7
 80157a0:	e7de      	b.n	8015760 <__multadd+0x40>
 80157a2:	bf00      	nop
	...

080157b0 <__hi0bits>:
 80157b0:	0c03      	lsrs	r3, r0, #16
 80157b2:	041b      	lsls	r3, r3, #16
 80157b4:	b9b3      	cbnz	r3, 80157e4 <__hi0bits+0x34>
 80157b6:	0400      	lsls	r0, r0, #16
 80157b8:	2310      	movs	r3, #16
 80157ba:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 80157be:	bf04      	itt	eq
 80157c0:	0200      	lsleq	r0, r0, #8
 80157c2:	3308      	addeq	r3, #8
 80157c4:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 80157c8:	bf04      	itt	eq
 80157ca:	0100      	lsleq	r0, r0, #4
 80157cc:	3304      	addeq	r3, #4
 80157ce:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 80157d2:	bf04      	itt	eq
 80157d4:	0080      	lsleq	r0, r0, #2
 80157d6:	3302      	addeq	r3, #2
 80157d8:	2800      	cmp	r0, #0
 80157da:	db07      	blt.n	80157ec <__hi0bits+0x3c>
 80157dc:	0042      	lsls	r2, r0, #1
 80157de:	d403      	bmi.n	80157e8 <__hi0bits+0x38>
 80157e0:	2020      	movs	r0, #32
 80157e2:	4770      	bx	lr
 80157e4:	2300      	movs	r3, #0
 80157e6:	e7e8      	b.n	80157ba <__hi0bits+0xa>
 80157e8:	1c58      	adds	r0, r3, #1
 80157ea:	4770      	bx	lr
 80157ec:	4618      	mov	r0, r3
 80157ee:	4770      	bx	lr

080157f0 <__lo0bits>:
 80157f0:	6803      	ldr	r3, [r0, #0]
 80157f2:	f013 0207 	ands.w	r2, r3, #7
 80157f6:	d007      	beq.n	8015808 <__lo0bits+0x18>
 80157f8:	07d9      	lsls	r1, r3, #31
 80157fa:	d420      	bmi.n	801583e <__lo0bits+0x4e>
 80157fc:	079a      	lsls	r2, r3, #30
 80157fe:	d420      	bmi.n	8015842 <__lo0bits+0x52>
 8015800:	089b      	lsrs	r3, r3, #2
 8015802:	6003      	str	r3, [r0, #0]
 8015804:	2002      	movs	r0, #2
 8015806:	4770      	bx	lr
 8015808:	b299      	uxth	r1, r3
 801580a:	b909      	cbnz	r1, 8015810 <__lo0bits+0x20>
 801580c:	0c1b      	lsrs	r3, r3, #16
 801580e:	2210      	movs	r2, #16
 8015810:	f013 0fff 	tst.w	r3, #255	; 0xff
 8015814:	bf04      	itt	eq
 8015816:	0a1b      	lsreq	r3, r3, #8
 8015818:	3208      	addeq	r2, #8
 801581a:	0719      	lsls	r1, r3, #28
 801581c:	bf04      	itt	eq
 801581e:	091b      	lsreq	r3, r3, #4
 8015820:	3204      	addeq	r2, #4
 8015822:	0799      	lsls	r1, r3, #30
 8015824:	bf04      	itt	eq
 8015826:	089b      	lsreq	r3, r3, #2
 8015828:	3202      	addeq	r2, #2
 801582a:	07d9      	lsls	r1, r3, #31
 801582c:	d404      	bmi.n	8015838 <__lo0bits+0x48>
 801582e:	085b      	lsrs	r3, r3, #1
 8015830:	d101      	bne.n	8015836 <__lo0bits+0x46>
 8015832:	2020      	movs	r0, #32
 8015834:	4770      	bx	lr
 8015836:	3201      	adds	r2, #1
 8015838:	6003      	str	r3, [r0, #0]
 801583a:	4610      	mov	r0, r2
 801583c:	4770      	bx	lr
 801583e:	2000      	movs	r0, #0
 8015840:	4770      	bx	lr
 8015842:	085b      	lsrs	r3, r3, #1
 8015844:	6003      	str	r3, [r0, #0]
 8015846:	2001      	movs	r0, #1
 8015848:	4770      	bx	lr
 801584a:	bf00      	nop
 801584c:	0000      	movs	r0, r0
	...

08015850 <__i2b>:
 8015850:	b510      	push	{r4, lr}
 8015852:	460c      	mov	r4, r1
 8015854:	2101      	movs	r1, #1
 8015856:	f7ff ff2b 	bl	80156b0 <_Balloc>
 801585a:	2201      	movs	r2, #1
 801585c:	6144      	str	r4, [r0, #20]
 801585e:	6102      	str	r2, [r0, #16]
 8015860:	bd10      	pop	{r4, pc}
 8015862:	bf00      	nop
	...

08015870 <__multiply>:
 8015870:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015874:	690f      	ldr	r7, [r1, #16]
 8015876:	6916      	ldr	r6, [r2, #16]
 8015878:	42b7      	cmp	r7, r6
 801587a:	b083      	sub	sp, #12
 801587c:	460d      	mov	r5, r1
 801587e:	4614      	mov	r4, r2
 8015880:	f2c0 808d 	blt.w	801599e <__multiply+0x12e>
 8015884:	4633      	mov	r3, r6
 8015886:	463e      	mov	r6, r7
 8015888:	461f      	mov	r7, r3
 801588a:	68ab      	ldr	r3, [r5, #8]
 801588c:	6869      	ldr	r1, [r5, #4]
 801588e:	eb06 0807 	add.w	r8, r6, r7
 8015892:	4598      	cmp	r8, r3
 8015894:	bfc8      	it	gt
 8015896:	3101      	addgt	r1, #1
 8015898:	f7ff ff0a 	bl	80156b0 <_Balloc>
 801589c:	f100 0c14 	add.w	ip, r0, #20
 80158a0:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
 80158a4:	45cc      	cmp	ip, r9
 80158a6:	9000      	str	r0, [sp, #0]
 80158a8:	d205      	bcs.n	80158b6 <__multiply+0x46>
 80158aa:	4663      	mov	r3, ip
 80158ac:	2100      	movs	r1, #0
 80158ae:	f843 1b04 	str.w	r1, [r3], #4
 80158b2:	4599      	cmp	r9, r3
 80158b4:	d8fb      	bhi.n	80158ae <__multiply+0x3e>
 80158b6:	f104 0214 	add.w	r2, r4, #20
 80158ba:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
 80158be:	f105 0314 	add.w	r3, r5, #20
 80158c2:	4552      	cmp	r2, sl
 80158c4:	eb03 0e86 	add.w	lr, r3, r6, lsl #2
 80158c8:	d254      	bcs.n	8015974 <__multiply+0x104>
 80158ca:	f8cd 9004 	str.w	r9, [sp, #4]
 80158ce:	4699      	mov	r9, r3
 80158d0:	f852 3b04 	ldr.w	r3, [r2], #4
 80158d4:	fa1f fb83 	uxth.w	fp, r3
 80158d8:	f1bb 0f00 	cmp.w	fp, #0
 80158dc:	d020      	beq.n	8015920 <__multiply+0xb0>
 80158de:	2000      	movs	r0, #0
 80158e0:	464f      	mov	r7, r9
 80158e2:	4666      	mov	r6, ip
 80158e4:	4605      	mov	r5, r0
 80158e6:	e000      	b.n	80158ea <__multiply+0x7a>
 80158e8:	461e      	mov	r6, r3
 80158ea:	f857 4b04 	ldr.w	r4, [r7], #4
 80158ee:	6830      	ldr	r0, [r6, #0]
 80158f0:	b2a1      	uxth	r1, r4
 80158f2:	b283      	uxth	r3, r0
 80158f4:	fb0b 3101 	mla	r1, fp, r1, r3
 80158f8:	0c24      	lsrs	r4, r4, #16
 80158fa:	0c00      	lsrs	r0, r0, #16
 80158fc:	194b      	adds	r3, r1, r5
 80158fe:	fb0b 0004 	mla	r0, fp, r4, r0
 8015902:	eb00 4013 	add.w	r0, r0, r3, lsr #16
 8015906:	b299      	uxth	r1, r3
 8015908:	4633      	mov	r3, r6
 801590a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 801590e:	45be      	cmp	lr, r7
 8015910:	ea4f 4510 	mov.w	r5, r0, lsr #16
 8015914:	f843 1b04 	str.w	r1, [r3], #4
 8015918:	d8e6      	bhi.n	80158e8 <__multiply+0x78>
 801591a:	6075      	str	r5, [r6, #4]
 801591c:	f852 3c04 	ldr.w	r3, [r2, #-4]
 8015920:	ea5f 4b13 	movs.w	fp, r3, lsr #16
 8015924:	d020      	beq.n	8015968 <__multiply+0xf8>
 8015926:	f8dc 3000 	ldr.w	r3, [ip]
 801592a:	4667      	mov	r7, ip
 801592c:	4618      	mov	r0, r3
 801592e:	464d      	mov	r5, r9
 8015930:	2100      	movs	r1, #0
 8015932:	e000      	b.n	8015936 <__multiply+0xc6>
 8015934:	4637      	mov	r7, r6
 8015936:	882c      	ldrh	r4, [r5, #0]
 8015938:	0c00      	lsrs	r0, r0, #16
 801593a:	fb0b 0004 	mla	r0, fp, r4, r0
 801593e:	4401      	add	r1, r0
 8015940:	b29c      	uxth	r4, r3
 8015942:	463e      	mov	r6, r7
 8015944:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
 8015948:	f846 3b04 	str.w	r3, [r6], #4
 801594c:	6878      	ldr	r0, [r7, #4]
 801594e:	f855 4b04 	ldr.w	r4, [r5], #4
 8015952:	b283      	uxth	r3, r0
 8015954:	0c24      	lsrs	r4, r4, #16
 8015956:	fb0b 3404 	mla	r4, fp, r4, r3
 801595a:	eb04 4311 	add.w	r3, r4, r1, lsr #16
 801595e:	45ae      	cmp	lr, r5
 8015960:	ea4f 4113 	mov.w	r1, r3, lsr #16
 8015964:	d8e6      	bhi.n	8015934 <__multiply+0xc4>
 8015966:	607b      	str	r3, [r7, #4]
 8015968:	4592      	cmp	sl, r2
 801596a:	f10c 0c04 	add.w	ip, ip, #4
 801596e:	d8af      	bhi.n	80158d0 <__multiply+0x60>
 8015970:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8015974:	f1b8 0f00 	cmp.w	r8, #0
 8015978:	dd0b      	ble.n	8015992 <__multiply+0x122>
 801597a:	f859 3c04 	ldr.w	r3, [r9, #-4]
 801597e:	f1a9 0904 	sub.w	r9, r9, #4
 8015982:	b11b      	cbz	r3, 801598c <__multiply+0x11c>
 8015984:	e005      	b.n	8015992 <__multiply+0x122>
 8015986:	f859 3d04 	ldr.w	r3, [r9, #-4]!
 801598a:	b913      	cbnz	r3, 8015992 <__multiply+0x122>
 801598c:	f1b8 0801 	subs.w	r8, r8, #1
 8015990:	d1f9      	bne.n	8015986 <__multiply+0x116>
 8015992:	9800      	ldr	r0, [sp, #0]
 8015994:	f8c0 8010 	str.w	r8, [r0, #16]
 8015998:	b003      	add	sp, #12
 801599a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801599e:	4615      	mov	r5, r2
 80159a0:	460c      	mov	r4, r1
 80159a2:	e772      	b.n	801588a <__multiply+0x1a>
	...

080159b0 <__pow5mult>:
 80159b0:	f012 0303 	ands.w	r3, r2, #3
 80159b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80159b8:	4614      	mov	r4, r2
 80159ba:	4607      	mov	r7, r0
 80159bc:	460e      	mov	r6, r1
 80159be:	d12d      	bne.n	8015a1c <__pow5mult+0x6c>
 80159c0:	10a4      	asrs	r4, r4, #2
 80159c2:	d01c      	beq.n	80159fe <__pow5mult+0x4e>
 80159c4:	6cbd      	ldr	r5, [r7, #72]	; 0x48
 80159c6:	b395      	cbz	r5, 8015a2e <__pow5mult+0x7e>
 80159c8:	07e3      	lsls	r3, r4, #31
 80159ca:	f04f 0800 	mov.w	r8, #0
 80159ce:	d406      	bmi.n	80159de <__pow5mult+0x2e>
 80159d0:	1064      	asrs	r4, r4, #1
 80159d2:	d014      	beq.n	80159fe <__pow5mult+0x4e>
 80159d4:	6828      	ldr	r0, [r5, #0]
 80159d6:	b1a8      	cbz	r0, 8015a04 <__pow5mult+0x54>
 80159d8:	4605      	mov	r5, r0
 80159da:	07e3      	lsls	r3, r4, #31
 80159dc:	d5f8      	bpl.n	80159d0 <__pow5mult+0x20>
 80159de:	4638      	mov	r0, r7
 80159e0:	4631      	mov	r1, r6
 80159e2:	462a      	mov	r2, r5
 80159e4:	f7ff ff44 	bl	8015870 <__multiply>
 80159e8:	b1b6      	cbz	r6, 8015a18 <__pow5mult+0x68>
 80159ea:	6872      	ldr	r2, [r6, #4]
 80159ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80159ee:	1064      	asrs	r4, r4, #1
 80159f0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80159f4:	6031      	str	r1, [r6, #0]
 80159f6:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 80159fa:	4606      	mov	r6, r0
 80159fc:	d1ea      	bne.n	80159d4 <__pow5mult+0x24>
 80159fe:	4630      	mov	r0, r6
 8015a00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015a04:	4629      	mov	r1, r5
 8015a06:	462a      	mov	r2, r5
 8015a08:	4638      	mov	r0, r7
 8015a0a:	f7ff ff31 	bl	8015870 <__multiply>
 8015a0e:	6028      	str	r0, [r5, #0]
 8015a10:	f8c0 8000 	str.w	r8, [r0]
 8015a14:	4605      	mov	r5, r0
 8015a16:	e7e0      	b.n	80159da <__pow5mult+0x2a>
 8015a18:	4606      	mov	r6, r0
 8015a1a:	e7d9      	b.n	80159d0 <__pow5mult+0x20>
 8015a1c:	1e5a      	subs	r2, r3, #1
 8015a1e:	4d0b      	ldr	r5, [pc, #44]	; (8015a4c <__pow5mult+0x9c>)
 8015a20:	2300      	movs	r3, #0
 8015a22:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 8015a26:	f7ff fe7b 	bl	8015720 <__multadd>
 8015a2a:	4606      	mov	r6, r0
 8015a2c:	e7c8      	b.n	80159c0 <__pow5mult+0x10>
 8015a2e:	2101      	movs	r1, #1
 8015a30:	4638      	mov	r0, r7
 8015a32:	f7ff fe3d 	bl	80156b0 <_Balloc>
 8015a36:	f240 2171 	movw	r1, #625	; 0x271
 8015a3a:	2201      	movs	r2, #1
 8015a3c:	2300      	movs	r3, #0
 8015a3e:	6141      	str	r1, [r0, #20]
 8015a40:	6102      	str	r2, [r0, #16]
 8015a42:	4605      	mov	r5, r0
 8015a44:	64b8      	str	r0, [r7, #72]	; 0x48
 8015a46:	6003      	str	r3, [r0, #0]
 8015a48:	e7be      	b.n	80159c8 <__pow5mult+0x18>
 8015a4a:	bf00      	nop
 8015a4c:	08017100 	.word	0x08017100

08015a50 <__lshift>:
 8015a50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8015a54:	690f      	ldr	r7, [r1, #16]
 8015a56:	688b      	ldr	r3, [r1, #8]
 8015a58:	ea4f 1962 	mov.w	r9, r2, asr #5
 8015a5c:	444f      	add	r7, r9
 8015a5e:	1c7d      	adds	r5, r7, #1
 8015a60:	429d      	cmp	r5, r3
 8015a62:	460e      	mov	r6, r1
 8015a64:	4614      	mov	r4, r2
 8015a66:	6849      	ldr	r1, [r1, #4]
 8015a68:	4680      	mov	r8, r0
 8015a6a:	dd04      	ble.n	8015a76 <__lshift+0x26>
 8015a6c:	005b      	lsls	r3, r3, #1
 8015a6e:	429d      	cmp	r5, r3
 8015a70:	f101 0101 	add.w	r1, r1, #1
 8015a74:	dcfa      	bgt.n	8015a6c <__lshift+0x1c>
 8015a76:	4640      	mov	r0, r8
 8015a78:	f7ff fe1a 	bl	80156b0 <_Balloc>
 8015a7c:	f1b9 0f00 	cmp.w	r9, #0
 8015a80:	f100 0114 	add.w	r1, r0, #20
 8015a84:	dd09      	ble.n	8015a9a <__lshift+0x4a>
 8015a86:	2300      	movs	r3, #0
 8015a88:	469e      	mov	lr, r3
 8015a8a:	460a      	mov	r2, r1
 8015a8c:	3301      	adds	r3, #1
 8015a8e:	454b      	cmp	r3, r9
 8015a90:	f842 eb04 	str.w	lr, [r2], #4
 8015a94:	d1fa      	bne.n	8015a8c <__lshift+0x3c>
 8015a96:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8015a9a:	6932      	ldr	r2, [r6, #16]
 8015a9c:	f106 0314 	add.w	r3, r6, #20
 8015aa0:	f014 0c1f 	ands.w	ip, r4, #31
 8015aa4:	eb03 0e82 	add.w	lr, r3, r2, lsl #2
 8015aa8:	d01f      	beq.n	8015aea <__lshift+0x9a>
 8015aaa:	f1cc 0920 	rsb	r9, ip, #32
 8015aae:	2200      	movs	r2, #0
 8015ab0:	681c      	ldr	r4, [r3, #0]
 8015ab2:	fa04 f40c 	lsl.w	r4, r4, ip
 8015ab6:	4314      	orrs	r4, r2
 8015ab8:	468a      	mov	sl, r1
 8015aba:	f841 4b04 	str.w	r4, [r1], #4
 8015abe:	f853 4b04 	ldr.w	r4, [r3], #4
 8015ac2:	459e      	cmp	lr, r3
 8015ac4:	fa24 f209 	lsr.w	r2, r4, r9
 8015ac8:	d8f2      	bhi.n	8015ab0 <__lshift+0x60>
 8015aca:	f8ca 2004 	str.w	r2, [sl, #4]
 8015ace:	b102      	cbz	r2, 8015ad2 <__lshift+0x82>
 8015ad0:	1cbd      	adds	r5, r7, #2
 8015ad2:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 8015ad6:	6872      	ldr	r2, [r6, #4]
 8015ad8:	3d01      	subs	r5, #1
 8015ada:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8015ade:	6105      	str	r5, [r0, #16]
 8015ae0:	6031      	str	r1, [r6, #0]
 8015ae2:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 8015ae6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8015aea:	3904      	subs	r1, #4
 8015aec:	f853 2b04 	ldr.w	r2, [r3], #4
 8015af0:	f841 2f04 	str.w	r2, [r1, #4]!
 8015af4:	459e      	cmp	lr, r3
 8015af6:	d8f9      	bhi.n	8015aec <__lshift+0x9c>
 8015af8:	e7eb      	b.n	8015ad2 <__lshift+0x82>
 8015afa:	bf00      	nop
 8015afc:	0000      	movs	r0, r0
	...

08015b00 <__mcmp>:
 8015b00:	6902      	ldr	r2, [r0, #16]
 8015b02:	690b      	ldr	r3, [r1, #16]
 8015b04:	1ad2      	subs	r2, r2, r3
 8015b06:	d113      	bne.n	8015b30 <__mcmp+0x30>
 8015b08:	009b      	lsls	r3, r3, #2
 8015b0a:	3014      	adds	r0, #20
 8015b0c:	3114      	adds	r1, #20
 8015b0e:	4419      	add	r1, r3
 8015b10:	b410      	push	{r4}
 8015b12:	4403      	add	r3, r0
 8015b14:	e001      	b.n	8015b1a <__mcmp+0x1a>
 8015b16:	4298      	cmp	r0, r3
 8015b18:	d20c      	bcs.n	8015b34 <__mcmp+0x34>
 8015b1a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 8015b1e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 8015b22:	4294      	cmp	r4, r2
 8015b24:	d0f7      	beq.n	8015b16 <__mcmp+0x16>
 8015b26:	d309      	bcc.n	8015b3c <__mcmp+0x3c>
 8015b28:	2001      	movs	r0, #1
 8015b2a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015b2e:	4770      	bx	lr
 8015b30:	4610      	mov	r0, r2
 8015b32:	4770      	bx	lr
 8015b34:	2000      	movs	r0, #0
 8015b36:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015b3a:	4770      	bx	lr
 8015b3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8015b40:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015b44:	4770      	bx	lr
 8015b46:	bf00      	nop
	...

08015b50 <__mdiff>:
 8015b50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015b54:	460e      	mov	r6, r1
 8015b56:	4605      	mov	r5, r0
 8015b58:	4611      	mov	r1, r2
 8015b5a:	4630      	mov	r0, r6
 8015b5c:	4614      	mov	r4, r2
 8015b5e:	f7ff ffcf 	bl	8015b00 <__mcmp>
 8015b62:	1e07      	subs	r7, r0, #0
 8015b64:	d054      	beq.n	8015c10 <__mdiff+0xc0>
 8015b66:	db4d      	blt.n	8015c04 <__mdiff+0xb4>
 8015b68:	f04f 0800 	mov.w	r8, #0
 8015b6c:	6871      	ldr	r1, [r6, #4]
 8015b6e:	4628      	mov	r0, r5
 8015b70:	f7ff fd9e 	bl	80156b0 <_Balloc>
 8015b74:	6937      	ldr	r7, [r6, #16]
 8015b76:	6923      	ldr	r3, [r4, #16]
 8015b78:	f8c0 800c 	str.w	r8, [r0, #12]
 8015b7c:	3614      	adds	r6, #20
 8015b7e:	f104 0214 	add.w	r2, r4, #20
 8015b82:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
 8015b86:	f100 0514 	add.w	r5, r0, #20
 8015b8a:	eb06 0e87 	add.w	lr, r6, r7, lsl #2
 8015b8e:	2300      	movs	r3, #0
 8015b90:	f856 8b04 	ldr.w	r8, [r6], #4
 8015b94:	f852 4b04 	ldr.w	r4, [r2], #4
 8015b98:	fa13 f388 	uxtah	r3, r3, r8
 8015b9c:	b2a1      	uxth	r1, r4
 8015b9e:	0c24      	lsrs	r4, r4, #16
 8015ba0:	1a59      	subs	r1, r3, r1
 8015ba2:	ebc4 4318 	rsb	r3, r4, r8, lsr #16
 8015ba6:	eb03 4321 	add.w	r3, r3, r1, asr #16
 8015baa:	b289      	uxth	r1, r1
 8015bac:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8015bb0:	4594      	cmp	ip, r2
 8015bb2:	f845 1b04 	str.w	r1, [r5], #4
 8015bb6:	ea4f 4323 	mov.w	r3, r3, asr #16
 8015bba:	4634      	mov	r4, r6
 8015bbc:	d8e8      	bhi.n	8015b90 <__mdiff+0x40>
 8015bbe:	45b6      	cmp	lr, r6
 8015bc0:	46ac      	mov	ip, r5
 8015bc2:	d915      	bls.n	8015bf0 <__mdiff+0xa0>
 8015bc4:	f854 2b04 	ldr.w	r2, [r4], #4
 8015bc8:	fa13 f182 	uxtah	r1, r3, r2
 8015bcc:	0c13      	lsrs	r3, r2, #16
 8015bce:	eb03 4321 	add.w	r3, r3, r1, asr #16
 8015bd2:	b289      	uxth	r1, r1
 8015bd4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8015bd8:	45a6      	cmp	lr, r4
 8015bda:	f845 1b04 	str.w	r1, [r5], #4
 8015bde:	ea4f 4323 	mov.w	r3, r3, asr #16
 8015be2:	d8ef      	bhi.n	8015bc4 <__mdiff+0x74>
 8015be4:	43f6      	mvns	r6, r6
 8015be6:	4476      	add	r6, lr
 8015be8:	f026 0503 	bic.w	r5, r6, #3
 8015bec:	3504      	adds	r5, #4
 8015bee:	4465      	add	r5, ip
 8015bf0:	3d04      	subs	r5, #4
 8015bf2:	b921      	cbnz	r1, 8015bfe <__mdiff+0xae>
 8015bf4:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8015bf8:	3f01      	subs	r7, #1
 8015bfa:	2b00      	cmp	r3, #0
 8015bfc:	d0fa      	beq.n	8015bf4 <__mdiff+0xa4>
 8015bfe:	6107      	str	r7, [r0, #16]
 8015c00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015c04:	4633      	mov	r3, r6
 8015c06:	f04f 0801 	mov.w	r8, #1
 8015c0a:	4626      	mov	r6, r4
 8015c0c:	461c      	mov	r4, r3
 8015c0e:	e7ad      	b.n	8015b6c <__mdiff+0x1c>
 8015c10:	4628      	mov	r0, r5
 8015c12:	4639      	mov	r1, r7
 8015c14:	f7ff fd4c 	bl	80156b0 <_Balloc>
 8015c18:	2301      	movs	r3, #1
 8015c1a:	6147      	str	r7, [r0, #20]
 8015c1c:	6103      	str	r3, [r0, #16]
 8015c1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015c22:	bf00      	nop
	...

08015c30 <__d2b>:
 8015c30:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8015c34:	ec57 6b10 	vmov	r6, r7, d0
 8015c38:	b083      	sub	sp, #12
 8015c3a:	4688      	mov	r8, r1
 8015c3c:	2101      	movs	r1, #1
 8015c3e:	463c      	mov	r4, r7
 8015c40:	f3c7 550a 	ubfx	r5, r7, #20, #11
 8015c44:	4617      	mov	r7, r2
 8015c46:	f7ff fd33 	bl	80156b0 <_Balloc>
 8015c4a:	f3c4 0413 	ubfx	r4, r4, #0, #20
 8015c4e:	4681      	mov	r9, r0
 8015c50:	b10d      	cbz	r5, 8015c56 <__d2b+0x26>
 8015c52:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
 8015c56:	9401      	str	r4, [sp, #4]
 8015c58:	b31e      	cbz	r6, 8015ca2 <__d2b+0x72>
 8015c5a:	a802      	add	r0, sp, #8
 8015c5c:	f840 6d08 	str.w	r6, [r0, #-8]!
 8015c60:	f7ff fdc6 	bl	80157f0 <__lo0bits>
 8015c64:	2800      	cmp	r0, #0
 8015c66:	d134      	bne.n	8015cd2 <__d2b+0xa2>
 8015c68:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8015c6c:	f8c9 2014 	str.w	r2, [r9, #20]
 8015c70:	2b00      	cmp	r3, #0
 8015c72:	bf14      	ite	ne
 8015c74:	2402      	movne	r4, #2
 8015c76:	2401      	moveq	r4, #1
 8015c78:	f8c9 3018 	str.w	r3, [r9, #24]
 8015c7c:	f8c9 4010 	str.w	r4, [r9, #16]
 8015c80:	b9dd      	cbnz	r5, 8015cba <__d2b+0x8a>
 8015c82:	eb09 0384 	add.w	r3, r9, r4, lsl #2
 8015c86:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 8015c8a:	f8c8 0000 	str.w	r0, [r8]
 8015c8e:	6918      	ldr	r0, [r3, #16]
 8015c90:	f7ff fd8e 	bl	80157b0 <__hi0bits>
 8015c94:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
 8015c98:	6038      	str	r0, [r7, #0]
 8015c9a:	4648      	mov	r0, r9
 8015c9c:	b003      	add	sp, #12
 8015c9e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8015ca2:	a801      	add	r0, sp, #4
 8015ca4:	f7ff fda4 	bl	80157f0 <__lo0bits>
 8015ca8:	2401      	movs	r4, #1
 8015caa:	9b01      	ldr	r3, [sp, #4]
 8015cac:	f8c9 3014 	str.w	r3, [r9, #20]
 8015cb0:	3020      	adds	r0, #32
 8015cb2:	f8c9 4010 	str.w	r4, [r9, #16]
 8015cb6:	2d00      	cmp	r5, #0
 8015cb8:	d0e3      	beq.n	8015c82 <__d2b+0x52>
 8015cba:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 8015cbe:	4405      	add	r5, r0
 8015cc0:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8015cc4:	f8c8 5000 	str.w	r5, [r8]
 8015cc8:	6038      	str	r0, [r7, #0]
 8015cca:	4648      	mov	r0, r9
 8015ccc:	b003      	add	sp, #12
 8015cce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8015cd2:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8015cd6:	f1c0 0120 	rsb	r1, r0, #32
 8015cda:	fa03 f101 	lsl.w	r1, r3, r1
 8015cde:	430a      	orrs	r2, r1
 8015ce0:	40c3      	lsrs	r3, r0
 8015ce2:	9301      	str	r3, [sp, #4]
 8015ce4:	f8c9 2014 	str.w	r2, [r9, #20]
 8015ce8:	e7c2      	b.n	8015c70 <__d2b+0x40>
 8015cea:	bf00      	nop
 8015cec:	0000      	movs	r0, r0
	...

08015cf0 <__fpclassifyd>:
 8015cf0:	ec53 2b10 	vmov	r2, r3, d0
 8015cf4:	b410      	push	{r4}
 8015cf6:	f033 4400 	bics.w	r4, r3, #2147483648	; 0x80000000
 8015cfa:	d008      	beq.n	8015d0e <__fpclassifyd+0x1e>
 8015cfc:	4911      	ldr	r1, [pc, #68]	; (8015d44 <__fpclassifyd+0x54>)
 8015cfe:	f5a3 1080 	sub.w	r0, r3, #1048576	; 0x100000
 8015d02:	4288      	cmp	r0, r1
 8015d04:	d808      	bhi.n	8015d18 <__fpclassifyd+0x28>
 8015d06:	2004      	movs	r0, #4
 8015d08:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015d0c:	4770      	bx	lr
 8015d0e:	b91a      	cbnz	r2, 8015d18 <__fpclassifyd+0x28>
 8015d10:	2002      	movs	r0, #2
 8015d12:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015d16:	4770      	bx	lr
 8015d18:	f103 43ff 	add.w	r3, r3, #2139095040	; 0x7f800000
 8015d1c:	4909      	ldr	r1, [pc, #36]	; (8015d44 <__fpclassifyd+0x54>)
 8015d1e:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
 8015d22:	428b      	cmp	r3, r1
 8015d24:	d9ef      	bls.n	8015d06 <__fpclassifyd+0x16>
 8015d26:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
 8015d2a:	d201      	bcs.n	8015d30 <__fpclassifyd+0x40>
 8015d2c:	2003      	movs	r0, #3
 8015d2e:	e7eb      	b.n	8015d08 <__fpclassifyd+0x18>
 8015d30:	4b05      	ldr	r3, [pc, #20]	; (8015d48 <__fpclassifyd+0x58>)
 8015d32:	429c      	cmp	r4, r3
 8015d34:	d001      	beq.n	8015d3a <__fpclassifyd+0x4a>
 8015d36:	2000      	movs	r0, #0
 8015d38:	e7e6      	b.n	8015d08 <__fpclassifyd+0x18>
 8015d3a:	fab2 f082 	clz	r0, r2
 8015d3e:	0940      	lsrs	r0, r0, #5
 8015d40:	e7e2      	b.n	8015d08 <__fpclassifyd+0x18>
 8015d42:	bf00      	nop
 8015d44:	7fdfffff 	.word	0x7fdfffff
 8015d48:	7ff00000 	.word	0x7ff00000
 8015d4c:	00000000 	.word	0x00000000

08015d50 <strlen>:
 8015d50:	f020 0103 	bic.w	r1, r0, #3
 8015d54:	f010 0003 	ands.w	r0, r0, #3
 8015d58:	f1c0 0000 	rsb	r0, r0, #0
 8015d5c:	f851 3b04 	ldr.w	r3, [r1], #4
 8015d60:	f100 0c04 	add.w	ip, r0, #4
 8015d64:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8015d68:	f06f 0200 	mvn.w	r2, #0
 8015d6c:	bf1c      	itt	ne
 8015d6e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8015d72:	4313      	orrne	r3, r2
 8015d74:	f04f 0c01 	mov.w	ip, #1
 8015d78:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8015d7c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8015d80:	eba3 020c 	sub.w	r2, r3, ip
 8015d84:	ea22 0203 	bic.w	r2, r2, r3
 8015d88:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8015d8c:	bf04      	itt	eq
 8015d8e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8015d92:	3004      	addeq	r0, #4
 8015d94:	d0f4      	beq.n	8015d80 <strlen+0x30>
 8015d96:	f1c2 0100 	rsb	r1, r2, #0
 8015d9a:	ea02 0201 	and.w	r2, r2, r1
 8015d9e:	fab2 f282 	clz	r2, r2
 8015da2:	f1c2 021f 	rsb	r2, r2, #31
 8015da6:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 8015daa:	4770      	bx	lr
 8015dac:	0000      	movs	r0, r0
	...

08015db0 <__ssprint_r>:
 8015db0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015db4:	6893      	ldr	r3, [r2, #8]
 8015db6:	f8d2 8000 	ldr.w	r8, [r2]
 8015dba:	b083      	sub	sp, #12
 8015dbc:	4691      	mov	r9, r2
 8015dbe:	2b00      	cmp	r3, #0
 8015dc0:	d072      	beq.n	8015ea8 <__ssprint_r+0xf8>
 8015dc2:	4607      	mov	r7, r0
 8015dc4:	f04f 0b00 	mov.w	fp, #0
 8015dc8:	6808      	ldr	r0, [r1, #0]
 8015dca:	688b      	ldr	r3, [r1, #8]
 8015dcc:	460d      	mov	r5, r1
 8015dce:	465c      	mov	r4, fp
 8015dd0:	2c00      	cmp	r4, #0
 8015dd2:	d045      	beq.n	8015e60 <__ssprint_r+0xb0>
 8015dd4:	429c      	cmp	r4, r3
 8015dd6:	461e      	mov	r6, r3
 8015dd8:	469a      	mov	sl, r3
 8015dda:	d348      	bcc.n	8015e6e <__ssprint_r+0xbe>
 8015ddc:	89ab      	ldrh	r3, [r5, #12]
 8015dde:	f413 6f90 	tst.w	r3, #1152	; 0x480
 8015de2:	d02d      	beq.n	8015e40 <__ssprint_r+0x90>
 8015de4:	696e      	ldr	r6, [r5, #20]
 8015de6:	6929      	ldr	r1, [r5, #16]
 8015de8:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 8015dec:	ebc1 0a00 	rsb	sl, r1, r0
 8015df0:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
 8015df4:	1c60      	adds	r0, r4, #1
 8015df6:	1076      	asrs	r6, r6, #1
 8015df8:	4450      	add	r0, sl
 8015dfa:	4286      	cmp	r6, r0
 8015dfc:	4632      	mov	r2, r6
 8015dfe:	bf3c      	itt	cc
 8015e00:	4606      	movcc	r6, r0
 8015e02:	4632      	movcc	r2, r6
 8015e04:	055b      	lsls	r3, r3, #21
 8015e06:	d535      	bpl.n	8015e74 <__ssprint_r+0xc4>
 8015e08:	4611      	mov	r1, r2
 8015e0a:	4638      	mov	r0, r7
 8015e0c:	f7ff f958 	bl	80150c0 <_malloc_r>
 8015e10:	2800      	cmp	r0, #0
 8015e12:	d039      	beq.n	8015e88 <__ssprint_r+0xd8>
 8015e14:	4652      	mov	r2, sl
 8015e16:	6929      	ldr	r1, [r5, #16]
 8015e18:	9001      	str	r0, [sp, #4]
 8015e1a:	f7f6 fd91 	bl	800c940 <memcpy>
 8015e1e:	89aa      	ldrh	r2, [r5, #12]
 8015e20:	9b01      	ldr	r3, [sp, #4]
 8015e22:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8015e26:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8015e2a:	81aa      	strh	r2, [r5, #12]
 8015e2c:	ebca 0206 	rsb	r2, sl, r6
 8015e30:	eb03 000a 	add.w	r0, r3, sl
 8015e34:	616e      	str	r6, [r5, #20]
 8015e36:	612b      	str	r3, [r5, #16]
 8015e38:	6028      	str	r0, [r5, #0]
 8015e3a:	60aa      	str	r2, [r5, #8]
 8015e3c:	4626      	mov	r6, r4
 8015e3e:	46a2      	mov	sl, r4
 8015e40:	4652      	mov	r2, sl
 8015e42:	4659      	mov	r1, fp
 8015e44:	f000 f994 	bl	8016170 <memmove>
 8015e48:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8015e4c:	68ab      	ldr	r3, [r5, #8]
 8015e4e:	6828      	ldr	r0, [r5, #0]
 8015e50:	1b9b      	subs	r3, r3, r6
 8015e52:	4450      	add	r0, sl
 8015e54:	1b14      	subs	r4, r2, r4
 8015e56:	60ab      	str	r3, [r5, #8]
 8015e58:	6028      	str	r0, [r5, #0]
 8015e5a:	f8c9 4008 	str.w	r4, [r9, #8]
 8015e5e:	b31c      	cbz	r4, 8015ea8 <__ssprint_r+0xf8>
 8015e60:	f8d8 b000 	ldr.w	fp, [r8]
 8015e64:	f8d8 4004 	ldr.w	r4, [r8, #4]
 8015e68:	f108 0808 	add.w	r8, r8, #8
 8015e6c:	e7b0      	b.n	8015dd0 <__ssprint_r+0x20>
 8015e6e:	4626      	mov	r6, r4
 8015e70:	46a2      	mov	sl, r4
 8015e72:	e7e5      	b.n	8015e40 <__ssprint_r+0x90>
 8015e74:	4638      	mov	r0, r7
 8015e76:	f000 f9e3 	bl	8016240 <_realloc_r>
 8015e7a:	4603      	mov	r3, r0
 8015e7c:	2800      	cmp	r0, #0
 8015e7e:	d1d5      	bne.n	8015e2c <__ssprint_r+0x7c>
 8015e80:	4638      	mov	r0, r7
 8015e82:	6929      	ldr	r1, [r5, #16]
 8015e84:	f000 f89c 	bl	8015fc0 <_free_r>
 8015e88:	230c      	movs	r3, #12
 8015e8a:	603b      	str	r3, [r7, #0]
 8015e8c:	89ab      	ldrh	r3, [r5, #12]
 8015e8e:	2200      	movs	r2, #0
 8015e90:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015e94:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8015e98:	81ab      	strh	r3, [r5, #12]
 8015e9a:	f8c9 2008 	str.w	r2, [r9, #8]
 8015e9e:	f8c9 2004 	str.w	r2, [r9, #4]
 8015ea2:	b003      	add	sp, #12
 8015ea4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015ea8:	2000      	movs	r0, #0
 8015eaa:	f8c9 0004 	str.w	r0, [r9, #4]
 8015eae:	b003      	add	sp, #12
 8015eb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08015ec0 <_calloc_r>:
 8015ec0:	b510      	push	{r4, lr}
 8015ec2:	fb02 f101 	mul.w	r1, r2, r1
 8015ec6:	f7ff f8fb 	bl	80150c0 <_malloc_r>
 8015eca:	4604      	mov	r4, r0
 8015ecc:	b168      	cbz	r0, 8015eea <_calloc_r+0x2a>
 8015ece:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8015ed2:	f022 0203 	bic.w	r2, r2, #3
 8015ed6:	3a04      	subs	r2, #4
 8015ed8:	2a24      	cmp	r2, #36	; 0x24
 8015eda:	d818      	bhi.n	8015f0e <_calloc_r+0x4e>
 8015edc:	2a13      	cmp	r2, #19
 8015ede:	d806      	bhi.n	8015eee <_calloc_r+0x2e>
 8015ee0:	4603      	mov	r3, r0
 8015ee2:	2200      	movs	r2, #0
 8015ee4:	601a      	str	r2, [r3, #0]
 8015ee6:	605a      	str	r2, [r3, #4]
 8015ee8:	609a      	str	r2, [r3, #8]
 8015eea:	4620      	mov	r0, r4
 8015eec:	bd10      	pop	{r4, pc}
 8015eee:	2300      	movs	r3, #0
 8015ef0:	2a1b      	cmp	r2, #27
 8015ef2:	6003      	str	r3, [r0, #0]
 8015ef4:	6043      	str	r3, [r0, #4]
 8015ef6:	d90f      	bls.n	8015f18 <_calloc_r+0x58>
 8015ef8:	2a24      	cmp	r2, #36	; 0x24
 8015efa:	6083      	str	r3, [r0, #8]
 8015efc:	60c3      	str	r3, [r0, #12]
 8015efe:	bf05      	ittet	eq
 8015f00:	6103      	streq	r3, [r0, #16]
 8015f02:	6143      	streq	r3, [r0, #20]
 8015f04:	f100 0310 	addne.w	r3, r0, #16
 8015f08:	f100 0318 	addeq.w	r3, r0, #24
 8015f0c:	e7e9      	b.n	8015ee2 <_calloc_r+0x22>
 8015f0e:	2100      	movs	r1, #0
 8015f10:	f7fc fdd6 	bl	8012ac0 <memset>
 8015f14:	4620      	mov	r0, r4
 8015f16:	bd10      	pop	{r4, pc}
 8015f18:	f100 0308 	add.w	r3, r0, #8
 8015f1c:	e7e1      	b.n	8015ee2 <_calloc_r+0x22>
 8015f1e:	bf00      	nop

08015f20 <_malloc_trim_r>:
 8015f20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015f22:	4f23      	ldr	r7, [pc, #140]	; (8015fb0 <_malloc_trim_r+0x90>)
 8015f24:	460c      	mov	r4, r1
 8015f26:	4606      	mov	r6, r0
 8015f28:	f7ff fbb2 	bl	8015690 <__malloc_lock>
 8015f2c:	68bb      	ldr	r3, [r7, #8]
 8015f2e:	685d      	ldr	r5, [r3, #4]
 8015f30:	f025 0503 	bic.w	r5, r5, #3
 8015f34:	1b29      	subs	r1, r5, r4
 8015f36:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 8015f3a:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 8015f3e:	f021 010f 	bic.w	r1, r1, #15
 8015f42:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 8015f46:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8015f4a:	db07      	blt.n	8015f5c <_malloc_trim_r+0x3c>
 8015f4c:	4630      	mov	r0, r6
 8015f4e:	2100      	movs	r1, #0
 8015f50:	f7fb f866 	bl	8011020 <_sbrk_r>
 8015f54:	68bb      	ldr	r3, [r7, #8]
 8015f56:	442b      	add	r3, r5
 8015f58:	4298      	cmp	r0, r3
 8015f5a:	d004      	beq.n	8015f66 <_malloc_trim_r+0x46>
 8015f5c:	4630      	mov	r0, r6
 8015f5e:	f7ff fb9f 	bl	80156a0 <__malloc_unlock>
 8015f62:	2000      	movs	r0, #0
 8015f64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015f66:	4630      	mov	r0, r6
 8015f68:	4261      	negs	r1, r4
 8015f6a:	f7fb f859 	bl	8011020 <_sbrk_r>
 8015f6e:	3001      	adds	r0, #1
 8015f70:	d00d      	beq.n	8015f8e <_malloc_trim_r+0x6e>
 8015f72:	4b10      	ldr	r3, [pc, #64]	; (8015fb4 <_malloc_trim_r+0x94>)
 8015f74:	68ba      	ldr	r2, [r7, #8]
 8015f76:	6819      	ldr	r1, [r3, #0]
 8015f78:	1b2d      	subs	r5, r5, r4
 8015f7a:	f045 0501 	orr.w	r5, r5, #1
 8015f7e:	4630      	mov	r0, r6
 8015f80:	1b09      	subs	r1, r1, r4
 8015f82:	6055      	str	r5, [r2, #4]
 8015f84:	6019      	str	r1, [r3, #0]
 8015f86:	f7ff fb8b 	bl	80156a0 <__malloc_unlock>
 8015f8a:	2001      	movs	r0, #1
 8015f8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015f8e:	4630      	mov	r0, r6
 8015f90:	2100      	movs	r1, #0
 8015f92:	f7fb f845 	bl	8011020 <_sbrk_r>
 8015f96:	68ba      	ldr	r2, [r7, #8]
 8015f98:	1a83      	subs	r3, r0, r2
 8015f9a:	2b0f      	cmp	r3, #15
 8015f9c:	ddde      	ble.n	8015f5c <_malloc_trim_r+0x3c>
 8015f9e:	4c06      	ldr	r4, [pc, #24]	; (8015fb8 <_malloc_trim_r+0x98>)
 8015fa0:	4904      	ldr	r1, [pc, #16]	; (8015fb4 <_malloc_trim_r+0x94>)
 8015fa2:	6824      	ldr	r4, [r4, #0]
 8015fa4:	f043 0301 	orr.w	r3, r3, #1
 8015fa8:	1b00      	subs	r0, r0, r4
 8015faa:	6053      	str	r3, [r2, #4]
 8015fac:	6008      	str	r0, [r1, #0]
 8015fae:	e7d5      	b.n	8015f5c <_malloc_trim_r+0x3c>
 8015fb0:	20000ca4 	.word	0x20000ca4
 8015fb4:	20006be4 	.word	0x20006be4
 8015fb8:	200010b0 	.word	0x200010b0
 8015fbc:	00000000 	.word	0x00000000

08015fc0 <_free_r>:
 8015fc0:	2900      	cmp	r1, #0
 8015fc2:	d04e      	beq.n	8016062 <_free_r+0xa2>
 8015fc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015fc8:	460c      	mov	r4, r1
 8015fca:	4680      	mov	r8, r0
 8015fcc:	f7ff fb60 	bl	8015690 <__malloc_lock>
 8015fd0:	f854 7c04 	ldr.w	r7, [r4, #-4]
 8015fd4:	4962      	ldr	r1, [pc, #392]	; (8016160 <_free_r+0x1a0>)
 8015fd6:	f027 0201 	bic.w	r2, r7, #1
 8015fda:	f1a4 0508 	sub.w	r5, r4, #8
 8015fde:	18ab      	adds	r3, r5, r2
 8015fe0:	688e      	ldr	r6, [r1, #8]
 8015fe2:	6858      	ldr	r0, [r3, #4]
 8015fe4:	429e      	cmp	r6, r3
 8015fe6:	f020 0003 	bic.w	r0, r0, #3
 8015fea:	d05a      	beq.n	80160a2 <_free_r+0xe2>
 8015fec:	07fe      	lsls	r6, r7, #31
 8015fee:	6058      	str	r0, [r3, #4]
 8015ff0:	d40b      	bmi.n	801600a <_free_r+0x4a>
 8015ff2:	f854 7c08 	ldr.w	r7, [r4, #-8]
 8015ff6:	1bed      	subs	r5, r5, r7
 8015ff8:	f101 0e08 	add.w	lr, r1, #8
 8015ffc:	68ac      	ldr	r4, [r5, #8]
 8015ffe:	4574      	cmp	r4, lr
 8016000:	443a      	add	r2, r7
 8016002:	d067      	beq.n	80160d4 <_free_r+0x114>
 8016004:	68ef      	ldr	r7, [r5, #12]
 8016006:	60e7      	str	r7, [r4, #12]
 8016008:	60bc      	str	r4, [r7, #8]
 801600a:	181c      	adds	r4, r3, r0
 801600c:	6864      	ldr	r4, [r4, #4]
 801600e:	07e4      	lsls	r4, r4, #31
 8016010:	d40c      	bmi.n	801602c <_free_r+0x6c>
 8016012:	4f54      	ldr	r7, [pc, #336]	; (8016164 <_free_r+0x1a4>)
 8016014:	689c      	ldr	r4, [r3, #8]
 8016016:	42bc      	cmp	r4, r7
 8016018:	4402      	add	r2, r0
 801601a:	d07c      	beq.n	8016116 <_free_r+0x156>
 801601c:	68d8      	ldr	r0, [r3, #12]
 801601e:	60e0      	str	r0, [r4, #12]
 8016020:	f042 0301 	orr.w	r3, r2, #1
 8016024:	6084      	str	r4, [r0, #8]
 8016026:	606b      	str	r3, [r5, #4]
 8016028:	50aa      	str	r2, [r5, r2]
 801602a:	e003      	b.n	8016034 <_free_r+0x74>
 801602c:	f042 0301 	orr.w	r3, r2, #1
 8016030:	606b      	str	r3, [r5, #4]
 8016032:	50aa      	str	r2, [r5, r2]
 8016034:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8016038:	d214      	bcs.n	8016064 <_free_r+0xa4>
 801603a:	08d2      	lsrs	r2, r2, #3
 801603c:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
 8016040:	6848      	ldr	r0, [r1, #4]
 8016042:	689f      	ldr	r7, [r3, #8]
 8016044:	60af      	str	r7, [r5, #8]
 8016046:	1092      	asrs	r2, r2, #2
 8016048:	2401      	movs	r4, #1
 801604a:	fa04 f202 	lsl.w	r2, r4, r2
 801604e:	4310      	orrs	r0, r2
 8016050:	60eb      	str	r3, [r5, #12]
 8016052:	6048      	str	r0, [r1, #4]
 8016054:	609d      	str	r5, [r3, #8]
 8016056:	60fd      	str	r5, [r7, #12]
 8016058:	4640      	mov	r0, r8
 801605a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801605e:	f7ff bb1f 	b.w	80156a0 <__malloc_unlock>
 8016062:	4770      	bx	lr
 8016064:	0a53      	lsrs	r3, r2, #9
 8016066:	2b04      	cmp	r3, #4
 8016068:	d847      	bhi.n	80160fa <_free_r+0x13a>
 801606a:	0993      	lsrs	r3, r2, #6
 801606c:	f103 0438 	add.w	r4, r3, #56	; 0x38
 8016070:	0060      	lsls	r0, r4, #1
 8016072:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 8016076:	493a      	ldr	r1, [pc, #232]	; (8016160 <_free_r+0x1a0>)
 8016078:	6883      	ldr	r3, [r0, #8]
 801607a:	4283      	cmp	r3, r0
 801607c:	d043      	beq.n	8016106 <_free_r+0x146>
 801607e:	6859      	ldr	r1, [r3, #4]
 8016080:	f021 0103 	bic.w	r1, r1, #3
 8016084:	4291      	cmp	r1, r2
 8016086:	d902      	bls.n	801608e <_free_r+0xce>
 8016088:	689b      	ldr	r3, [r3, #8]
 801608a:	4298      	cmp	r0, r3
 801608c:	d1f7      	bne.n	801607e <_free_r+0xbe>
 801608e:	68da      	ldr	r2, [r3, #12]
 8016090:	60ea      	str	r2, [r5, #12]
 8016092:	60ab      	str	r3, [r5, #8]
 8016094:	4640      	mov	r0, r8
 8016096:	6095      	str	r5, [r2, #8]
 8016098:	60dd      	str	r5, [r3, #12]
 801609a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801609e:	f7ff baff 	b.w	80156a0 <__malloc_unlock>
 80160a2:	07ff      	lsls	r7, r7, #31
 80160a4:	4402      	add	r2, r0
 80160a6:	d407      	bmi.n	80160b8 <_free_r+0xf8>
 80160a8:	f854 3c08 	ldr.w	r3, [r4, #-8]
 80160ac:	1aed      	subs	r5, r5, r3
 80160ae:	441a      	add	r2, r3
 80160b0:	68a8      	ldr	r0, [r5, #8]
 80160b2:	68eb      	ldr	r3, [r5, #12]
 80160b4:	60c3      	str	r3, [r0, #12]
 80160b6:	6098      	str	r0, [r3, #8]
 80160b8:	4b2b      	ldr	r3, [pc, #172]	; (8016168 <_free_r+0x1a8>)
 80160ba:	681b      	ldr	r3, [r3, #0]
 80160bc:	f042 0001 	orr.w	r0, r2, #1
 80160c0:	429a      	cmp	r2, r3
 80160c2:	6068      	str	r0, [r5, #4]
 80160c4:	608d      	str	r5, [r1, #8]
 80160c6:	d3c7      	bcc.n	8016058 <_free_r+0x98>
 80160c8:	4b28      	ldr	r3, [pc, #160]	; (801616c <_free_r+0x1ac>)
 80160ca:	4640      	mov	r0, r8
 80160cc:	6819      	ldr	r1, [r3, #0]
 80160ce:	f7ff ff27 	bl	8015f20 <_malloc_trim_r>
 80160d2:	e7c1      	b.n	8016058 <_free_r+0x98>
 80160d4:	1819      	adds	r1, r3, r0
 80160d6:	6849      	ldr	r1, [r1, #4]
 80160d8:	07c9      	lsls	r1, r1, #31
 80160da:	d409      	bmi.n	80160f0 <_free_r+0x130>
 80160dc:	68d9      	ldr	r1, [r3, #12]
 80160de:	689b      	ldr	r3, [r3, #8]
 80160e0:	4402      	add	r2, r0
 80160e2:	f042 0001 	orr.w	r0, r2, #1
 80160e6:	60d9      	str	r1, [r3, #12]
 80160e8:	608b      	str	r3, [r1, #8]
 80160ea:	6068      	str	r0, [r5, #4]
 80160ec:	50aa      	str	r2, [r5, r2]
 80160ee:	e7b3      	b.n	8016058 <_free_r+0x98>
 80160f0:	f042 0301 	orr.w	r3, r2, #1
 80160f4:	606b      	str	r3, [r5, #4]
 80160f6:	50aa      	str	r2, [r5, r2]
 80160f8:	e7ae      	b.n	8016058 <_free_r+0x98>
 80160fa:	2b14      	cmp	r3, #20
 80160fc:	d814      	bhi.n	8016128 <_free_r+0x168>
 80160fe:	f103 045b 	add.w	r4, r3, #91	; 0x5b
 8016102:	0060      	lsls	r0, r4, #1
 8016104:	e7b5      	b.n	8016072 <_free_r+0xb2>
 8016106:	684a      	ldr	r2, [r1, #4]
 8016108:	10a4      	asrs	r4, r4, #2
 801610a:	2001      	movs	r0, #1
 801610c:	40a0      	lsls	r0, r4
 801610e:	4302      	orrs	r2, r0
 8016110:	604a      	str	r2, [r1, #4]
 8016112:	461a      	mov	r2, r3
 8016114:	e7bc      	b.n	8016090 <_free_r+0xd0>
 8016116:	f042 0301 	orr.w	r3, r2, #1
 801611a:	614d      	str	r5, [r1, #20]
 801611c:	610d      	str	r5, [r1, #16]
 801611e:	60ec      	str	r4, [r5, #12]
 8016120:	60ac      	str	r4, [r5, #8]
 8016122:	606b      	str	r3, [r5, #4]
 8016124:	50aa      	str	r2, [r5, r2]
 8016126:	e797      	b.n	8016058 <_free_r+0x98>
 8016128:	2b54      	cmp	r3, #84	; 0x54
 801612a:	d804      	bhi.n	8016136 <_free_r+0x176>
 801612c:	0b13      	lsrs	r3, r2, #12
 801612e:	f103 046e 	add.w	r4, r3, #110	; 0x6e
 8016132:	0060      	lsls	r0, r4, #1
 8016134:	e79d      	b.n	8016072 <_free_r+0xb2>
 8016136:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 801613a:	d804      	bhi.n	8016146 <_free_r+0x186>
 801613c:	0bd3      	lsrs	r3, r2, #15
 801613e:	f103 0477 	add.w	r4, r3, #119	; 0x77
 8016142:	0060      	lsls	r0, r4, #1
 8016144:	e795      	b.n	8016072 <_free_r+0xb2>
 8016146:	f240 5054 	movw	r0, #1364	; 0x554
 801614a:	4283      	cmp	r3, r0
 801614c:	d804      	bhi.n	8016158 <_free_r+0x198>
 801614e:	0c93      	lsrs	r3, r2, #18
 8016150:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8016154:	0060      	lsls	r0, r4, #1
 8016156:	e78c      	b.n	8016072 <_free_r+0xb2>
 8016158:	20fc      	movs	r0, #252	; 0xfc
 801615a:	247e      	movs	r4, #126	; 0x7e
 801615c:	e789      	b.n	8016072 <_free_r+0xb2>
 801615e:	bf00      	nop
 8016160:	20000ca4 	.word	0x20000ca4
 8016164:	20000cac 	.word	0x20000cac
 8016168:	200010ac 	.word	0x200010ac
 801616c:	20006be0 	.word	0x20006be0

08016170 <memmove>:
 8016170:	4288      	cmp	r0, r1
 8016172:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016174:	d90d      	bls.n	8016192 <memmove+0x22>
 8016176:	188b      	adds	r3, r1, r2
 8016178:	4298      	cmp	r0, r3
 801617a:	d20a      	bcs.n	8016192 <memmove+0x22>
 801617c:	1881      	adds	r1, r0, r2
 801617e:	2a00      	cmp	r2, #0
 8016180:	d054      	beq.n	801622c <memmove+0xbc>
 8016182:	1a9a      	subs	r2, r3, r2
 8016184:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8016188:	f801 4d01 	strb.w	r4, [r1, #-1]!
 801618c:	4293      	cmp	r3, r2
 801618e:	d1f9      	bne.n	8016184 <memmove+0x14>
 8016190:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016192:	2a0f      	cmp	r2, #15
 8016194:	d948      	bls.n	8016228 <memmove+0xb8>
 8016196:	ea40 0301 	orr.w	r3, r0, r1
 801619a:	079b      	lsls	r3, r3, #30
 801619c:	d147      	bne.n	801622e <memmove+0xbe>
 801619e:	f100 0410 	add.w	r4, r0, #16
 80161a2:	f101 0310 	add.w	r3, r1, #16
 80161a6:	4615      	mov	r5, r2
 80161a8:	f853 6c10 	ldr.w	r6, [r3, #-16]
 80161ac:	f844 6c10 	str.w	r6, [r4, #-16]
 80161b0:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 80161b4:	f844 6c0c 	str.w	r6, [r4, #-12]
 80161b8:	f853 6c08 	ldr.w	r6, [r3, #-8]
 80161bc:	f844 6c08 	str.w	r6, [r4, #-8]
 80161c0:	3d10      	subs	r5, #16
 80161c2:	f853 6c04 	ldr.w	r6, [r3, #-4]
 80161c6:	f844 6c04 	str.w	r6, [r4, #-4]
 80161ca:	2d0f      	cmp	r5, #15
 80161cc:	f103 0310 	add.w	r3, r3, #16
 80161d0:	f104 0410 	add.w	r4, r4, #16
 80161d4:	d8e8      	bhi.n	80161a8 <memmove+0x38>
 80161d6:	f1a2 0310 	sub.w	r3, r2, #16
 80161da:	f023 030f 	bic.w	r3, r3, #15
 80161de:	f002 0e0f 	and.w	lr, r2, #15
 80161e2:	3310      	adds	r3, #16
 80161e4:	f1be 0f03 	cmp.w	lr, #3
 80161e8:	4419      	add	r1, r3
 80161ea:	4403      	add	r3, r0
 80161ec:	d921      	bls.n	8016232 <memmove+0xc2>
 80161ee:	1f1e      	subs	r6, r3, #4
 80161f0:	460d      	mov	r5, r1
 80161f2:	4674      	mov	r4, lr
 80161f4:	3c04      	subs	r4, #4
 80161f6:	f855 7b04 	ldr.w	r7, [r5], #4
 80161fa:	f846 7f04 	str.w	r7, [r6, #4]!
 80161fe:	2c03      	cmp	r4, #3
 8016200:	d8f8      	bhi.n	80161f4 <memmove+0x84>
 8016202:	f1ae 0404 	sub.w	r4, lr, #4
 8016206:	f024 0403 	bic.w	r4, r4, #3
 801620a:	3404      	adds	r4, #4
 801620c:	4423      	add	r3, r4
 801620e:	4421      	add	r1, r4
 8016210:	f002 0203 	and.w	r2, r2, #3
 8016214:	b152      	cbz	r2, 801622c <memmove+0xbc>
 8016216:	3b01      	subs	r3, #1
 8016218:	440a      	add	r2, r1
 801621a:	f811 4b01 	ldrb.w	r4, [r1], #1
 801621e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8016222:	4291      	cmp	r1, r2
 8016224:	d1f9      	bne.n	801621a <memmove+0xaa>
 8016226:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016228:	4603      	mov	r3, r0
 801622a:	e7f3      	b.n	8016214 <memmove+0xa4>
 801622c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801622e:	4603      	mov	r3, r0
 8016230:	e7f1      	b.n	8016216 <memmove+0xa6>
 8016232:	4672      	mov	r2, lr
 8016234:	e7ee      	b.n	8016214 <memmove+0xa4>
 8016236:	bf00      	nop
	...

08016240 <_realloc_r>:
 8016240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016244:	4617      	mov	r7, r2
 8016246:	b083      	sub	sp, #12
 8016248:	460e      	mov	r6, r1
 801624a:	2900      	cmp	r1, #0
 801624c:	f000 80e7 	beq.w	801641e <_realloc_r+0x1de>
 8016250:	4681      	mov	r9, r0
 8016252:	f107 050b 	add.w	r5, r7, #11
 8016256:	f7ff fa1b 	bl	8015690 <__malloc_lock>
 801625a:	f856 3c04 	ldr.w	r3, [r6, #-4]
 801625e:	2d16      	cmp	r5, #22
 8016260:	f023 0403 	bic.w	r4, r3, #3
 8016264:	f1a6 0808 	sub.w	r8, r6, #8
 8016268:	d84c      	bhi.n	8016304 <_realloc_r+0xc4>
 801626a:	2210      	movs	r2, #16
 801626c:	4615      	mov	r5, r2
 801626e:	42af      	cmp	r7, r5
 8016270:	d84d      	bhi.n	801630e <_realloc_r+0xce>
 8016272:	4294      	cmp	r4, r2
 8016274:	f280 8084 	bge.w	8016380 <_realloc_r+0x140>
 8016278:	f8df b3ac 	ldr.w	fp, [pc, #940]	; 8016628 <_realloc_r+0x3e8>
 801627c:	f8db 0008 	ldr.w	r0, [fp, #8]
 8016280:	eb08 0104 	add.w	r1, r8, r4
 8016284:	4288      	cmp	r0, r1
 8016286:	f000 80d6 	beq.w	8016436 <_realloc_r+0x1f6>
 801628a:	6848      	ldr	r0, [r1, #4]
 801628c:	f020 0e01 	bic.w	lr, r0, #1
 8016290:	448e      	add	lr, r1
 8016292:	f8de e004 	ldr.w	lr, [lr, #4]
 8016296:	f01e 0f01 	tst.w	lr, #1
 801629a:	d13f      	bne.n	801631c <_realloc_r+0xdc>
 801629c:	f020 0003 	bic.w	r0, r0, #3
 80162a0:	4420      	add	r0, r4
 80162a2:	4290      	cmp	r0, r2
 80162a4:	f280 80c1 	bge.w	801642a <_realloc_r+0x1ea>
 80162a8:	07db      	lsls	r3, r3, #31
 80162aa:	f100 808f 	bmi.w	80163cc <_realloc_r+0x18c>
 80162ae:	f856 3c08 	ldr.w	r3, [r6, #-8]
 80162b2:	ebc3 0a08 	rsb	sl, r3, r8
 80162b6:	f8da 3004 	ldr.w	r3, [sl, #4]
 80162ba:	f023 0303 	bic.w	r3, r3, #3
 80162be:	eb00 0e03 	add.w	lr, r0, r3
 80162c2:	4596      	cmp	lr, r2
 80162c4:	db34      	blt.n	8016330 <_realloc_r+0xf0>
 80162c6:	68cb      	ldr	r3, [r1, #12]
 80162c8:	688a      	ldr	r2, [r1, #8]
 80162ca:	4657      	mov	r7, sl
 80162cc:	60d3      	str	r3, [r2, #12]
 80162ce:	609a      	str	r2, [r3, #8]
 80162d0:	f857 1f08 	ldr.w	r1, [r7, #8]!
 80162d4:	f8da 300c 	ldr.w	r3, [sl, #12]
 80162d8:	60cb      	str	r3, [r1, #12]
 80162da:	1f22      	subs	r2, r4, #4
 80162dc:	2a24      	cmp	r2, #36	; 0x24
 80162de:	6099      	str	r1, [r3, #8]
 80162e0:	f200 8136 	bhi.w	8016550 <_realloc_r+0x310>
 80162e4:	2a13      	cmp	r2, #19
 80162e6:	f240 80fd 	bls.w	80164e4 <_realloc_r+0x2a4>
 80162ea:	6833      	ldr	r3, [r6, #0]
 80162ec:	f8ca 3008 	str.w	r3, [sl, #8]
 80162f0:	6873      	ldr	r3, [r6, #4]
 80162f2:	f8ca 300c 	str.w	r3, [sl, #12]
 80162f6:	2a1b      	cmp	r2, #27
 80162f8:	f200 8140 	bhi.w	801657c <_realloc_r+0x33c>
 80162fc:	3608      	adds	r6, #8
 80162fe:	f10a 0310 	add.w	r3, sl, #16
 8016302:	e0f0      	b.n	80164e6 <_realloc_r+0x2a6>
 8016304:	f025 0507 	bic.w	r5, r5, #7
 8016308:	2d00      	cmp	r5, #0
 801630a:	462a      	mov	r2, r5
 801630c:	daaf      	bge.n	801626e <_realloc_r+0x2e>
 801630e:	230c      	movs	r3, #12
 8016310:	2000      	movs	r0, #0
 8016312:	f8c9 3000 	str.w	r3, [r9]
 8016316:	b003      	add	sp, #12
 8016318:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801631c:	07d9      	lsls	r1, r3, #31
 801631e:	d455      	bmi.n	80163cc <_realloc_r+0x18c>
 8016320:	f856 3c08 	ldr.w	r3, [r6, #-8]
 8016324:	ebc3 0a08 	rsb	sl, r3, r8
 8016328:	f8da 3004 	ldr.w	r3, [sl, #4]
 801632c:	f023 0303 	bic.w	r3, r3, #3
 8016330:	4423      	add	r3, r4
 8016332:	4293      	cmp	r3, r2
 8016334:	db4a      	blt.n	80163cc <_realloc_r+0x18c>
 8016336:	4657      	mov	r7, sl
 8016338:	f8da 100c 	ldr.w	r1, [sl, #12]
 801633c:	f857 0f08 	ldr.w	r0, [r7, #8]!
 8016340:	1f22      	subs	r2, r4, #4
 8016342:	2a24      	cmp	r2, #36	; 0x24
 8016344:	60c1      	str	r1, [r0, #12]
 8016346:	6088      	str	r0, [r1, #8]
 8016348:	f200 810e 	bhi.w	8016568 <_realloc_r+0x328>
 801634c:	2a13      	cmp	r2, #19
 801634e:	f240 8109 	bls.w	8016564 <_realloc_r+0x324>
 8016352:	6831      	ldr	r1, [r6, #0]
 8016354:	f8ca 1008 	str.w	r1, [sl, #8]
 8016358:	6871      	ldr	r1, [r6, #4]
 801635a:	f8ca 100c 	str.w	r1, [sl, #12]
 801635e:	2a1b      	cmp	r2, #27
 8016360:	f200 8121 	bhi.w	80165a6 <_realloc_r+0x366>
 8016364:	3608      	adds	r6, #8
 8016366:	f10a 0210 	add.w	r2, sl, #16
 801636a:	6831      	ldr	r1, [r6, #0]
 801636c:	6011      	str	r1, [r2, #0]
 801636e:	6871      	ldr	r1, [r6, #4]
 8016370:	6051      	str	r1, [r2, #4]
 8016372:	68b1      	ldr	r1, [r6, #8]
 8016374:	6091      	str	r1, [r2, #8]
 8016376:	461c      	mov	r4, r3
 8016378:	f8da 3004 	ldr.w	r3, [sl, #4]
 801637c:	463e      	mov	r6, r7
 801637e:	46d0      	mov	r8, sl
 8016380:	1b62      	subs	r2, r4, r5
 8016382:	2a0f      	cmp	r2, #15
 8016384:	f003 0301 	and.w	r3, r3, #1
 8016388:	d80e      	bhi.n	80163a8 <_realloc_r+0x168>
 801638a:	4323      	orrs	r3, r4
 801638c:	4444      	add	r4, r8
 801638e:	f8c8 3004 	str.w	r3, [r8, #4]
 8016392:	6863      	ldr	r3, [r4, #4]
 8016394:	f043 0301 	orr.w	r3, r3, #1
 8016398:	6063      	str	r3, [r4, #4]
 801639a:	4648      	mov	r0, r9
 801639c:	f7ff f980 	bl	80156a0 <__malloc_unlock>
 80163a0:	4630      	mov	r0, r6
 80163a2:	b003      	add	sp, #12
 80163a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80163a8:	eb08 0105 	add.w	r1, r8, r5
 80163ac:	431d      	orrs	r5, r3
 80163ae:	f042 0301 	orr.w	r3, r2, #1
 80163b2:	440a      	add	r2, r1
 80163b4:	f8c8 5004 	str.w	r5, [r8, #4]
 80163b8:	604b      	str	r3, [r1, #4]
 80163ba:	6853      	ldr	r3, [r2, #4]
 80163bc:	f043 0301 	orr.w	r3, r3, #1
 80163c0:	3108      	adds	r1, #8
 80163c2:	6053      	str	r3, [r2, #4]
 80163c4:	4648      	mov	r0, r9
 80163c6:	f7ff fdfb 	bl	8015fc0 <_free_r>
 80163ca:	e7e6      	b.n	801639a <_realloc_r+0x15a>
 80163cc:	4639      	mov	r1, r7
 80163ce:	4648      	mov	r0, r9
 80163d0:	f7fe fe76 	bl	80150c0 <_malloc_r>
 80163d4:	4607      	mov	r7, r0
 80163d6:	b1d8      	cbz	r0, 8016410 <_realloc_r+0x1d0>
 80163d8:	f856 3c04 	ldr.w	r3, [r6, #-4]
 80163dc:	f023 0201 	bic.w	r2, r3, #1
 80163e0:	4442      	add	r2, r8
 80163e2:	f1a0 0108 	sub.w	r1, r0, #8
 80163e6:	4291      	cmp	r1, r2
 80163e8:	f000 80ac 	beq.w	8016544 <_realloc_r+0x304>
 80163ec:	1f22      	subs	r2, r4, #4
 80163ee:	2a24      	cmp	r2, #36	; 0x24
 80163f0:	f200 8099 	bhi.w	8016526 <_realloc_r+0x2e6>
 80163f4:	2a13      	cmp	r2, #19
 80163f6:	d86a      	bhi.n	80164ce <_realloc_r+0x28e>
 80163f8:	4603      	mov	r3, r0
 80163fa:	4632      	mov	r2, r6
 80163fc:	6811      	ldr	r1, [r2, #0]
 80163fe:	6019      	str	r1, [r3, #0]
 8016400:	6851      	ldr	r1, [r2, #4]
 8016402:	6059      	str	r1, [r3, #4]
 8016404:	6892      	ldr	r2, [r2, #8]
 8016406:	609a      	str	r2, [r3, #8]
 8016408:	4631      	mov	r1, r6
 801640a:	4648      	mov	r0, r9
 801640c:	f7ff fdd8 	bl	8015fc0 <_free_r>
 8016410:	4648      	mov	r0, r9
 8016412:	f7ff f945 	bl	80156a0 <__malloc_unlock>
 8016416:	4638      	mov	r0, r7
 8016418:	b003      	add	sp, #12
 801641a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801641e:	4611      	mov	r1, r2
 8016420:	b003      	add	sp, #12
 8016422:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016426:	f7fe be4b 	b.w	80150c0 <_malloc_r>
 801642a:	68ca      	ldr	r2, [r1, #12]
 801642c:	6889      	ldr	r1, [r1, #8]
 801642e:	4604      	mov	r4, r0
 8016430:	60ca      	str	r2, [r1, #12]
 8016432:	6091      	str	r1, [r2, #8]
 8016434:	e7a4      	b.n	8016380 <_realloc_r+0x140>
 8016436:	6841      	ldr	r1, [r0, #4]
 8016438:	f021 0103 	bic.w	r1, r1, #3
 801643c:	4421      	add	r1, r4
 801643e:	f105 0010 	add.w	r0, r5, #16
 8016442:	4281      	cmp	r1, r0
 8016444:	da5b      	bge.n	80164fe <_realloc_r+0x2be>
 8016446:	07db      	lsls	r3, r3, #31
 8016448:	d4c0      	bmi.n	80163cc <_realloc_r+0x18c>
 801644a:	f856 3c08 	ldr.w	r3, [r6, #-8]
 801644e:	ebc3 0a08 	rsb	sl, r3, r8
 8016452:	f8da 3004 	ldr.w	r3, [sl, #4]
 8016456:	f023 0303 	bic.w	r3, r3, #3
 801645a:	eb01 0c03 	add.w	ip, r1, r3
 801645e:	4560      	cmp	r0, ip
 8016460:	f73f af66 	bgt.w	8016330 <_realloc_r+0xf0>
 8016464:	4657      	mov	r7, sl
 8016466:	f8da 300c 	ldr.w	r3, [sl, #12]
 801646a:	f857 1f08 	ldr.w	r1, [r7, #8]!
 801646e:	1f22      	subs	r2, r4, #4
 8016470:	2a24      	cmp	r2, #36	; 0x24
 8016472:	60cb      	str	r3, [r1, #12]
 8016474:	6099      	str	r1, [r3, #8]
 8016476:	f200 80b8 	bhi.w	80165ea <_realloc_r+0x3aa>
 801647a:	2a13      	cmp	r2, #19
 801647c:	f240 80a9 	bls.w	80165d2 <_realloc_r+0x392>
 8016480:	6833      	ldr	r3, [r6, #0]
 8016482:	f8ca 3008 	str.w	r3, [sl, #8]
 8016486:	6873      	ldr	r3, [r6, #4]
 8016488:	f8ca 300c 	str.w	r3, [sl, #12]
 801648c:	2a1b      	cmp	r2, #27
 801648e:	f200 80b5 	bhi.w	80165fc <_realloc_r+0x3bc>
 8016492:	3608      	adds	r6, #8
 8016494:	f10a 0310 	add.w	r3, sl, #16
 8016498:	6832      	ldr	r2, [r6, #0]
 801649a:	601a      	str	r2, [r3, #0]
 801649c:	6872      	ldr	r2, [r6, #4]
 801649e:	605a      	str	r2, [r3, #4]
 80164a0:	68b2      	ldr	r2, [r6, #8]
 80164a2:	609a      	str	r2, [r3, #8]
 80164a4:	eb0a 0205 	add.w	r2, sl, r5
 80164a8:	ebc5 030c 	rsb	r3, r5, ip
 80164ac:	f043 0301 	orr.w	r3, r3, #1
 80164b0:	f8cb 2008 	str.w	r2, [fp, #8]
 80164b4:	6053      	str	r3, [r2, #4]
 80164b6:	f8da 3004 	ldr.w	r3, [sl, #4]
 80164ba:	f003 0301 	and.w	r3, r3, #1
 80164be:	431d      	orrs	r5, r3
 80164c0:	4648      	mov	r0, r9
 80164c2:	f8ca 5004 	str.w	r5, [sl, #4]
 80164c6:	f7ff f8eb 	bl	80156a0 <__malloc_unlock>
 80164ca:	4638      	mov	r0, r7
 80164cc:	e769      	b.n	80163a2 <_realloc_r+0x162>
 80164ce:	6833      	ldr	r3, [r6, #0]
 80164d0:	6003      	str	r3, [r0, #0]
 80164d2:	6873      	ldr	r3, [r6, #4]
 80164d4:	6043      	str	r3, [r0, #4]
 80164d6:	2a1b      	cmp	r2, #27
 80164d8:	d829      	bhi.n	801652e <_realloc_r+0x2ee>
 80164da:	f100 0308 	add.w	r3, r0, #8
 80164de:	f106 0208 	add.w	r2, r6, #8
 80164e2:	e78b      	b.n	80163fc <_realloc_r+0x1bc>
 80164e4:	463b      	mov	r3, r7
 80164e6:	6832      	ldr	r2, [r6, #0]
 80164e8:	601a      	str	r2, [r3, #0]
 80164ea:	6872      	ldr	r2, [r6, #4]
 80164ec:	605a      	str	r2, [r3, #4]
 80164ee:	68b2      	ldr	r2, [r6, #8]
 80164f0:	609a      	str	r2, [r3, #8]
 80164f2:	463e      	mov	r6, r7
 80164f4:	4674      	mov	r4, lr
 80164f6:	f8da 3004 	ldr.w	r3, [sl, #4]
 80164fa:	46d0      	mov	r8, sl
 80164fc:	e740      	b.n	8016380 <_realloc_r+0x140>
 80164fe:	eb08 0205 	add.w	r2, r8, r5
 8016502:	1b4b      	subs	r3, r1, r5
 8016504:	f043 0301 	orr.w	r3, r3, #1
 8016508:	f8cb 2008 	str.w	r2, [fp, #8]
 801650c:	6053      	str	r3, [r2, #4]
 801650e:	f856 3c04 	ldr.w	r3, [r6, #-4]
 8016512:	f003 0301 	and.w	r3, r3, #1
 8016516:	431d      	orrs	r5, r3
 8016518:	4648      	mov	r0, r9
 801651a:	f846 5c04 	str.w	r5, [r6, #-4]
 801651e:	f7ff f8bf 	bl	80156a0 <__malloc_unlock>
 8016522:	4630      	mov	r0, r6
 8016524:	e73d      	b.n	80163a2 <_realloc_r+0x162>
 8016526:	4631      	mov	r1, r6
 8016528:	f7ff fe22 	bl	8016170 <memmove>
 801652c:	e76c      	b.n	8016408 <_realloc_r+0x1c8>
 801652e:	68b3      	ldr	r3, [r6, #8]
 8016530:	6083      	str	r3, [r0, #8]
 8016532:	68f3      	ldr	r3, [r6, #12]
 8016534:	60c3      	str	r3, [r0, #12]
 8016536:	2a24      	cmp	r2, #36	; 0x24
 8016538:	d02c      	beq.n	8016594 <_realloc_r+0x354>
 801653a:	f100 0310 	add.w	r3, r0, #16
 801653e:	f106 0210 	add.w	r2, r6, #16
 8016542:	e75b      	b.n	80163fc <_realloc_r+0x1bc>
 8016544:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8016548:	f022 0203 	bic.w	r2, r2, #3
 801654c:	4414      	add	r4, r2
 801654e:	e717      	b.n	8016380 <_realloc_r+0x140>
 8016550:	4631      	mov	r1, r6
 8016552:	4638      	mov	r0, r7
 8016554:	4674      	mov	r4, lr
 8016556:	463e      	mov	r6, r7
 8016558:	f7ff fe0a 	bl	8016170 <memmove>
 801655c:	46d0      	mov	r8, sl
 801655e:	f8da 3004 	ldr.w	r3, [sl, #4]
 8016562:	e70d      	b.n	8016380 <_realloc_r+0x140>
 8016564:	463a      	mov	r2, r7
 8016566:	e700      	b.n	801636a <_realloc_r+0x12a>
 8016568:	4631      	mov	r1, r6
 801656a:	4638      	mov	r0, r7
 801656c:	461c      	mov	r4, r3
 801656e:	463e      	mov	r6, r7
 8016570:	f7ff fdfe 	bl	8016170 <memmove>
 8016574:	46d0      	mov	r8, sl
 8016576:	f8da 3004 	ldr.w	r3, [sl, #4]
 801657a:	e701      	b.n	8016380 <_realloc_r+0x140>
 801657c:	68b3      	ldr	r3, [r6, #8]
 801657e:	f8ca 3010 	str.w	r3, [sl, #16]
 8016582:	68f3      	ldr	r3, [r6, #12]
 8016584:	f8ca 3014 	str.w	r3, [sl, #20]
 8016588:	2a24      	cmp	r2, #36	; 0x24
 801658a:	d018      	beq.n	80165be <_realloc_r+0x37e>
 801658c:	3610      	adds	r6, #16
 801658e:	f10a 0318 	add.w	r3, sl, #24
 8016592:	e7a8      	b.n	80164e6 <_realloc_r+0x2a6>
 8016594:	6933      	ldr	r3, [r6, #16]
 8016596:	6103      	str	r3, [r0, #16]
 8016598:	6973      	ldr	r3, [r6, #20]
 801659a:	6143      	str	r3, [r0, #20]
 801659c:	f106 0218 	add.w	r2, r6, #24
 80165a0:	f100 0318 	add.w	r3, r0, #24
 80165a4:	e72a      	b.n	80163fc <_realloc_r+0x1bc>
 80165a6:	68b1      	ldr	r1, [r6, #8]
 80165a8:	f8ca 1010 	str.w	r1, [sl, #16]
 80165ac:	68f1      	ldr	r1, [r6, #12]
 80165ae:	f8ca 1014 	str.w	r1, [sl, #20]
 80165b2:	2a24      	cmp	r2, #36	; 0x24
 80165b4:	d00f      	beq.n	80165d6 <_realloc_r+0x396>
 80165b6:	3610      	adds	r6, #16
 80165b8:	f10a 0218 	add.w	r2, sl, #24
 80165bc:	e6d5      	b.n	801636a <_realloc_r+0x12a>
 80165be:	6933      	ldr	r3, [r6, #16]
 80165c0:	f8ca 3018 	str.w	r3, [sl, #24]
 80165c4:	6973      	ldr	r3, [r6, #20]
 80165c6:	f8ca 301c 	str.w	r3, [sl, #28]
 80165ca:	3618      	adds	r6, #24
 80165cc:	f10a 0320 	add.w	r3, sl, #32
 80165d0:	e789      	b.n	80164e6 <_realloc_r+0x2a6>
 80165d2:	463b      	mov	r3, r7
 80165d4:	e760      	b.n	8016498 <_realloc_r+0x258>
 80165d6:	6932      	ldr	r2, [r6, #16]
 80165d8:	f8ca 2018 	str.w	r2, [sl, #24]
 80165dc:	6972      	ldr	r2, [r6, #20]
 80165de:	f8ca 201c 	str.w	r2, [sl, #28]
 80165e2:	3618      	adds	r6, #24
 80165e4:	f10a 0220 	add.w	r2, sl, #32
 80165e8:	e6bf      	b.n	801636a <_realloc_r+0x12a>
 80165ea:	4631      	mov	r1, r6
 80165ec:	4638      	mov	r0, r7
 80165ee:	f8cd c004 	str.w	ip, [sp, #4]
 80165f2:	f7ff fdbd 	bl	8016170 <memmove>
 80165f6:	f8dd c004 	ldr.w	ip, [sp, #4]
 80165fa:	e753      	b.n	80164a4 <_realloc_r+0x264>
 80165fc:	68b3      	ldr	r3, [r6, #8]
 80165fe:	f8ca 3010 	str.w	r3, [sl, #16]
 8016602:	68f3      	ldr	r3, [r6, #12]
 8016604:	f8ca 3014 	str.w	r3, [sl, #20]
 8016608:	2a24      	cmp	r2, #36	; 0x24
 801660a:	d003      	beq.n	8016614 <_realloc_r+0x3d4>
 801660c:	3610      	adds	r6, #16
 801660e:	f10a 0318 	add.w	r3, sl, #24
 8016612:	e741      	b.n	8016498 <_realloc_r+0x258>
 8016614:	6933      	ldr	r3, [r6, #16]
 8016616:	f8ca 3018 	str.w	r3, [sl, #24]
 801661a:	6973      	ldr	r3, [r6, #20]
 801661c:	f8ca 301c 	str.w	r3, [sl, #28]
 8016620:	3618      	adds	r6, #24
 8016622:	f10a 0320 	add.w	r3, sl, #32
 8016626:	e737      	b.n	8016498 <_realloc_r+0x258>
 8016628:	20000ca4 	.word	0x20000ca4
 801662c:	00000000 	.word	0x00000000
 8016630:	656c6469 	.word	0x656c6469
	...

08016640 <ch_debug>:
 8016640:	6e69616d 18011600 08480404 1814100c     main......H.....
 8016650:	1e1d1c00 0000201f 00000000 00000000     ..... ..........

08016660 <vmt>:
 8016660:	0800e0d1 0800e0b1 0800e111 0800e0f1     ................
 8016670:	0800e101 0800e0e1 0800e0c1 0800e0a1     ................

08016680 <zero_status>:
	...

08016690 <active_status>:
	...

080166a0 <halted_status>:
 80166a0:	00000001 00000000 00000000 00000000     ................

080166b0 <_stm32_dma_streams>:
 80166b0:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 80166c0:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 80166d0:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 80166e0:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 80166f0:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 8016700:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 8016710:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 8016720:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 8016730:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 8016740:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 8016750:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 8016760:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.
 8016770:	20414d44 6c696166 00657275 00000000     DMA failure.....

08016780 <fsparams>:
 8016780:	00000080 00000140 00000003 00000000     ....@...........
 8016790:	5f627375 5f646c6c 706d7570 00000000     usb_lld_pump....

080167a0 <ep0config>:
 80167a0:	00000000 0800e531 0800e861 0800e921     ....1...a...!...
 80167b0:	00400040 20001718 20001718 00000001     @.@.... ... ....
 80167c0:	2000172c 00000000 00000000 00000000     ,.. ............

080167d0 <pal_default_config>:
 80167d0:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
 80167e0:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
 80167f0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 8016800:	04000000 00000040 02208001 00000000     ....@..... .....
 8016810:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
 8016820:	00060600 55000100 00000000 ffffffff     .......U........
 8016830:	00555055 00000fff 00000000 00000000     UPU.............
 8016840:	00000040 00000000 ffffffff 00000000     @...............
 8016850:	0000ffff 00000000 00000000 00000000     ................
 8016860:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8016880:	ffffffff 00000000 0000ffff 00000000     ................
	...
 801689c:	ffffffff 00000000 0000ffff 00000000     ................
	...
 80168b8:	ffffffff 00000000 0000ffff 00000000     ................
	...

080168d0 <spicfg>:
 80168d0:	00000000 40020400 0010000c 00000000     .......@........
 80168e0:	35324343 45203032 00495458 4264312d     CC2520 EXTI.-1dB
 80168f0:	0000006d 42643131 0000006d 42643431     m...11dBm...14dB
 8016900:	0000006d 42643631 0000006d 42643731     m...16dBm...17dB
 8016910:	0000006d 00000000 00000000 00000000     m...............
 8016920:	35324343 45203032 00004358 00000000     CC2520 EXC......
 8016930:	6c6c6548 6f57206f 00646c72 00000000     Hello World.....

08016940 <ep1config>:
 8016940:	00000002 00000000 0800e241 0800e2a1     ........A.......
 8016950:	00400040 2000235c 20002370 00000002     @.@.\#. p#. ....
	...

08016970 <vcom_configuration_descriptor>:
 8016970:	00000043 080169c0 00000000 00000000     C....i..........

08016980 <ep2config>:
 8016980:	00000003 00000000 0800e301 00000000     ................
 8016990:	00000010 200020f0 00000000 00000001     ..... . ........
	...

080169b0 <usbcfg>:
 80169b0:	08011a81 08011a51 0800e201 00000000     ....Q...........

080169c0 <vcom_configuration_descriptor_data>:
 80169c0:	00430209 c0000102 00040932 02020100     ..C.....2.......
 80169d0:	24050001 05011000 01000124 02022404     ...$....$....$..
 80169e0:	00062405 82050701 ff000803 00010409     .$..............
 80169f0:	00000a02 01050700 00004002 02810507     .........@......
 8016a00:	00000040 00000000 00000000 00000000     @...............

08016a10 <vcom_device_descriptor_data>:
 8016a10:	01100112 40000002 57400483 02010200     .......@..@W....
 8016a20:	00000103 00000000 00000000 00000000     ................

08016a30 <vcom_string0>:
 8016a30:	04090304 00000000 00000000 00000000     ................

08016a40 <vcom_string1>:
 8016a40:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 8016a50:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 8016a60:	00630069 00000073 00000000 00000000     i.c.s...........

08016a70 <vcom_string2>:
 8016a70:	00430338 00690068 00690062 0053004f     8.C.h.i.b.i.O.S.
 8016a80:	0052002f 00200054 00690056 00740072     /.R.T. .V.i.r.t.
 8016a90:	00610075 0020006c 004f0043 0020004d     u.a.l. .C.O.M. .
 8016aa0:	006f0050 00740072 00000000 00000000     P.o.r.t.........

08016ab0 <vcom_string3>:
 8016ab0:	00330308 00310030 00000000 00000000     ..3.0.1.........

08016ac0 <vcom_strings>:
 8016ac0:	00000004 08016a30 00000026 08016a40     ....0j..&...@j..
 8016ad0:	00000038 08016a70 00000008 08016ab0     8...pj.......j..

08016ae0 <serusbcfg>:
 8016ae0:	20001498 00020101 00000000 00000000     ... ............

08016af0 <vcom_device_descriptor>:
 8016af0:	00000012 08016a10 00000000 00000000     .....j..........
 8016b00:	35324343 54203032 00000078 35324343     CC2520 Tx...CC25
 8016b10:	52203032 00000058 00000000 00000000     20 RX...........
 8016b20:	2055504d 706d6153 676e696c 00000000     MPU Sampling....
 8016b30:	706d6153 676e696c 65687420 72796720     Sampling the gyr
 8016b40:	666f206f 74657366 6f662073 30312072     o offsets for 10
 8016b50:	74692030 74617265 736e6f69 0d2e2e2e     0 iterations....
 8016b60:	0000000a 7366664f 58207465 6425203a     ....Offset X: %d
 8016b70:	664f0a0d 74657366 203a5920 0a0d6425     ..Offset Y: %d..
 8016b80:	7366664f 5a207465 6425203a 0a0d0a0d     Offset Z: %d....
 8016b90:	00000000 20636341 203a2058 66322e25     ....Acc X : %.2f
 8016ba0:	63410a0d 20592063 2e25203a 0a0d6632     ..Acc Y : %.2f..
 8016bb0:	20636341 203a205a 66322e25 61520a0d     Acc Z : %.2f..Ra
 8016bc0:	58206574 2e25203a 0a0d6632 65746152     te X: %.2f..Rate
 8016bd0:	203a5920 66322e25 61520a0d 5a206574      Y: %.2f..Rate Z
 8016be0:	2e25203a 0a0d6632 2067614d 25203a58     : %.2f..Mag X: %
 8016bf0:	0d66322e 67614d0a 203a5920 66322e25     .2f..Mag Y: %.2f
 8016c00:	614d0a0d 3a5a2067 322e2520 460a0d66     ..Mag Z: %.2f..F
 8016c10:	656c6961 65722064 3a736461 0d642520     ailed reads: %d.
 8016c20:	6961460a 2064656c 2067616d 64616572     .Failed mag read
 8016c30:	25203a73 530a0d64 6c706d61 75642065     s: %d..Sample du
 8016c40:	69746172 203a6e6f 66322e25 20736d20     ration: %.2f ms 
 8016c50:	2e25202f 48206632 0d0a0d7a 0000000a     / %.2f Hz.......

08016c60 <i2cfg>:
 8016c60:	00000001 00061a80 00000002 00000000     ................

08016c70 <extcfg>:
	...
 8016cb8:	00000031 08011601 00000000 00000000     1...............
	...

08016d30 <crc16_tab>:
 8016d30:	10210000 30632042 50a54084 70e760c6     ..!.B c0.@.P.`.p
 8016d40:	91298108 b16ba14a d1adc18c f1efe1ce     ..).J.k.........
 8016d50:	02101231 22523273 429452b5 62d672f7     1...s2R".R.B.r.b
 8016d60:	83189339 a35ab37b c39cd3bd e3def3ff     9...{.Z.........
 8016d70:	34432462 14010420 74c764e6 548544a4     b$C4 ....d.t.D.T
 8016d80:	b54ba56a 95098528 f5cfe5ee d58dc5ac     j.K.(...........
 8016d90:	26723653 06301611 66f676d7 46b45695     S6r&..0..v.f.V.F
 8016da0:	a77ab75b 87389719 e7fef7df c7bcd79d     [.z...8.........
 8016db0:	58e548c4 78a76886 18610840 38232802     .H.X.h.x@.a..(#8
 8016dc0:	d9edc9cc f9afe98e 99698948 b92ba90a     ........H.i...+.
 8016dd0:	4ad45af5 6a967ab7 0a501a71 2a123a33     .Z.J.z.jq.P.3:.*
 8016de0:	cbdcdbfd eb9efbbf 8b589b79 ab1abb3b     ........y.X.;...
 8016df0:	7c876ca6 5cc54ce4 3c032c22 1c410c60     .l.|.L.\",.<`.A.
 8016e00:	fd8fedae ddcdcdec bd0bad2a 9d498d68     ........*...h.I.
 8016e10:	6eb67e97 4ef45ed5 2e323e13 0e701e51     .~.n.^.N.>2.Q.p.
 8016e20:	efbeff9f cffcdfdd af3abf1b 8f789f59     ..........:.Y.x.
 8016e30:	81a99188 a1ebb1ca c12dd10c e16ff14e     ..........-.N.o.
 8016e40:	00a11080 20e330c2 40255004 60677046     .....0. .P%@Fpg`
 8016e50:	939883b9 b3daa3fb d31cc33d f35ee37f     ........=.....^.
 8016e60:	129002b1 32d222f3 52144235 72566277     .....".25B.RwbVr
 8016e70:	a5cbb5ea 858995a8 e54ff56e c50dd52c     ........n.O.,...
 8016e80:	24c334e2 048114a0 64477466 44055424     .4.$....ftGd$T.D
 8016e90:	b7faa7db 97b88799 f77ee75f d73cc71d     ........_.~...<.
 8016ea0:	36f226d3 16b00691 76766657 56344615     .&.6....Wfvv.F4V
 8016eb0:	c96dd94c e92ff90e 89e999c8 a9abb98a     L.m.../.........
 8016ec0:	48655844 68277806 08e118c0 28a33882     DXeH.x'h.....8.(
 8016ed0:	db5ccb7d fb1eeb3f 9bd88bf9 bb9aabbb     }.\.?...........
 8016ee0:	5a544a75 7a166a37 1ad00af1 3a922ab3     uJTZ7j.z.....*.:
 8016ef0:	ed0ffd2e cd4ddd6c ad8bbdaa 8dc99de8     ....l.M.........
 8016f00:	6c077c26 4c455c64 2c833ca2 0cc11ce0     &|.ld\EL.<.,....
 8016f10:	ff3eef1f df7ccf5d bfbaaf9b 9ff88fd9     ..>.].|.........
 8016f20:	7e366e17 5e744e55 3eb22e93 1ef00ed1     .n6~UNt^...>....

08016f30 <adcgrpcfg>:
 8016f30:	00080001 00000000 00000000 00000000     ................
 8016f40:	40000000 00d806db 00003000 00700000     ...@.....0....p.
 8016f50:	00000211 08d62d44 00000000 00000000     ....D-..........
 8016f60:	2d425355 69726553 70206c61 65636f72     USB-Serial proce
 8016f70:	00007373 2d425355 69726553 72206c61     ss..USB-Serial r
 8016f80:	00646165 00000000 00000000 00000000     ead.............
 8016f90:	00000043 00000000 00000000 00000000     C...............

08016fa0 <zeroes.6911>:
 8016fa0:	30303030 30303030 30303030 30303030     0000000000000000

08016fb0 <blanks.6910>:
 8016fb0:	20202020 20202020 20202020 20202020                     
 8016fc0:	00464e49 00666e69 004e414e 006e616e     INF.inf.NAN.nan.
 8016fd0:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 8016fe0:	00000000 33323130 37363534 62613938     ....0123456789ab
 8016ff0:	66656463 00000000 6c756e28 0000296c     cdef....(null)..
 8017000:	00000030 00000000 00000000 00000000     0...............
 8017010:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
 8017020:	49534f50 00000058 0000002e 00000000     POSIX...........

08017030 <__mprec_tens>:
 8017030:	00000000 3ff00000 00000000 40240000     .......?......$@
 8017040:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
 8017050:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
 8017060:	00000000 412e8480 00000000 416312d0     .......A......cA
 8017070:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
 8017080:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
 8017090:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
 80170a0:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
 80170b0:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
 80170c0:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
 80170d0:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
 80170e0:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
 80170f0:	79d99db4 44ea7843 00000000 00000000     ...yCx.D........

08017100 <p05.5302>:
 8017100:	00000005 00000019 0000007d 00000000     ........}.......

08017110 <__mprec_bigtens>:
 8017110:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
 8017120:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
 8017130:	7f73bf3c 75154fdd                       <.s..O.u
